{
    "mmio_functions": {
        "next": {
            "name": "next",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 46,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *next(struct _timeout *t)\n{\n\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);\n\n\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);\n}\n",
                {
                    "46": "static struct _timeout *next(struct _timeout *t)",
                    "47": "{",
                    "48": "\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);",
                    "49": "",
                    "50": "\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);",
                    "51": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_device_init": {
            "name": "z_impl_device_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/init.c",
            "location_line": 379,
            "function_content": [
                "/* End marker */\nint z_impl_device_init(const struct device *dev)\n{\n\tif (dev == NULL) {\n\t\treturn -ENOENT;\n\t}\n\n\tSTRUCT_SECTION_FOREACH_ALTERNATE(_deferred_init, init_entry, entry) {\n\t\tif (entry->dev == dev) {\n\t\t\treturn do_device_init(entry);\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n",
                {
                    "379": "int z_impl_device_init(const struct device *dev)",
                    "380": "{",
                    "381": "\tif (dev == NULL) {",
                    "382": "\t\treturn -ENOENT;",
                    "383": "\t}",
                    "384": "",
                    "385": "\tSTRUCT_SECTION_FOREACH_ALTERNATE(_deferred_init, init_entry, entry) {",
                    "386": "\t\tif (entry->dev == dev) {",
                    "387": "\t\t\treturn do_device_init(entry);",
                    "388": "\t\t}",
                    "389": "\t}",
                    "390": "",
                    "391": "\treturn -ENOENT;",
                    "392": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_sem_init": {
            "name": "z_impl_k_sem_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sem.c",
            "location_line": 45,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_SEM */\nint z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,\n\t\t      unsigned int limit)\n{\n\t/*\n\t * Limit cannot be zero and count cannot be greater than limit\n\t */\n\tCHECKIF(limit == 0U || initial_count > limit) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);\n\n\t\treturn -EINVAL;\n\t}\n\n\tsem->count = initial_count;\n\tsem->limit = limit;\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);\n\n\tz_waitq_init(&sem->wait_q);\n#if defined(CONFIG_POLL)\n\tsys_dlist_init(&sem->poll_events);\n#endif /* CONFIG_POLL */\n\tk_object_init(sem);\n\n#ifdef CONFIG_OBJ_CORE_SEM\n\tk_obj_core_init_and_link(K_OBJ_CORE(sem), &obj_type_sem);\n#endif /* CONFIG_OBJ_CORE_SEM */\n\n\treturn 0;\n}\n",
                {
                    "45": "int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,",
                    "46": "\t\t      unsigned int limit)",
                    "47": "{",
                    "48": "\t/*",
                    "49": "\t * Limit cannot be zero and count cannot be greater than limit",
                    "50": "\t */",
                    "51": "\tCHECKIF(limit == 0U || initial_count > limit) {",
                    "52": "\t\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);",
                    "53": "",
                    "54": "\t\treturn -EINVAL;",
                    "55": "\t}",
                    "56": "",
                    "57": "\tsem->count = initial_count;",
                    "58": "\tsem->limit = limit;",
                    "59": "",
                    "60": "\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);",
                    "61": "",
                    "62": "\tz_waitq_init(&sem->wait_q);",
                    "63": "#if defined(CONFIG_POLL)",
                    "64": "\tsys_dlist_init(&sem->poll_events);",
                    "65": "#endif /* CONFIG_POLL */",
                    "66": "\tk_object_init(sem);",
                    "67": "",
                    "68": "#ifdef CONFIG_OBJ_CORE_SEM",
                    "69": "\tk_obj_core_init_and_link(K_OBJ_CORE(sem), &obj_type_sem);",
                    "70": "#endif /* CONFIG_OBJ_CORE_SEM */",
                    "71": "",
                    "72": "\treturn 0;",
                    "73": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_condvar_init": {
            "name": "z_impl_k_condvar_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/condvar.c",
            "location_line": 21,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_CONDVAR */\nint z_impl_k_condvar_init(struct k_condvar *condvar)\n{\n\tz_waitq_init(&condvar->wait_q);\n\tk_object_init(condvar);\n\n#ifdef CONFIG_OBJ_CORE_CONDVAR\n\tk_obj_core_init_and_link(K_OBJ_CORE(condvar), &obj_type_condvar);\n#endif /* CONFIG_OBJ_CORE_CONDVAR */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_condvar, condvar, 0);\n\n\treturn 0;\n}\n",
                {
                    "21": "int z_impl_k_condvar_init(struct k_condvar *condvar)",
                    "22": "{",
                    "23": "\tz_waitq_init(&condvar->wait_q);",
                    "24": "\tk_object_init(condvar);",
                    "25": "",
                    "26": "#ifdef CONFIG_OBJ_CORE_CONDVAR",
                    "27": "\tk_obj_core_init_and_link(K_OBJ_CORE(condvar), &obj_type_condvar);",
                    "28": "#endif /* CONFIG_OBJ_CORE_CONDVAR */",
                    "29": "",
                    "30": "\tSYS_PORT_TRACING_OBJ_INIT(k_condvar, condvar, 0);",
                    "31": "",
                    "32": "\treturn 0;",
                    "33": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_mutex_lock": {
            "name": "z_impl_k_mutex_lock",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mutex.c",
            "location_line": 105,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)\n{\n\tint new_prio;\n\tk_spinlock_key_t key;\n\tbool resched = false;\n\n\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);\n\n\tkey = k_spin_lock(&lock);\n\n\tif (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {\n\n\t\tmutex->owner_orig_prio = (mutex->lock_count == 0U) ?\n\t\t\t\t\t_current->base.prio :\n\t\t\t\t\tmutex->owner_orig_prio;\n\n\t\tmutex->lock_count++;\n\t\tmutex->owner = _current;\n\n\t\tLOG_DBG(\"%p took mutex %p, count: %d, orig prio: %d\",\n\t\t\t_current, mutex, mutex->lock_count,\n\t\t\tmutex->owner_orig_prio);\n\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);\n\n\t\treturn -EBUSY;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);\n\n\tnew_prio = new_prio_for_inheritance(_current->base.prio,\n\t\t\t\t\t    mutex->owner->base.prio);\n\n\tLOG_DBG(\"adjusting prio up on mutex %p\", mutex);\n\n\tif (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {\n\t\tresched = adjust_owner_prio(mutex, new_prio);\n\t}\n\n\tint got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);\n\n\tLOG_DBG(\"on mutex %p got_mutex value: %d\", mutex, got_mutex);\n\n\tLOG_DBG(\"%p got mutex %p (y/n): %c\", _current, mutex,\n\t\tgot_mutex ? 'y' : 'n');\n\n\tif (got_mutex == 0) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);\n\t\treturn 0;\n\t}\n\n\t/* timed out */\n\n\tLOG_DBG(\"%p timeout on mutex %p\", _current, mutex);\n\n\tkey = k_spin_lock(&lock);\n\n\t/*\n\t * Check if mutex was unlocked after this thread was unpended.\n\t * If so, skip adjusting owner's priority down.\n\t */\n\tif (likely(mutex->owner != NULL)) {\n\t\tstruct k_thread *waiter = z_waitq_head(&mutex->wait_q);\n\n\t\tnew_prio = (waiter != NULL) ?\n\t\t\tnew_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :\n\t\t\tmutex->owner_orig_prio;\n\n\t\tLOG_DBG(\"adjusting prio down on mutex %p\", mutex);\n\n\t\tresched = adjust_owner_prio(mutex, new_prio) || resched;\n\t}\n\n\tif (resched) {\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);\n\n\treturn -EAGAIN;\n}\n",
                {
                    "105": "int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)",
                    "106": "{",
                    "107": "\tint new_prio;",
                    "108": "\tk_spinlock_key_t key;",
                    "109": "\tbool resched = false;",
                    "110": "",
                    "111": "\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");",
                    "112": "",
                    "113": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);",
                    "114": "",
                    "115": "\tkey = k_spin_lock(&lock);",
                    "116": "",
                    "117": "\tif (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {",
                    "118": "",
                    "119": "\t\tmutex->owner_orig_prio = (mutex->lock_count == 0U) ?",
                    "120": "\t\t\t\t\t_current->base.prio :",
                    "121": "\t\t\t\t\tmutex->owner_orig_prio;",
                    "122": "",
                    "123": "\t\tmutex->lock_count++;",
                    "124": "\t\tmutex->owner = _current;",
                    "125": "",
                    "126": "\t\tLOG_DBG(\"%p took mutex %p, count: %d, orig prio: %d\",",
                    "127": "\t\t\t_current, mutex, mutex->lock_count,",
                    "128": "\t\t\tmutex->owner_orig_prio);",
                    "129": "",
                    "130": "\t\tk_spin_unlock(&lock, key);",
                    "131": "",
                    "132": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);",
                    "133": "",
                    "134": "\t\treturn 0;",
                    "135": "\t}",
                    "136": "",
                    "137": "\tif (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {",
                    "138": "\t\tk_spin_unlock(&lock, key);",
                    "139": "",
                    "140": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);",
                    "141": "",
                    "142": "\t\treturn -EBUSY;",
                    "143": "\t}",
                    "144": "",
                    "145": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);",
                    "146": "",
                    "147": "\tnew_prio = new_prio_for_inheritance(_current->base.prio,",
                    "148": "\t\t\t\t\t    mutex->owner->base.prio);",
                    "149": "",
                    "150": "\tLOG_DBG(\"adjusting prio up on mutex %p\", mutex);",
                    "151": "",
                    "152": "\tif (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {",
                    "153": "\t\tresched = adjust_owner_prio(mutex, new_prio);",
                    "154": "\t}",
                    "155": "",
                    "156": "\tint got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);",
                    "157": "",
                    "158": "\tLOG_DBG(\"on mutex %p got_mutex value: %d\", mutex, got_mutex);",
                    "159": "",
                    "160": "\tLOG_DBG(\"%p got mutex %p (y/n): %c\", _current, mutex,",
                    "161": "\t\tgot_mutex ? 'y' : 'n');",
                    "162": "",
                    "163": "\tif (got_mutex == 0) {",
                    "164": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);",
                    "165": "\t\treturn 0;",
                    "166": "\t}",
                    "167": "",
                    "168": "\t/* timed out */",
                    "169": "",
                    "170": "\tLOG_DBG(\"%p timeout on mutex %p\", _current, mutex);",
                    "171": "",
                    "172": "\tkey = k_spin_lock(&lock);",
                    "173": "",
                    "174": "\t/*",
                    "175": "\t * Check if mutex was unlocked after this thread was unpended.",
                    "176": "\t * If so, skip adjusting owner's priority down.",
                    "177": "\t */",
                    "178": "\tif (likely(mutex->owner != NULL)) {",
                    "179": "\t\tstruct k_thread *waiter = z_waitq_head(&mutex->wait_q);",
                    "180": "",
                    "181": "\t\tnew_prio = (waiter != NULL) ?",
                    "182": "\t\t\tnew_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :",
                    "183": "\t\t\tmutex->owner_orig_prio;",
                    "184": "",
                    "185": "\t\tLOG_DBG(\"adjusting prio down on mutex %p\", mutex);",
                    "186": "",
                    "187": "\t\tresched = adjust_owner_prio(mutex, new_prio) || resched;",
                    "188": "\t}",
                    "189": "",
                    "190": "\tif (resched) {",
                    "191": "\t\tz_reschedule(&lock, key);",
                    "192": "\t} else {",
                    "193": "\t\tk_spin_unlock(&lock, key);",
                    "194": "\t}",
                    "195": "",
                    "196": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);",
                    "197": "",
                    "198": "\treturn -EAGAIN;",
                    "199": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_mutex_init": {
            "name": "z_impl_k_mutex_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mutex.c",
            "location_line": 55,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MUTEX */\nint z_impl_k_mutex_init(struct k_mutex *mutex)\n{\n\tmutex->owner = NULL;\n\tmutex->lock_count = 0U;\n\n\tz_waitq_init(&mutex->wait_q);\n\n\tk_object_init(mutex);\n\n#ifdef CONFIG_OBJ_CORE_MUTEX\n\tk_obj_core_init_and_link(K_OBJ_CORE(mutex), &obj_type_mutex);\n#endif /* CONFIG_OBJ_CORE_MUTEX */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);\n\n\treturn 0;\n}\n",
                {
                    "55": "int z_impl_k_mutex_init(struct k_mutex *mutex)",
                    "56": "{",
                    "57": "\tmutex->owner = NULL;",
                    "58": "\tmutex->lock_count = 0U;",
                    "59": "",
                    "60": "\tz_waitq_init(&mutex->wait_q);",
                    "61": "",
                    "62": "\tk_object_init(mutex);",
                    "63": "",
                    "64": "#ifdef CONFIG_OBJ_CORE_MUTEX",
                    "65": "\tk_obj_core_init_and_link(K_OBJ_CORE(mutex), &obj_type_mutex);",
                    "66": "#endif /* CONFIG_OBJ_CORE_MUTEX */",
                    "67": "",
                    "68": "\tSYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);",
                    "69": "",
                    "70": "\treturn 0;",
                    "71": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_init": {
            "name": "z_impl_k_queue_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/queue.c",
            "location_line": 58,
            "function_content": [
                "/* Data was directly placed in the queue, the first word\n* reserved for the linked list. User mode isn't allowed to\n* do this, although it can get data sent this way.\n*/\nvoid z_impl_k_queue_init(struct k_queue *queue)\n{\n\tsys_sflist_init(&queue->data_q);\n\tqueue->lock = (struct k_spinlock) {};\n\tz_waitq_init(&queue->wait_q);\n#if defined(CONFIG_POLL)\n\tsys_dlist_init(&queue->poll_events);\n#endif\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_queue, queue);\n\n\tk_object_init(queue);\n}\n",
                {
                    "58": "void z_impl_k_queue_init(struct k_queue *queue)",
                    "59": "{",
                    "60": "\tsys_sflist_init(&queue->data_q);",
                    "61": "\tqueue->lock = (struct k_spinlock) {};",
                    "62": "\tz_waitq_init(&queue->wait_q);",
                    "63": "#if defined(CONFIG_POLL)",
                    "64": "\tsys_dlist_init(&queue->poll_events);",
                    "65": "#endif",
                    "66": "",
                    "67": "\tSYS_PORT_TRACING_OBJ_INIT(k_queue, queue);",
                    "68": "",
                    "69": "\tk_object_init(queue);",
                    "70": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_timer_status_sync": {
            "name": "z_impl_k_timer_status_sync",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timer.c",
            "location_line": 247,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nuint32_t z_impl_k_timer_status_sync(struct k_timer *timer)\n{\n\t__ASSERT(!arch_is_in_isr(), \"\");\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, status_sync, timer);\n\n\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tuint32_t result;\n\n\t\tdo {\n\t\t\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\t\t\tif (!z_is_inactive_timeout(&timer->timeout)) {\n\t\t\t\tresult = *(volatile uint32_t *)&timer->status;\n\t\t\t\ttimer->status = 0U;\n\t\t\t\tk_spin_unlock(&lock, key);\n\t\t\t\tif (result > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = timer->status;\n\t\t\t\tk_spin_unlock(&lock, key);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\n\t\treturn result;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tuint32_t result = timer->status;\n\n\tif (result == 0U) {\n\t\tif (!z_is_inactive_timeout(&timer->timeout)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);\n\n\t\t\t/* wait for timer to expire or stop */\n\t\t\t(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);\n\n\t\t\t/* get updated timer status */\n\t\t\tkey = k_spin_lock(&lock);\n\t\t\tresult = timer->status;\n\t\t} else {\n\t\t\t/* timer is already stopped */\n\t\t}\n\t} else {\n\t\t/* timer has already expired at least once */\n\t}\n\n\ttimer->status = 0U;\n\tk_spin_unlock(&lock, key);\n\n\t/**\n\t * @note\tNew tracing hook\n\t */\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);\n\n\treturn result;\n}\n",
                {
                    "247": "uint32_t z_impl_k_timer_status_sync(struct k_timer *timer)",
                    "248": "{",
                    "249": "\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "250": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, status_sync, timer);",
                    "251": "",
                    "252": "\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "253": "\t\tuint32_t result;",
                    "254": "",
                    "255": "\t\tdo {",
                    "256": "\t\t\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "257": "",
                    "258": "\t\t\tif (!z_is_inactive_timeout(&timer->timeout)) {",
                    "259": "\t\t\t\tresult = *(volatile uint32_t *)&timer->status;",
                    "260": "\t\t\t\ttimer->status = 0U;",
                    "261": "\t\t\t\tk_spin_unlock(&lock, key);",
                    "262": "\t\t\t\tif (result > 0) {",
                    "263": "\t\t\t\t\tbreak;",
                    "264": "\t\t\t\t}",
                    "265": "\t\t\t} else {",
                    "266": "\t\t\t\tresult = timer->status;",
                    "267": "\t\t\t\tk_spin_unlock(&lock, key);",
                    "268": "\t\t\t\tbreak;",
                    "269": "\t\t\t}",
                    "270": "\t\t} while (true);",
                    "271": "",
                    "272": "\t\treturn result;",
                    "273": "\t}",
                    "274": "",
                    "275": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "276": "\tuint32_t result = timer->status;",
                    "277": "",
                    "278": "\tif (result == 0U) {",
                    "279": "\t\tif (!z_is_inactive_timeout(&timer->timeout)) {",
                    "280": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);",
                    "281": "",
                    "282": "\t\t\t/* wait for timer to expire or stop */",
                    "283": "\t\t\t(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);",
                    "284": "",
                    "285": "\t\t\t/* get updated timer status */",
                    "286": "\t\t\tkey = k_spin_lock(&lock);",
                    "287": "\t\t\tresult = timer->status;",
                    "288": "\t\t} else {",
                    "289": "\t\t\t/* timer is already stopped */",
                    "290": "\t\t}",
                    "291": "\t} else {",
                    "292": "\t\t/* timer has already expired at least once */",
                    "293": "\t}",
                    "294": "",
                    "295": "\ttimer->status = 0U;",
                    "296": "\tk_spin_unlock(&lock, key);",
                    "297": "",
                    "298": "\t/**",
                    "299": "\t * @note\tNew tracing hook",
                    "300": "\t */",
                    "301": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);",
                    "302": "",
                    "303": "\treturn result;",
                    "304": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_yield": {
            "name": "z_impl_k_yield",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1115,
            "function_content": [
                "#endif /* CONFIG_SCHED_DEADLINE */\nvoid z_impl_k_yield(void)\n{\n\t__ASSERT(!arch_is_in_isr(), \"\");\n\n\tSYS_PORT_TRACING_FUNC(k_thread, yield);\n\n\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);\n\n\tif (!IS_ENABLED(CONFIG_SMP) ||\n\t    z_is_thread_queued(_current)) {\n\t\tdequeue_thread(_current);\n\t}\n\tqueue_thread(_current);\n\tupdate_cache(1);\n\tz_swap(&_sched_spinlock, key);\n}\n",
                {
                    "1115": "void z_impl_k_yield(void)",
                    "1116": "{",
                    "1117": "\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "1118": "",
                    "1119": "\tSYS_PORT_TRACING_FUNC(k_thread, yield);",
                    "1120": "",
                    "1121": "\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);",
                    "1122": "",
                    "1123": "\tif (!IS_ENABLED(CONFIG_SMP) ||",
                    "1124": "\t    z_is_thread_queued(_current)) {",
                    "1125": "\t\tdequeue_thread(_current);",
                    "1126": "\t}",
                    "1127": "\tqueue_thread(_current);",
                    "1128": "\tupdate_cache(1);",
                    "1129": "\tz_swap(&_sched_spinlock, key);",
                    "1130": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timer_expiration_handler": {
            "name": "z_timer_expiration_handler",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timer.c",
            "location_line": 27,
            "function_content": [
                "/**\n* @brief Handle expiration of a kernel timer object.\n*\n* @param t  Timeout used by the timer.\n*/\nvoid z_timer_expiration_handler(struct _timeout *t)\n{\n\tstruct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);\n\tstruct k_thread *thread;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\t/* In sys_clock_announce(), when a timeout expires, it is first removed\n\t * from the timeout list, then its expiration handler is called (with\n\t * unlocked interrupts). For kernel timers, the expiration handler is\n\t * this function. Usually, the timeout structure related to the timer\n\t * that is handled here will not be linked to the timeout list at this\n\t * point. But it may happen that before this function is executed and\n\t * interrupts are locked again, a given timer gets restarted from an\n\t * interrupt context that has a priority higher than the system timer\n\t * interrupt. Then, the timeout structure for this timer will turn out\n\t * to be linked to the timeout list. And in such case, since the timer\n\t * was restarted, its expiration handler should not be executed then,\n\t * so the function exits immediately.\n\t */\n\tif (sys_dnode_is_linked(&t->node)) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\t/*\n\t * if the timer is periodic, start it again; don't add _TICK_ALIGN\n\t * since we're already aligned to a tick boundary\n\t */\n\tif (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&\n\t    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {\n\t\tk_timeout_t next = timer->period;\n\n\t\t/* see note about z_add_timeout() in z_impl_k_timer_start() */\n\t\tnext.ticks = MAX(next.ticks - 1, 0);\n\n#ifdef CONFIG_TIMEOUT_64BIT\n\t\t/* Exploit the fact that uptime during a kernel\n\t\t * timeout handler reflects the time of the scheduled\n\t\t * event and not real time to get some inexpensive\n\t\t * protection against late interrupts.  If we're\n\t\t * delayed for any reason, we still end up calculating\n\t\t * the next expiration as a regular stride from where\n\t\t * we \"should\" have run.  Requires absolute timeouts.\n\t\t * (Note offset by one: we're nominally at the\n\t\t * beginning of a tick, so need to defeat the \"round\n\t\t * down\" behavior on timeout addition).\n\t\t */\n\t\tnext = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);\n#endif /* CONFIG_TIMEOUT_64BIT */\n\t\tz_add_timeout(&timer->timeout, z_timer_expiration_handler,\n\t\t\t      next);\n\t}\n\n\t/* update timer's status */\n\ttimer->status += 1U;\n\n\t/* invoke timer expiry function */\n\tif (timer->expiry_fn != NULL) {\n\t\t/* Unlock for user handler. */\n\t\tk_spin_unlock(&lock, key);\n\t\ttimer->expiry_fn(timer);\n\t\tkey = k_spin_lock(&lock);\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\tthread = z_waitq_head(&timer->wait_q);\n\n\tif (thread == NULL) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\tz_unpend_thread_no_timeout(thread);\n\n\tarch_thread_return_value_set(thread, 0);\n\n\tk_spin_unlock(&lock, key);\n\n\tz_ready_thread(thread);\n}\n",
                {
                    "27": "void z_timer_expiration_handler(struct _timeout *t)",
                    "28": "{",
                    "29": "\tstruct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);",
                    "30": "\tstruct k_thread *thread;",
                    "31": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "32": "",
                    "33": "\t/* In sys_clock_announce(), when a timeout expires, it is first removed",
                    "34": "\t * from the timeout list, then its expiration handler is called (with",
                    "35": "\t * unlocked interrupts). For kernel timers, the expiration handler is",
                    "36": "\t * this function. Usually, the timeout structure related to the timer",
                    "37": "\t * that is handled here will not be linked to the timeout list at this",
                    "38": "\t * point. But it may happen that before this function is executed and",
                    "39": "\t * interrupts are locked again, a given timer gets restarted from an",
                    "40": "\t * interrupt context that has a priority higher than the system timer",
                    "41": "\t * interrupt. Then, the timeout structure for this timer will turn out",
                    "42": "\t * to be linked to the timeout list. And in such case, since the timer",
                    "43": "\t * was restarted, its expiration handler should not be executed then,",
                    "44": "\t * so the function exits immediately.",
                    "45": "\t */",
                    "46": "\tif (sys_dnode_is_linked(&t->node)) {",
                    "47": "\t\tk_spin_unlock(&lock, key);",
                    "48": "\t\treturn;",
                    "49": "\t}",
                    "50": "",
                    "51": "\t/*",
                    "52": "\t * if the timer is periodic, start it again; don't add _TICK_ALIGN",
                    "53": "\t * since we're already aligned to a tick boundary",
                    "54": "\t */",
                    "55": "\tif (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&",
                    "56": "\t    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {",
                    "57": "\t\tk_timeout_t next = timer->period;",
                    "58": "",
                    "59": "\t\t/* see note about z_add_timeout() in z_impl_k_timer_start() */",
                    "60": "\t\tnext.ticks = MAX(next.ticks - 1, 0);",
                    "61": "",
                    "62": "#ifdef CONFIG_TIMEOUT_64BIT",
                    "63": "\t\t/* Exploit the fact that uptime during a kernel",
                    "64": "\t\t * timeout handler reflects the time of the scheduled",
                    "65": "\t\t * event and not real time to get some inexpensive",
                    "66": "\t\t * protection against late interrupts.  If we're",
                    "67": "\t\t * delayed for any reason, we still end up calculating",
                    "68": "\t\t * the next expiration as a regular stride from where",
                    "69": "\t\t * we \"should\" have run.  Requires absolute timeouts.",
                    "70": "\t\t * (Note offset by one: we're nominally at the",
                    "71": "\t\t * beginning of a tick, so need to defeat the \"round",
                    "72": "\t\t * down\" behavior on timeout addition).",
                    "73": "\t\t */",
                    "74": "\t\tnext = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);",
                    "75": "#endif /* CONFIG_TIMEOUT_64BIT */",
                    "76": "\t\tz_add_timeout(&timer->timeout, z_timer_expiration_handler,",
                    "77": "\t\t\t      next);",
                    "78": "\t}",
                    "79": "",
                    "80": "\t/* update timer's status */",
                    "81": "\ttimer->status += 1U;",
                    "82": "",
                    "83": "\t/* invoke timer expiry function */",
                    "84": "\tif (timer->expiry_fn != NULL) {",
                    "85": "\t\t/* Unlock for user handler. */",
                    "86": "\t\tk_spin_unlock(&lock, key);",
                    "87": "\t\ttimer->expiry_fn(timer);",
                    "88": "\t\tkey = k_spin_lock(&lock);",
                    "89": "\t}",
                    "90": "",
                    "91": "\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "92": "\t\tk_spin_unlock(&lock, key);",
                    "93": "\t\treturn;",
                    "94": "\t}",
                    "95": "",
                    "96": "\tthread = z_waitq_head(&timer->wait_q);",
                    "97": "",
                    "98": "\tif (thread == NULL) {",
                    "99": "\t\tk_spin_unlock(&lock, key);",
                    "100": "\t\treturn;",
                    "101": "\t}",
                    "102": "",
                    "103": "\tz_unpend_thread_no_timeout(thread);",
                    "104": "",
                    "105": "\tarch_thread_return_value_set(thread, 0);",
                    "106": "",
                    "107": "\tk_spin_unlock(&lock, key);",
                    "108": "",
                    "109": "\tz_ready_thread(thread);",
                    "110": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_init": {
            "name": "k_heap_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/kheap.c",
            "location_line": 15,
            "function_content": [
                "/* private kernel APIs */\nvoid k_heap_init(struct k_heap *heap, void *mem, size_t bytes)\n{\n\tz_waitq_init(&heap->wait_q);\n\tsys_heap_init(&heap->heap, mem, bytes);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);\n}\n",
                {
                    "15": "void k_heap_init(struct k_heap *heap, void *mem, size_t bytes)",
                    "16": "{",
                    "17": "\tz_waitq_init(&heap->wait_q);",
                    "18": "\tsys_heap_init(&heap->heap, mem, bytes);",
                    "19": "",
                    "20": "\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);",
                    "21": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_init": {
            "name": "k_mem_slab_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mem_slab.c",
            "location_line": 171,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\nint k_mem_slab_init(struct k_mem_slab *slab, void *buffer,\n\t\t    size_t block_size, uint32_t num_blocks)\n{\n\tint rc;\n\n\tslab->info.num_blocks = num_blocks;\n\tslab->info.block_size = block_size;\n\tslab->buffer = buffer;\n\tslab->info.num_used = 0U;\n\tslab->lock = (struct k_spinlock) {};\n\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\tslab->info.max_used = 0U;\n#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */\n\n\trc = create_free_list(slab);\n\tif (rc < 0) {\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_OBJ_CORE_MEM_SLAB\n\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);\n#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\n#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB\n\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,\n\t\t\t\t  sizeof(struct k_mem_slab_info));\n#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */\n\n\tz_waitq_init(&slab->wait_q);\n\tk_object_init(slab);\nout:\n\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);\n\n\treturn rc;\n}\n",
                {
                    "171": "int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,",
                    "172": "\t\t    size_t block_size, uint32_t num_blocks)",
                    "173": "{",
                    "174": "\tint rc;",
                    "175": "",
                    "176": "\tslab->info.num_blocks = num_blocks;",
                    "177": "\tslab->info.block_size = block_size;",
                    "178": "\tslab->buffer = buffer;",
                    "179": "\tslab->info.num_used = 0U;",
                    "180": "\tslab->lock = (struct k_spinlock) {};",
                    "181": "",
                    "182": "#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION",
                    "183": "\tslab->info.max_used = 0U;",
                    "184": "#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */",
                    "185": "",
                    "186": "\trc = create_free_list(slab);",
                    "187": "\tif (rc < 0) {",
                    "188": "\t\tgoto out;",
                    "189": "\t}",
                    "190": "",
                    "191": "#ifdef CONFIG_OBJ_CORE_MEM_SLAB",
                    "192": "\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);",
                    "193": "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */",
                    "194": "#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB",
                    "195": "\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,",
                    "196": "\t\t\t\t  sizeof(struct k_mem_slab_info));",
                    "197": "#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */",
                    "198": "",
                    "199": "\tz_waitq_init(&slab->wait_q);",
                    "200": "\tk_object_init(slab);",
                    "201": "out:",
                    "202": "\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);",
                    "203": "",
                    "204": "\treturn rc;",
                    "205": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_get": {
            "name": "k_mbox_get",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mailbox.c",
            "location_line": 382,
            "function_content": [
                "/* keep message around for later data retrieval */\nint k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,\n\t       k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_mbox_msg *tx_msg;\n\tk_spinlock_key_t key;\n\tint result;\n\n\t/* save receiver id so it can be used during message matching */\n\trx_msg->tx_target_thread = _current;\n\n\t/* search mailbox's tx queue for a compatible sender */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {\n\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take sender out of mailbox's tx queue */\n\t\t\tz_unpend_thread(sending_thread);\n\n\t\t\tk_spin_unlock(&mbox->lock, key);\n\n\t\t\t/* consume message data immediately, if needed */\n\t\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* didn't find a matching sender */\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);\n\n\t\t/* don't wait for a matching sender to appear */\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);\n\n\t/* wait until a matching sender appears or a timeout occurs */\n\t_current->base.swap_data = rx_msg;\n\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);\n\n\t/* consume message data immediately, if needed */\n\tif (result == 0) {\n\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\n\treturn result;\n}\n",
                {
                    "382": "int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,",
                    "383": "\t       k_timeout_t timeout)",
                    "384": "{",
                    "385": "\tstruct k_thread *sending_thread;",
                    "386": "\tstruct k_mbox_msg *tx_msg;",
                    "387": "\tk_spinlock_key_t key;",
                    "388": "\tint result;",
                    "389": "",
                    "390": "\t/* save receiver id so it can be used during message matching */",
                    "391": "\trx_msg->tx_target_thread = _current;",
                    "392": "",
                    "393": "\t/* search mailbox's tx queue for a compatible sender */",
                    "394": "\tkey = k_spin_lock(&mbox->lock);",
                    "395": "",
                    "396": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);",
                    "397": "",
                    "398": "\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {",
                    "399": "\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;",
                    "400": "",
                    "401": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "402": "\t\t\t/* take sender out of mailbox's tx queue */",
                    "403": "\t\t\tz_unpend_thread(sending_thread);",
                    "404": "",
                    "405": "\t\t\tk_spin_unlock(&mbox->lock, key);",
                    "406": "",
                    "407": "\t\t\t/* consume message data immediately, if needed */",
                    "408": "\t\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "409": "",
                    "410": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "411": "\t\t\treturn result;",
                    "412": "\t\t}",
                    "413": "\t}",
                    "414": "",
                    "415": "\t/* didn't find a matching sender */",
                    "416": "",
                    "417": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "418": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);",
                    "419": "",
                    "420": "\t\t/* don't wait for a matching sender to appear */",
                    "421": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "422": "\t\treturn -ENOMSG;",
                    "423": "\t}",
                    "424": "",
                    "425": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);",
                    "426": "",
                    "427": "\t/* wait until a matching sender appears or a timeout occurs */",
                    "428": "\t_current->base.swap_data = rx_msg;",
                    "429": "\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);",
                    "430": "",
                    "431": "\t/* consume message data immediately, if needed */",
                    "432": "\tif (result == 0) {",
                    "433": "\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "434": "\t}",
                    "435": "",
                    "436": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "437": "",
                    "438": "\treturn result;",
                    "439": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_init": {
            "name": "k_mbox_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mailbox.c",
            "location_line": 87,
            "function_content": [
                "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS > 0 */\nvoid k_mbox_init(struct k_mbox *mbox)\n{\n\tz_waitq_init(&mbox->tx_msg_queue);\n\tz_waitq_init(&mbox->rx_msg_queue);\n\tmbox->lock = (struct k_spinlock) {};\n\n#ifdef CONFIG_OBJ_CORE_MAILBOX\n\tk_obj_core_init_and_link(K_OBJ_CORE(mbox), &obj_type_mailbox);\n#endif /* CONFIG_OBJ_CORE_MAILBOX */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_mbox, mbox);\n}\n",
                {
                    "87": "void k_mbox_init(struct k_mbox *mbox)",
                    "88": "{",
                    "89": "\tz_waitq_init(&mbox->tx_msg_queue);",
                    "90": "\tz_waitq_init(&mbox->rx_msg_queue);",
                    "91": "\tmbox->lock = (struct k_spinlock) {};",
                    "92": "",
                    "93": "#ifdef CONFIG_OBJ_CORE_MAILBOX",
                    "94": "\tk_obj_core_init_and_link(K_OBJ_CORE(mbox), &obj_type_mailbox);",
                    "95": "#endif /* CONFIG_OBJ_CORE_MAILBOX */",
                    "96": "",
                    "97": "\tSYS_PORT_TRACING_OBJ_INIT(k_mbox, mbox);",
                    "98": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_cleanup": {
            "name": "k_msgq_cleanup",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/msg_q.c",
            "location_line": 103,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_msgq_cleanup(struct k_msgq *msgq)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);\n\n\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);\n\n\t\treturn -EBUSY;\n\t}\n\n\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {\n\t\tk_free(msgq->buffer_start);\n\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);\n\n\treturn 0;\n}\n",
                {
                    "103": "int k_msgq_cleanup(struct k_msgq *msgq)",
                    "104": "{",
                    "105": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);",
                    "106": "",
                    "107": "\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {",
                    "108": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);",
                    "109": "",
                    "110": "\t\treturn -EBUSY;",
                    "111": "\t}",
                    "112": "",
                    "113": "\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {",
                    "114": "\t\tk_free(msgq->buffer_start);",
                    "115": "\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;",
                    "116": "\t}",
                    "117": "",
                    "118": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);",
                    "119": "",
                    "120": "\treturn 0;",
                    "121": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_init": {
            "name": "k_msgq_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/msg_q.c",
            "location_line": 39,
            "function_content": [
                "#endif /* CONFIG_POLL */\nvoid k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,\n\t\t uint32_t max_msgs)\n{\n\tmsgq->msg_size = msg_size;\n\tmsgq->max_msgs = max_msgs;\n\tmsgq->buffer_start = buffer;\n\tmsgq->buffer_end = buffer + (max_msgs * msg_size);\n\tmsgq->read_ptr = buffer;\n\tmsgq->write_ptr = buffer;\n\tmsgq->used_msgs = 0;\n\tmsgq->flags = 0;\n\tz_waitq_init(&msgq->wait_q);\n\tmsgq->lock = (struct k_spinlock) {};\n#ifdef CONFIG_POLL\n\tsys_dlist_init(&msgq->poll_events);\n#endif\t/* CONFIG_POLL */\n\n#ifdef CONFIG_OBJ_CORE_MSGQ\n\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);\n#endif /* CONFIG_OBJ_CORE_MSGQ */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);\n\n\tk_object_init(msgq);\n}\n",
                {
                    "39": "void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,",
                    "40": "\t\t uint32_t max_msgs)",
                    "41": "{",
                    "42": "\tmsgq->msg_size = msg_size;",
                    "43": "\tmsgq->max_msgs = max_msgs;",
                    "44": "\tmsgq->buffer_start = buffer;",
                    "45": "\tmsgq->buffer_end = buffer + (max_msgs * msg_size);",
                    "46": "\tmsgq->read_ptr = buffer;",
                    "47": "\tmsgq->write_ptr = buffer;",
                    "48": "\tmsgq->used_msgs = 0;",
                    "49": "\tmsgq->flags = 0;",
                    "50": "\tz_waitq_init(&msgq->wait_q);",
                    "51": "\tmsgq->lock = (struct k_spinlock) {};",
                    "52": "#ifdef CONFIG_POLL",
                    "53": "\tsys_dlist_init(&msgq->poll_events);",
                    "54": "#endif\t/* CONFIG_POLL */",
                    "55": "",
                    "56": "#ifdef CONFIG_OBJ_CORE_MSGQ",
                    "57": "\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);",
                    "58": "#endif /* CONFIG_OBJ_CORE_MSGQ */",
                    "59": "",
                    "60": "\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);",
                    "61": "",
                    "62": "\tk_object_init(msgq);",
                    "63": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_cancel_delayable_sync": {
            "name": "k_work_cancel_delayable_sync",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 1065,
            "function_content": [
                "/* Schedule the work item with the new parameters. */\nbool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,\n\t\t\t\t  struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);\n\n\tstruct z_work_canceller *canceller = &sync->canceller;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tbool pending = (work_delayable_busy_get_locked(dwork) != 0U);\n\tbool need_wait = false;\n\n\tif (pending) {\n\t\t(void)cancel_delayable_async_locked(dwork);\n\t\tneed_wait = cancel_sync_locked(&dwork->work, canceller);\n\t}\n\n\tk_spin_unlock(&lock, key);\n\n\tif (need_wait) {\n\t\tk_sem_take(&canceller->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);\n\treturn pending;\n}\n",
                {
                    "1065": "bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,",
                    "1066": "\t\t\t\t  struct k_work_sync *sync)",
                    "1067": "{",
                    "1068": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "1069": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "1070": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "1071": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "1072": "\t__ASSERT_NO_MSG(arch_mem_coherent(sync));",
                    "1073": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "1074": "",
                    "1075": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);",
                    "1076": "",
                    "1077": "\tstruct z_work_canceller *canceller = &sync->canceller;",
                    "1078": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "1079": "\tbool pending = (work_delayable_busy_get_locked(dwork) != 0U);",
                    "1080": "\tbool need_wait = false;",
                    "1081": "",
                    "1082": "\tif (pending) {",
                    "1083": "\t\t(void)cancel_delayable_async_locked(dwork);",
                    "1084": "\t\tneed_wait = cancel_sync_locked(&dwork->work, canceller);",
                    "1085": "\t}",
                    "1086": "",
                    "1087": "\tk_spin_unlock(&lock, key);",
                    "1088": "",
                    "1089": "\tif (need_wait) {",
                    "1090": "\t\tk_sem_take(&canceller->sem, K_FOREVER);",
                    "1091": "\t}",
                    "1092": "",
                    "1093": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);",
                    "1094": "\treturn pending;",
                    "1095": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_flush_delayable": {
            "name": "k_work_flush_delayable",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 1097,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nbool k_work_flush_delayable(struct k_work_delayable *dwork,\n\t\t\t    struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush_delayable, dwork, sync);\n\n\tstruct k_work *work = &dwork->work;\n\tstruct z_work_flusher *flusher = &sync->flusher;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\t/* If it's idle release the lock and return immediately. */\n\tif (work_busy_get_locked(work) == 0U) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, false);\n\n\t\treturn false;\n\t}\n\n\t/* If unscheduling did something then submit it.  Ignore a\n\t * failed submission (e.g. when cancelling).\n\t */\n\tif (unschedule_locked(dwork)) {\n\t\tstruct k_work_q *queue = dwork->queue;\n\n\t\t(void)submit_to_queue_locked(work, &queue);\n\t}\n\n\t/* Wait for it to finish */\n\tbool need_flush = work_flush_locked(work, flusher);\n\n\tk_spin_unlock(&lock, key);\n\n\t/* If necessary wait until the flusher item completes */\n\tif (need_flush) {\n\t\tk_sem_take(&flusher->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, need_flush);\n\n\treturn need_flush;\n}\n",
                {
                    "1097": "bool k_work_flush_delayable(struct k_work_delayable *dwork,",
                    "1098": "\t\t\t    struct k_work_sync *sync)",
                    "1099": "{",
                    "1100": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "1101": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "1102": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "1103": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "1104": "\t__ASSERT_NO_MSG(arch_mem_coherent(sync));",
                    "1105": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "1106": "",
                    "1107": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush_delayable, dwork, sync);",
                    "1108": "",
                    "1109": "\tstruct k_work *work = &dwork->work;",
                    "1110": "\tstruct z_work_flusher *flusher = &sync->flusher;",
                    "1111": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "1112": "",
                    "1113": "\t/* If it's idle release the lock and return immediately. */",
                    "1114": "\tif (work_busy_get_locked(work) == 0U) {",
                    "1115": "\t\tk_spin_unlock(&lock, key);",
                    "1116": "",
                    "1117": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, false);",
                    "1118": "",
                    "1119": "\t\treturn false;",
                    "1120": "\t}",
                    "1121": "",
                    "1122": "\t/* If unscheduling did something then submit it.  Ignore a",
                    "1123": "\t * failed submission (e.g. when cancelling).",
                    "1124": "\t */",
                    "1125": "\tif (unschedule_locked(dwork)) {",
                    "1126": "\t\tstruct k_work_q *queue = dwork->queue;",
                    "1127": "",
                    "1128": "\t\t(void)submit_to_queue_locked(work, &queue);",
                    "1129": "\t}",
                    "1130": "",
                    "1131": "\t/* Wait for it to finish */",
                    "1132": "\tbool need_flush = work_flush_locked(work, flusher);",
                    "1133": "",
                    "1134": "\tk_spin_unlock(&lock, key);",
                    "1135": "",
                    "1136": "\t/* If necessary wait until the flusher item completes */",
                    "1137": "\tif (need_flush) {",
                    "1138": "\t\tk_sem_take(&flusher->sem, K_FOREVER);",
                    "1139": "\t}",
                    "1140": "",
                    "1141": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, need_flush);",
                    "1142": "",
                    "1143": "\treturn need_flush;",
                    "1144": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_init_delayable": {
            "name": "k_work_init_delayable",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 856,
            "function_content": [
                "/* If the work is still marked delayed (should be) then clear that\n* state and submit it to the queue.  If successful the queue will be\n* notified of new work at the next reschedule point.\n*\n* If not successful there is no notification that the work has been\n* abandoned.  Sorry.\n*/\nvoid k_work_init_delayable(struct k_work_delayable *dwork,\n\t\t\t    k_work_handler_t handler)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(handler != NULL);\n\n\t*dwork = (struct k_work_delayable){\n\t\t.work = {\n\t\t\t.handler = handler,\n\t\t\t.flags = K_WORK_DELAYABLE,\n\t\t},\n\t};\n\tz_init_timeout(&dwork->timeout);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_work_delayable, dwork);\n}\n",
                {
                    "856": "void k_work_init_delayable(struct k_work_delayable *dwork,",
                    "857": "\t\t\t    k_work_handler_t handler)",
                    "858": "{",
                    "859": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "860": "\t__ASSERT_NO_MSG(handler != NULL);",
                    "861": "",
                    "862": "\t*dwork = (struct k_work_delayable){",
                    "863": "\t\t.work = {",
                    "864": "\t\t\t.handler = handler,",
                    "865": "\t\t\t.flags = K_WORK_DELAYABLE,",
                    "866": "\t\t},",
                    "867": "\t};",
                    "868": "\tz_init_timeout(&dwork->timeout);",
                    "869": "",
                    "870": "\tSYS_PORT_TRACING_OBJ_INIT(k_work_delayable, dwork);",
                    "871": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_queue_start": {
            "name": "k_work_queue_start",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 729,
            "function_content": [
                "/* Optionally yield to prevent the work queue from\n* starving other threads.\n*/\nvoid k_work_queue_start(struct k_work_q *queue,\n\t\t\tk_thread_stack_t *stack,\n\t\t\tsize_t stack_size,\n\t\t\tint prio,\n\t\t\tconst struct k_work_queue_config *cfg)\n{\n\t__ASSERT_NO_MSG(queue);\n\t__ASSERT_NO_MSG(stack);\n\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));\n\tuint32_t flags = K_WORK_QUEUE_STARTED;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);\n\n\tsys_slist_init(&queue->pending);\n\tz_waitq_init(&queue->notifyq);\n\tz_waitq_init(&queue->drainq);\n\n\tif ((cfg != NULL) && cfg->no_yield) {\n\t\tflags |= K_WORK_QUEUE_NO_YIELD;\n\t}\n\n\t/* It hasn't actually been started yet, but all the state is in place\n\t * so we can submit things and once the thread gets control it's ready\n\t * to roll.\n\t */\n\tflags_set(&queue->flags, flags);\n\n\t(void)k_thread_create(&queue->thread, stack, stack_size,\n\t\t\t      work_queue_main, queue, NULL, NULL,\n\t\t\t      prio, 0, K_FOREVER);\n\n\tif ((cfg != NULL) && (cfg->name != NULL)) {\n\t\tk_thread_name_set(&queue->thread, cfg->name);\n\t}\n\n\tif ((cfg != NULL) && (cfg->essential)) {\n\t\tqueue->thread.base.user_options |= K_ESSENTIAL;\n\t}\n\n\tk_thread_start(&queue->thread);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);\n}\n",
                {
                    "729": "void k_work_queue_start(struct k_work_q *queue,",
                    "730": "\t\t\tk_thread_stack_t *stack,",
                    "731": "\t\t\tsize_t stack_size,",
                    "732": "\t\t\tint prio,",
                    "733": "\t\t\tconst struct k_work_queue_config *cfg)",
                    "734": "{",
                    "735": "\t__ASSERT_NO_MSG(queue);",
                    "736": "\t__ASSERT_NO_MSG(stack);",
                    "737": "\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));",
                    "738": "\tuint32_t flags = K_WORK_QUEUE_STARTED;",
                    "739": "",
                    "740": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);",
                    "741": "",
                    "742": "\tsys_slist_init(&queue->pending);",
                    "743": "\tz_waitq_init(&queue->notifyq);",
                    "744": "\tz_waitq_init(&queue->drainq);",
                    "745": "",
                    "746": "\tif ((cfg != NULL) && cfg->no_yield) {",
                    "747": "\t\tflags |= K_WORK_QUEUE_NO_YIELD;",
                    "748": "\t}",
                    "749": "",
                    "750": "\t/* It hasn't actually been started yet, but all the state is in place",
                    "751": "\t * so we can submit things and once the thread gets control it's ready",
                    "752": "\t * to roll.",
                    "753": "\t */",
                    "754": "\tflags_set(&queue->flags, flags);",
                    "755": "",
                    "756": "\t(void)k_thread_create(&queue->thread, stack, stack_size,",
                    "757": "\t\t\t      work_queue_main, queue, NULL, NULL,",
                    "758": "\t\t\t      prio, 0, K_FOREVER);",
                    "759": "",
                    "760": "\tif ((cfg != NULL) && (cfg->name != NULL)) {",
                    "761": "\t\tk_thread_name_set(&queue->thread, cfg->name);",
                    "762": "\t}",
                    "763": "",
                    "764": "\tif ((cfg != NULL) && (cfg->essential)) {",
                    "765": "\t\tqueue->thread.base.user_options |= K_ESSENTIAL;",
                    "766": "\t}",
                    "767": "",
                    "768": "\tk_thread_start(&queue->thread);",
                    "769": "",
                    "770": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);",
                    "771": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_cancel_sync": {
            "name": "k_work_cancel_sync",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 577,
            "function_content": [
                "/* If something's still running then we have to wait for\n* completion, which is indicated when finish_cancel() gets\n* invoked.\n*/\nbool k_work_cancel_sync(struct k_work *work,\n\t\t\tstruct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(work != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_sync, work, sync);\n\n\tstruct z_work_canceller *canceller = &sync->canceller;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tbool pending = (work_busy_get_locked(work) != 0U);\n\tbool need_wait = false;\n\n\tif (pending) {\n\t\t(void)cancel_async_locked(work);\n\t\tneed_wait = cancel_sync_locked(work, canceller);\n\t}\n\n\tk_spin_unlock(&lock, key);\n\n\tif (need_wait) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, cancel_sync, work, sync);\n\n\t\tk_sem_take(&canceller->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_sync, work, sync, pending);\n\treturn pending;\n}\n",
                {
                    "577": "bool k_work_cancel_sync(struct k_work *work,",
                    "578": "\t\t\tstruct k_work_sync *sync)",
                    "579": "{",
                    "580": "\t__ASSERT_NO_MSG(work != NULL);",
                    "581": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "582": "\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));",
                    "583": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "584": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "585": "\t__ASSERT_NO_MSG(arch_mem_coherent(sync));",
                    "586": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "587": "",
                    "588": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_sync, work, sync);",
                    "589": "",
                    "590": "\tstruct z_work_canceller *canceller = &sync->canceller;",
                    "591": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "592": "\tbool pending = (work_busy_get_locked(work) != 0U);",
                    "593": "\tbool need_wait = false;",
                    "594": "",
                    "595": "\tif (pending) {",
                    "596": "\t\t(void)cancel_async_locked(work);",
                    "597": "\t\tneed_wait = cancel_sync_locked(work, canceller);",
                    "598": "\t}",
                    "599": "",
                    "600": "\tk_spin_unlock(&lock, key);",
                    "601": "",
                    "602": "\tif (need_wait) {",
                    "603": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, cancel_sync, work, sync);",
                    "604": "",
                    "605": "\t\tk_sem_take(&canceller->sem, K_FOREVER);",
                    "606": "\t}",
                    "607": "",
                    "608": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_sync, work, sync, pending);",
                    "609": "\treturn pending;",
                    "610": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_flush": {
            "name": "k_work_flush",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/work.c",
            "location_line": 465,
            "function_content": [
                "/* Flush the work item if necessary.\n*\n* Flushing is necessary only if the work is either queued or running.\n*\n* Invoked with work lock held by key.\n* Sleeps.\n*\n* @param work the work item that is to be flushed\n* @param flusher state used to synchronize the flush\n*\n* @retval true if work is queued or running.  If this happens the\n* caller must take the flusher semaphore after releasing the lock.\n*\n* @retval false otherwise.  No wait required.\n*/\nbool k_work_flush(struct k_work *work,\n\t\t  struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(work != NULL);\n\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(sync != NULL);\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush, work);\n\n\tstruct z_work_flusher *flusher = &sync->flusher;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tbool need_flush = work_flush_locked(work, flusher);\n\n\tk_spin_unlock(&lock, key);\n\n\t/* If necessary wait until the flusher item completes */\n\tif (need_flush) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, flush, work, K_FOREVER);\n\n\t\tk_sem_take(&flusher->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush, work, need_flush);\n\n\treturn need_flush;\n}\n",
                {
                    "465": "bool k_work_flush(struct k_work *work,",
                    "466": "\t\t  struct k_work_sync *sync)",
                    "467": "{",
                    "468": "\t__ASSERT_NO_MSG(work != NULL);",
                    "469": "\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));",
                    "470": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "471": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "472": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "473": "\t__ASSERT_NO_MSG(arch_mem_coherent(sync));",
                    "474": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "475": "",
                    "476": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush, work);",
                    "477": "",
                    "478": "\tstruct z_work_flusher *flusher = &sync->flusher;",
                    "479": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "480": "",
                    "481": "\tbool need_flush = work_flush_locked(work, flusher);",
                    "482": "",
                    "483": "\tk_spin_unlock(&lock, key);",
                    "484": "",
                    "485": "\t/* If necessary wait until the flusher item completes */",
                    "486": "\tif (need_flush) {",
                    "487": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, flush, work, K_FOREVER);",
                    "488": "",
                    "489": "\t\tk_sem_take(&flusher->sem, K_FOREVER);",
                    "490": "\t}",
                    "491": "",
                    "492": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush, work, need_flush);",
                    "493": "",
                    "494": "\treturn need_flush;",
                    "495": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_stack_cleanup": {
            "name": "k_stack_cleanup",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/stack.c",
            "location_line": 80,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_stack_cleanup(struct k_stack *stack)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);\n\n\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {\n\t\tk_free(stack->base);\n\t\tstack->base = NULL;\n\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);\n\n\treturn 0;\n}\n",
                {
                    "80": "int k_stack_cleanup(struct k_stack *stack)",
                    "81": "{",
                    "82": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);",
                    "83": "",
                    "84": "\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {",
                    "85": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);",
                    "86": "",
                    "87": "\t\treturn -EAGAIN;",
                    "88": "\t}",
                    "89": "",
                    "90": "\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {",
                    "91": "\t\tk_free(stack->base);",
                    "92": "\t\tstack->base = NULL;",
                    "93": "\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;",
                    "94": "\t}",
                    "95": "",
                    "96": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);",
                    "97": "",
                    "98": "\treturn 0;",
                    "99": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_stack_init": {
            "name": "k_stack_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/stack.c",
            "location_line": 27,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_STACK */\nvoid k_stack_init(struct k_stack *stack, stack_data_t *buffer,\n\t\t  uint32_t num_entries)\n{\n\tz_waitq_init(&stack->wait_q);\n\tstack->lock = (struct k_spinlock) {};\n\tstack->next = buffer;\n\tstack->base = buffer;\n\tstack->top = stack->base + num_entries;\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_stack, stack);\n\tk_object_init(stack);\n\n#ifdef CONFIG_OBJ_CORE_STACK\n\tk_obj_core_init_and_link(K_OBJ_CORE(stack), &obj_type_stack);\n#endif /* CONFIG_OBJ_CORE_STACK */\n}\n",
                {
                    "27": "void k_stack_init(struct k_stack *stack, stack_data_t *buffer,",
                    "28": "\t\t  uint32_t num_entries)",
                    "29": "{",
                    "30": "\tz_waitq_init(&stack->wait_q);",
                    "31": "\tstack->lock = (struct k_spinlock) {};",
                    "32": "\tstack->next = buffer;",
                    "33": "\tstack->base = buffer;",
                    "34": "\tstack->top = stack->base + num_entries;",
                    "35": "",
                    "36": "\tSYS_PORT_TRACING_OBJ_INIT(k_stack, stack);",
                    "37": "\tk_object_init(stack);",
                    "38": "",
                    "39": "#ifdef CONFIG_OBJ_CORE_STACK",
                    "40": "\tk_obj_core_init_and_link(K_OBJ_CORE(stack), &obj_type_stack);",
                    "41": "#endif /* CONFIG_OBJ_CORE_STACK */",
                    "42": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_timer_init": {
            "name": "k_timer_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timer.c",
            "location_line": 113,
            "function_content": [
                "/* Unlock for user handler. */\nvoid k_timer_init(struct k_timer *timer,\n\t\t\t k_timer_expiry_t expiry_fn,\n\t\t\t k_timer_stop_t stop_fn)\n{\n\ttimer->expiry_fn = expiry_fn;\n\ttimer->stop_fn = stop_fn;\n\ttimer->status = 0U;\n\n\tif (IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tz_waitq_init(&timer->wait_q);\n\t}\n\n\tz_init_timeout(&timer->timeout);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_timer, timer);\n\n\ttimer->user_data = NULL;\n\n\tk_object_init(timer);\n\n#ifdef CONFIG_OBJ_CORE_TIMER\n\tk_obj_core_init_and_link(K_OBJ_CORE(timer), &obj_type_timer);\n#endif /* CONFIG_OBJ_CORE_TIMER */\n}\n",
                {
                    "113": "void k_timer_init(struct k_timer *timer,",
                    "114": "\t\t\t k_timer_expiry_t expiry_fn,",
                    "115": "\t\t\t k_timer_stop_t stop_fn)",
                    "116": "{",
                    "117": "\ttimer->expiry_fn = expiry_fn;",
                    "118": "\ttimer->stop_fn = stop_fn;",
                    "119": "\ttimer->status = 0U;",
                    "120": "",
                    "121": "\tif (IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "122": "\t\tz_waitq_init(&timer->wait_q);",
                    "123": "\t}",
                    "124": "",
                    "125": "\tz_init_timeout(&timer->timeout);",
                    "126": "",
                    "127": "\tSYS_PORT_TRACING_OBJ_INIT(k_timer, timer);",
                    "128": "",
                    "129": "\ttimer->user_data = NULL;",
                    "130": "",
                    "131": "\tk_object_init(timer);",
                    "132": "",
                    "133": "#ifdef CONFIG_OBJ_CORE_TIMER",
                    "134": "\tk_obj_core_init_and_link(K_OBJ_CORE(timer), &obj_type_timer);",
                    "135": "#endif /* CONFIG_OBJ_CORE_TIMER */",
                    "136": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timeout_remaining": {
            "name": "z_timeout_remaining",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 173,
            "function_content": [
                "/* must be locked */\nk_ticks_t z_timeout_remaining(const struct _timeout *timeout)\n{\n\tk_ticks_t ticks = 0;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tif (!z_is_inactive_timeout(timeout)) {\n\t\t\tticks = timeout_rem(timeout) - elapsed();\n\t\t}\n\t}\n\n\treturn ticks;\n}\n",
                {
                    "173": "k_ticks_t z_timeout_remaining(const struct _timeout *timeout)",
                    "174": "{",
                    "175": "\tk_ticks_t ticks = 0;",
                    "176": "",
                    "177": "\tK_SPINLOCK(&timeout_lock) {",
                    "178": "\t\tif (!z_is_inactive_timeout(timeout)) {",
                    "179": "\t\t\tticks = timeout_rem(timeout) - elapsed();",
                    "180": "\t\t}",
                    "181": "\t}",
                    "182": "",
                    "183": "\treturn ticks;",
                    "184": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timeout_expires": {
            "name": "z_timeout_expires",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 186,
            "function_content": [
                "/* must be locked */\nk_ticks_t z_timeout_expires(const struct _timeout *timeout)\n{\n\tk_ticks_t ticks = 0;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tticks = curr_tick;\n\t\tif (!z_is_inactive_timeout(timeout)) {\n\t\t\tticks += timeout_rem(timeout);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n",
                {
                    "186": "k_ticks_t z_timeout_expires(const struct _timeout *timeout)",
                    "187": "{",
                    "188": "\tk_ticks_t ticks = 0;",
                    "189": "",
                    "190": "\tK_SPINLOCK(&timeout_lock) {",
                    "191": "\t\tticks = curr_tick;",
                    "192": "\t\tif (!z_is_inactive_timeout(timeout)) {",
                    "193": "\t\t\tticks += timeout_rem(timeout);",
                    "194": "\t\t}",
                    "195": "\t}",
                    "196": "",
                    "197": "\treturn ticks;",
                    "198": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_setup_new_thread": {
            "name": "z_setup_new_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/thread.c",
            "location_line": 517,
            "function_content": [
                "/*\n* The provided stack_size value is presumed to be either the result of\n* K_THREAD_STACK_SIZEOF(stack), or the size value passed to the instance\n* of K_THREAD_STACK_DEFINE() which defined 'stack'.\n*/\nchar *z_setup_new_thread(struct k_thread *new_thread,\n\t\t\t k_thread_stack_t *stack, size_t stack_size,\n\t\t\t k_thread_entry_t entry,\n\t\t\t void *p1, void *p2, void *p3,\n\t\t\t int prio, uint32_t options, const char *name)\n{\n\tchar *stack_ptr;\n\n\tZ_ASSERT_VALID_PRIO(prio, entry);\n\n#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP\n\tk_thread_abort_cleanup_check_reuse(new_thread);\n#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */\n\n#ifdef CONFIG_OBJ_CORE_THREAD\n\tk_obj_core_init_and_link(K_OBJ_CORE(new_thread), &obj_type_thread);\n#ifdef CONFIG_OBJ_CORE_STATS_THREAD\n\tk_obj_core_stats_register(K_OBJ_CORE(new_thread),\n\t\t\t\t  &new_thread->base.usage,\n\t\t\t\t  sizeof(new_thread->base.usage));\n#endif /* CONFIG_OBJ_CORE_STATS_THREAD */\n#endif /* CONFIG_OBJ_CORE_THREAD */\n\n#ifdef CONFIG_USERSPACE\n\t__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),\n\t\t \"user thread %p with kernel-only stack %p\",\n\t\t new_thread, stack);\n\tk_object_init(new_thread);\n\tk_object_init(stack);\n\tnew_thread->stack_obj = stack;\n\tnew_thread->syscall_frame = NULL;\n\n\t/* Any given thread has access to itself */\n\tk_object_access_grant(new_thread, new_thread);\n#endif /* CONFIG_USERSPACE */\n\tz_waitq_init(&new_thread->join_queue);\n\n\t/* Initialize various struct k_thread members */\n\tz_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);\n\tstack_ptr = setup_thread_stack(new_thread, stack, stack_size);\n\n#ifdef CONFIG_KERNEL_COHERENCE\n\t/* Check that the thread object is safe, but that the stack is\n\t * still cached!\n\t */\n\t__ASSERT_NO_MSG(arch_mem_coherent(new_thread));\n\n\t/* When dynamic thread stack is available, the stack may come from\n\t * uncached area.\n\t */\n#ifndef CONFIG_DYNAMIC_THREAD\n\t__ASSERT_NO_MSG(!arch_mem_coherent(stack));\n#endif  /* CONFIG_DYNAMIC_THREAD */\n\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tarch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);\n\n\t/* static threads overwrite it afterwards with real value */\n\tnew_thread->init_data = NULL;\n\n#ifdef CONFIG_USE_SWITCH\n\t/* switch_handle must be non-null except when inside z_swap()\n\t * for synchronization reasons.  Historically some notional\n\t * USE_SWITCH architectures have actually ignored the field\n\t */\n\t__ASSERT(new_thread->switch_handle != NULL,\n\t\t \"arch layer failed to initialize switch_handle\");\n#endif /* CONFIG_USE_SWITCH */\n#ifdef CONFIG_THREAD_CUSTOM_DATA\n\t/* Initialize custom data field (value is opaque to kernel) */\n\tnew_thread->custom_data = NULL;\n#endif /* CONFIG_THREAD_CUSTOM_DATA */\n#ifdef CONFIG_EVENTS\n\tnew_thread->no_wake_on_timeout = false;\n#endif /* CONFIG_EVENTS */\n#ifdef CONFIG_THREAD_MONITOR\n\tnew_thread->entry.pEntry = entry;\n\tnew_thread->entry.parameter1 = p1;\n\tnew_thread->entry.parameter2 = p2;\n\tnew_thread->entry.parameter3 = p3;\n\n\tk_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);\n\n\tnew_thread->next_thread = _kernel.threads;\n\t_kernel.threads = new_thread;\n\tk_spin_unlock(&z_thread_monitor_lock, key);\n#endif /* CONFIG_THREAD_MONITOR */\n#ifdef CONFIG_THREAD_NAME\n\tif (name != NULL) {\n\t\tstrncpy(new_thread->name, name,\n\t\t\tCONFIG_THREAD_MAX_NAME_LEN - 1);\n\t\t/* Ensure NULL termination, truncate if longer */\n\t\tnew_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\\0';\n\t} else {\n\t\tnew_thread->name[0] = '\\0';\n\t}\n#endif /* CONFIG_THREAD_NAME */\n#ifdef CONFIG_SCHED_CPU_MASK\n\tif (IS_ENABLED(CONFIG_SCHED_CPU_MASK_PIN_ONLY)) {\n\t\tnew_thread->base.cpu_mask = 1; /* must specify only one cpu */\n\t} else {\n\t\tnew_thread->base.cpu_mask = -1; /* allow all cpus */\n\t}\n#endif /* CONFIG_SCHED_CPU_MASK */\n#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN\n\t/* _current may be null if the dummy thread is not used */\n\tif (!_current) {\n\t\tnew_thread->resource_pool = NULL;\n\t\treturn stack_ptr;\n\t}\n#endif /* CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN */\n#ifdef CONFIG_USERSPACE\n\tz_mem_domain_init_thread(new_thread);\n\n\tif ((options & K_INHERIT_PERMS) != 0U) {\n\t\tk_thread_perms_inherit(_current, new_thread);\n\t}\n#endif /* CONFIG_USERSPACE */\n#ifdef CONFIG_SCHED_DEADLINE\n\tnew_thread->base.prio_deadline = 0;\n#endif /* CONFIG_SCHED_DEADLINE */\n\tnew_thread->resource_pool = _current->resource_pool;\n\n#ifdef CONFIG_SMP\n\tz_waitq_init(&new_thread->halt_queue);\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_SCHED_THREAD_USAGE\n\tnew_thread->base.usage = (struct k_cycle_stats) {};\n\tnew_thread->base.usage.track_usage =\n\t\tCONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;\n#endif /* CONFIG_SCHED_THREAD_USAGE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);\n\n\treturn stack_ptr;\n}\n",
                {
                    "517": "char *z_setup_new_thread(struct k_thread *new_thread,",
                    "518": "\t\t\t k_thread_stack_t *stack, size_t stack_size,",
                    "519": "\t\t\t k_thread_entry_t entry,",
                    "520": "\t\t\t void *p1, void *p2, void *p3,",
                    "521": "\t\t\t int prio, uint32_t options, const char *name)",
                    "522": "{",
                    "523": "\tchar *stack_ptr;",
                    "524": "",
                    "525": "\tZ_ASSERT_VALID_PRIO(prio, entry);",
                    "526": "",
                    "527": "#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP",
                    "528": "\tk_thread_abort_cleanup_check_reuse(new_thread);",
                    "529": "#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */",
                    "530": "",
                    "531": "#ifdef CONFIG_OBJ_CORE_THREAD",
                    "532": "\tk_obj_core_init_and_link(K_OBJ_CORE(new_thread), &obj_type_thread);",
                    "533": "#ifdef CONFIG_OBJ_CORE_STATS_THREAD",
                    "534": "\tk_obj_core_stats_register(K_OBJ_CORE(new_thread),",
                    "535": "\t\t\t\t  &new_thread->base.usage,",
                    "536": "\t\t\t\t  sizeof(new_thread->base.usage));",
                    "537": "#endif /* CONFIG_OBJ_CORE_STATS_THREAD */",
                    "538": "#endif /* CONFIG_OBJ_CORE_THREAD */",
                    "539": "",
                    "540": "#ifdef CONFIG_USERSPACE",
                    "541": "\t__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),",
                    "542": "\t\t \"user thread %p with kernel-only stack %p\",",
                    "543": "\t\t new_thread, stack);",
                    "544": "\tk_object_init(new_thread);",
                    "545": "\tk_object_init(stack);",
                    "546": "\tnew_thread->stack_obj = stack;",
                    "547": "\tnew_thread->syscall_frame = NULL;",
                    "548": "",
                    "549": "\t/* Any given thread has access to itself */",
                    "550": "\tk_object_access_grant(new_thread, new_thread);",
                    "551": "#endif /* CONFIG_USERSPACE */",
                    "552": "\tz_waitq_init(&new_thread->join_queue);",
                    "553": "",
                    "554": "\t/* Initialize various struct k_thread members */",
                    "555": "\tz_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);",
                    "556": "\tstack_ptr = setup_thread_stack(new_thread, stack, stack_size);",
                    "557": "",
                    "558": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "559": "\t/* Check that the thread object is safe, but that the stack is",
                    "560": "\t * still cached!",
                    "561": "\t */",
                    "562": "\t__ASSERT_NO_MSG(arch_mem_coherent(new_thread));",
                    "563": "",
                    "564": "\t/* When dynamic thread stack is available, the stack may come from",
                    "565": "\t * uncached area.",
                    "566": "\t */",
                    "567": "#ifndef CONFIG_DYNAMIC_THREAD",
                    "568": "\t__ASSERT_NO_MSG(!arch_mem_coherent(stack));",
                    "569": "#endif  /* CONFIG_DYNAMIC_THREAD */",
                    "570": "",
                    "571": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "572": "",
                    "573": "\tarch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);",
                    "574": "",
                    "575": "\t/* static threads overwrite it afterwards with real value */",
                    "576": "\tnew_thread->init_data = NULL;",
                    "577": "",
                    "578": "#ifdef CONFIG_USE_SWITCH",
                    "579": "\t/* switch_handle must be non-null except when inside z_swap()",
                    "580": "\t * for synchronization reasons.  Historically some notional",
                    "581": "\t * USE_SWITCH architectures have actually ignored the field",
                    "582": "\t */",
                    "583": "\t__ASSERT(new_thread->switch_handle != NULL,",
                    "584": "\t\t \"arch layer failed to initialize switch_handle\");",
                    "585": "#endif /* CONFIG_USE_SWITCH */",
                    "586": "#ifdef CONFIG_THREAD_CUSTOM_DATA",
                    "587": "\t/* Initialize custom data field (value is opaque to kernel) */",
                    "588": "\tnew_thread->custom_data = NULL;",
                    "589": "#endif /* CONFIG_THREAD_CUSTOM_DATA */",
                    "590": "#ifdef CONFIG_EVENTS",
                    "591": "\tnew_thread->no_wake_on_timeout = false;",
                    "592": "#endif /* CONFIG_EVENTS */",
                    "593": "#ifdef CONFIG_THREAD_MONITOR",
                    "594": "\tnew_thread->entry.pEntry = entry;",
                    "595": "\tnew_thread->entry.parameter1 = p1;",
                    "596": "\tnew_thread->entry.parameter2 = p2;",
                    "597": "\tnew_thread->entry.parameter3 = p3;",
                    "598": "",
                    "599": "\tk_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);",
                    "600": "",
                    "601": "\tnew_thread->next_thread = _kernel.threads;",
                    "602": "\t_kernel.threads = new_thread;",
                    "603": "\tk_spin_unlock(&z_thread_monitor_lock, key);",
                    "604": "#endif /* CONFIG_THREAD_MONITOR */",
                    "605": "#ifdef CONFIG_THREAD_NAME",
                    "606": "\tif (name != NULL) {",
                    "607": "\t\tstrncpy(new_thread->name, name,",
                    "608": "\t\t\tCONFIG_THREAD_MAX_NAME_LEN - 1);",
                    "609": "\t\t/* Ensure NULL termination, truncate if longer */",
                    "610": "\t\tnew_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\\0';",
                    "611": "\t} else {",
                    "612": "\t\tnew_thread->name[0] = '\\0';",
                    "613": "\t}",
                    "614": "#endif /* CONFIG_THREAD_NAME */",
                    "615": "#ifdef CONFIG_SCHED_CPU_MASK",
                    "616": "\tif (IS_ENABLED(CONFIG_SCHED_CPU_MASK_PIN_ONLY)) {",
                    "617": "\t\tnew_thread->base.cpu_mask = 1; /* must specify only one cpu */",
                    "618": "\t} else {",
                    "619": "\t\tnew_thread->base.cpu_mask = -1; /* allow all cpus */",
                    "620": "\t}",
                    "621": "#endif /* CONFIG_SCHED_CPU_MASK */",
                    "622": "#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN",
                    "623": "\t/* _current may be null if the dummy thread is not used */",
                    "624": "\tif (!_current) {",
                    "625": "\t\tnew_thread->resource_pool = NULL;",
                    "626": "\t\treturn stack_ptr;",
                    "627": "\t}",
                    "628": "#endif /* CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN */",
                    "629": "#ifdef CONFIG_USERSPACE",
                    "630": "\tz_mem_domain_init_thread(new_thread);",
                    "631": "",
                    "632": "\tif ((options & K_INHERIT_PERMS) != 0U) {",
                    "633": "\t\tk_thread_perms_inherit(_current, new_thread);",
                    "634": "\t}",
                    "635": "#endif /* CONFIG_USERSPACE */",
                    "636": "#ifdef CONFIG_SCHED_DEADLINE",
                    "637": "\tnew_thread->base.prio_deadline = 0;",
                    "638": "#endif /* CONFIG_SCHED_DEADLINE */",
                    "639": "\tnew_thread->resource_pool = _current->resource_pool;",
                    "640": "",
                    "641": "#ifdef CONFIG_SMP",
                    "642": "\tz_waitq_init(&new_thread->halt_queue);",
                    "643": "#endif /* CONFIG_SMP */",
                    "644": "",
                    "645": "#ifdef CONFIG_SCHED_THREAD_USAGE",
                    "646": "\tnew_thread->base.usage = (struct k_cycle_stats) {};",
                    "647": "\tnew_thread->base.usage.track_usage =",
                    "648": "\t\tCONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;",
                    "649": "#endif /* CONFIG_SCHED_THREAD_USAGE */",
                    "650": "",
                    "651": "\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);",
                    "652": "",
                    "653": "\treturn stack_ptr;",
                    "654": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_init_thread_base": {
            "name": "z_init_thread_base",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/thread.c",
            "location_line": 748,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_init_thread_base(struct _thread_base *thread_base, int priority,\n\t\t       uint32_t initial_state, unsigned int options)\n{\n\t/* k_q_node is initialized upon first insertion in a list */\n\tthread_base->pended_on = NULL;\n\tthread_base->user_options = (uint8_t)options;\n\tthread_base->thread_state = (uint8_t)initial_state;\n\n\tthread_base->prio = priority;\n\n\tthread_base->sched_locked = 0U;\n\n#ifdef CONFIG_SMP\n\tthread_base->is_idle = 0;\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_TIMESLICE_PER_THREAD\n\tthread_base->slice_ticks = 0;\n\tthread_base->slice_expired = NULL;\n#endif /* CONFIG_TIMESLICE_PER_THREAD */\n\n\t/* swap_data does not need to be initialized */\n\n\tz_init_thread_timeout(thread_base);\n}\n",
                {
                    "748": "void z_init_thread_base(struct _thread_base *thread_base, int priority,",
                    "749": "\t\t       uint32_t initial_state, unsigned int options)",
                    "750": "{",
                    "751": "\t/* k_q_node is initialized upon first insertion in a list */",
                    "752": "\tthread_base->pended_on = NULL;",
                    "753": "\tthread_base->user_options = (uint8_t)options;",
                    "754": "\tthread_base->thread_state = (uint8_t)initial_state;",
                    "755": "",
                    "756": "\tthread_base->prio = priority;",
                    "757": "",
                    "758": "\tthread_base->sched_locked = 0U;",
                    "759": "",
                    "760": "#ifdef CONFIG_SMP",
                    "761": "\tthread_base->is_idle = 0;",
                    "762": "#endif /* CONFIG_SMP */",
                    "763": "",
                    "764": "#ifdef CONFIG_TIMESLICE_PER_THREAD",
                    "765": "\tthread_base->slice_ticks = 0;",
                    "766": "\tthread_base->slice_expired = NULL;",
                    "767": "#endif /* CONFIG_TIMESLICE_PER_THREAD */",
                    "768": "",
                    "769": "\t/* swap_data does not need to be initialized */",
                    "770": "",
                    "771": "\tz_init_thread_timeout(thread_base);",
                    "772": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_abort_timeout": {
            "name": "z_abort_timeout",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 144,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nint z_abort_timeout(struct _timeout *to)\n{\n\tint ret = -EINVAL;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tif (sys_dnode_is_linked(&to->node)) {\n\t\t\tremove_timeout(to);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
                {
                    "144": "int z_abort_timeout(struct _timeout *to)",
                    "145": "{",
                    "146": "\tint ret = -EINVAL;",
                    "147": "",
                    "148": "\tK_SPINLOCK(&timeout_lock) {",
                    "149": "\t\tif (sys_dnode_is_linked(&to->node)) {",
                    "150": "\t\t\tremove_timeout(to);",
                    "151": "\t\t\tret = 0;",
                    "152": "\t\t}",
                    "153": "\t}",
                    "154": "",
                    "155": "\treturn ret;",
                    "156": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_add_timeout": {
            "name": "z_add_timeout",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 99,
            "function_content": [
                "/* While sys_clock_announce() is executing, new relative timeouts will be\n* scheduled relatively to the currently firing timeout's original tick\n* value (=curr_tick) rather than relative to the current\n* sys_clock_elapsed().\n*\n* This means that timeouts being scheduled from within timeout callbacks\n* will be scheduled at well-defined offsets from the currently firing\n* timeout.\n*\n* As a side effect, the same will happen if an ISR with higher priority\n* preempts a timeout callback and schedules a timeout.\n*\n* The distinction is implemented by looking at announce_remaining which\n* will be non-zero while sys_clock_announce() is executing and zero\n* otherwise.\n*/\nvoid z_add_timeout(struct _timeout *to, _timeout_func_t fn,\n\t\t   k_timeout_t timeout)\n{\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\treturn;\n\t}\n\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(to));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\t__ASSERT(!sys_dnode_is_linked(&to->node), \"\");\n\tto->fn = fn;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tstruct _timeout *t;\n\n\t\tif (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&\n\t\t    (Z_TICK_ABS(timeout.ticks) >= 0)) {\n\t\t\tk_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;\n\n\t\t\tto->dticks = MAX(1, ticks);\n\t\t} else {\n\t\t\tto->dticks = timeout.ticks + 1 + elapsed();\n\t\t}\n\n\t\tfor (t = first(); t != NULL; t = next(t)) {\n\t\t\tif (t->dticks > to->dticks) {\n\t\t\t\tt->dticks -= to->dticks;\n\t\t\t\tsys_dlist_insert(&t->node, &to->node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tto->dticks -= t->dticks;\n\t\t}\n\n\t\tif (t == NULL) {\n\t\t\tsys_dlist_append(&timeout_list, &to->node);\n\t\t}\n\n\t\tif (to == first() && announce_remaining == 0) {\n\t\t\tsys_clock_set_timeout(next_timeout(), false);\n\t\t}\n\t}\n}\n",
                {
                    "99": "void z_add_timeout(struct _timeout *to, _timeout_func_t fn,",
                    "100": "\t\t   k_timeout_t timeout)",
                    "101": "{",
                    "102": "\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {",
                    "103": "\t\treturn;",
                    "104": "\t}",
                    "105": "",
                    "106": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "107": "\t__ASSERT_NO_MSG(arch_mem_coherent(to));",
                    "108": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "109": "",
                    "110": "\t__ASSERT(!sys_dnode_is_linked(&to->node), \"\");",
                    "111": "\tto->fn = fn;",
                    "112": "",
                    "113": "\tK_SPINLOCK(&timeout_lock) {",
                    "114": "\t\tstruct _timeout *t;",
                    "115": "",
                    "116": "\t\tif (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&",
                    "117": "\t\t    (Z_TICK_ABS(timeout.ticks) >= 0)) {",
                    "118": "\t\t\tk_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;",
                    "119": "",
                    "120": "\t\t\tto->dticks = MAX(1, ticks);",
                    "121": "\t\t} else {",
                    "122": "\t\t\tto->dticks = timeout.ticks + 1 + elapsed();",
                    "123": "\t\t}",
                    "124": "",
                    "125": "\t\tfor (t = first(); t != NULL; t = next(t)) {",
                    "126": "\t\t\tif (t->dticks > to->dticks) {",
                    "127": "\t\t\t\tt->dticks -= to->dticks;",
                    "128": "\t\t\t\tsys_dlist_insert(&t->node, &to->node);",
                    "129": "\t\t\t\tbreak;",
                    "130": "\t\t\t}",
                    "131": "\t\t\tto->dticks -= t->dticks;",
                    "132": "\t\t}",
                    "133": "",
                    "134": "\t\tif (t == NULL) {",
                    "135": "\t\t\tsys_dlist_append(&timeout_list, &to->node);",
                    "136": "\t\t}",
                    "137": "",
                    "138": "\t\tif (to == first() && announce_remaining == 0) {",
                    "139": "\t\t\tsys_clock_set_timeout(next_timeout(), false);",
                    "140": "\t\t}",
                    "141": "\t}",
                    "142": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_waitq_walk": {
            "name": "z_sched_waitq_walk",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1579,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nint z_sched_waitq_walk(_wait_q_t  *wait_q,\n\t\t       int (*func)(struct k_thread *, void *), void *data)\n{\n\tstruct k_thread *thread;\n\tint  status = 0;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {\n\n\t\t\t/*\n\t\t\t * Invoke the callback function on each waiting thread\n\t\t\t * for as long as there are both waiting threads AND\n\t\t\t * it returns 0.\n\t\t\t */\n\n\t\t\tstatus = func(thread, data);\n\t\t\tif (status != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n",
                {
                    "1579": "int z_sched_waitq_walk(_wait_q_t  *wait_q,",
                    "1580": "\t\t       int (*func)(struct k_thread *, void *), void *data)",
                    "1581": "{",
                    "1582": "\tstruct k_thread *thread;",
                    "1583": "\tint  status = 0;",
                    "1584": "",
                    "1585": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1586": "\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {",
                    "1587": "",
                    "1588": "\t\t\t/*",
                    "1589": "\t\t\t * Invoke the callback function on each waiting thread",
                    "1590": "\t\t\t * for as long as there are both waiting threads AND",
                    "1591": "\t\t\t * it returns 0.",
                    "1592": "\t\t\t */",
                    "1593": "",
                    "1594": "\t\t\tstatus = func(thread, data);",
                    "1595": "\t\t\tif (status != 0) {",
                    "1596": "\t\t\t\tbreak;",
                    "1597": "\t\t\t}",
                    "1598": "\t\t}",
                    "1599": "\t}",
                    "1600": "",
                    "1601": "\treturn status;",
                    "1602": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wake_thread": {
            "name": "z_sched_wake_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 635,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nvoid z_sched_wake_thread(struct k_thread *thread, bool is_timeout)\n{\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tbool killed = (thread->base.thread_state &\n\t\t\t\t(_THREAD_DEAD | _THREAD_ABORTING));\n\n#ifdef CONFIG_EVENTS\n\t\tbool do_nothing = thread->no_wake_on_timeout && is_timeout;\n\n\t\tthread->no_wake_on_timeout = false;\n\n\t\tif (do_nothing) {\n\t\t\tcontinue;\n\t\t}\n#endif /* CONFIG_EVENTS */\n\n\t\tif (!killed) {\n\t\t\t/* The thread is not being killed */\n\t\t\tif (thread->base.pended_on != NULL) {\n\t\t\t\tunpend_thread_no_timeout(thread);\n\t\t\t}\n\t\t\tz_mark_thread_as_started(thread);\n\t\t\tif (is_timeout) {\n\t\t\t\tz_mark_thread_as_not_suspended(thread);\n\t\t\t}\n\t\t\tready_thread(thread);\n\t\t}\n\t}\n\n}\n",
                {
                    "635": "void z_sched_wake_thread(struct k_thread *thread, bool is_timeout)",
                    "636": "{",
                    "637": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "638": "\t\tbool killed = (thread->base.thread_state &",
                    "639": "\t\t\t\t(_THREAD_DEAD | _THREAD_ABORTING));",
                    "640": "",
                    "641": "#ifdef CONFIG_EVENTS",
                    "642": "\t\tbool do_nothing = thread->no_wake_on_timeout && is_timeout;",
                    "643": "",
                    "644": "\t\tthread->no_wake_on_timeout = false;",
                    "645": "",
                    "646": "\t\tif (do_nothing) {",
                    "647": "\t\t\tcontinue;",
                    "648": "\t\t}",
                    "649": "#endif /* CONFIG_EVENTS */",
                    "650": "",
                    "651": "\t\tif (!killed) {",
                    "652": "\t\t\t/* The thread is not being killed */",
                    "653": "\t\t\tif (thread->base.pended_on != NULL) {",
                    "654": "\t\t\t\tunpend_thread_no_timeout(thread);",
                    "655": "\t\t\t}",
                    "656": "\t\t\tz_mark_thread_as_started(thread);",
                    "657": "\t\t\tif (is_timeout) {",
                    "658": "\t\t\t\tz_mark_thread_as_not_suspended(thread);",
                    "659": "\t\t\t}",
                    "660": "\t\t\tready_thread(thread);",
                    "661": "\t\t}",
                    "662": "\t}",
                    "663": "",
                    "664": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wake": {
            "name": "z_sched_wake",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1546,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nbool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)\n{\n\tstruct k_thread *thread;\n\tbool ret = false;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tz_thread_return_value_set_with_data(thread,\n\t\t\t\t\t\t\t    swap_retval,\n\t\t\t\t\t\t\t    swap_data);\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t\t(void)z_abort_thread_timeout(thread);\n\t\t\tready_thread(thread);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
                {
                    "1546": "bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)",
                    "1547": "{",
                    "1548": "\tstruct k_thread *thread;",
                    "1549": "\tbool ret = false;",
                    "1550": "",
                    "1551": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1552": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "1553": "",
                    "1554": "\t\tif (thread != NULL) {",
                    "1555": "\t\t\tz_thread_return_value_set_with_data(thread,",
                    "1556": "\t\t\t\t\t\t\t    swap_retval,",
                    "1557": "\t\t\t\t\t\t\t    swap_data);",
                    "1558": "\t\t\tunpend_thread_no_timeout(thread);",
                    "1559": "\t\t\t(void)z_abort_thread_timeout(thread);",
                    "1560": "\t\t\tready_thread(thread);",
                    "1561": "\t\t\tret = true;",
                    "1562": "\t\t}",
                    "1563": "\t}",
                    "1564": "",
                    "1565": "\treturn ret;",
                    "1566": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "move_thread_to_end_of_prio_q": {
            "name": "move_thread_to_end_of_prio_q",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 290,
            "function_content": [
                "#endif /* CONFIG_SMP */\nvoid move_thread_to_end_of_prio_q(struct k_thread *thread)\n{\n\tif (z_is_thread_queued(thread)) {\n\t\tdequeue_thread(thread);\n\t}\n\tqueue_thread(thread);\n\tupdate_cache(thread == _current);\n}\n",
                {
                    "290": "void move_thread_to_end_of_prio_q(struct k_thread *thread)",
                    "291": "{",
                    "292": "\tif (z_is_thread_queued(thread)) {",
                    "293": "\t\tdequeue_thread(thread);",
                    "294": "\t}",
                    "295": "\tqueue_thread(thread);",
                    "296": "\tupdate_cache(thread == _current);",
                    "297": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_requeue_current": {
            "name": "z_requeue_current",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 174,
            "function_content": [
                "/* Called out of z_swap() when CONFIG_SMP.  The current thread can\n* never live in the run queue until we are inexorably on the context\n* switch path on SMP, otherwise there is a deadlock condition where a\n* set of CPUs pick a cycle of threads to run and wait for them all to\n* context switch forever.\n*/\nvoid z_requeue_current(struct k_thread *thread)\n{\n\tif (z_is_thread_queued(thread)) {\n\t\trunq_add(thread);\n\t}\n\tsignal_pending_ipi();\n}\n",
                {
                    "174": "void z_requeue_current(struct k_thread *thread)",
                    "175": "{",
                    "176": "\tif (z_is_thread_queued(thread)) {",
                    "177": "\t\trunq_add(thread);",
                    "178": "\t}",
                    "179": "\tsignal_pending_ipi();",
                    "180": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_prio_set": {
            "name": "z_thread_prio_set",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 739,
            "function_content": [
                "/* Priority set utility that does no rescheduling, it just changes the\n* run queue state, returning true if a reschedule is needed later.\n*/\nbool z_thread_prio_set(struct k_thread *thread, int prio)\n{\n\tbool need_sched = 0;\n\tint old_prio = thread->base.prio;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tneed_sched = z_is_thread_ready(thread);\n\n\t\tif (need_sched) {\n\t\t\tif (!IS_ENABLED(CONFIG_SMP) || z_is_thread_queued(thread)) {\n\t\t\t\tdequeue_thread(thread);\n\t\t\t\tthread->base.prio = prio;\n\t\t\t\tqueue_thread(thread);\n\n\t\t\t\tif (old_prio > prio) {\n\t\t\t\t\tflag_ipi(ipi_mask_create(thread));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is a running thread on SMP. Update its\n\t\t\t\t * priority, but do not requeue it. An IPI is\n\t\t\t\t * needed if the priority is both being lowered\n\t\t\t\t * and it is running on another CPU.\n\t\t\t\t */\n\n\t\t\t\tthread->base.prio = prio;\n\n\t\t\t\tstruct _cpu *cpu;\n\n\t\t\t\tcpu = thread_active_elsewhere(thread);\n\t\t\t\tif ((cpu != NULL) && (old_prio < prio)) {\n\t\t\t\t\tflag_ipi(IPI_CPU_MASK(cpu->id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdate_cache(1);\n\t\t} else {\n\t\t\tthread->base.prio = prio;\n\t\t}\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);\n\n\treturn need_sched;\n}\n",
                {
                    "739": "bool z_thread_prio_set(struct k_thread *thread, int prio)",
                    "740": "{",
                    "741": "\tbool need_sched = 0;",
                    "742": "\tint old_prio = thread->base.prio;",
                    "743": "",
                    "744": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "745": "\t\tneed_sched = z_is_thread_ready(thread);",
                    "746": "",
                    "747": "\t\tif (need_sched) {",
                    "748": "\t\t\tif (!IS_ENABLED(CONFIG_SMP) || z_is_thread_queued(thread)) {",
                    "749": "\t\t\t\tdequeue_thread(thread);",
                    "750": "\t\t\t\tthread->base.prio = prio;",
                    "751": "\t\t\t\tqueue_thread(thread);",
                    "752": "",
                    "753": "\t\t\t\tif (old_prio > prio) {",
                    "754": "\t\t\t\t\tflag_ipi(ipi_mask_create(thread));",
                    "755": "\t\t\t\t}",
                    "756": "\t\t\t} else {",
                    "757": "\t\t\t\t/*",
                    "758": "\t\t\t\t * This is a running thread on SMP. Update its",
                    "759": "\t\t\t\t * priority, but do not requeue it. An IPI is",
                    "760": "\t\t\t\t * needed if the priority is both being lowered",
                    "761": "\t\t\t\t * and it is running on another CPU.",
                    "762": "\t\t\t\t */",
                    "763": "",
                    "764": "\t\t\t\tthread->base.prio = prio;",
                    "765": "",
                    "766": "\t\t\t\tstruct _cpu *cpu;",
                    "767": "",
                    "768": "\t\t\t\tcpu = thread_active_elsewhere(thread);",
                    "769": "\t\t\t\tif ((cpu != NULL) && (old_prio < prio)) {",
                    "770": "\t\t\t\t\tflag_ipi(IPI_CPU_MASK(cpu->id));",
                    "771": "\t\t\t\t}",
                    "772": "\t\t\t}",
                    "773": "",
                    "774": "\t\t\tupdate_cache(1);",
                    "775": "\t\t} else {",
                    "776": "\t\t\tthread->base.prio = prio;",
                    "777": "\t\t}",
                    "778": "\t}",
                    "779": "",
                    "780": "\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);",
                    "781": "",
                    "782": "\treturn need_sched;",
                    "783": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend_all": {
            "name": "z_unpend_all",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 992,
            "function_content": [
                "#endif /* CONFIG_USE_SWITCH */\nint z_unpend_all(_wait_q_t *wait_q)\n{\n\tint need_sched = 0;\n\tstruct k_thread *thread;\n\n\tfor (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {\n\t\tz_unpend_thread(thread);\n\t\tz_ready_thread(thread);\n\t\tneed_sched = 1;\n\t}\n\n\treturn need_sched;\n}\n",
                {
                    "992": "int z_unpend_all(_wait_q_t *wait_q)",
                    "993": "{",
                    "994": "\tint need_sched = 0;",
                    "995": "\tstruct k_thread *thread;",
                    "996": "",
                    "997": "\tfor (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {",
                    "998": "\t\tz_unpend_thread(thread);",
                    "999": "\t\tz_ready_thread(thread);",
                    "1000": "\t\tneed_sched = 1;",
                    "1001": "\t}",
                    "1002": "",
                    "1003": "\treturn need_sched;",
                    "1004": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend_thread": {
            "name": "z_unpend_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 730,
            "function_content": [
                "/* We do a \"lock swap\" prior to calling z_swap(), such that\n* the caller's lock gets released as desired.  But we ensure\n* that we hold the scheduler lock and leave local interrupts\n* masked until we reach the context switch.  z_swap() itself\n* has similar code; the duplication is because it's a legacy\n* API that doesn't expect to be called with scheduler lock\n* held.\n*/\nvoid z_unpend_thread(struct k_thread *thread)\n{\n\tz_unpend_thread_no_timeout(thread);\n\t(void)z_abort_thread_timeout(thread);\n}\n",
                {
                    "730": "void z_unpend_thread(struct k_thread *thread)",
                    "731": "{",
                    "732": "\tz_unpend_thread_no_timeout(thread);",
                    "733": "\t(void)z_abort_thread_timeout(thread);",
                    "734": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend_first_thread": {
            "name": "z_unpend_first_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 714,
            "function_content": [
                "/* We do a \"lock swap\" prior to calling z_swap(), such that\n* the caller's lock gets released as desired.  But we ensure\n* that we hold the scheduler lock and leave local interrupts\n* masked until we reach the context switch.  z_swap() itself\n* has similar code; the duplication is because it's a legacy\n* API that doesn't expect to be called with scheduler lock\n* held.\n*/\nstruct k_thread *z_unpend_first_thread(_wait_q_t *wait_q)\n{\n\tstruct k_thread *thread = NULL;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t\t(void)z_abort_thread_timeout(thread);\n\t\t}\n\t}\n\n\treturn thread;\n}\n",
                {
                    "714": "struct k_thread *z_unpend_first_thread(_wait_q_t *wait_q)",
                    "715": "{",
                    "716": "\tstruct k_thread *thread = NULL;",
                    "717": "",
                    "718": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "719": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "720": "",
                    "721": "\t\tif (thread != NULL) {",
                    "722": "\t\t\tunpend_thread_no_timeout(thread);",
                    "723": "\t\t\t(void)z_abort_thread_timeout(thread);",
                    "724": "\t\t}",
                    "725": "\t}",
                    "726": "",
                    "727": "\treturn thread;",
                    "728": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend1_no_timeout": {
            "name": "z_unpend1_no_timeout",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 699,
            "function_content": [
                "/* We do a \"lock swap\" prior to calling z_swap(), such that\n* the caller's lock gets released as desired.  But we ensure\n* that we hold the scheduler lock and leave local interrupts\n* masked until we reach the context switch.  z_swap() itself\n* has similar code; the duplication is because it's a legacy\n* API that doesn't expect to be called with scheduler lock\n* held.\n*/\nstruct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)\n{\n\tstruct k_thread *thread = NULL;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t}\n\t}\n\n\treturn thread;\n}\n",
                {
                    "699": "struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)",
                    "700": "{",
                    "701": "\tstruct k_thread *thread = NULL;",
                    "702": "",
                    "703": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "704": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "705": "",
                    "706": "\t\tif (thread != NULL) {",
                    "707": "\t\t\tunpend_thread_no_timeout(thread);",
                    "708": "\t\t}",
                    "709": "\t}",
                    "710": "",
                    "711": "\treturn thread;",
                    "712": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sys_init_run_level": {
            "name": "z_sys_init_run_level",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/init.c",
            "location_line": 348,
            "function_content": [
                "/**\n* @brief Execute all the init entry initialization functions at a given level\n*\n* @details Invokes the initialization routine for each init entry object\n* created by the INIT_ENTRY_DEFINE() macro using the specified level.\n* The linker script places the init entry objects in memory in the order\n* they need to be invoked, with symbols indicating where one level leaves\n* off and the next one begins.\n*\n* @param level init level to run.\n*/\nstatic void z_sys_init_run_level(enum init_level level)\n{\n\tstatic const struct init_entry *levels[] = {\n\t\t__init_EARLY_start,\n\t\t__init_PRE_KERNEL_1_start,\n\t\t__init_PRE_KERNEL_2_start,\n\t\t__init_POST_KERNEL_start,\n\t\t__init_APPLICATION_start,\n#ifdef CONFIG_SMP\n\t\t__init_SMP_start,\n#endif /* CONFIG_SMP */\n\t\t/* End marker */\n\t\t__init_end,\n\t};\n\tconst struct init_entry *entry;\n\n\tfor (entry = levels[level]; entry < levels[level+1]; entry++) {\n\t\tconst struct device *dev = entry->dev;\n\t\tint result;\n\n\t\tsys_trace_sys_init_enter(entry, level);\n\t\tif (dev != NULL) {\n\t\t\tresult = do_device_init(entry);\n\t\t} else {\n\t\t\tresult = entry->init_fn.sys();\n\t\t}\n\t\tsys_trace_sys_init_exit(entry, level, result);\n\t}\n}\n",
                {
                    "348": "static void z_sys_init_run_level(enum init_level level)",
                    "349": "{",
                    "350": "\tstatic const struct init_entry *levels[] = {",
                    "351": "\t\t__init_EARLY_start,",
                    "352": "\t\t__init_PRE_KERNEL_1_start,",
                    "353": "\t\t__init_PRE_KERNEL_2_start,",
                    "354": "\t\t__init_POST_KERNEL_start,",
                    "355": "\t\t__init_APPLICATION_start,",
                    "356": "#ifdef CONFIG_SMP",
                    "357": "\t\t__init_SMP_start,",
                    "358": "#endif /* CONFIG_SMP */",
                    "359": "\t\t/* End marker */",
                    "360": "\t\t__init_end,",
                    "361": "\t};",
                    "362": "\tconst struct init_entry *entry;",
                    "363": "",
                    "364": "\tfor (entry = levels[level]; entry < levels[level+1]; entry++) {",
                    "365": "\t\tconst struct device *dev = entry->dev;",
                    "366": "\t\tint result;",
                    "367": "",
                    "368": "\t\tsys_trace_sys_init_enter(entry, level);",
                    "369": "\t\tif (dev != NULL) {",
                    "370": "\t\t\tresult = do_device_init(entry);",
                    "371": "\t\t} else {",
                    "372": "\t\t\tresult = entry->init_fn.sys();",
                    "373": "\t\t}",
                    "374": "\t\tsys_trace_sys_init_exit(entry, level, result);",
                    "375": "\t}",
                    "376": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "do_device_init": {
            "name": "do_device_init",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/init.c",
            "location_line": 306,
            "function_content": [
                "/* LCOV_EXCL_STOP */\nstatic int do_device_init(const struct init_entry *entry)\n{\n\tconst struct device *dev = entry->dev;\n\tint rc = 0;\n\n\tif (entry->init_fn.dev != NULL) {\n\t\trc = entry->init_fn.dev(dev);\n\t\t/* Mark device initialized. If initialization\n\t\t * failed, record the error condition.\n\t\t */\n\t\tif (rc != 0) {\n\t\t\tif (rc < 0) {\n\t\t\t\trc = -rc;\n\t\t\t}\n\t\t\tif (rc > UINT8_MAX) {\n\t\t\t\trc = UINT8_MAX;\n\t\t\t}\n\t\t\tdev->state->init_res = rc;\n\t\t}\n\t}\n\n\tdev->state->initialized = true;\n\n\tif (rc == 0) {\n\t\t/* Run automatic device runtime enablement */\n\t\t(void)pm_device_runtime_auto_enable(dev);\n\t}\n\n\treturn rc;\n}\n",
                {
                    "306": "static int do_device_init(const struct init_entry *entry)",
                    "307": "{",
                    "308": "\tconst struct device *dev = entry->dev;",
                    "309": "\tint rc = 0;",
                    "310": "",
                    "311": "\tif (entry->init_fn.dev != NULL) {",
                    "312": "\t\trc = entry->init_fn.dev(dev);",
                    "313": "\t\t/* Mark device initialized. If initialization",
                    "314": "\t\t * failed, record the error condition.",
                    "315": "\t\t */",
                    "316": "\t\tif (rc != 0) {",
                    "317": "\t\t\tif (rc < 0) {",
                    "318": "\t\t\t\trc = -rc;",
                    "319": "\t\t\t}",
                    "320": "\t\t\tif (rc > UINT8_MAX) {",
                    "321": "\t\t\t\trc = UINT8_MAX;",
                    "322": "\t\t\t}",
                    "323": "\t\t\tdev->state->init_res = rc;",
                    "324": "\t\t}",
                    "325": "\t}",
                    "326": "",
                    "327": "\tdev->state->initialized = true;",
                    "328": "",
                    "329": "\tif (rc == 0) {",
                    "330": "\t\t/* Run automatic device runtime enablement */",
                    "331": "\t\t(void)pm_device_runtime_auto_enable(dev);",
                    "332": "\t}",
                    "333": "",
                    "334": "\treturn rc;",
                    "335": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_put": {
            "name": "mbox_message_put",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mailbox.c",
            "location_line": 210,
            "function_content": [
                "/**\n* @brief Send a mailbox message.\n*\n* Helper routine that handles both synchronous and asynchronous sends.\n*\n* @param mbox Pointer to the mailbox object.\n* @param tx_msg Pointer to transmit message descriptor.\n* @param timeout Maximum time (milliseconds) to wait for the message to be\n*        received (although not necessarily completely processed).\n*        Use K_NO_WAIT to return immediately, or K_FOREVER to wait as long\n*        as necessary.\n*\n* @return 0 if successful, -ENOMSG if failed immediately, -EAGAIN if timed out\n*/\nstatic int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_thread *receiving_thread;\n\tstruct k_mbox_msg *rx_msg;\n\tk_spinlock_key_t key;\n\n\t/* save sender id so it can be used during message matching */\n\ttx_msg->rx_source_thread = _current;\n\n\t/* finish readying sending thread (actual or dummy) for send */\n\tsending_thread = tx_msg->_syncing_thread;\n\tsending_thread->base.swap_data = tx_msg;\n\n\t/* search mailbox's rx queue for a compatible receiver */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {\n\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take receiver out of rx queue */\n\t\t\tz_unpend_thread(receiving_thread);\n\n\t\t\t/* ready receiver for execution */\n\t\t\tarch_thread_return_value_set(receiving_thread, 0);\n\t\t\tz_ready_thread(receiving_thread);\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t\t\t/*\n\t\t\t * asynchronous send: swap out current thread\n\t\t\t * if receiver has priority, otherwise let it continue\n\t\t\t *\n\t\t\t * note: dummy sending thread sits (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)\n\t\t\t    != 0U) {\n\t\t\t\tz_reschedule(&mbox->lock, key);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t\t\t/*\n\t\t\t * synchronous send: pend current thread (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* didn't find a matching receiver: don't wait for one */\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);\n\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/* asynchronous send: dummy thread waits on tx queue for receiver */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn 0;\n\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t/* synchronous send: sender waits on tx queue for receiver or timeout */\n\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\treturn ret;\n}\n",
                {
                    "210": "static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,",
                    "211": "\t\t\t     k_timeout_t timeout)",
                    "212": "{",
                    "213": "\tstruct k_thread *sending_thread;",
                    "214": "\tstruct k_thread *receiving_thread;",
                    "215": "\tstruct k_mbox_msg *rx_msg;",
                    "216": "\tk_spinlock_key_t key;",
                    "217": "",
                    "218": "\t/* save sender id so it can be used during message matching */",
                    "219": "\ttx_msg->rx_source_thread = _current;",
                    "220": "",
                    "221": "\t/* finish readying sending thread (actual or dummy) for send */",
                    "222": "\tsending_thread = tx_msg->_syncing_thread;",
                    "223": "\tsending_thread->base.swap_data = tx_msg;",
                    "224": "",
                    "225": "\t/* search mailbox's rx queue for a compatible receiver */",
                    "226": "\tkey = k_spin_lock(&mbox->lock);",
                    "227": "",
                    "228": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);",
                    "229": "",
                    "230": "\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {",
                    "231": "\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;",
                    "232": "",
                    "233": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "234": "\t\t\t/* take receiver out of rx queue */",
                    "235": "\t\t\tz_unpend_thread(receiving_thread);",
                    "236": "",
                    "237": "\t\t\t/* ready receiver for execution */",
                    "238": "\t\t\tarch_thread_return_value_set(receiving_thread, 0);",
                    "239": "\t\t\tz_ready_thread(receiving_thread);",
                    "240": "",
                    "241": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "242": "\t\t\t/*",
                    "243": "\t\t\t * asynchronous send: swap out current thread",
                    "244": "\t\t\t * if receiver has priority, otherwise let it continue",
                    "245": "\t\t\t *",
                    "246": "\t\t\t * note: dummy sending thread sits (unqueued)",
                    "247": "\t\t\t * until the receiver consumes the message",
                    "248": "\t\t\t */",
                    "249": "\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)",
                    "250": "\t\t\t    != 0U) {",
                    "251": "\t\t\t\tz_reschedule(&mbox->lock, key);",
                    "252": "\t\t\t\treturn 0;",
                    "253": "\t\t\t}",
                    "254": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "255": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "256": "",
                    "257": "\t\t\t/*",
                    "258": "\t\t\t * synchronous send: pend current thread (unqueued)",
                    "259": "\t\t\t * until the receiver consumes the message",
                    "260": "\t\t\t */",
                    "261": "\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);",
                    "262": "",
                    "263": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "264": "",
                    "265": "\t\t\treturn ret;",
                    "266": "\t\t}",
                    "267": "\t}",
                    "268": "",
                    "269": "\t/* didn't find a matching receiver: don't wait for one */",
                    "270": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "271": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);",
                    "272": "",
                    "273": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "274": "\t\treturn -ENOMSG;",
                    "275": "\t}",
                    "276": "",
                    "277": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "278": "\t/* asynchronous send: dummy thread waits on tx queue for receiver */",
                    "279": "\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {",
                    "280": "\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);",
                    "281": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "282": "\t\treturn 0;",
                    "283": "\t}",
                    "284": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "286": "",
                    "287": "\t/* synchronous send: sender waits on tx queue for receiver or timeout */",
                    "288": "\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);",
                    "289": "",
                    "290": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "291": "",
                    "292": "\treturn ret;",
                    "293": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "adjust_owner_prio": {
            "name": "adjust_owner_prio",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mutex.c",
            "location_line": 91,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)\n{\n\tif (mutex->owner->base.prio != new_prio) {\n\n\t\tLOG_DBG(\"%p (ready (y/n): %c) prio changed to %d (was %d)\",\n\t\t\tmutex->owner, z_is_thread_ready(mutex->owner) ?\n\t\t\t'y' : 'n',\n\t\t\tnew_prio, mutex->owner->base.prio);\n\n\t\treturn z_thread_prio_set(mutex->owner, new_prio);\n\t}\n\treturn false;\n}\n",
                {
                    "91": "static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)",
                    "92": "{",
                    "93": "\tif (mutex->owner->base.prio != new_prio) {",
                    "94": "",
                    "95": "\t\tLOG_DBG(\"%p (ready (y/n): %c) prio changed to %d (was %d)\",",
                    "96": "\t\t\tmutex->owner, z_is_thread_ready(mutex->owner) ?",
                    "97": "\t\t\t'y' : 'n',",
                    "98": "\t\t\tnew_prio, mutex->owner->base.prio);",
                    "99": "",
                    "100": "\t\treturn z_thread_prio_set(mutex->owner, new_prio);",
                    "101": "\t}",
                    "102": "\treturn false;",
                    "103": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "halt_thread": {
            "name": "halt_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1331,
            "function_content": [
                "/**\n* @brief Dequeues the specified thread\n*\n* Dequeues the specified thread and move it into the specified new state.\n*\n* @param thread Identify the thread to halt\n* @param new_state New thread state (_THREAD_DEAD or _THREAD_SUSPENDED)\n*/\nstatic void halt_thread(struct k_thread *thread, uint8_t new_state)\n{\n\tbool dummify = false;\n\n\t/* We hold the lock, and the thread is known not to be running\n\t * anywhere.\n\t */\n\tif ((thread->base.thread_state & new_state) == 0U) {\n\t\tthread->base.thread_state |= new_state;\n\t\tif (z_is_thread_queued(thread)) {\n\t\t\tdequeue_thread(thread);\n\t\t}\n\n\t\tif (new_state == _THREAD_DEAD) {\n\t\t\tif (thread->base.pended_on != NULL) {\n\t\t\t\tunpend_thread_no_timeout(thread);\n\t\t\t}\n\t\t\t(void)z_abort_thread_timeout(thread);\n\t\t\tunpend_all(&thread->join_queue);\n\n\t\t\t/* Edge case: aborting _current from within an\n\t\t\t * ISR that preempted it requires clearing the\n\t\t\t * _current pointer so the upcoming context\n\t\t\t * switch doesn't clobber the now-freed\n\t\t\t * memory\n\t\t\t */\n\t\t\tif (thread == _current && arch_is_in_isr()) {\n\t\t\t\tdummify = true;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_SMP\n\t\tunpend_all(&thread->halt_queue);\n#endif /* CONFIG_SMP */\n\t\tupdate_cache(1);\n\n\t\tif (new_state == _THREAD_SUSPENDED) {\n\t\t\tclear_halting(thread);\n\t\t\treturn;\n\t\t}\n\n#if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)\n\t\tarch_float_disable(thread);\n#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */\n\n\t\tSYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);\n\n\t\tz_thread_monitor_exit(thread);\n#ifdef CONFIG_THREAD_ABORT_HOOK\n\t\tthread_abort_hook(thread);\n#endif /* CONFIG_THREAD_ABORT_HOOK */\n\n#ifdef CONFIG_OBJ_CORE_THREAD\n#ifdef CONFIG_OBJ_CORE_STATS_THREAD\n\t\tk_obj_core_stats_deregister(K_OBJ_CORE(thread));\n#endif /* CONFIG_OBJ_CORE_STATS_THREAD */\n\t\tk_obj_core_unlink(K_OBJ_CORE(thread));\n#endif /* CONFIG_OBJ_CORE_THREAD */\n\n#ifdef CONFIG_USERSPACE\n\t\tz_mem_domain_exit_thread(thread);\n\t\tk_thread_perms_all_clear(thread);\n\t\tk_object_uninit(thread->stack_obj);\n\t\tk_object_uninit(thread);\n#endif /* CONFIG_USERSPACE */\n\n#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP\n\t\tk_thread_abort_cleanup(thread);\n#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */\n\n\t\t/* Do this \"set _current to dummy\" step last so that\n\t\t * subsystems above can rely on _current being\n\t\t * unchanged.  Disabled for posix as that arch\n\t\t * continues to use the _current pointer in its swap\n\t\t * code.  Note that we must leave a non-null switch\n\t\t * handle for any threads spinning in join() (this can\n\t\t * never be used, as our thread is flagged dead, but\n\t\t * it must not be NULL otherwise join can deadlock).\n\t\t */\n\t\tif (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {\n#ifdef CONFIG_USE_SWITCH\n\t\t\t_current->switch_handle = _current;\n#endif\n\t\t\tz_dummy_thread_init(&_thread_dummy);\n\n\t\t}\n\n\t\t/* Finally update the halting thread state, on which\n\t\t * other CPUs might be spinning (see\n\t\t * thread_halt_spin()).\n\t\t */\n\t\tclear_halting(thread);\n\t}\n}\n",
                {
                    "1331": "static void halt_thread(struct k_thread *thread, uint8_t new_state)",
                    "1332": "{",
                    "1333": "\tbool dummify = false;",
                    "1334": "",
                    "1335": "\t/* We hold the lock, and the thread is known not to be running",
                    "1336": "\t * anywhere.",
                    "1337": "\t */",
                    "1338": "\tif ((thread->base.thread_state & new_state) == 0U) {",
                    "1339": "\t\tthread->base.thread_state |= new_state;",
                    "1340": "\t\tif (z_is_thread_queued(thread)) {",
                    "1341": "\t\t\tdequeue_thread(thread);",
                    "1342": "\t\t}",
                    "1343": "",
                    "1344": "\t\tif (new_state == _THREAD_DEAD) {",
                    "1345": "\t\t\tif (thread->base.pended_on != NULL) {",
                    "1346": "\t\t\t\tunpend_thread_no_timeout(thread);",
                    "1347": "\t\t\t}",
                    "1348": "\t\t\t(void)z_abort_thread_timeout(thread);",
                    "1349": "\t\t\tunpend_all(&thread->join_queue);",
                    "1350": "",
                    "1351": "\t\t\t/* Edge case: aborting _current from within an",
                    "1352": "\t\t\t * ISR that preempted it requires clearing the",
                    "1353": "\t\t\t * _current pointer so the upcoming context",
                    "1354": "\t\t\t * switch doesn't clobber the now-freed",
                    "1355": "\t\t\t * memory",
                    "1356": "\t\t\t */",
                    "1357": "\t\t\tif (thread == _current && arch_is_in_isr()) {",
                    "1358": "\t\t\t\tdummify = true;",
                    "1359": "\t\t\t}",
                    "1360": "\t\t}",
                    "1361": "#ifdef CONFIG_SMP",
                    "1362": "\t\tunpend_all(&thread->halt_queue);",
                    "1363": "#endif /* CONFIG_SMP */",
                    "1364": "\t\tupdate_cache(1);",
                    "1365": "",
                    "1366": "\t\tif (new_state == _THREAD_SUSPENDED) {",
                    "1367": "\t\t\tclear_halting(thread);",
                    "1368": "\t\t\treturn;",
                    "1369": "\t\t}",
                    "1370": "",
                    "1371": "#if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)",
                    "1372": "\t\tarch_float_disable(thread);",
                    "1373": "#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */",
                    "1374": "",
                    "1375": "\t\tSYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);",
                    "1376": "",
                    "1377": "\t\tz_thread_monitor_exit(thread);",
                    "1378": "#ifdef CONFIG_THREAD_ABORT_HOOK",
                    "1379": "\t\tthread_abort_hook(thread);",
                    "1380": "#endif /* CONFIG_THREAD_ABORT_HOOK */",
                    "1381": "",
                    "1382": "#ifdef CONFIG_OBJ_CORE_THREAD",
                    "1383": "#ifdef CONFIG_OBJ_CORE_STATS_THREAD",
                    "1384": "\t\tk_obj_core_stats_deregister(K_OBJ_CORE(thread));",
                    "1385": "#endif /* CONFIG_OBJ_CORE_STATS_THREAD */",
                    "1386": "\t\tk_obj_core_unlink(K_OBJ_CORE(thread));",
                    "1387": "#endif /* CONFIG_OBJ_CORE_THREAD */",
                    "1388": "",
                    "1389": "#ifdef CONFIG_USERSPACE",
                    "1390": "\t\tz_mem_domain_exit_thread(thread);",
                    "1391": "\t\tk_thread_perms_all_clear(thread);",
                    "1392": "\t\tk_object_uninit(thread->stack_obj);",
                    "1393": "\t\tk_object_uninit(thread);",
                    "1394": "#endif /* CONFIG_USERSPACE */",
                    "1395": "",
                    "1396": "#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP",
                    "1397": "\t\tk_thread_abort_cleanup(thread);",
                    "1398": "#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */",
                    "1399": "",
                    "1400": "\t\t/* Do this \"set _current to dummy\" step last so that",
                    "1401": "\t\t * subsystems above can rely on _current being",
                    "1402": "\t\t * unchanged.  Disabled for posix as that arch",
                    "1403": "\t\t * continues to use the _current pointer in its swap",
                    "1404": "\t\t * code.  Note that we must leave a non-null switch",
                    "1405": "\t\t * handle for any threads spinning in join() (this can",
                    "1406": "\t\t * never be used, as our thread is flagged dead, but",
                    "1407": "\t\t * it must not be NULL otherwise join can deadlock).",
                    "1408": "\t\t */",
                    "1409": "\t\tif (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {",
                    "1410": "#ifdef CONFIG_USE_SWITCH",
                    "1411": "\t\t\t_current->switch_handle = _current;",
                    "1412": "#endif",
                    "1413": "\t\t\tz_dummy_thread_init(&_thread_dummy);",
                    "1414": "",
                    "1415": "\t\t}",
                    "1416": "",
                    "1417": "\t\t/* Finally update the halting thread state, on which",
                    "1418": "\t\t * other CPUs might be spinning (see",
                    "1419": "\t\t * thread_halt_spin()).",
                    "1420": "\t\t */",
                    "1421": "\t\tclear_halting(thread);",
                    "1422": "\t}",
                    "1423": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "init_ready_q": {
            "name": "init_ready_q",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1006,
            "function_content": [
                "#endif /* CONFIG_USE_SWITCH */\nvoid init_ready_q(struct _ready_q *ready_q)\n{\n#if defined(CONFIG_SCHED_SCALABLE)\n\tready_q->runq = (struct _priq_rb) {\n\t\t.tree = {\n\t\t\t.lessthan_fn = z_priq_rb_lessthan,\n\t\t}\n\t};\n#elif defined(CONFIG_SCHED_MULTIQ)\n\tfor (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {\n\t\tsys_dlist_init(&ready_q->runq.queues[i]);\n\t}\n#else\n\tsys_dlist_init(&ready_q->runq);\n#endif\n}\n",
                {
                    "1006": "void init_ready_q(struct _ready_q *ready_q)",
                    "1007": "{",
                    "1008": "#if defined(CONFIG_SCHED_SCALABLE)",
                    "1009": "\tready_q->runq = (struct _priq_rb) {",
                    "1010": "\t\t.tree = {",
                    "1011": "\t\t\t.lessthan_fn = z_priq_rb_lessthan,",
                    "1012": "\t\t}",
                    "1013": "\t};",
                    "1014": "#elif defined(CONFIG_SCHED_MULTIQ)",
                    "1015": "\tfor (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {",
                    "1016": "\t\tsys_dlist_init(&ready_q->runq.queues[i]);",
                    "1017": "\t}",
                    "1018": "#else",
                    "1019": "\tsys_dlist_init(&ready_q->runq);",
                    "1020": "#endif",
                    "1021": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "add_to_waitq_locked": {
            "name": "add_to_waitq_locked",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 580,
            "function_content": [
                "/* _sched_spinlock must be held */\nstatic void add_to_waitq_locked(struct k_thread *thread, _wait_q_t *wait_q)\n{\n\tunready_thread(thread);\n\tz_mark_thread_as_pending(thread);\n\n\tSYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);\n\n\tif (wait_q != NULL) {\n\t\tthread->base.pended_on = wait_q;\n\t\t_priq_wait_add(&wait_q->waitq, thread);\n\t}\n}\n",
                {
                    "580": "static void add_to_waitq_locked(struct k_thread *thread, _wait_q_t *wait_q)",
                    "581": "{",
                    "582": "\tunready_thread(thread);",
                    "583": "\tz_mark_thread_as_pending(thread);",
                    "584": "",
                    "585": "\tSYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);",
                    "586": "",
                    "587": "\tif (wait_q != NULL) {",
                    "588": "\t\tthread->base.pended_on = wait_q;",
                    "589": "\t\t_priq_wait_add(&wait_q->waitq, thread);",
                    "590": "\t}",
                    "591": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "unready_thread": {
            "name": "unready_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 571,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic void unready_thread(struct k_thread *thread)\n{\n\tif (z_is_thread_queued(thread)) {\n\t\tdequeue_thread(thread);\n\t}\n\tupdate_cache(thread == _current);\n}\n",
                {
                    "571": "static void unready_thread(struct k_thread *thread)",
                    "572": "{",
                    "573": "\tif (z_is_thread_queued(thread)) {",
                    "574": "\t\tdequeue_thread(thread);",
                    "575": "\t}",
                    "576": "\tupdate_cache(thread == _current);",
                    "577": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ready_thread": {
            "name": "ready_thread",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 373,
            "function_content": [
                "#endif /* CONFIG_SMP */\nstatic void ready_thread(struct k_thread *thread)\n{\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(arch_mem_coherent(thread));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\t/* If thread is queued already, do not try and added it to the\n\t * run queue again\n\t */\n\tif (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);\n\n\t\tqueue_thread(thread);\n\t\tupdate_cache(0);\n\n\t\tflag_ipi(ipi_mask_create(thread));\n\t}\n}\n",
                {
                    "373": "static void ready_thread(struct k_thread *thread)",
                    "374": "{",
                    "375": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "376": "\t__ASSERT_NO_MSG(arch_mem_coherent(thread));",
                    "377": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "378": "",
                    "379": "\t/* If thread is queued already, do not try and added it to the",
                    "380": "\t * run queue again",
                    "381": "\t */",
                    "382": "\tif (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {",
                    "383": "\t\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);",
                    "384": "",
                    "385": "\t\tqueue_thread(thread);",
                    "386": "\t\tupdate_cache(0);",
                    "387": "",
                    "388": "\t\tflag_ipi(ipi_mask_create(thread));",
                    "389": "\t}",
                    "390": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "update_cache": {
            "name": "update_cache",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 323,
            "function_content": [
                "/* CONFIG_NUM_METAIRQ_PRIORITIES > 0 &&\n* CONFIG_NUM_COOP_PRIORITIES > CONFIG_NUM_METAIRQ_PRIORITIES\n*/\nstatic void update_cache(int preempt_ok)\n{\n#ifndef CONFIG_SMP\n\tstruct k_thread *thread = next_up();\n\n\tif (should_preempt(thread, preempt_ok)) {\n#ifdef CONFIG_TIMESLICING\n\t\tif (thread != _current) {\n\t\t\tz_reset_time_slice(thread);\n\t\t}\n#endif /* CONFIG_TIMESLICING */\n\t\tupdate_metairq_preempt(thread);\n\t\t_kernel.ready_q.cache = thread;\n\t} else {\n\t\t_kernel.ready_q.cache = _current;\n\t}\n\n#else\n\t/* The way this works is that the CPU record keeps its\n\t * \"cooperative swapping is OK\" flag until the next reschedule\n\t * call or context switch.  It doesn't need to be tracked per\n\t * thread because if the thread gets preempted for whatever\n\t * reason the scheduler will make the same decision anyway.\n\t */\n\t_current_cpu->swap_ok = preempt_ok;\n#endif /* CONFIG_SMP */\n}\n",
                {
                    "323": "static void update_cache(int preempt_ok)",
                    "324": "{",
                    "325": "#ifndef CONFIG_SMP",
                    "326": "\tstruct k_thread *thread = next_up();",
                    "327": "",
                    "328": "\tif (should_preempt(thread, preempt_ok)) {",
                    "329": "#ifdef CONFIG_TIMESLICING",
                    "330": "\t\tif (thread != _current) {",
                    "331": "\t\t\tz_reset_time_slice(thread);",
                    "332": "\t\t}",
                    "333": "#endif /* CONFIG_TIMESLICING */",
                    "334": "\t\tupdate_metairq_preempt(thread);",
                    "335": "\t\t_kernel.ready_q.cache = thread;",
                    "336": "\t} else {",
                    "337": "\t\t_kernel.ready_q.cache = _current;",
                    "338": "\t}",
                    "339": "",
                    "340": "#else",
                    "341": "\t/* The way this works is that the CPU record keeps its",
                    "342": "\t * \"cooperative swapping is OK\" flag until the next reschedule",
                    "343": "\t * call or context switch.  It doesn't need to be tracked per",
                    "344": "\t * thread because if the thread gets preempted for whatever",
                    "345": "\t * reason the scheduler will make the same decision anyway.",
                    "346": "\t */",
                    "347": "\t_current_cpu->swap_ok = preempt_ok;",
                    "348": "#endif /* CONFIG_SMP */",
                    "349": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "remove_timeout": {
            "name": "remove_timeout",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 53,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic void remove_timeout(struct _timeout *t)\n{\n\tif (next(t) != NULL) {\n\t\tnext(t)->dticks += t->dticks;\n\t}\n\n\tsys_dlist_remove(&t->node);\n}\n",
                {
                    "53": "static void remove_timeout(struct _timeout *t)",
                    "54": "{",
                    "55": "\tif (next(t) != NULL) {",
                    "56": "\t\tnext(t)->dticks += t->dticks;",
                    "57": "\t}",
                    "58": "",
                    "59": "\tsys_dlist_remove(&t->node);",
                    "60": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "first": {
            "name": "first",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 39,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *first(void)\n{\n\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);\n\n\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);\n}\n",
                {
                    "39": "static struct _timeout *first(void)",
                    "40": "{",
                    "41": "\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);",
                    "42": "",
                    "43": "\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);",
                    "44": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_cbvprintf_impl": {
            "name": "z_cbvprintf_impl",
            "file_path": "/home/chenkaiqiu/zephyr/lib/os/cbprintf_complete.c",
            "location_line": 1369,
            "function_content": [
                "/* Outline function to emit all characters in [sp, ep). */\nint z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,\n\t\t     va_list ap, uint32_t flags)\n{\n\tchar buf[CONVERTED_BUFLEN];\n\tsize_t count = 0;\n\tsint_value_type sint;\n\tcbprintf_cb_local out = __out;\n\n\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)\n\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;\n\n/* Output character, returning EOF if output failed, otherwise\n * updating count.\n *\n * NB: c is evaluated exactly once: side-effects are OK\n */\n#define OUTC(c) do { \\\n\tint rc = (*out)((int)(c), ctx); \\\n\t\\\n\tif (rc < 0) { \\\n\t\treturn rc; \\\n\t} \\\n\t++count; \\\n} while (false)\n\n/* Output sequence of characters, returning a negative error if output\n * failed.\n */\n\n#define OUTS(_sp, _ep) do { \\\n\tint rc = outs(out, ctx, (_sp), (_ep)); \\\n\t\\\n\tif (rc < 0) {\t    \\\n\t\treturn rc; \\\n\t} \\\n\tcount += rc; \\\n} while (false)\n\n\twhile (*fp != 0) {\n\t\tif (*fp != '%') {\n\t\t\tOUTC(*fp);\n\t\t\t++fp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Force union into RAM with conversion state to\n\t\t * mitigate LLVM code generation bug.\n\t\t */\n\t\tstruct {\n\t\t\tunion argument_value value;\n\t\t\tstruct conversion conv;\n\t\t} state = {\n\t\t\t.value = {\n\t\t\t\t.uint = 0,\n\t\t\t},\n\t\t};\n\t\tstruct conversion *const conv = &state.conv;\n\t\tunion argument_value *const value = &state.value;\n\t\tconst char *sp = fp;\n\t\tint width = -1;\n\t\tint precision = -1;\n\t\tconst char *bps = NULL;\n\t\tconst char *bpe = buf + sizeof(buf);\n\t\tchar sign = 0;\n\n\t\tfp = extract_conversion(conv, sp);\n\n\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\t\t\t    && tagged_ap) {\n\t\t\t\t/* Skip over the argument tag as it is not being\n\t\t\t\t * used here.\n\t\t\t\t */\n\t\t\t\t(void)va_arg(ap, int);\n\t\t\t}\n\t\t}\n\n\t\t/* If dynamic width is specified, process it,\n\t\t * otherwise set width if present.\n\t\t */\n\t\tif (conv->width_star) {\n\t\t\twidth = va_arg(ap, int);\n\n\t\t\tif (width < 0) {\n\t\t\t\tconv->flag_dash = true;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t} else if (conv->width_present) {\n\t\t\twidth = conv->width_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* If dynamic precision is specified, process it, otherwise\n\t\t * set precision if present.  For floating point where\n\t\t * precision is not present use 6.\n\t\t */\n\t\tif (conv->prec_star) {\n\t\t\tint arg = va_arg(ap, int);\n\n\t\t\tif (arg < 0) {\n\t\t\t\tconv->prec_present = false;\n\t\t\t} else {\n\t\t\t\tprecision = arg;\n\t\t\t}\n\t\t} else if (conv->prec_present) {\n\t\t\tprecision = conv->prec_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* Reuse width and precision memory in conv for value\n\t\t * padding counts.\n\t\t */\n\t\tconv->pad0_value = 0;\n\t\tconv->pad0_pre_exp = 0;\n\n\t\t/* FP conversion requires knowing the precision. */\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)\n\t\t    && (conv->specifier_cat == SPECIFIER_FP)\n\t\t    && !conv->prec_present) {\n\t\t\tif (conv->specifier_a) {\n\t\t\t\tprecision = FRACTION_HEX;\n\t\t\t} else {\n\t\t\t\tprecision = 6;\n\t\t\t}\n\t\t}\n\n\t\t/* Get the value to be converted from the args.\n\t\t *\n\t\t * This can't be extracted to a helper function because\n\t\t * passing a pointer to va_list doesn't work on x86_64.  See\n\t\t * https://stackoverflow.com/a/8048892.\n\t\t */\n\t\tenum specifier_cat_enum specifier_cat\n\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;\n\t\tenum length_mod_enum length_mod\n\t\t\t= (enum length_mod_enum)conv->length_mod;\n\n\t\t/* Extract the value based on the argument category and length.\n\t\t *\n\t\t * Note that the length modifier doesn't affect the value of a\n\t\t * pointer argument.\n\t\t */\n\t\tif (specifier_cat == SPECIFIER_SINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->sint = va_arg(ap, int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif (WCHAR_IS_SIGNED\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->sint = va_arg(ap, long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\t/* Though ssize_t is the signed equivalent of\n\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.\n\t\t\t\t * Assume that size_t and ptrdiff_t are the\n\t\t\t\t * unsigned and signed equivalents of each\n\t\t\t\t * other.  This can be checked in a platform\n\t\t\t\t * test.\n\t\t\t\t */\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->sint = (signed char)value->sint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->sint = (short)value->sint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_UINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->uint = va_arg(ap, unsigned int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif ((!WCHAR_IS_SIGNED)\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\tunsigned long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\t\t\tuintmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->uint = (unsigned char)value->uint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->uint = (unsigned short)value->uint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_FP) {\n\t\t\tif (length_mod == LENGTH_UPPER_L) {\n\t\t\t\tvalue->ldbl = va_arg(ap, long double);\n\t\t\t} else {\n\t\t\t\tvalue->dbl = va_arg(ap, double);\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_PTR) {\n\t\t\tvalue->ptr = va_arg(ap, void *);\n\t\t}\n\n\t\t/* We've now consumed all arguments related to this\n\t\t * specification.  If the conversion is invalid, or is\n\t\t * something we don't support, then output the original\n\t\t * specification and move on.\n\t\t */\n\t\tif (conv->invalid || conv->unsupported) {\n\t\t\tOUTS(sp, fp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do formatting, either into the buffer or\n\t\t * referencing external data.\n\t\t */\n\t\tswitch (conv->specifier) {\n\t\tcase '%':\n\t\t\tOUTC('%');\n\t\t\tbreak;\n\t\tcase 's': {\n\t\t\tbps = (const char *)value->ptr;\n\n\t\t\tsize_t len;\n\n\t\t\tif (precision >= 0) {\n\t\t\t\tlen = strnlen(bps, precision);\n\t\t\t} else {\n\t\t\t\tlen = strlen(bps);\n\t\t\t}\n\n\t\t\tbpe = bps + len;\n\t\t\tprecision = -1;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 'p':\n\t\t\t/* Implementation-defined: null is \"(nil)\", non-null\n\t\t\t * has 0x prefix followed by significant address hex\n\t\t\t * digits, no leading zeros.\n\t\t\t */\n\t\t\tif (value->ptr != NULL) {\n\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,\n\t\t\t\t\t\t  buf, bpe);\n\n\t\t\t\t/* Use 0x prefix */\n\t\t\t\tconv->altform_0c = true;\n\t\t\t\tconv->specifier = 'x';\n\n\t\t\t\tgoto prec_int_pad0;\n\t\t\t}\n\n\t\t\tbps = \"(nil)\";\n\t\t\tbpe = bps + 5;\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tbps = buf;\n\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;\n\t\t\tbpe = buf + 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tif (conv->flag_plus) {\n\t\t\t\tsign = '+';\n\t\t\t} else if (conv->flag_space) {\n\t\t\t\tsign = ' ';\n\t\t\t}\n\n\t\t\t/* sint/uint overlay in the union, and so\n\t\t\t * can't appear in read and write operations\n\t\t\t * in the same statement.\n\t\t\t */\n\t\t\tsint = value->sint;\n\t\t\tif (sint < 0) {\n\t\t\t\tsign = '-';\n\t\t\t\tvalue->uint = (uint_value_type)-sint;\n\t\t\t} else {\n\t\t\t\tvalue->uint = (uint_value_type)sint;\n\t\t\t}\n\n\t\t\t__fallthrough;\n\t\tcase 'o':\n\t\tcase 'u':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);\n\n\t\tprec_int_pad0:\n\t\t\t/* Update pad0 values based on precision and converted\n\t\t\t * length.  Note that a non-empty sign is not in the\n\t\t\t * converted sequence, but it does not affect the\n\t\t\t * padding size.\n\t\t\t */\n\t\t\tif (precision >= 0) {\n\t\t\t\tsize_t len = bpe - bps;\n\n\t\t\t\t/* Zero-padding flag is ignored for integer\n\t\t\t\t * conversions with precision.\n\t\t\t\t */\n\t\t\t\tconv->flag_zero = false;\n\n\t\t\t\t/* Set pad0_value to satisfy precision */\n\t\t\t\tif (len < (size_t)precision) {\n\t\t\t\t\tconv->pad0_value = precision - (int)len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {\n\t\t\t\tstore_count(conv, value->ptr, count);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FP_CONV_CASES:\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {\n\t\t\t\tbps = encode_float(value->dbl, conv, precision,\n\t\t\t\t\t\t   &sign, buf, &bpe);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Add an empty default with break, this is a defensive\n\t\t\t * programming. Static analysis tool won't raise a violation\n\t\t\t * if default is empty, but has that comment.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If we don't have a converted value to emit, move\n\t\t * on.\n\t\t */\n\t\tif (bps == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The converted value is now stored in [bps, bpe), excluding\n\t\t * any required zero padding.\n\t\t *\n\t\t * The unjustified output will be:\n\t\t *\n\t\t * * any sign character (sint-only)\n\t\t * * any altform prefix\n\t\t * * for FP:\n\t\t *   * any pre-decimal content from the converted value\n\t\t *   * any pad0_value padding (!postdp)\n\t\t *   * any decimal point in the converted value\n\t\t *   * any pad0_value padding (postdp)\n\t\t *   * any pre-exponent content from the converted value\n\t\t *   * any pad0_pre_exp padding\n\t\t *   * any exponent content from the converted value\n\t\t * * for non-FP:\n\t\t *   * any pad0_prefix\n\t\t *   * the converted value\n\t\t */\n\t\tsize_t nj_len = (bpe - bps);\n\t\tint pad_len = 0;\n\n\t\tif (sign != 0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tif (conv->altform_0c) {\n\t\t\tnj_len += 2U;\n\t\t} else if (conv->altform_0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tnj_len += conv->pad0_value;\n\t\tif (conv->pad_fp) {\n\t\t\tnj_len += conv->pad0_pre_exp;\n\t\t}\n\n\t\t/* If we have a width update width to hold the padding we need\n\t\t * for justification.  The result may be negative, which will\n\t\t * result in no padding.\n\t\t *\n\t\t * If a non-negative padding width is present and we're doing\n\t\t * right-justification, emit the padding now.\n\t\t */\n\t\tif (width > 0) {\n\t\t\twidth -= (int)nj_len;\n\n\t\t\tif (!conv->flag_dash) {\n\t\t\t\tchar pad = ' ';\n\n\t\t\t\t/* If we're zero-padding we have to emit the\n\t\t\t\t * sign first.\n\t\t\t\t */\n\t\t\t\tif (conv->flag_zero) {\n\t\t\t\t\tif (sign != 0) {\n\t\t\t\t\t\tOUTC(sign);\n\t\t\t\t\t\tsign = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpad = '0';\n\t\t\t\t}\n\n\t\t\t\twhile (width-- > 0) {\n\t\t\t\t\tOUTC(pad);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have a sign that hasn't been emitted, now's the\n\t\t * time....\n\t\t */\n\t\tif (sign != 0) {\n\t\t\tOUTC(sign);\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {\n\t\t\tconst char *cp = bps;\n\n\t\t\tif (conv->specifier_a) {\n\t\t\t\t/* Only padding is pre_exp */\n\t\t\t\twhile (*cp != 'p') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\n\t\t\t\tpad_len = conv->pad0_value;\n\t\t\t\tif (!conv->pad_postdp) {\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*cp == '.') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t\t/* Remaining padding is\n\t\t\t\t\t * post-dp.\n\t\t\t\t\t */\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_pre_exp;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(cp, bpe);\n\t\t} else {\n\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tif (conv->altform_0c) {\n\t\t\t\tOUTC(conv->specifier);\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_value;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(bps, bpe);\n\t\t}\n\n\t\t/* Finish left justification */\n\t\twhile (width > 0) {\n\t\t\tOUTC(' ');\n\t\t\t--width;\n\t\t}\n\t}\n\n\treturn count;\n#undef OUTS\n#undef OUTC\n}\n",
                {
                    "1369": "int z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,",
                    "1370": "\t\t     va_list ap, uint32_t flags)",
                    "1371": "{",
                    "1372": "\tchar buf[CONVERTED_BUFLEN];",
                    "1373": "\tsize_t count = 0;",
                    "1374": "\tsint_value_type sint;",
                    "1375": "\tcbprintf_cb_local out = __out;",
                    "1376": "",
                    "1377": "\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)",
                    "1378": "\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;",
                    "1379": "",
                    "1380": "/* Output character, returning EOF if output failed, otherwise",
                    "1381": " * updating count.",
                    "1382": " *",
                    "1383": " * NB: c is evaluated exactly once: side-effects are OK",
                    "1384": " */",
                    "1385": "#define OUTC(c) do { \\",
                    "1386": "\tint rc = (*out)((int)(c), ctx); \\",
                    "1387": "\t\\",
                    "1388": "\tif (rc < 0) { \\",
                    "1389": "\t\treturn rc; \\",
                    "1390": "\t} \\",
                    "1391": "\t++count; \\",
                    "1392": "} while (false)",
                    "1393": "",
                    "1394": "/* Output sequence of characters, returning a negative error if output",
                    "1395": " * failed.",
                    "1396": " */",
                    "1397": "",
                    "1398": "#define OUTS(_sp, _ep) do { \\",
                    "1399": "\tint rc = outs(out, ctx, (_sp), (_ep)); \\",
                    "1400": "\t\\",
                    "1401": "\tif (rc < 0) {\t    \\",
                    "1402": "\t\treturn rc; \\",
                    "1403": "\t} \\",
                    "1404": "\tcount += rc; \\",
                    "1405": "} while (false)",
                    "1406": "",
                    "1407": "\twhile (*fp != 0) {",
                    "1408": "\t\tif (*fp != '%') {",
                    "1409": "\t\t\tOUTC(*fp);",
                    "1410": "\t\t\t++fp;",
                    "1411": "\t\t\tcontinue;",
                    "1412": "\t\t}",
                    "1413": "",
                    "1414": "\t\t/* Force union into RAM with conversion state to",
                    "1415": "\t\t * mitigate LLVM code generation bug.",
                    "1416": "\t\t */",
                    "1417": "\t\tstruct {",
                    "1418": "\t\t\tunion argument_value value;",
                    "1419": "\t\t\tstruct conversion conv;",
                    "1420": "\t\t} state = {",
                    "1421": "\t\t\t.value = {",
                    "1422": "\t\t\t\t.uint = 0,",
                    "1423": "\t\t\t},",
                    "1424": "\t\t};",
                    "1425": "\t\tstruct conversion *const conv = &state.conv;",
                    "1426": "\t\tunion argument_value *const value = &state.value;",
                    "1427": "\t\tconst char *sp = fp;",
                    "1428": "\t\tint width = -1;",
                    "1429": "\t\tint precision = -1;",
                    "1430": "\t\tconst char *bps = NULL;",
                    "1431": "\t\tconst char *bpe = buf + sizeof(buf);",
                    "1432": "\t\tchar sign = 0;",
                    "1433": "",
                    "1434": "\t\tfp = extract_conversion(conv, sp);",
                    "1435": "",
                    "1436": "\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {",
                    "1437": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)",
                    "1438": "\t\t\t    && tagged_ap) {",
                    "1439": "\t\t\t\t/* Skip over the argument tag as it is not being",
                    "1440": "\t\t\t\t * used here.",
                    "1441": "\t\t\t\t */",
                    "1442": "\t\t\t\t(void)va_arg(ap, int);",
                    "1443": "\t\t\t}",
                    "1444": "\t\t}",
                    "1445": "",
                    "1446": "\t\t/* If dynamic width is specified, process it,",
                    "1447": "\t\t * otherwise set width if present.",
                    "1448": "\t\t */",
                    "1449": "\t\tif (conv->width_star) {",
                    "1450": "\t\t\twidth = va_arg(ap, int);",
                    "1451": "",
                    "1452": "\t\t\tif (width < 0) {",
                    "1453": "\t\t\t\tconv->flag_dash = true;",
                    "1454": "\t\t\t\twidth = -width;",
                    "1455": "\t\t\t}",
                    "1456": "\t\t} else if (conv->width_present) {",
                    "1457": "\t\t\twidth = conv->width_value;",
                    "1458": "\t\t} else {",
                    "1459": "\t\t\t;",
                    "1460": "\t\t}",
                    "1461": "",
                    "1462": "\t\t/* If dynamic precision is specified, process it, otherwise",
                    "1463": "\t\t * set precision if present.  For floating point where",
                    "1464": "\t\t * precision is not present use 6.",
                    "1465": "\t\t */",
                    "1466": "\t\tif (conv->prec_star) {",
                    "1467": "\t\t\tint arg = va_arg(ap, int);",
                    "1468": "",
                    "1469": "\t\t\tif (arg < 0) {",
                    "1470": "\t\t\t\tconv->prec_present = false;",
                    "1471": "\t\t\t} else {",
                    "1472": "\t\t\t\tprecision = arg;",
                    "1473": "\t\t\t}",
                    "1474": "\t\t} else if (conv->prec_present) {",
                    "1475": "\t\t\tprecision = conv->prec_value;",
                    "1476": "\t\t} else {",
                    "1477": "\t\t\t;",
                    "1478": "\t\t}",
                    "1479": "",
                    "1480": "\t\t/* Reuse width and precision memory in conv for value",
                    "1481": "\t\t * padding counts.",
                    "1482": "\t\t */",
                    "1483": "\t\tconv->pad0_value = 0;",
                    "1484": "\t\tconv->pad0_pre_exp = 0;",
                    "1485": "",
                    "1486": "\t\t/* FP conversion requires knowing the precision. */",
                    "1487": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)",
                    "1488": "\t\t    && (conv->specifier_cat == SPECIFIER_FP)",
                    "1489": "\t\t    && !conv->prec_present) {",
                    "1490": "\t\t\tif (conv->specifier_a) {",
                    "1491": "\t\t\t\tprecision = FRACTION_HEX;",
                    "1492": "\t\t\t} else {",
                    "1493": "\t\t\t\tprecision = 6;",
                    "1494": "\t\t\t}",
                    "1495": "\t\t}",
                    "1496": "",
                    "1497": "\t\t/* Get the value to be converted from the args.",
                    "1498": "\t\t *",
                    "1499": "\t\t * This can't be extracted to a helper function because",
                    "1500": "\t\t * passing a pointer to va_list doesn't work on x86_64.  See",
                    "1501": "\t\t * https://stackoverflow.com/a/8048892.",
                    "1502": "\t\t */",
                    "1503": "\t\tenum specifier_cat_enum specifier_cat",
                    "1504": "\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;",
                    "1505": "\t\tenum length_mod_enum length_mod",
                    "1506": "\t\t\t= (enum length_mod_enum)conv->length_mod;",
                    "1507": "",
                    "1508": "\t\t/* Extract the value based on the argument category and length.",
                    "1509": "\t\t *",
                    "1510": "\t\t * Note that the length modifier doesn't affect the value of a",
                    "1511": "\t\t * pointer argument.",
                    "1512": "\t\t */",
                    "1513": "\t\tif (specifier_cat == SPECIFIER_SINT) {",
                    "1514": "\t\t\tswitch (length_mod) {",
                    "1515": "\t\t\tdefault:",
                    "1516": "\t\t\tcase LENGTH_NONE:",
                    "1517": "\t\t\tcase LENGTH_HH:",
                    "1518": "\t\t\tcase LENGTH_H:",
                    "1519": "\t\t\t\tvalue->sint = va_arg(ap, int);",
                    "1520": "\t\t\t\tbreak;",
                    "1521": "\t\t\tcase LENGTH_L:",
                    "1522": "\t\t\t\tif (WCHAR_IS_SIGNED",
                    "1523": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1524": "\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,",
                    "1525": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1526": "\t\t\t\t} else {",
                    "1527": "\t\t\t\t\tvalue->sint = va_arg(ap, long);",
                    "1528": "\t\t\t\t}",
                    "1529": "\t\t\t\tbreak;",
                    "1530": "\t\t\tcase LENGTH_LL:",
                    "1531": "\t\t\t\tvalue->sint =",
                    "1532": "\t\t\t\t\t(sint_value_type)va_arg(ap, long long);",
                    "1533": "\t\t\t\tbreak;",
                    "1534": "\t\t\tcase LENGTH_J:",
                    "1535": "\t\t\t\tvalue->sint =",
                    "1536": "\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);",
                    "1537": "\t\t\t\tbreak;",
                    "1538": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1539": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1540": "\t\t\t\t/* Though ssize_t is the signed equivalent of",
                    "1541": "\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.",
                    "1542": "\t\t\t\t * Assume that size_t and ptrdiff_t are the",
                    "1543": "\t\t\t\t * unsigned and signed equivalents of each",
                    "1544": "\t\t\t\t * other.  This can be checked in a platform",
                    "1545": "\t\t\t\t * test.",
                    "1546": "\t\t\t\t */",
                    "1547": "\t\t\t\tvalue->sint =",
                    "1548": "\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);",
                    "1549": "\t\t\t\tbreak;",
                    "1550": "\t\t\t}",
                    "1551": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1552": "\t\t\t\tvalue->sint = (signed char)value->sint;",
                    "1553": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1554": "\t\t\t\tvalue->sint = (short)value->sint;",
                    "1555": "\t\t\t}",
                    "1556": "\t\t} else if (specifier_cat == SPECIFIER_UINT) {",
                    "1557": "\t\t\tswitch (length_mod) {",
                    "1558": "\t\t\tdefault:",
                    "1559": "\t\t\tcase LENGTH_NONE:",
                    "1560": "\t\t\tcase LENGTH_HH:",
                    "1561": "\t\t\tcase LENGTH_H:",
                    "1562": "\t\t\t\tvalue->uint = va_arg(ap, unsigned int);",
                    "1563": "\t\t\t\tbreak;",
                    "1564": "\t\t\tcase LENGTH_L:",
                    "1565": "\t\t\t\tif ((!WCHAR_IS_SIGNED)",
                    "1566": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1567": "\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,",
                    "1568": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1569": "\t\t\t\t} else {",
                    "1570": "\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);",
                    "1571": "\t\t\t\t}",
                    "1572": "\t\t\t\tbreak;",
                    "1573": "\t\t\tcase LENGTH_LL:",
                    "1574": "\t\t\t\tvalue->uint =",
                    "1575": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1576": "\t\t\t\t\t\tunsigned long long);",
                    "1577": "\t\t\t\tbreak;",
                    "1578": "\t\t\tcase LENGTH_J:",
                    "1579": "\t\t\t\tvalue->uint =",
                    "1580": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1581": "\t\t\t\t\t\t\t\tuintmax_t);",
                    "1582": "\t\t\t\tbreak;",
                    "1583": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1584": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1585": "\t\t\t\tvalue->uint =",
                    "1586": "\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);",
                    "1587": "\t\t\t\tbreak;",
                    "1588": "\t\t\t}",
                    "1589": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1590": "\t\t\t\tvalue->uint = (unsigned char)value->uint;",
                    "1591": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1592": "\t\t\t\tvalue->uint = (unsigned short)value->uint;",
                    "1593": "\t\t\t}",
                    "1594": "\t\t} else if (specifier_cat == SPECIFIER_FP) {",
                    "1595": "\t\t\tif (length_mod == LENGTH_UPPER_L) {",
                    "1596": "\t\t\t\tvalue->ldbl = va_arg(ap, long double);",
                    "1597": "\t\t\t} else {",
                    "1598": "\t\t\t\tvalue->dbl = va_arg(ap, double);",
                    "1599": "\t\t\t}",
                    "1600": "\t\t} else if (specifier_cat == SPECIFIER_PTR) {",
                    "1601": "\t\t\tvalue->ptr = va_arg(ap, void *);",
                    "1602": "\t\t}",
                    "1603": "",
                    "1604": "\t\t/* We've now consumed all arguments related to this",
                    "1605": "\t\t * specification.  If the conversion is invalid, or is",
                    "1606": "\t\t * something we don't support, then output the original",
                    "1607": "\t\t * specification and move on.",
                    "1608": "\t\t */",
                    "1609": "\t\tif (conv->invalid || conv->unsupported) {",
                    "1610": "\t\t\tOUTS(sp, fp);",
                    "1611": "\t\t\tcontinue;",
                    "1612": "\t\t}",
                    "1613": "",
                    "1614": "\t\t/* Do formatting, either into the buffer or",
                    "1615": "\t\t * referencing external data.",
                    "1616": "\t\t */",
                    "1617": "\t\tswitch (conv->specifier) {",
                    "1618": "\t\tcase '%':",
                    "1619": "\t\t\tOUTC('%');",
                    "1620": "\t\t\tbreak;",
                    "1621": "\t\tcase 's': {",
                    "1622": "\t\t\tbps = (const char *)value->ptr;",
                    "1623": "",
                    "1624": "\t\t\tsize_t len;",
                    "1625": "",
                    "1626": "\t\t\tif (precision >= 0) {",
                    "1627": "\t\t\t\tlen = strnlen(bps, precision);",
                    "1628": "\t\t\t} else {",
                    "1629": "\t\t\t\tlen = strlen(bps);",
                    "1630": "\t\t\t}",
                    "1631": "",
                    "1632": "\t\t\tbpe = bps + len;",
                    "1633": "\t\t\tprecision = -1;",
                    "1634": "",
                    "1635": "\t\t\tbreak;",
                    "1636": "\t\t}",
                    "1637": "\t\tcase 'p':",
                    "1638": "\t\t\t/* Implementation-defined: null is \"(nil)\", non-null",
                    "1639": "\t\t\t * has 0x prefix followed by significant address hex",
                    "1640": "\t\t\t * digits, no leading zeros.",
                    "1641": "\t\t\t */",
                    "1642": "\t\t\tif (value->ptr != NULL) {",
                    "1643": "\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,",
                    "1644": "\t\t\t\t\t\t  buf, bpe);",
                    "1645": "",
                    "1646": "\t\t\t\t/* Use 0x prefix */",
                    "1647": "\t\t\t\tconv->altform_0c = true;",
                    "1648": "\t\t\t\tconv->specifier = 'x';",
                    "1649": "",
                    "1650": "\t\t\t\tgoto prec_int_pad0;",
                    "1651": "\t\t\t}",
                    "1652": "",
                    "1653": "\t\t\tbps = \"(nil)\";",
                    "1654": "\t\t\tbpe = bps + 5;",
                    "1655": "",
                    "1656": "\t\t\tbreak;",
                    "1657": "\t\tcase 'c':",
                    "1658": "\t\t\tbps = buf;",
                    "1659": "\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;",
                    "1660": "\t\t\tbpe = buf + 1;",
                    "1661": "\t\t\tbreak;",
                    "1662": "\t\tcase 'd':",
                    "1663": "\t\tcase 'i':",
                    "1664": "\t\t\tif (conv->flag_plus) {",
                    "1665": "\t\t\t\tsign = '+';",
                    "1666": "\t\t\t} else if (conv->flag_space) {",
                    "1667": "\t\t\t\tsign = ' ';",
                    "1668": "\t\t\t}",
                    "1669": "",
                    "1670": "\t\t\t/* sint/uint overlay in the union, and so",
                    "1671": "\t\t\t * can't appear in read and write operations",
                    "1672": "\t\t\t * in the same statement.",
                    "1673": "\t\t\t */",
                    "1674": "\t\t\tsint = value->sint;",
                    "1675": "\t\t\tif (sint < 0) {",
                    "1676": "\t\t\t\tsign = '-';",
                    "1677": "\t\t\t\tvalue->uint = (uint_value_type)-sint;",
                    "1678": "\t\t\t} else {",
                    "1679": "\t\t\t\tvalue->uint = (uint_value_type)sint;",
                    "1680": "\t\t\t}",
                    "1681": "",
                    "1682": "\t\t\t__fallthrough;",
                    "1683": "\t\tcase 'o':",
                    "1684": "\t\tcase 'u':",
                    "1685": "\t\tcase 'x':",
                    "1686": "\t\tcase 'X':",
                    "1687": "\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);",
                    "1688": "",
                    "1689": "\t\tprec_int_pad0:",
                    "1690": "\t\t\t/* Update pad0 values based on precision and converted",
                    "1691": "\t\t\t * length.  Note that a non-empty sign is not in the",
                    "1692": "\t\t\t * converted sequence, but it does not affect the",
                    "1693": "\t\t\t * padding size.",
                    "1694": "\t\t\t */",
                    "1695": "\t\t\tif (precision >= 0) {",
                    "1696": "\t\t\t\tsize_t len = bpe - bps;",
                    "1697": "",
                    "1698": "\t\t\t\t/* Zero-padding flag is ignored for integer",
                    "1699": "\t\t\t\t * conversions with precision.",
                    "1700": "\t\t\t\t */",
                    "1701": "\t\t\t\tconv->flag_zero = false;",
                    "1702": "",
                    "1703": "\t\t\t\t/* Set pad0_value to satisfy precision */",
                    "1704": "\t\t\t\tif (len < (size_t)precision) {",
                    "1705": "\t\t\t\t\tconv->pad0_value = precision - (int)len;",
                    "1706": "\t\t\t\t}",
                    "1707": "\t\t\t}",
                    "1708": "",
                    "1709": "\t\t\tbreak;",
                    "1710": "\t\tcase 'n':",
                    "1711": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {",
                    "1712": "\t\t\t\tstore_count(conv, value->ptr, count);",
                    "1713": "\t\t\t}",
                    "1714": "",
                    "1715": "\t\t\tbreak;",
                    "1716": "",
                    "1717": "\t\tcase FP_CONV_CASES:",
                    "1718": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {",
                    "1719": "\t\t\t\tbps = encode_float(value->dbl, conv, precision,",
                    "1720": "\t\t\t\t\t\t   &sign, buf, &bpe);",
                    "1721": "\t\t\t}",
                    "1722": "\t\t\tbreak;",
                    "1723": "\t\tdefault:",
                    "1724": "\t\t\t/* Add an empty default with break, this is a defensive",
                    "1725": "\t\t\t * programming. Static analysis tool won't raise a violation",
                    "1726": "\t\t\t * if default is empty, but has that comment.",
                    "1727": "\t\t\t */",
                    "1728": "\t\t\tbreak;",
                    "1729": "\t\t}",
                    "1730": "",
                    "1731": "\t\t/* If we don't have a converted value to emit, move",
                    "1732": "\t\t * on.",
                    "1733": "\t\t */",
                    "1734": "\t\tif (bps == NULL) {",
                    "1735": "\t\t\tcontinue;",
                    "1736": "\t\t}",
                    "1737": "",
                    "1738": "\t\t/* The converted value is now stored in [bps, bpe), excluding",
                    "1739": "\t\t * any required zero padding.",
                    "1740": "\t\t *",
                    "1741": "\t\t * The unjustified output will be:",
                    "1742": "\t\t *",
                    "1743": "\t\t * * any sign character (sint-only)",
                    "1744": "\t\t * * any altform prefix",
                    "1745": "\t\t * * for FP:",
                    "1746": "\t\t *   * any pre-decimal content from the converted value",
                    "1747": "\t\t *   * any pad0_value padding (!postdp)",
                    "1748": "\t\t *   * any decimal point in the converted value",
                    "1749": "\t\t *   * any pad0_value padding (postdp)",
                    "1750": "\t\t *   * any pre-exponent content from the converted value",
                    "1751": "\t\t *   * any pad0_pre_exp padding",
                    "1752": "\t\t *   * any exponent content from the converted value",
                    "1753": "\t\t * * for non-FP:",
                    "1754": "\t\t *   * any pad0_prefix",
                    "1755": "\t\t *   * the converted value",
                    "1756": "\t\t */",
                    "1757": "\t\tsize_t nj_len = (bpe - bps);",
                    "1758": "\t\tint pad_len = 0;",
                    "1759": "",
                    "1760": "\t\tif (sign != 0) {",
                    "1761": "\t\t\tnj_len += 1U;",
                    "1762": "\t\t}",
                    "1763": "",
                    "1764": "\t\tif (conv->altform_0c) {",
                    "1765": "\t\t\tnj_len += 2U;",
                    "1766": "\t\t} else if (conv->altform_0) {",
                    "1767": "\t\t\tnj_len += 1U;",
                    "1768": "\t\t}",
                    "1769": "",
                    "1770": "\t\tnj_len += conv->pad0_value;",
                    "1771": "\t\tif (conv->pad_fp) {",
                    "1772": "\t\t\tnj_len += conv->pad0_pre_exp;",
                    "1773": "\t\t}",
                    "1774": "",
                    "1775": "\t\t/* If we have a width update width to hold the padding we need",
                    "1776": "\t\t * for justification.  The result may be negative, which will",
                    "1777": "\t\t * result in no padding.",
                    "1778": "\t\t *",
                    "1779": "\t\t * If a non-negative padding width is present and we're doing",
                    "1780": "\t\t * right-justification, emit the padding now.",
                    "1781": "\t\t */",
                    "1782": "\t\tif (width > 0) {",
                    "1783": "\t\t\twidth -= (int)nj_len;",
                    "1784": "",
                    "1785": "\t\t\tif (!conv->flag_dash) {",
                    "1786": "\t\t\t\tchar pad = ' ';",
                    "1787": "",
                    "1788": "\t\t\t\t/* If we're zero-padding we have to emit the",
                    "1789": "\t\t\t\t * sign first.",
                    "1790": "\t\t\t\t */",
                    "1791": "\t\t\t\tif (conv->flag_zero) {",
                    "1792": "\t\t\t\t\tif (sign != 0) {",
                    "1793": "\t\t\t\t\t\tOUTC(sign);",
                    "1794": "\t\t\t\t\t\tsign = 0;",
                    "1795": "\t\t\t\t\t}",
                    "1796": "\t\t\t\t\tpad = '0';",
                    "1797": "\t\t\t\t}",
                    "1798": "",
                    "1799": "\t\t\t\twhile (width-- > 0) {",
                    "1800": "\t\t\t\t\tOUTC(pad);",
                    "1801": "\t\t\t\t}",
                    "1802": "\t\t\t}",
                    "1803": "\t\t}",
                    "1804": "",
                    "1805": "\t\t/* If we have a sign that hasn't been emitted, now's the",
                    "1806": "\t\t * time....",
                    "1807": "\t\t */",
                    "1808": "\t\tif (sign != 0) {",
                    "1809": "\t\t\tOUTC(sign);",
                    "1810": "\t\t}",
                    "1811": "",
                    "1812": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {",
                    "1813": "\t\t\tconst char *cp = bps;",
                    "1814": "",
                    "1815": "\t\t\tif (conv->specifier_a) {",
                    "1816": "\t\t\t\t/* Only padding is pre_exp */",
                    "1817": "\t\t\t\twhile (*cp != 'p') {",
                    "1818": "\t\t\t\t\tOUTC(*cp);",
                    "1819": "\t\t\t\t\t++cp;",
                    "1820": "\t\t\t\t}",
                    "1821": "\t\t\t} else {",
                    "1822": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1823": "\t\t\t\t\tOUTC(*cp);",
                    "1824": "\t\t\t\t\t++cp;",
                    "1825": "\t\t\t\t}",
                    "1826": "",
                    "1827": "\t\t\t\tpad_len = conv->pad0_value;",
                    "1828": "\t\t\t\tif (!conv->pad_postdp) {",
                    "1829": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1830": "\t\t\t\t\t\tOUTC('0');",
                    "1831": "\t\t\t\t\t}",
                    "1832": "\t\t\t\t}",
                    "1833": "",
                    "1834": "\t\t\t\tif (*cp == '.') {",
                    "1835": "\t\t\t\t\tOUTC(*cp);",
                    "1836": "\t\t\t\t\t++cp;",
                    "1837": "\t\t\t\t\t/* Remaining padding is",
                    "1838": "\t\t\t\t\t * post-dp.",
                    "1839": "\t\t\t\t\t */",
                    "1840": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1841": "\t\t\t\t\t\tOUTC('0');",
                    "1842": "\t\t\t\t\t}",
                    "1843": "\t\t\t\t}",
                    "1844": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1845": "\t\t\t\t\tOUTC(*cp);",
                    "1846": "\t\t\t\t\t++cp;",
                    "1847": "\t\t\t\t}",
                    "1848": "\t\t\t}",
                    "1849": "",
                    "1850": "\t\t\tpad_len = conv->pad0_pre_exp;",
                    "1851": "\t\t\twhile (pad_len-- > 0) {",
                    "1852": "\t\t\t\tOUTC('0');",
                    "1853": "\t\t\t}",
                    "1854": "",
                    "1855": "\t\t\tOUTS(cp, bpe);",
                    "1856": "\t\t} else {",
                    "1857": "\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {",
                    "1858": "\t\t\t\tOUTC('0');",
                    "1859": "\t\t\t}",
                    "1860": "",
                    "1861": "\t\t\tif (conv->altform_0c) {",
                    "1862": "\t\t\t\tOUTC(conv->specifier);",
                    "1863": "\t\t\t}",
                    "1864": "",
                    "1865": "\t\t\tpad_len = conv->pad0_value;",
                    "1866": "\t\t\twhile (pad_len-- > 0) {",
                    "1867": "\t\t\t\tOUTC('0');",
                    "1868": "\t\t\t}",
                    "1869": "",
                    "1870": "\t\t\tOUTS(bps, bpe);",
                    "1871": "\t\t}",
                    "1872": "",
                    "1873": "\t\t/* Finish left justification */",
                    "1874": "\t\twhile (width > 0) {",
                    "1875": "\t\t\tOUTC(' ');",
                    "1876": "\t\t\t--width;",
                    "1877": "\t\t}",
                    "1878": "\t}",
                    "1879": "",
                    "1880": "\treturn count;",
                    "1881": "#undef OUTS",
                    "1882": "#undef OUTC",
                    "1883": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "encode_float": {
            "name": "encode_float",
            "file_path": "/home/chenkaiqiu/zephyr/lib/os/cbprintf_complete.c",
            "location_line": 869,
            "function_content": [
                "/* Convert the IEEE 754-2008 double to text format.\n*\n* @param value the 64-bit floating point value.\n*\n* @param conv details about how the conversion is to proceed.  Some fields\n* are adjusted based on the value being converted.\n*\n* @param precision the precision for the conversion (generally digits past\n* the decimal point).\n*\n* @param bps pointer to the first character in a buffer that will hold the\n* converted value.\n*\n* @param bpe On entry this points to the end of the buffer reserved to hold\n* the converted value.  On exit it is updated to point just past the\n* converted value.\n*\n* return a pointer to the start of the converted value.  This may not be @p\n* bps but will be consistent with the exit value of *bpe.\n*/\nstatic char *encode_float(double value,\n\t\t\t  struct conversion *conv,\n\t\t\t  int precision,\n\t\t\t  char *sign,\n\t\t\t  char *bps,\n\t\t\t  const char **bpe)\n{\n\tunion {\n\t\tuint64_t u64;\n\t\tdouble dbl;\n\t} u = {\n\t\t.dbl = value,\n\t};\n\tbool prune_zero = false;\n\tchar *buf = bps;\n\n\t/* Prepend the sign: '-' if negative, flags control\n\t * non-negative behavior.\n\t */\n\tif ((u.u64 & SIGN_MASK) != 0U) {\n\t\t*sign = '-';\n\t} else if (conv->flag_plus) {\n\t\t*sign = '+';\n\t} else if (conv->flag_space) {\n\t\t*sign = ' ';\n\t} else {\n\t\t;\n\t}\n\n\t/* Extract the non-negative offset exponent and fraction.  Record\n\t * whether the value is subnormal.\n\t */\n\tchar c = conv->specifier;\n\tint expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);\n\tuint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);\n\tbool is_subnormal = (expo == 0) && (fract != 0);\n\n\t/* Exponent of all-ones signals infinity or NaN, which are\n\t * text constants regardless of specifier.\n\t */\n\tif (expo == BIT_MASK(EXPONENT_BITS)) {\n\t\tif (fract == 0) {\n\t\t\tif (isupper((unsigned char)c) != 0) {\n\t\t\t\tbuf[0] = 'I';\n\t\t\t\tbuf[1] = 'N';\n\t\t\t\tbuf[2] = 'F';\n\t\t\t\tbuf += 3;\n\t\t\t} else {\n\t\t\t\tbuf[0] = 'i';\n\t\t\t\tbuf[1] = 'n';\n\t\t\t\tbuf[2] = 'f';\n\t\t\t\tbuf += 3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (isupper((unsigned char)c) != 0) {\n\t\t\t\tbuf[0] = 'N';\n\t\t\t\tbuf[1] = 'A';\n\t\t\t\tbuf[2] = 'N';\n\t\t\t\tbuf += 3;\n\t\t\t} else {\n\t\t\t\tbuf[0] = 'n';\n\t\t\t\tbuf[1] = 'a';\n\t\t\t\tbuf[2] = 'n';\n\t\t\t\tbuf += 3;\n\t\t\t}\n\t\t}\n\n\t\t/* No zero-padding with text values */\n\t\tconv->flag_zero = false;\n\n\t\t*bpe = buf;\n\t\treturn bps;\n\t}\n\n\t/* The case of an F specifier is no longer relevant. */\n\tif (c == 'F') {\n\t\tc = 'f';\n\t}\n\n\t/* Handle converting to the hex representation. */\n\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_A_SUPPORT)\n\t    && (IS_ENABLED(CONFIG_CBPRINTF_FP_ALWAYS_A)\n\t\t|| conv->specifier_a)) {\n\t\tbuf[0] = '0';\n\t\tbuf[1] = 'x';\n\t\tbuf += 2;\n\n\t\t/* Remove the offset from the exponent, and store the\n\t\t * non-fractional value.  Subnormals require increasing the\n\t\t * exponent as first bit isn't the implicit bit.\n\t\t */\n\t\texpo -= 1023;\n\t\tif (is_subnormal) {\n\t\t\t*buf = '0';\n\t\t\t++buf;\n\t\t\t++expo;\n\t\t} else {\n\t\t\t*buf = '1';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* If we didn't get precision from a %a specification then we\n\t\t * treat it as from a %a specification with no precision: full\n\t\t * range, zero-pruning enabled.\n\t\t *\n\t\t * Otherwise we have to cap the precision of the generated\n\t\t * fraction, or possibly round it.\n\t\t */\n\t\tif (!(conv->specifier_a && conv->prec_present)) {\n\t\t\tprecision = FRACTION_HEX;\n\t\t\tprune_zero = true;\n\t\t} else if (precision > FRACTION_HEX) {\n\t\t\tconv->pad0_pre_exp = precision - FRACTION_HEX;\n\t\t\tconv->pad_fp = true;\n\t\t\tprecision = FRACTION_HEX;\n\t\t} else if ((fract != 0)\n\t\t\t   && (precision < FRACTION_HEX)) {\n\t\t\tsize_t pos = 4 * (FRACTION_HEX - precision) - 1;\n\t\t\tuint64_t mask = BIT64(pos);\n\n\t\t\t/* Round only if the bit that would round is\n\t\t\t * set.\n\t\t\t */\n\t\t\tif ((fract & mask) != 0ULL) {\n\t\t\t\tfract += mask;\n\t\t\t}\n\t\t}\n\n\t\t/* Record whether we must retain the decimal point even if we\n\t\t * can prune zeros.\n\t\t */\n\t\tbool require_dp = ((fract != 0) || conv->flag_hash);\n\n\t\tif (require_dp || (precision != 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* Get the fractional value as a hexadecimal string, using x\n\t\t * for a and X for A.\n\t\t */\n\t\tstruct conversion aconv = {\n\t\t\t.specifier = isupper((unsigned char)c) != 0 ? 'X' : 'x',\n\t\t};\n\t\tconst char *spe = *bpe;\n\t\tchar *sp = bps + (spe - bps);\n\n\t\tif (fract != 0) {\n\t\t\tsp = encode_uint(fract, &aconv, buf, spe);\n\t\t}\n\n\t\t/* Pad out to full range since this is below the decimal\n\t\t * point.\n\t\t */\n\t\twhile ((spe - sp) < FRACTION_HEX) {\n\t\t\t--sp;\n\t\t\t*sp = '0';\n\t\t}\n\n\t\t/* Append the leading significant \"digits\". */\n\t\twhile ((sp < spe) && (precision > 0)) {\n\t\t\t*buf = *sp;\n\t\t\t++buf;\n\t\t\t++sp;\n\t\t\t--precision;\n\t\t}\n\n\t\tif (prune_zero) {\n\t\t\twhile (*--buf == '0') {\n\t\t\t\t;\n\t\t\t}\n\t\t\tif ((*buf != '.') || require_dp) {\n\t\t\t\t++buf;\n\t\t\t}\n\t\t}\n\n\t\t*buf = 'p';\n\t\t++buf;\n\t\tif (expo >= 0) {\n\t\t\t*buf = '+';\n\t\t\t++buf;\n\t\t} else {\n\t\t\t*buf = '-';\n\t\t\t++buf;\n\t\t\texpo = -expo;\n\t\t}\n\n\t\taconv.specifier = 'i';\n\t\tsp = encode_uint(expo, &aconv, buf, spe);\n\n\t\twhile (sp < spe) {\n\t\t\t*buf = *sp;\n\t\t\t++buf;\n\t\t\t++sp;\n\t\t}\n\n\t\t*bpe = buf;\n\t\treturn bps;\n\t}\n\n\t/* Remainder of code operates on a 64-bit fraction, so shift up (and\n\t * discard garbage from the exponent where the implicit 1 would be\n\t * stored).\n\t */\n\tfract <<= EXPONENT_BITS;\n\tfract &= ~SIGN_MASK;\n\n\t/* Non-zero values need normalization. */\n\tif ((expo | fract) != 0) {\n\t\tif (is_subnormal) {\n\t\t\t/* Fraction is subnormal.  Normalize it and correct\n\t\t\t * the exponent.\n\t\t\t */\n\t\t\tfor (fract <<= 1; (fract & BIT_63) == 0; fract <<= 1) {\n\t\t\t\texpo--;\n\t\t\t}\n\t\t}\n\t\t/* Adjust the offset exponent to be signed rather than offset,\n\t\t * and set the implicit 1 bit in the (shifted) 53-bit\n\t\t * fraction.\n\t\t */\n\t\texpo -= (1023 - 1);\t/* +1 since .1 vs 1. */\n\t\tfract |= BIT_63;\n\t}\n\n\t/*\n\t * Let's consider:\n\t *\n\t *\tvalue = fract * 2^expo * 10^decexp\n\t *\n\t * Initially decexp = 0. The goal is to bring exp between\n\t * 0 and -2 as the magnitude of a fractional decimal digit is 3 bits.\n\t */\n\tint decexp = 0;\n\n\twhile (expo < -2) {\n\t\t/*\n\t\t * Make room to allow a multiplication by 5 without overflow.\n\t\t * We test only the top part for faster code.\n\t\t */\n\t\tdo {\n\t\t\tfract >>= 1;\n\t\t\texpo++;\n\t\t} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));\n\n\t\t/* Perform fract * 5 * 2 / 10 */\n\t\tfract *= 5U;\n\t\texpo++;\n\t\tdecexp--;\n\t}\n\n\twhile (expo > 0) {\n\t\t/*\n\t\t * Perform fract / 5 / 2 * 10.\n\t\t * The +2 is there to do round the result of the division\n\t\t * by 5 not to lose too much precision in extreme cases.\n\t\t */\n\t\tfract += 2;\n\t\t_ldiv5(&fract);\n\t\texpo--;\n\t\tdecexp++;\n\n\t\t/* Bring back our fractional number to full scale */\n\t\tdo {\n\t\t\tfract <<= 1;\n\t\t\texpo--;\n\t\t} while (!(fract & BIT_63));\n\t}\n\n\t/*\n\t * The binary fractional point is located somewhere above bit 63.\n\t * Move it between bits 59 and 60 to give 4 bits of room to the\n\t * integer part.\n\t */\n\tfract >>= (4 - expo);\n\n\tif ((c == 'g') || (c == 'G')) {\n\t\t/* Use the specified precision and exponent to select the\n\t\t * representation and correct the precision and zero-pruning\n\t\t * in accordance with the ISO C rule.\n\t\t */\n\t\tif ((decexp < (-4 + 1)) || (decexp > precision)) {\n\t\t\tc += 'e' - 'g';  /* e or E */\n\t\t\tif (precision > 0) {\n\t\t\t\tprecision--;\n\t\t\t}\n\t\t} else {\n\t\t\tc = 'f';\n\t\t\tprecision -= decexp;\n\t\t}\n\t\tif (!conv->flag_hash && (precision > 0)) {\n\t\t\tprune_zero = true;\n\t\t}\n\t}\n\n\tint decimals;\n\tif (c == 'f') {\n\t\tdecimals = precision + decexp;\n\t\tif (decimals < 0) {\n\t\t\tdecimals = 0;\n\t\t}\n\t} else {\n\t\tdecimals = precision + 1;\n\t}\n\n\tint digit_count = 16;\n\n\tif (decimals > 16) {\n\t\tdecimals = 16;\n\t}\n\n\t/* Round the value to the last digit being printed. */\n\tuint64_t round = BIT64(59); /* 0.5 */\n\twhile (decimals-- != 0) {\n\t\t_ldiv10(&round);\n\t}\n\tfract += round;\n\t/* Make sure rounding didn't make fract >= 1.0 */\n\tif (fract >= BIT64(60)) {\n\t\t_ldiv10(&fract);\n\t\tdecexp++;\n\t}\n\n\tif (c == 'f') {\n\t\tif (decexp > 0) {\n\t\t\t/* Emit the digits above the decimal point. */\n\t\t\twhile ((decexp > 0) && (digit_count > 0)) {\n\t\t\t\t*buf = _get_digit(&fract, &digit_count);\n\t\t\t\t++buf;\n\t\t\t\tdecexp--;\n\t\t\t}\n\n\t\t\tconv->pad0_value = decexp;\n\n\t\t\tdecexp = 0;\n\t\t} else {\n\t\t\t*buf = '0';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* Emit the decimal point only if required by the alternative\n\t\t * format, or if more digits are to follow.\n\t\t */\n\t\tif (conv->flag_hash || (precision > 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\n\t\tif ((decexp < 0) && (precision > 0)) {\n\t\t\tconv->pad0_value = -decexp;\n\t\t\tif (conv->pad0_value > precision) {\n\t\t\t\tconv->pad0_value = precision;\n\t\t\t}\n\n\t\t\tprecision -= conv->pad0_value;\n\t\t\tconv->pad_postdp = (conv->pad0_value > 0);\n\t\t}\n\t} else { /* e or E */\n\t\t/* Emit the one digit before the decimal.  If it's not zero,\n\t\t * this is significant so reduce the base-10 exponent.\n\t\t */\n\t\t*buf = _get_digit(&fract, &digit_count);\n\t\tif (*buf++ != '0') {\n\t\t\tdecexp--;\n\t\t}\n\n\t\t/* Emit the decimal point only if required by the alternative\n\t\t * format, or if more digits are to follow.\n\t\t */\n\t\tif (conv->flag_hash || (precision > 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\t}\n\n\twhile ((precision > 0) && (digit_count > 0)) {\n\t\t*buf = _get_digit(&fract, &digit_count);\n\t\t++buf;\n\t\tprecision--;\n\t}\n\n\tconv->pad0_pre_exp = precision;\n\n\tif (prune_zero) {\n\t\tconv->pad0_pre_exp = 0;\n\t\tdo {\n\t\t\t--buf;\n\t\t} while (*buf == '0');\n\t\tif (*buf != '.') {\n\t\t\t++buf;\n\t\t}\n\t}\n\n\t/* Emit the explicit exponent, if format requires it. */\n\tif ((c == 'e') || (c == 'E')) {\n\t\t*buf = c;\n\t\t++buf;\n\t\tif (decexp < 0) {\n\t\t\tdecexp = -decexp;\n\t\t\t*buf = '-';\n\t\t\t++buf;\n\t\t} else {\n\t\t\t*buf = '+';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* At most 3 digits to the decimal.  Spit them out. */\n\t\tif (decexp >= 100) {\n\t\t\t*buf = (decexp / 100) + '0';\n\t\t\t++buf;\n\t\t\tdecexp %= 100;\n\t\t}\n\n\t\tbuf[0] = (decexp / 10) + '0';\n\t\tbuf[1] = (decexp % 10) + '0';\n\t\tbuf += 2;\n\t}\n\n\t/* Cache whether there's padding required */\n\tconv->pad_fp = (conv->pad0_value > 0)\n\t\t|| (conv->pad0_pre_exp > 0);\n\n\t/* Set the end of the encoded sequence, and return its start.  Also\n\t * store EOS as a non-digit/non-decimal value so we don't have to\n\t * check against bpe when iterating in multiple places.\n\t */\n\t*bpe = buf;\n\t*buf = 0;\n\treturn bps;\n}\n",
                {
                    "869": "static char *encode_float(double value,",
                    "870": "\t\t\t  struct conversion *conv,",
                    "871": "\t\t\t  int precision,",
                    "872": "\t\t\t  char *sign,",
                    "873": "\t\t\t  char *bps,",
                    "874": "\t\t\t  const char **bpe)",
                    "875": "{",
                    "876": "\tunion {",
                    "877": "\t\tuint64_t u64;",
                    "878": "\t\tdouble dbl;",
                    "879": "\t} u = {",
                    "880": "\t\t.dbl = value,",
                    "881": "\t};",
                    "882": "\tbool prune_zero = false;",
                    "883": "\tchar *buf = bps;",
                    "884": "",
                    "885": "\t/* Prepend the sign: '-' if negative, flags control",
                    "886": "\t * non-negative behavior.",
                    "887": "\t */",
                    "888": "\tif ((u.u64 & SIGN_MASK) != 0U) {",
                    "889": "\t\t*sign = '-';",
                    "890": "\t} else if (conv->flag_plus) {",
                    "891": "\t\t*sign = '+';",
                    "892": "\t} else if (conv->flag_space) {",
                    "893": "\t\t*sign = ' ';",
                    "894": "\t} else {",
                    "895": "\t\t;",
                    "896": "\t}",
                    "897": "",
                    "898": "\t/* Extract the non-negative offset exponent and fraction.  Record",
                    "899": "\t * whether the value is subnormal.",
                    "900": "\t */",
                    "901": "\tchar c = conv->specifier;",
                    "902": "\tint expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);",
                    "903": "\tuint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);",
                    "904": "\tbool is_subnormal = (expo == 0) && (fract != 0);",
                    "905": "",
                    "906": "\t/* Exponent of all-ones signals infinity or NaN, which are",
                    "907": "\t * text constants regardless of specifier.",
                    "908": "\t */",
                    "909": "\tif (expo == BIT_MASK(EXPONENT_BITS)) {",
                    "910": "\t\tif (fract == 0) {",
                    "911": "\t\t\tif (isupper((unsigned char)c) != 0) {",
                    "912": "\t\t\t\tbuf[0] = 'I';",
                    "913": "\t\t\t\tbuf[1] = 'N';",
                    "914": "\t\t\t\tbuf[2] = 'F';",
                    "915": "\t\t\t\tbuf += 3;",
                    "916": "\t\t\t} else {",
                    "917": "\t\t\t\tbuf[0] = 'i';",
                    "918": "\t\t\t\tbuf[1] = 'n';",
                    "919": "\t\t\t\tbuf[2] = 'f';",
                    "920": "\t\t\t\tbuf += 3;",
                    "921": "\t\t\t}",
                    "922": "\t\t} else {",
                    "923": "\t\t\tif (isupper((unsigned char)c) != 0) {",
                    "924": "\t\t\t\tbuf[0] = 'N';",
                    "925": "\t\t\t\tbuf[1] = 'A';",
                    "926": "\t\t\t\tbuf[2] = 'N';",
                    "927": "\t\t\t\tbuf += 3;",
                    "928": "\t\t\t} else {",
                    "929": "\t\t\t\tbuf[0] = 'n';",
                    "930": "\t\t\t\tbuf[1] = 'a';",
                    "931": "\t\t\t\tbuf[2] = 'n';",
                    "932": "\t\t\t\tbuf += 3;",
                    "933": "\t\t\t}",
                    "934": "\t\t}",
                    "935": "",
                    "936": "\t\t/* No zero-padding with text values */",
                    "937": "\t\tconv->flag_zero = false;",
                    "938": "",
                    "939": "\t\t*bpe = buf;",
                    "940": "\t\treturn bps;",
                    "941": "\t}",
                    "942": "",
                    "943": "\t/* The case of an F specifier is no longer relevant. */",
                    "944": "\tif (c == 'F') {",
                    "945": "\t\tc = 'f';",
                    "946": "\t}",
                    "947": "",
                    "948": "\t/* Handle converting to the hex representation. */",
                    "949": "\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_A_SUPPORT)",
                    "950": "\t    && (IS_ENABLED(CONFIG_CBPRINTF_FP_ALWAYS_A)",
                    "951": "\t\t|| conv->specifier_a)) {",
                    "952": "\t\tbuf[0] = '0';",
                    "953": "\t\tbuf[1] = 'x';",
                    "954": "\t\tbuf += 2;",
                    "955": "",
                    "956": "\t\t/* Remove the offset from the exponent, and store the",
                    "957": "\t\t * non-fractional value.  Subnormals require increasing the",
                    "958": "\t\t * exponent as first bit isn't the implicit bit.",
                    "959": "\t\t */",
                    "960": "\t\texpo -= 1023;",
                    "961": "\t\tif (is_subnormal) {",
                    "962": "\t\t\t*buf = '0';",
                    "963": "\t\t\t++buf;",
                    "964": "\t\t\t++expo;",
                    "965": "\t\t} else {",
                    "966": "\t\t\t*buf = '1';",
                    "967": "\t\t\t++buf;",
                    "968": "\t\t}",
                    "969": "",
                    "970": "\t\t/* If we didn't get precision from a %a specification then we",
                    "971": "\t\t * treat it as from a %a specification with no precision: full",
                    "972": "\t\t * range, zero-pruning enabled.",
                    "973": "\t\t *",
                    "974": "\t\t * Otherwise we have to cap the precision of the generated",
                    "975": "\t\t * fraction, or possibly round it.",
                    "976": "\t\t */",
                    "977": "\t\tif (!(conv->specifier_a && conv->prec_present)) {",
                    "978": "\t\t\tprecision = FRACTION_HEX;",
                    "979": "\t\t\tprune_zero = true;",
                    "980": "\t\t} else if (precision > FRACTION_HEX) {",
                    "981": "\t\t\tconv->pad0_pre_exp = precision - FRACTION_HEX;",
                    "982": "\t\t\tconv->pad_fp = true;",
                    "983": "\t\t\tprecision = FRACTION_HEX;",
                    "984": "\t\t} else if ((fract != 0)",
                    "985": "\t\t\t   && (precision < FRACTION_HEX)) {",
                    "986": "\t\t\tsize_t pos = 4 * (FRACTION_HEX - precision) - 1;",
                    "987": "\t\t\tuint64_t mask = BIT64(pos);",
                    "988": "",
                    "989": "\t\t\t/* Round only if the bit that would round is",
                    "990": "\t\t\t * set.",
                    "991": "\t\t\t */",
                    "992": "\t\t\tif ((fract & mask) != 0ULL) {",
                    "993": "\t\t\t\tfract += mask;",
                    "994": "\t\t\t}",
                    "995": "\t\t}",
                    "996": "",
                    "997": "\t\t/* Record whether we must retain the decimal point even if we",
                    "998": "\t\t * can prune zeros.",
                    "999": "\t\t */",
                    "1000": "\t\tbool require_dp = ((fract != 0) || conv->flag_hash);",
                    "1001": "",
                    "1002": "\t\tif (require_dp || (precision != 0)) {",
                    "1003": "\t\t\t*buf = '.';",
                    "1004": "\t\t\t++buf;",
                    "1005": "\t\t}",
                    "1006": "",
                    "1007": "\t\t/* Get the fractional value as a hexadecimal string, using x",
                    "1008": "\t\t * for a and X for A.",
                    "1009": "\t\t */",
                    "1010": "\t\tstruct conversion aconv = {",
                    "1011": "\t\t\t.specifier = isupper((unsigned char)c) != 0 ? 'X' : 'x',",
                    "1012": "\t\t};",
                    "1013": "\t\tconst char *spe = *bpe;",
                    "1014": "\t\tchar *sp = bps + (spe - bps);",
                    "1015": "",
                    "1016": "\t\tif (fract != 0) {",
                    "1017": "\t\t\tsp = encode_uint(fract, &aconv, buf, spe);",
                    "1018": "\t\t}",
                    "1019": "",
                    "1020": "\t\t/* Pad out to full range since this is below the decimal",
                    "1021": "\t\t * point.",
                    "1022": "\t\t */",
                    "1023": "\t\twhile ((spe - sp) < FRACTION_HEX) {",
                    "1024": "\t\t\t--sp;",
                    "1025": "\t\t\t*sp = '0';",
                    "1026": "\t\t}",
                    "1027": "",
                    "1028": "\t\t/* Append the leading significant \"digits\". */",
                    "1029": "\t\twhile ((sp < spe) && (precision > 0)) {",
                    "1030": "\t\t\t*buf = *sp;",
                    "1031": "\t\t\t++buf;",
                    "1032": "\t\t\t++sp;",
                    "1033": "\t\t\t--precision;",
                    "1034": "\t\t}",
                    "1035": "",
                    "1036": "\t\tif (prune_zero) {",
                    "1037": "\t\t\twhile (*--buf == '0') {",
                    "1038": "\t\t\t\t;",
                    "1039": "\t\t\t}",
                    "1040": "\t\t\tif ((*buf != '.') || require_dp) {",
                    "1041": "\t\t\t\t++buf;",
                    "1042": "\t\t\t}",
                    "1043": "\t\t}",
                    "1044": "",
                    "1045": "\t\t*buf = 'p';",
                    "1046": "\t\t++buf;",
                    "1047": "\t\tif (expo >= 0) {",
                    "1048": "\t\t\t*buf = '+';",
                    "1049": "\t\t\t++buf;",
                    "1050": "\t\t} else {",
                    "1051": "\t\t\t*buf = '-';",
                    "1052": "\t\t\t++buf;",
                    "1053": "\t\t\texpo = -expo;",
                    "1054": "\t\t}",
                    "1055": "",
                    "1056": "\t\taconv.specifier = 'i';",
                    "1057": "\t\tsp = encode_uint(expo, &aconv, buf, spe);",
                    "1058": "",
                    "1059": "\t\twhile (sp < spe) {",
                    "1060": "\t\t\t*buf = *sp;",
                    "1061": "\t\t\t++buf;",
                    "1062": "\t\t\t++sp;",
                    "1063": "\t\t}",
                    "1064": "",
                    "1065": "\t\t*bpe = buf;",
                    "1066": "\t\treturn bps;",
                    "1067": "\t}",
                    "1068": "",
                    "1069": "\t/* Remainder of code operates on a 64-bit fraction, so shift up (and",
                    "1070": "\t * discard garbage from the exponent where the implicit 1 would be",
                    "1071": "\t * stored).",
                    "1072": "\t */",
                    "1073": "\tfract <<= EXPONENT_BITS;",
                    "1074": "\tfract &= ~SIGN_MASK;",
                    "1075": "",
                    "1076": "\t/* Non-zero values need normalization. */",
                    "1077": "\tif ((expo | fract) != 0) {",
                    "1078": "\t\tif (is_subnormal) {",
                    "1079": "\t\t\t/* Fraction is subnormal.  Normalize it and correct",
                    "1080": "\t\t\t * the exponent.",
                    "1081": "\t\t\t */",
                    "1082": "\t\t\tfor (fract <<= 1; (fract & BIT_63) == 0; fract <<= 1) {",
                    "1083": "\t\t\t\texpo--;",
                    "1084": "\t\t\t}",
                    "1085": "\t\t}",
                    "1086": "\t\t/* Adjust the offset exponent to be signed rather than offset,",
                    "1087": "\t\t * and set the implicit 1 bit in the (shifted) 53-bit",
                    "1088": "\t\t * fraction.",
                    "1089": "\t\t */",
                    "1090": "\t\texpo -= (1023 - 1);\t/* +1 since .1 vs 1. */",
                    "1091": "\t\tfract |= BIT_63;",
                    "1092": "\t}",
                    "1093": "",
                    "1094": "\t/*",
                    "1095": "\t * Let's consider:",
                    "1096": "\t *",
                    "1097": "\t *\tvalue = fract * 2^expo * 10^decexp",
                    "1098": "\t *",
                    "1099": "\t * Initially decexp = 0. The goal is to bring exp between",
                    "1100": "\t * 0 and -2 as the magnitude of a fractional decimal digit is 3 bits.",
                    "1101": "\t */",
                    "1102": "\tint decexp = 0;",
                    "1103": "",
                    "1104": "\twhile (expo < -2) {",
                    "1105": "\t\t/*",
                    "1106": "\t\t * Make room to allow a multiplication by 5 without overflow.",
                    "1107": "\t\t * We test only the top part for faster code.",
                    "1108": "\t\t */",
                    "1109": "\t\tdo {",
                    "1110": "\t\t\tfract >>= 1;",
                    "1111": "\t\t\texpo++;",
                    "1112": "\t\t} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));",
                    "1113": "",
                    "1114": "\t\t/* Perform fract * 5 * 2 / 10 */",
                    "1115": "\t\tfract *= 5U;",
                    "1116": "\t\texpo++;",
                    "1117": "\t\tdecexp--;",
                    "1118": "\t}",
                    "1119": "",
                    "1120": "\twhile (expo > 0) {",
                    "1121": "\t\t/*",
                    "1122": "\t\t * Perform fract / 5 / 2 * 10.",
                    "1123": "\t\t * The +2 is there to do round the result of the division",
                    "1124": "\t\t * by 5 not to lose too much precision in extreme cases.",
                    "1125": "\t\t */",
                    "1126": "\t\tfract += 2;",
                    "1127": "\t\t_ldiv5(&fract);",
                    "1128": "\t\texpo--;",
                    "1129": "\t\tdecexp++;",
                    "1130": "",
                    "1131": "\t\t/* Bring back our fractional number to full scale */",
                    "1132": "\t\tdo {",
                    "1133": "\t\t\tfract <<= 1;",
                    "1134": "\t\t\texpo--;",
                    "1135": "\t\t} while (!(fract & BIT_63));",
                    "1136": "\t}",
                    "1137": "",
                    "1138": "\t/*",
                    "1139": "\t * The binary fractional point is located somewhere above bit 63.",
                    "1140": "\t * Move it between bits 59 and 60 to give 4 bits of room to the",
                    "1141": "\t * integer part.",
                    "1142": "\t */",
                    "1143": "\tfract >>= (4 - expo);",
                    "1144": "",
                    "1145": "\tif ((c == 'g') || (c == 'G')) {",
                    "1146": "\t\t/* Use the specified precision and exponent to select the",
                    "1147": "\t\t * representation and correct the precision and zero-pruning",
                    "1148": "\t\t * in accordance with the ISO C rule.",
                    "1149": "\t\t */",
                    "1150": "\t\tif ((decexp < (-4 + 1)) || (decexp > precision)) {",
                    "1151": "\t\t\tc += 'e' - 'g';  /* e or E */",
                    "1152": "\t\t\tif (precision > 0) {",
                    "1153": "\t\t\t\tprecision--;",
                    "1154": "\t\t\t}",
                    "1155": "\t\t} else {",
                    "1156": "\t\t\tc = 'f';",
                    "1157": "\t\t\tprecision -= decexp;",
                    "1158": "\t\t}",
                    "1159": "\t\tif (!conv->flag_hash && (precision > 0)) {",
                    "1160": "\t\t\tprune_zero = true;",
                    "1161": "\t\t}",
                    "1162": "\t}",
                    "1163": "",
                    "1164": "\tint decimals;",
                    "1165": "\tif (c == 'f') {",
                    "1166": "\t\tdecimals = precision + decexp;",
                    "1167": "\t\tif (decimals < 0) {",
                    "1168": "\t\t\tdecimals = 0;",
                    "1169": "\t\t}",
                    "1170": "\t} else {",
                    "1171": "\t\tdecimals = precision + 1;",
                    "1172": "\t}",
                    "1173": "",
                    "1174": "\tint digit_count = 16;",
                    "1175": "",
                    "1176": "\tif (decimals > 16) {",
                    "1177": "\t\tdecimals = 16;",
                    "1178": "\t}",
                    "1179": "",
                    "1180": "\t/* Round the value to the last digit being printed. */",
                    "1181": "\tuint64_t round = BIT64(59); /* 0.5 */",
                    "1182": "\twhile (decimals-- != 0) {",
                    "1183": "\t\t_ldiv10(&round);",
                    "1184": "\t}",
                    "1185": "\tfract += round;",
                    "1186": "\t/* Make sure rounding didn't make fract >= 1.0 */",
                    "1187": "\tif (fract >= BIT64(60)) {",
                    "1188": "\t\t_ldiv10(&fract);",
                    "1189": "\t\tdecexp++;",
                    "1190": "\t}",
                    "1191": "",
                    "1192": "\tif (c == 'f') {",
                    "1193": "\t\tif (decexp > 0) {",
                    "1194": "\t\t\t/* Emit the digits above the decimal point. */",
                    "1195": "\t\t\twhile ((decexp > 0) && (digit_count > 0)) {",
                    "1196": "\t\t\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1197": "\t\t\t\t++buf;",
                    "1198": "\t\t\t\tdecexp--;",
                    "1199": "\t\t\t}",
                    "1200": "",
                    "1201": "\t\t\tconv->pad0_value = decexp;",
                    "1202": "",
                    "1203": "\t\t\tdecexp = 0;",
                    "1204": "\t\t} else {",
                    "1205": "\t\t\t*buf = '0';",
                    "1206": "\t\t\t++buf;",
                    "1207": "\t\t}",
                    "1208": "",
                    "1209": "\t\t/* Emit the decimal point only if required by the alternative",
                    "1210": "\t\t * format, or if more digits are to follow.",
                    "1211": "\t\t */",
                    "1212": "\t\tif (conv->flag_hash || (precision > 0)) {",
                    "1213": "\t\t\t*buf = '.';",
                    "1214": "\t\t\t++buf;",
                    "1215": "\t\t}",
                    "1216": "",
                    "1217": "\t\tif ((decexp < 0) && (precision > 0)) {",
                    "1218": "\t\t\tconv->pad0_value = -decexp;",
                    "1219": "\t\t\tif (conv->pad0_value > precision) {",
                    "1220": "\t\t\t\tconv->pad0_value = precision;",
                    "1221": "\t\t\t}",
                    "1222": "",
                    "1223": "\t\t\tprecision -= conv->pad0_value;",
                    "1224": "\t\t\tconv->pad_postdp = (conv->pad0_value > 0);",
                    "1225": "\t\t}",
                    "1226": "\t} else { /* e or E */",
                    "1227": "\t\t/* Emit the one digit before the decimal.  If it's not zero,",
                    "1228": "\t\t * this is significant so reduce the base-10 exponent.",
                    "1229": "\t\t */",
                    "1230": "\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1231": "\t\tif (*buf++ != '0') {",
                    "1232": "\t\t\tdecexp--;",
                    "1233": "\t\t}",
                    "1234": "",
                    "1235": "\t\t/* Emit the decimal point only if required by the alternative",
                    "1236": "\t\t * format, or if more digits are to follow.",
                    "1237": "\t\t */",
                    "1238": "\t\tif (conv->flag_hash || (precision > 0)) {",
                    "1239": "\t\t\t*buf = '.';",
                    "1240": "\t\t\t++buf;",
                    "1241": "\t\t}",
                    "1242": "\t}",
                    "1243": "",
                    "1244": "\twhile ((precision > 0) && (digit_count > 0)) {",
                    "1245": "\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1246": "\t\t++buf;",
                    "1247": "\t\tprecision--;",
                    "1248": "\t}",
                    "1249": "",
                    "1250": "\tconv->pad0_pre_exp = precision;",
                    "1251": "",
                    "1252": "\tif (prune_zero) {",
                    "1253": "\t\tconv->pad0_pre_exp = 0;",
                    "1254": "\t\tdo {",
                    "1255": "\t\t\t--buf;",
                    "1256": "\t\t} while (*buf == '0');",
                    "1257": "\t\tif (*buf != '.') {",
                    "1258": "\t\t\t++buf;",
                    "1259": "\t\t}",
                    "1260": "\t}",
                    "1261": "",
                    "1262": "\t/* Emit the explicit exponent, if format requires it. */",
                    "1263": "\tif ((c == 'e') || (c == 'E')) {",
                    "1264": "\t\t*buf = c;",
                    "1265": "\t\t++buf;",
                    "1266": "\t\tif (decexp < 0) {",
                    "1267": "\t\t\tdecexp = -decexp;",
                    "1268": "\t\t\t*buf = '-';",
                    "1269": "\t\t\t++buf;",
                    "1270": "\t\t} else {",
                    "1271": "\t\t\t*buf = '+';",
                    "1272": "\t\t\t++buf;",
                    "1273": "\t\t}",
                    "1274": "",
                    "1275": "\t\t/* At most 3 digits to the decimal.  Spit them out. */",
                    "1276": "\t\tif (decexp >= 100) {",
                    "1277": "\t\t\t*buf = (decexp / 100) + '0';",
                    "1278": "\t\t\t++buf;",
                    "1279": "\t\t\tdecexp %= 100;",
                    "1280": "\t\t}",
                    "1281": "",
                    "1282": "\t\tbuf[0] = (decexp / 10) + '0';",
                    "1283": "\t\tbuf[1] = (decexp % 10) + '0';",
                    "1284": "\t\tbuf += 2;",
                    "1285": "\t}",
                    "1286": "",
                    "1287": "\t/* Cache whether there's padding required */",
                    "1288": "\tconv->pad_fp = (conv->pad0_value > 0)",
                    "1289": "\t\t|| (conv->pad0_pre_exp > 0);",
                    "1290": "",
                    "1291": "\t/* Set the end of the encoded sequence, and return its start.  Also",
                    "1292": "\t * store EOS as a non-digit/non-decimal value so we don't have to",
                    "1293": "\t * check against bpe when iterating in multiple places.",
                    "1294": "\t */",
                    "1295": "\t*bpe = buf;",
                    "1296": "\t*buf = 0;",
                    "1297": "\treturn bps;",
                    "1298": "}"
                }
            ],
            "function_content_in_lines": {}
        }
    },
    "driver_functions": {},
    "buffer_functions": {
        "next": {
            "name": "next",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 46,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *next(struct _timeout *t)\n{\n\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);\n\n\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);\n}\n",
                {
                    "46": "static struct _timeout *next(struct _timeout *t)",
                    "47": "{",
                    "48": "\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);",
                    "49": "",
                    "50": "\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);",
                    "51": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_get": {
            "name": "k_mbox_get",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mailbox.c",
            "location_line": 382,
            "function_content": [
                "/* keep message around for later data retrieval */\nint k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,\n\t       k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_mbox_msg *tx_msg;\n\tk_spinlock_key_t key;\n\tint result;\n\n\t/* save receiver id so it can be used during message matching */\n\trx_msg->tx_target_thread = _current;\n\n\t/* search mailbox's tx queue for a compatible sender */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {\n\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take sender out of mailbox's tx queue */\n\t\t\tz_unpend_thread(sending_thread);\n\n\t\t\tk_spin_unlock(&mbox->lock, key);\n\n\t\t\t/* consume message data immediately, if needed */\n\t\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* didn't find a matching sender */\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);\n\n\t\t/* don't wait for a matching sender to appear */\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);\n\n\t/* wait until a matching sender appears or a timeout occurs */\n\t_current->base.swap_data = rx_msg;\n\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);\n\n\t/* consume message data immediately, if needed */\n\tif (result == 0) {\n\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\n\treturn result;\n}\n",
                {
                    "382": "int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,",
                    "383": "\t       k_timeout_t timeout)",
                    "384": "{",
                    "385": "\tstruct k_thread *sending_thread;",
                    "386": "\tstruct k_mbox_msg *tx_msg;",
                    "387": "\tk_spinlock_key_t key;",
                    "388": "\tint result;",
                    "389": "",
                    "390": "\t/* save receiver id so it can be used during message matching */",
                    "391": "\trx_msg->tx_target_thread = _current;",
                    "392": "",
                    "393": "\t/* search mailbox's tx queue for a compatible sender */",
                    "394": "\tkey = k_spin_lock(&mbox->lock);",
                    "395": "",
                    "396": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);",
                    "397": "",
                    "398": "\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {",
                    "399": "\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;",
                    "400": "",
                    "401": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "402": "\t\t\t/* take sender out of mailbox's tx queue */",
                    "403": "\t\t\tz_unpend_thread(sending_thread);",
                    "404": "",
                    "405": "\t\t\tk_spin_unlock(&mbox->lock, key);",
                    "406": "",
                    "407": "\t\t\t/* consume message data immediately, if needed */",
                    "408": "\t\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "409": "",
                    "410": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "411": "\t\t\treturn result;",
                    "412": "\t\t}",
                    "413": "\t}",
                    "414": "",
                    "415": "\t/* didn't find a matching sender */",
                    "416": "",
                    "417": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "418": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);",
                    "419": "",
                    "420": "\t\t/* don't wait for a matching sender to appear */",
                    "421": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "422": "\t\treturn -ENOMSG;",
                    "423": "\t}",
                    "424": "",
                    "425": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);",
                    "426": "",
                    "427": "\t/* wait until a matching sender appears or a timeout occurs */",
                    "428": "\t_current->base.swap_data = rx_msg;",
                    "429": "\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);",
                    "430": "",
                    "431": "\t/* consume message data immediately, if needed */",
                    "432": "\tif (result == 0) {",
                    "433": "\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "434": "\t}",
                    "435": "",
                    "436": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "437": "",
                    "438": "\treturn result;",
                    "439": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_timeout": {
            "name": "z_thread_timeout",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 668,
            "function_content": [
                "/* Timeout handler for *_thread_timeout() APIs */\nvoid z_thread_timeout(struct _timeout *timeout)\n{\n\tstruct k_thread *thread = CONTAINER_OF(timeout,\n\t\t\t\t\t       struct k_thread, base.timeout);\n\n\tz_sched_wake_thread(thread, true);\n}\n",
                {
                    "668": "void z_thread_timeout(struct _timeout *timeout)",
                    "669": "{",
                    "670": "\tstruct k_thread *thread = CONTAINER_OF(timeout,",
                    "671": "\t\t\t\t\t       struct k_thread, base.timeout);",
                    "672": "",
                    "673": "\tz_sched_wake_thread(thread, true);",
                    "674": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_waitq_walk": {
            "name": "z_sched_waitq_walk",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/sched.c",
            "location_line": 1579,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nint z_sched_waitq_walk(_wait_q_t  *wait_q,\n\t\t       int (*func)(struct k_thread *, void *), void *data)\n{\n\tstruct k_thread *thread;\n\tint  status = 0;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {\n\n\t\t\t/*\n\t\t\t * Invoke the callback function on each waiting thread\n\t\t\t * for as long as there are both waiting threads AND\n\t\t\t * it returns 0.\n\t\t\t */\n\n\t\t\tstatus = func(thread, data);\n\t\t\tif (status != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n",
                {
                    "1579": "int z_sched_waitq_walk(_wait_q_t  *wait_q,",
                    "1580": "\t\t       int (*func)(struct k_thread *, void *), void *data)",
                    "1581": "{",
                    "1582": "\tstruct k_thread *thread;",
                    "1583": "\tint  status = 0;",
                    "1584": "",
                    "1585": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1586": "\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {",
                    "1587": "",
                    "1588": "\t\t\t/*",
                    "1589": "\t\t\t * Invoke the callback function on each waiting thread",
                    "1590": "\t\t\t * for as long as there are both waiting threads AND",
                    "1591": "\t\t\t * it returns 0.",
                    "1592": "\t\t\t */",
                    "1593": "",
                    "1594": "\t\t\tstatus = func(thread, data);",
                    "1595": "\t\t\tif (status != 0) {",
                    "1596": "\t\t\t\tbreak;",
                    "1597": "\t\t\t}",
                    "1598": "\t\t}",
                    "1599": "\t}",
                    "1600": "",
                    "1601": "\treturn status;",
                    "1602": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_priq_rb_lessthan": {
            "name": "z_priq_rb_lessthan",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/priority_queues.c",
            "location_line": 12,
            "function_content": [
                "/*\n* Copyright (c) 2018,2024 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nbool z_priq_rb_lessthan(struct rbnode *a, struct rbnode *b)\n{\n\tstruct k_thread *thread_a, *thread_b;\n\tint32_t cmp;\n\n\tthread_a = CONTAINER_OF(a, struct k_thread, base.qnode_rb);\n\tthread_b = CONTAINER_OF(b, struct k_thread, base.qnode_rb);\n\n\tcmp = z_sched_prio_cmp(thread_a, thread_b);\n\n\tif (cmp > 0) {\n\t\treturn true;\n\t} else if (cmp < 0) {\n\t\treturn false;\n\t} else {\n\t\treturn thread_a->base.order_key < thread_b->base.order_key\n\t\t\t? 1 : 0;\n\t}\n}\n",
                {
                    "12": "bool z_priq_rb_lessthan(struct rbnode *a, struct rbnode *b)",
                    "13": "{",
                    "14": "\tstruct k_thread *thread_a, *thread_b;",
                    "15": "\tint32_t cmp;",
                    "16": "",
                    "17": "\tthread_a = CONTAINER_OF(a, struct k_thread, base.qnode_rb);",
                    "18": "\tthread_b = CONTAINER_OF(b, struct k_thread, base.qnode_rb);",
                    "19": "",
                    "20": "\tcmp = z_sched_prio_cmp(thread_a, thread_b);",
                    "21": "",
                    "22": "\tif (cmp > 0) {",
                    "23": "\t\treturn true;",
                    "24": "\t} else if (cmp < 0) {",
                    "25": "\t\treturn false;",
                    "26": "\t} else {",
                    "27": "\t\treturn thread_a->base.order_key < thread_b->base.order_key",
                    "28": "\t\t\t? 1 : 0;",
                    "29": "\t}",
                    "30": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_put": {
            "name": "mbox_message_put",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/mailbox.c",
            "location_line": 210,
            "function_content": [
                "/**\n* @brief Send a mailbox message.\n*\n* Helper routine that handles both synchronous and asynchronous sends.\n*\n* @param mbox Pointer to the mailbox object.\n* @param tx_msg Pointer to transmit message descriptor.\n* @param timeout Maximum time (milliseconds) to wait for the message to be\n*        received (although not necessarily completely processed).\n*        Use K_NO_WAIT to return immediately, or K_FOREVER to wait as long\n*        as necessary.\n*\n* @return 0 if successful, -ENOMSG if failed immediately, -EAGAIN if timed out\n*/\nstatic int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_thread *receiving_thread;\n\tstruct k_mbox_msg *rx_msg;\n\tk_spinlock_key_t key;\n\n\t/* save sender id so it can be used during message matching */\n\ttx_msg->rx_source_thread = _current;\n\n\t/* finish readying sending thread (actual or dummy) for send */\n\tsending_thread = tx_msg->_syncing_thread;\n\tsending_thread->base.swap_data = tx_msg;\n\n\t/* search mailbox's rx queue for a compatible receiver */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {\n\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take receiver out of rx queue */\n\t\t\tz_unpend_thread(receiving_thread);\n\n\t\t\t/* ready receiver for execution */\n\t\t\tarch_thread_return_value_set(receiving_thread, 0);\n\t\t\tz_ready_thread(receiving_thread);\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t\t\t/*\n\t\t\t * asynchronous send: swap out current thread\n\t\t\t * if receiver has priority, otherwise let it continue\n\t\t\t *\n\t\t\t * note: dummy sending thread sits (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)\n\t\t\t    != 0U) {\n\t\t\t\tz_reschedule(&mbox->lock, key);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t\t\t/*\n\t\t\t * synchronous send: pend current thread (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* didn't find a matching receiver: don't wait for one */\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);\n\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/* asynchronous send: dummy thread waits on tx queue for receiver */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn 0;\n\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t/* synchronous send: sender waits on tx queue for receiver or timeout */\n\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\treturn ret;\n}\n",
                {
                    "210": "static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,",
                    "211": "\t\t\t     k_timeout_t timeout)",
                    "212": "{",
                    "213": "\tstruct k_thread *sending_thread;",
                    "214": "\tstruct k_thread *receiving_thread;",
                    "215": "\tstruct k_mbox_msg *rx_msg;",
                    "216": "\tk_spinlock_key_t key;",
                    "217": "",
                    "218": "\t/* save sender id so it can be used during message matching */",
                    "219": "\ttx_msg->rx_source_thread = _current;",
                    "220": "",
                    "221": "\t/* finish readying sending thread (actual or dummy) for send */",
                    "222": "\tsending_thread = tx_msg->_syncing_thread;",
                    "223": "\tsending_thread->base.swap_data = tx_msg;",
                    "224": "",
                    "225": "\t/* search mailbox's rx queue for a compatible receiver */",
                    "226": "\tkey = k_spin_lock(&mbox->lock);",
                    "227": "",
                    "228": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);",
                    "229": "",
                    "230": "\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {",
                    "231": "\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;",
                    "232": "",
                    "233": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "234": "\t\t\t/* take receiver out of rx queue */",
                    "235": "\t\t\tz_unpend_thread(receiving_thread);",
                    "236": "",
                    "237": "\t\t\t/* ready receiver for execution */",
                    "238": "\t\t\tarch_thread_return_value_set(receiving_thread, 0);",
                    "239": "\t\t\tz_ready_thread(receiving_thread);",
                    "240": "",
                    "241": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "242": "\t\t\t/*",
                    "243": "\t\t\t * asynchronous send: swap out current thread",
                    "244": "\t\t\t * if receiver has priority, otherwise let it continue",
                    "245": "\t\t\t *",
                    "246": "\t\t\t * note: dummy sending thread sits (unqueued)",
                    "247": "\t\t\t * until the receiver consumes the message",
                    "248": "\t\t\t */",
                    "249": "\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)",
                    "250": "\t\t\t    != 0U) {",
                    "251": "\t\t\t\tz_reschedule(&mbox->lock, key);",
                    "252": "\t\t\t\treturn 0;",
                    "253": "\t\t\t}",
                    "254": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "255": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "256": "",
                    "257": "\t\t\t/*",
                    "258": "\t\t\t * synchronous send: pend current thread (unqueued)",
                    "259": "\t\t\t * until the receiver consumes the message",
                    "260": "\t\t\t */",
                    "261": "\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);",
                    "262": "",
                    "263": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "264": "",
                    "265": "\t\t\treturn ret;",
                    "266": "\t\t}",
                    "267": "\t}",
                    "268": "",
                    "269": "\t/* didn't find a matching receiver: don't wait for one */",
                    "270": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "271": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);",
                    "272": "",
                    "273": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "274": "\t\treturn -ENOMSG;",
                    "275": "\t}",
                    "276": "",
                    "277": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "278": "\t/* asynchronous send: dummy thread waits on tx queue for receiver */",
                    "279": "\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {",
                    "280": "\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);",
                    "281": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "282": "\t\treturn 0;",
                    "283": "\t}",
                    "284": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "286": "",
                    "287": "\t/* synchronous send: sender waits on tx queue for receiver or timeout */",
                    "288": "\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);",
                    "289": "",
                    "290": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "291": "",
                    "292": "\treturn ret;",
                    "293": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "first": {
            "name": "first",
            "file_path": "/home/chenkaiqiu/zephyr/kernel/timeout.c",
            "location_line": 39,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *first(void)\n{\n\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);\n\n\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);\n}\n",
                {
                    "39": "static struct _timeout *first(void)",
                    "40": "{",
                    "41": "\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);",
                    "42": "",
                    "43": "\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);",
                    "44": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_cbvprintf_impl": {
            "name": "z_cbvprintf_impl",
            "file_path": "/home/chenkaiqiu/zephyr/lib/os/cbprintf_complete.c",
            "location_line": 1369,
            "function_content": [
                "/* Outline function to emit all characters in [sp, ep). */\nint z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,\n\t\t     va_list ap, uint32_t flags)\n{\n\tchar buf[CONVERTED_BUFLEN];\n\tsize_t count = 0;\n\tsint_value_type sint;\n\tcbprintf_cb_local out = __out;\n\n\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)\n\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;\n\n/* Output character, returning EOF if output failed, otherwise\n * updating count.\n *\n * NB: c is evaluated exactly once: side-effects are OK\n */\n#define OUTC(c) do { \\\n\tint rc = (*out)((int)(c), ctx); \\\n\t\\\n\tif (rc < 0) { \\\n\t\treturn rc; \\\n\t} \\\n\t++count; \\\n} while (false)\n\n/* Output sequence of characters, returning a negative error if output\n * failed.\n */\n\n#define OUTS(_sp, _ep) do { \\\n\tint rc = outs(out, ctx, (_sp), (_ep)); \\\n\t\\\n\tif (rc < 0) {\t    \\\n\t\treturn rc; \\\n\t} \\\n\tcount += rc; \\\n} while (false)\n\n\twhile (*fp != 0) {\n\t\tif (*fp != '%') {\n\t\t\tOUTC(*fp);\n\t\t\t++fp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Force union into RAM with conversion state to\n\t\t * mitigate LLVM code generation bug.\n\t\t */\n\t\tstruct {\n\t\t\tunion argument_value value;\n\t\t\tstruct conversion conv;\n\t\t} state = {\n\t\t\t.value = {\n\t\t\t\t.uint = 0,\n\t\t\t},\n\t\t};\n\t\tstruct conversion *const conv = &state.conv;\n\t\tunion argument_value *const value = &state.value;\n\t\tconst char *sp = fp;\n\t\tint width = -1;\n\t\tint precision = -1;\n\t\tconst char *bps = NULL;\n\t\tconst char *bpe = buf + sizeof(buf);\n\t\tchar sign = 0;\n\n\t\tfp = extract_conversion(conv, sp);\n\n\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\t\t\t    && tagged_ap) {\n\t\t\t\t/* Skip over the argument tag as it is not being\n\t\t\t\t * used here.\n\t\t\t\t */\n\t\t\t\t(void)va_arg(ap, int);\n\t\t\t}\n\t\t}\n\n\t\t/* If dynamic width is specified, process it,\n\t\t * otherwise set width if present.\n\t\t */\n\t\tif (conv->width_star) {\n\t\t\twidth = va_arg(ap, int);\n\n\t\t\tif (width < 0) {\n\t\t\t\tconv->flag_dash = true;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t} else if (conv->width_present) {\n\t\t\twidth = conv->width_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* If dynamic precision is specified, process it, otherwise\n\t\t * set precision if present.  For floating point where\n\t\t * precision is not present use 6.\n\t\t */\n\t\tif (conv->prec_star) {\n\t\t\tint arg = va_arg(ap, int);\n\n\t\t\tif (arg < 0) {\n\t\t\t\tconv->prec_present = false;\n\t\t\t} else {\n\t\t\t\tprecision = arg;\n\t\t\t}\n\t\t} else if (conv->prec_present) {\n\t\t\tprecision = conv->prec_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* Reuse width and precision memory in conv for value\n\t\t * padding counts.\n\t\t */\n\t\tconv->pad0_value = 0;\n\t\tconv->pad0_pre_exp = 0;\n\n\t\t/* FP conversion requires knowing the precision. */\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)\n\t\t    && (conv->specifier_cat == SPECIFIER_FP)\n\t\t    && !conv->prec_present) {\n\t\t\tif (conv->specifier_a) {\n\t\t\t\tprecision = FRACTION_HEX;\n\t\t\t} else {\n\t\t\t\tprecision = 6;\n\t\t\t}\n\t\t}\n\n\t\t/* Get the value to be converted from the args.\n\t\t *\n\t\t * This can't be extracted to a helper function because\n\t\t * passing a pointer to va_list doesn't work on x86_64.  See\n\t\t * https://stackoverflow.com/a/8048892.\n\t\t */\n\t\tenum specifier_cat_enum specifier_cat\n\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;\n\t\tenum length_mod_enum length_mod\n\t\t\t= (enum length_mod_enum)conv->length_mod;\n\n\t\t/* Extract the value based on the argument category and length.\n\t\t *\n\t\t * Note that the length modifier doesn't affect the value of a\n\t\t * pointer argument.\n\t\t */\n\t\tif (specifier_cat == SPECIFIER_SINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->sint = va_arg(ap, int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif (WCHAR_IS_SIGNED\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->sint = va_arg(ap, long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\t/* Though ssize_t is the signed equivalent of\n\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.\n\t\t\t\t * Assume that size_t and ptrdiff_t are the\n\t\t\t\t * unsigned and signed equivalents of each\n\t\t\t\t * other.  This can be checked in a platform\n\t\t\t\t * test.\n\t\t\t\t */\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->sint = (signed char)value->sint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->sint = (short)value->sint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_UINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->uint = va_arg(ap, unsigned int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif ((!WCHAR_IS_SIGNED)\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\tunsigned long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\t\t\tuintmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->uint = (unsigned char)value->uint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->uint = (unsigned short)value->uint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_FP) {\n\t\t\tif (length_mod == LENGTH_UPPER_L) {\n\t\t\t\tvalue->ldbl = va_arg(ap, long double);\n\t\t\t} else {\n\t\t\t\tvalue->dbl = va_arg(ap, double);\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_PTR) {\n\t\t\tvalue->ptr = va_arg(ap, void *);\n\t\t}\n\n\t\t/* We've now consumed all arguments related to this\n\t\t * specification.  If the conversion is invalid, or is\n\t\t * something we don't support, then output the original\n\t\t * specification and move on.\n\t\t */\n\t\tif (conv->invalid || conv->unsupported) {\n\t\t\tOUTS(sp, fp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do formatting, either into the buffer or\n\t\t * referencing external data.\n\t\t */\n\t\tswitch (conv->specifier) {\n\t\tcase '%':\n\t\t\tOUTC('%');\n\t\t\tbreak;\n\t\tcase 's': {\n\t\t\tbps = (const char *)value->ptr;\n\n\t\t\tsize_t len;\n\n\t\t\tif (precision >= 0) {\n\t\t\t\tlen = strnlen(bps, precision);\n\t\t\t} else {\n\t\t\t\tlen = strlen(bps);\n\t\t\t}\n\n\t\t\tbpe = bps + len;\n\t\t\tprecision = -1;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 'p':\n\t\t\t/* Implementation-defined: null is \"(nil)\", non-null\n\t\t\t * has 0x prefix followed by significant address hex\n\t\t\t * digits, no leading zeros.\n\t\t\t */\n\t\t\tif (value->ptr != NULL) {\n\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,\n\t\t\t\t\t\t  buf, bpe);\n\n\t\t\t\t/* Use 0x prefix */\n\t\t\t\tconv->altform_0c = true;\n\t\t\t\tconv->specifier = 'x';\n\n\t\t\t\tgoto prec_int_pad0;\n\t\t\t}\n\n\t\t\tbps = \"(nil)\";\n\t\t\tbpe = bps + 5;\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tbps = buf;\n\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;\n\t\t\tbpe = buf + 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tif (conv->flag_plus) {\n\t\t\t\tsign = '+';\n\t\t\t} else if (conv->flag_space) {\n\t\t\t\tsign = ' ';\n\t\t\t}\n\n\t\t\t/* sint/uint overlay in the union, and so\n\t\t\t * can't appear in read and write operations\n\t\t\t * in the same statement.\n\t\t\t */\n\t\t\tsint = value->sint;\n\t\t\tif (sint < 0) {\n\t\t\t\tsign = '-';\n\t\t\t\tvalue->uint = (uint_value_type)-sint;\n\t\t\t} else {\n\t\t\t\tvalue->uint = (uint_value_type)sint;\n\t\t\t}\n\n\t\t\t__fallthrough;\n\t\tcase 'o':\n\t\tcase 'u':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);\n\n\t\tprec_int_pad0:\n\t\t\t/* Update pad0 values based on precision and converted\n\t\t\t * length.  Note that a non-empty sign is not in the\n\t\t\t * converted sequence, but it does not affect the\n\t\t\t * padding size.\n\t\t\t */\n\t\t\tif (precision >= 0) {\n\t\t\t\tsize_t len = bpe - bps;\n\n\t\t\t\t/* Zero-padding flag is ignored for integer\n\t\t\t\t * conversions with precision.\n\t\t\t\t */\n\t\t\t\tconv->flag_zero = false;\n\n\t\t\t\t/* Set pad0_value to satisfy precision */\n\t\t\t\tif (len < (size_t)precision) {\n\t\t\t\t\tconv->pad0_value = precision - (int)len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {\n\t\t\t\tstore_count(conv, value->ptr, count);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FP_CONV_CASES:\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {\n\t\t\t\tbps = encode_float(value->dbl, conv, precision,\n\t\t\t\t\t\t   &sign, buf, &bpe);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Add an empty default with break, this is a defensive\n\t\t\t * programming. Static analysis tool won't raise a violation\n\t\t\t * if default is empty, but has that comment.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If we don't have a converted value to emit, move\n\t\t * on.\n\t\t */\n\t\tif (bps == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The converted value is now stored in [bps, bpe), excluding\n\t\t * any required zero padding.\n\t\t *\n\t\t * The unjustified output will be:\n\t\t *\n\t\t * * any sign character (sint-only)\n\t\t * * any altform prefix\n\t\t * * for FP:\n\t\t *   * any pre-decimal content from the converted value\n\t\t *   * any pad0_value padding (!postdp)\n\t\t *   * any decimal point in the converted value\n\t\t *   * any pad0_value padding (postdp)\n\t\t *   * any pre-exponent content from the converted value\n\t\t *   * any pad0_pre_exp padding\n\t\t *   * any exponent content from the converted value\n\t\t * * for non-FP:\n\t\t *   * any pad0_prefix\n\t\t *   * the converted value\n\t\t */\n\t\tsize_t nj_len = (bpe - bps);\n\t\tint pad_len = 0;\n\n\t\tif (sign != 0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tif (conv->altform_0c) {\n\t\t\tnj_len += 2U;\n\t\t} else if (conv->altform_0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tnj_len += conv->pad0_value;\n\t\tif (conv->pad_fp) {\n\t\t\tnj_len += conv->pad0_pre_exp;\n\t\t}\n\n\t\t/* If we have a width update width to hold the padding we need\n\t\t * for justification.  The result may be negative, which will\n\t\t * result in no padding.\n\t\t *\n\t\t * If a non-negative padding width is present and we're doing\n\t\t * right-justification, emit the padding now.\n\t\t */\n\t\tif (width > 0) {\n\t\t\twidth -= (int)nj_len;\n\n\t\t\tif (!conv->flag_dash) {\n\t\t\t\tchar pad = ' ';\n\n\t\t\t\t/* If we're zero-padding we have to emit the\n\t\t\t\t * sign first.\n\t\t\t\t */\n\t\t\t\tif (conv->flag_zero) {\n\t\t\t\t\tif (sign != 0) {\n\t\t\t\t\t\tOUTC(sign);\n\t\t\t\t\t\tsign = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpad = '0';\n\t\t\t\t}\n\n\t\t\t\twhile (width-- > 0) {\n\t\t\t\t\tOUTC(pad);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have a sign that hasn't been emitted, now's the\n\t\t * time....\n\t\t */\n\t\tif (sign != 0) {\n\t\t\tOUTC(sign);\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {\n\t\t\tconst char *cp = bps;\n\n\t\t\tif (conv->specifier_a) {\n\t\t\t\t/* Only padding is pre_exp */\n\t\t\t\twhile (*cp != 'p') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\n\t\t\t\tpad_len = conv->pad0_value;\n\t\t\t\tif (!conv->pad_postdp) {\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*cp == '.') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t\t/* Remaining padding is\n\t\t\t\t\t * post-dp.\n\t\t\t\t\t */\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_pre_exp;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(cp, bpe);\n\t\t} else {\n\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tif (conv->altform_0c) {\n\t\t\t\tOUTC(conv->specifier);\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_value;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(bps, bpe);\n\t\t}\n\n\t\t/* Finish left justification */\n\t\twhile (width > 0) {\n\t\t\tOUTC(' ');\n\t\t\t--width;\n\t\t}\n\t}\n\n\treturn count;\n#undef OUTS\n#undef OUTC\n}\n",
                {
                    "1369": "int z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,",
                    "1370": "\t\t     va_list ap, uint32_t flags)",
                    "1371": "{",
                    "1372": "\tchar buf[CONVERTED_BUFLEN];",
                    "1373": "\tsize_t count = 0;",
                    "1374": "\tsint_value_type sint;",
                    "1375": "\tcbprintf_cb_local out = __out;",
                    "1376": "",
                    "1377": "\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)",
                    "1378": "\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;",
                    "1379": "",
                    "1380": "/* Output character, returning EOF if output failed, otherwise",
                    "1381": " * updating count.",
                    "1382": " *",
                    "1383": " * NB: c is evaluated exactly once: side-effects are OK",
                    "1384": " */",
                    "1385": "#define OUTC(c) do { \\",
                    "1386": "\tint rc = (*out)((int)(c), ctx); \\",
                    "1387": "\t\\",
                    "1388": "\tif (rc < 0) { \\",
                    "1389": "\t\treturn rc; \\",
                    "1390": "\t} \\",
                    "1391": "\t++count; \\",
                    "1392": "} while (false)",
                    "1393": "",
                    "1394": "/* Output sequence of characters, returning a negative error if output",
                    "1395": " * failed.",
                    "1396": " */",
                    "1397": "",
                    "1398": "#define OUTS(_sp, _ep) do { \\",
                    "1399": "\tint rc = outs(out, ctx, (_sp), (_ep)); \\",
                    "1400": "\t\\",
                    "1401": "\tif (rc < 0) {\t    \\",
                    "1402": "\t\treturn rc; \\",
                    "1403": "\t} \\",
                    "1404": "\tcount += rc; \\",
                    "1405": "} while (false)",
                    "1406": "",
                    "1407": "\twhile (*fp != 0) {",
                    "1408": "\t\tif (*fp != '%') {",
                    "1409": "\t\t\tOUTC(*fp);",
                    "1410": "\t\t\t++fp;",
                    "1411": "\t\t\tcontinue;",
                    "1412": "\t\t}",
                    "1413": "",
                    "1414": "\t\t/* Force union into RAM with conversion state to",
                    "1415": "\t\t * mitigate LLVM code generation bug.",
                    "1416": "\t\t */",
                    "1417": "\t\tstruct {",
                    "1418": "\t\t\tunion argument_value value;",
                    "1419": "\t\t\tstruct conversion conv;",
                    "1420": "\t\t} state = {",
                    "1421": "\t\t\t.value = {",
                    "1422": "\t\t\t\t.uint = 0,",
                    "1423": "\t\t\t},",
                    "1424": "\t\t};",
                    "1425": "\t\tstruct conversion *const conv = &state.conv;",
                    "1426": "\t\tunion argument_value *const value = &state.value;",
                    "1427": "\t\tconst char *sp = fp;",
                    "1428": "\t\tint width = -1;",
                    "1429": "\t\tint precision = -1;",
                    "1430": "\t\tconst char *bps = NULL;",
                    "1431": "\t\tconst char *bpe = buf + sizeof(buf);",
                    "1432": "\t\tchar sign = 0;",
                    "1433": "",
                    "1434": "\t\tfp = extract_conversion(conv, sp);",
                    "1435": "",
                    "1436": "\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {",
                    "1437": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)",
                    "1438": "\t\t\t    && tagged_ap) {",
                    "1439": "\t\t\t\t/* Skip over the argument tag as it is not being",
                    "1440": "\t\t\t\t * used here.",
                    "1441": "\t\t\t\t */",
                    "1442": "\t\t\t\t(void)va_arg(ap, int);",
                    "1443": "\t\t\t}",
                    "1444": "\t\t}",
                    "1445": "",
                    "1446": "\t\t/* If dynamic width is specified, process it,",
                    "1447": "\t\t * otherwise set width if present.",
                    "1448": "\t\t */",
                    "1449": "\t\tif (conv->width_star) {",
                    "1450": "\t\t\twidth = va_arg(ap, int);",
                    "1451": "",
                    "1452": "\t\t\tif (width < 0) {",
                    "1453": "\t\t\t\tconv->flag_dash = true;",
                    "1454": "\t\t\t\twidth = -width;",
                    "1455": "\t\t\t}",
                    "1456": "\t\t} else if (conv->width_present) {",
                    "1457": "\t\t\twidth = conv->width_value;",
                    "1458": "\t\t} else {",
                    "1459": "\t\t\t;",
                    "1460": "\t\t}",
                    "1461": "",
                    "1462": "\t\t/* If dynamic precision is specified, process it, otherwise",
                    "1463": "\t\t * set precision if present.  For floating point where",
                    "1464": "\t\t * precision is not present use 6.",
                    "1465": "\t\t */",
                    "1466": "\t\tif (conv->prec_star) {",
                    "1467": "\t\t\tint arg = va_arg(ap, int);",
                    "1468": "",
                    "1469": "\t\t\tif (arg < 0) {",
                    "1470": "\t\t\t\tconv->prec_present = false;",
                    "1471": "\t\t\t} else {",
                    "1472": "\t\t\t\tprecision = arg;",
                    "1473": "\t\t\t}",
                    "1474": "\t\t} else if (conv->prec_present) {",
                    "1475": "\t\t\tprecision = conv->prec_value;",
                    "1476": "\t\t} else {",
                    "1477": "\t\t\t;",
                    "1478": "\t\t}",
                    "1479": "",
                    "1480": "\t\t/* Reuse width and precision memory in conv for value",
                    "1481": "\t\t * padding counts.",
                    "1482": "\t\t */",
                    "1483": "\t\tconv->pad0_value = 0;",
                    "1484": "\t\tconv->pad0_pre_exp = 0;",
                    "1485": "",
                    "1486": "\t\t/* FP conversion requires knowing the precision. */",
                    "1487": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)",
                    "1488": "\t\t    && (conv->specifier_cat == SPECIFIER_FP)",
                    "1489": "\t\t    && !conv->prec_present) {",
                    "1490": "\t\t\tif (conv->specifier_a) {",
                    "1491": "\t\t\t\tprecision = FRACTION_HEX;",
                    "1492": "\t\t\t} else {",
                    "1493": "\t\t\t\tprecision = 6;",
                    "1494": "\t\t\t}",
                    "1495": "\t\t}",
                    "1496": "",
                    "1497": "\t\t/* Get the value to be converted from the args.",
                    "1498": "\t\t *",
                    "1499": "\t\t * This can't be extracted to a helper function because",
                    "1500": "\t\t * passing a pointer to va_list doesn't work on x86_64.  See",
                    "1501": "\t\t * https://stackoverflow.com/a/8048892.",
                    "1502": "\t\t */",
                    "1503": "\t\tenum specifier_cat_enum specifier_cat",
                    "1504": "\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;",
                    "1505": "\t\tenum length_mod_enum length_mod",
                    "1506": "\t\t\t= (enum length_mod_enum)conv->length_mod;",
                    "1507": "",
                    "1508": "\t\t/* Extract the value based on the argument category and length.",
                    "1509": "\t\t *",
                    "1510": "\t\t * Note that the length modifier doesn't affect the value of a",
                    "1511": "\t\t * pointer argument.",
                    "1512": "\t\t */",
                    "1513": "\t\tif (specifier_cat == SPECIFIER_SINT) {",
                    "1514": "\t\t\tswitch (length_mod) {",
                    "1515": "\t\t\tdefault:",
                    "1516": "\t\t\tcase LENGTH_NONE:",
                    "1517": "\t\t\tcase LENGTH_HH:",
                    "1518": "\t\t\tcase LENGTH_H:",
                    "1519": "\t\t\t\tvalue->sint = va_arg(ap, int);",
                    "1520": "\t\t\t\tbreak;",
                    "1521": "\t\t\tcase LENGTH_L:",
                    "1522": "\t\t\t\tif (WCHAR_IS_SIGNED",
                    "1523": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1524": "\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,",
                    "1525": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1526": "\t\t\t\t} else {",
                    "1527": "\t\t\t\t\tvalue->sint = va_arg(ap, long);",
                    "1528": "\t\t\t\t}",
                    "1529": "\t\t\t\tbreak;",
                    "1530": "\t\t\tcase LENGTH_LL:",
                    "1531": "\t\t\t\tvalue->sint =",
                    "1532": "\t\t\t\t\t(sint_value_type)va_arg(ap, long long);",
                    "1533": "\t\t\t\tbreak;",
                    "1534": "\t\t\tcase LENGTH_J:",
                    "1535": "\t\t\t\tvalue->sint =",
                    "1536": "\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);",
                    "1537": "\t\t\t\tbreak;",
                    "1538": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1539": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1540": "\t\t\t\t/* Though ssize_t is the signed equivalent of",
                    "1541": "\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.",
                    "1542": "\t\t\t\t * Assume that size_t and ptrdiff_t are the",
                    "1543": "\t\t\t\t * unsigned and signed equivalents of each",
                    "1544": "\t\t\t\t * other.  This can be checked in a platform",
                    "1545": "\t\t\t\t * test.",
                    "1546": "\t\t\t\t */",
                    "1547": "\t\t\t\tvalue->sint =",
                    "1548": "\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);",
                    "1549": "\t\t\t\tbreak;",
                    "1550": "\t\t\t}",
                    "1551": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1552": "\t\t\t\tvalue->sint = (signed char)value->sint;",
                    "1553": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1554": "\t\t\t\tvalue->sint = (short)value->sint;",
                    "1555": "\t\t\t}",
                    "1556": "\t\t} else if (specifier_cat == SPECIFIER_UINT) {",
                    "1557": "\t\t\tswitch (length_mod) {",
                    "1558": "\t\t\tdefault:",
                    "1559": "\t\t\tcase LENGTH_NONE:",
                    "1560": "\t\t\tcase LENGTH_HH:",
                    "1561": "\t\t\tcase LENGTH_H:",
                    "1562": "\t\t\t\tvalue->uint = va_arg(ap, unsigned int);",
                    "1563": "\t\t\t\tbreak;",
                    "1564": "\t\t\tcase LENGTH_L:",
                    "1565": "\t\t\t\tif ((!WCHAR_IS_SIGNED)",
                    "1566": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1567": "\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,",
                    "1568": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1569": "\t\t\t\t} else {",
                    "1570": "\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);",
                    "1571": "\t\t\t\t}",
                    "1572": "\t\t\t\tbreak;",
                    "1573": "\t\t\tcase LENGTH_LL:",
                    "1574": "\t\t\t\tvalue->uint =",
                    "1575": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1576": "\t\t\t\t\t\tunsigned long long);",
                    "1577": "\t\t\t\tbreak;",
                    "1578": "\t\t\tcase LENGTH_J:",
                    "1579": "\t\t\t\tvalue->uint =",
                    "1580": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1581": "\t\t\t\t\t\t\t\tuintmax_t);",
                    "1582": "\t\t\t\tbreak;",
                    "1583": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1584": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1585": "\t\t\t\tvalue->uint =",
                    "1586": "\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);",
                    "1587": "\t\t\t\tbreak;",
                    "1588": "\t\t\t}",
                    "1589": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1590": "\t\t\t\tvalue->uint = (unsigned char)value->uint;",
                    "1591": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1592": "\t\t\t\tvalue->uint = (unsigned short)value->uint;",
                    "1593": "\t\t\t}",
                    "1594": "\t\t} else if (specifier_cat == SPECIFIER_FP) {",
                    "1595": "\t\t\tif (length_mod == LENGTH_UPPER_L) {",
                    "1596": "\t\t\t\tvalue->ldbl = va_arg(ap, long double);",
                    "1597": "\t\t\t} else {",
                    "1598": "\t\t\t\tvalue->dbl = va_arg(ap, double);",
                    "1599": "\t\t\t}",
                    "1600": "\t\t} else if (specifier_cat == SPECIFIER_PTR) {",
                    "1601": "\t\t\tvalue->ptr = va_arg(ap, void *);",
                    "1602": "\t\t}",
                    "1603": "",
                    "1604": "\t\t/* We've now consumed all arguments related to this",
                    "1605": "\t\t * specification.  If the conversion is invalid, or is",
                    "1606": "\t\t * something we don't support, then output the original",
                    "1607": "\t\t * specification and move on.",
                    "1608": "\t\t */",
                    "1609": "\t\tif (conv->invalid || conv->unsupported) {",
                    "1610": "\t\t\tOUTS(sp, fp);",
                    "1611": "\t\t\tcontinue;",
                    "1612": "\t\t}",
                    "1613": "",
                    "1614": "\t\t/* Do formatting, either into the buffer or",
                    "1615": "\t\t * referencing external data.",
                    "1616": "\t\t */",
                    "1617": "\t\tswitch (conv->specifier) {",
                    "1618": "\t\tcase '%':",
                    "1619": "\t\t\tOUTC('%');",
                    "1620": "\t\t\tbreak;",
                    "1621": "\t\tcase 's': {",
                    "1622": "\t\t\tbps = (const char *)value->ptr;",
                    "1623": "",
                    "1624": "\t\t\tsize_t len;",
                    "1625": "",
                    "1626": "\t\t\tif (precision >= 0) {",
                    "1627": "\t\t\t\tlen = strnlen(bps, precision);",
                    "1628": "\t\t\t} else {",
                    "1629": "\t\t\t\tlen = strlen(bps);",
                    "1630": "\t\t\t}",
                    "1631": "",
                    "1632": "\t\t\tbpe = bps + len;",
                    "1633": "\t\t\tprecision = -1;",
                    "1634": "",
                    "1635": "\t\t\tbreak;",
                    "1636": "\t\t}",
                    "1637": "\t\tcase 'p':",
                    "1638": "\t\t\t/* Implementation-defined: null is \"(nil)\", non-null",
                    "1639": "\t\t\t * has 0x prefix followed by significant address hex",
                    "1640": "\t\t\t * digits, no leading zeros.",
                    "1641": "\t\t\t */",
                    "1642": "\t\t\tif (value->ptr != NULL) {",
                    "1643": "\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,",
                    "1644": "\t\t\t\t\t\t  buf, bpe);",
                    "1645": "",
                    "1646": "\t\t\t\t/* Use 0x prefix */",
                    "1647": "\t\t\t\tconv->altform_0c = true;",
                    "1648": "\t\t\t\tconv->specifier = 'x';",
                    "1649": "",
                    "1650": "\t\t\t\tgoto prec_int_pad0;",
                    "1651": "\t\t\t}",
                    "1652": "",
                    "1653": "\t\t\tbps = \"(nil)\";",
                    "1654": "\t\t\tbpe = bps + 5;",
                    "1655": "",
                    "1656": "\t\t\tbreak;",
                    "1657": "\t\tcase 'c':",
                    "1658": "\t\t\tbps = buf;",
                    "1659": "\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;",
                    "1660": "\t\t\tbpe = buf + 1;",
                    "1661": "\t\t\tbreak;",
                    "1662": "\t\tcase 'd':",
                    "1663": "\t\tcase 'i':",
                    "1664": "\t\t\tif (conv->flag_plus) {",
                    "1665": "\t\t\t\tsign = '+';",
                    "1666": "\t\t\t} else if (conv->flag_space) {",
                    "1667": "\t\t\t\tsign = ' ';",
                    "1668": "\t\t\t}",
                    "1669": "",
                    "1670": "\t\t\t/* sint/uint overlay in the union, and so",
                    "1671": "\t\t\t * can't appear in read and write operations",
                    "1672": "\t\t\t * in the same statement.",
                    "1673": "\t\t\t */",
                    "1674": "\t\t\tsint = value->sint;",
                    "1675": "\t\t\tif (sint < 0) {",
                    "1676": "\t\t\t\tsign = '-';",
                    "1677": "\t\t\t\tvalue->uint = (uint_value_type)-sint;",
                    "1678": "\t\t\t} else {",
                    "1679": "\t\t\t\tvalue->uint = (uint_value_type)sint;",
                    "1680": "\t\t\t}",
                    "1681": "",
                    "1682": "\t\t\t__fallthrough;",
                    "1683": "\t\tcase 'o':",
                    "1684": "\t\tcase 'u':",
                    "1685": "\t\tcase 'x':",
                    "1686": "\t\tcase 'X':",
                    "1687": "\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);",
                    "1688": "",
                    "1689": "\t\tprec_int_pad0:",
                    "1690": "\t\t\t/* Update pad0 values based on precision and converted",
                    "1691": "\t\t\t * length.  Note that a non-empty sign is not in the",
                    "1692": "\t\t\t * converted sequence, but it does not affect the",
                    "1693": "\t\t\t * padding size.",
                    "1694": "\t\t\t */",
                    "1695": "\t\t\tif (precision >= 0) {",
                    "1696": "\t\t\t\tsize_t len = bpe - bps;",
                    "1697": "",
                    "1698": "\t\t\t\t/* Zero-padding flag is ignored for integer",
                    "1699": "\t\t\t\t * conversions with precision.",
                    "1700": "\t\t\t\t */",
                    "1701": "\t\t\t\tconv->flag_zero = false;",
                    "1702": "",
                    "1703": "\t\t\t\t/* Set pad0_value to satisfy precision */",
                    "1704": "\t\t\t\tif (len < (size_t)precision) {",
                    "1705": "\t\t\t\t\tconv->pad0_value = precision - (int)len;",
                    "1706": "\t\t\t\t}",
                    "1707": "\t\t\t}",
                    "1708": "",
                    "1709": "\t\t\tbreak;",
                    "1710": "\t\tcase 'n':",
                    "1711": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {",
                    "1712": "\t\t\t\tstore_count(conv, value->ptr, count);",
                    "1713": "\t\t\t}",
                    "1714": "",
                    "1715": "\t\t\tbreak;",
                    "1716": "",
                    "1717": "\t\tcase FP_CONV_CASES:",
                    "1718": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {",
                    "1719": "\t\t\t\tbps = encode_float(value->dbl, conv, precision,",
                    "1720": "\t\t\t\t\t\t   &sign, buf, &bpe);",
                    "1721": "\t\t\t}",
                    "1722": "\t\t\tbreak;",
                    "1723": "\t\tdefault:",
                    "1724": "\t\t\t/* Add an empty default with break, this is a defensive",
                    "1725": "\t\t\t * programming. Static analysis tool won't raise a violation",
                    "1726": "\t\t\t * if default is empty, but has that comment.",
                    "1727": "\t\t\t */",
                    "1728": "\t\t\tbreak;",
                    "1729": "\t\t}",
                    "1730": "",
                    "1731": "\t\t/* If we don't have a converted value to emit, move",
                    "1732": "\t\t * on.",
                    "1733": "\t\t */",
                    "1734": "\t\tif (bps == NULL) {",
                    "1735": "\t\t\tcontinue;",
                    "1736": "\t\t}",
                    "1737": "",
                    "1738": "\t\t/* The converted value is now stored in [bps, bpe), excluding",
                    "1739": "\t\t * any required zero padding.",
                    "1740": "\t\t *",
                    "1741": "\t\t * The unjustified output will be:",
                    "1742": "\t\t *",
                    "1743": "\t\t * * any sign character (sint-only)",
                    "1744": "\t\t * * any altform prefix",
                    "1745": "\t\t * * for FP:",
                    "1746": "\t\t *   * any pre-decimal content from the converted value",
                    "1747": "\t\t *   * any pad0_value padding (!postdp)",
                    "1748": "\t\t *   * any decimal point in the converted value",
                    "1749": "\t\t *   * any pad0_value padding (postdp)",
                    "1750": "\t\t *   * any pre-exponent content from the converted value",
                    "1751": "\t\t *   * any pad0_pre_exp padding",
                    "1752": "\t\t *   * any exponent content from the converted value",
                    "1753": "\t\t * * for non-FP:",
                    "1754": "\t\t *   * any pad0_prefix",
                    "1755": "\t\t *   * the converted value",
                    "1756": "\t\t */",
                    "1757": "\t\tsize_t nj_len = (bpe - bps);",
                    "1758": "\t\tint pad_len = 0;",
                    "1759": "",
                    "1760": "\t\tif (sign != 0) {",
                    "1761": "\t\t\tnj_len += 1U;",
                    "1762": "\t\t}",
                    "1763": "",
                    "1764": "\t\tif (conv->altform_0c) {",
                    "1765": "\t\t\tnj_len += 2U;",
                    "1766": "\t\t} else if (conv->altform_0) {",
                    "1767": "\t\t\tnj_len += 1U;",
                    "1768": "\t\t}",
                    "1769": "",
                    "1770": "\t\tnj_len += conv->pad0_value;",
                    "1771": "\t\tif (conv->pad_fp) {",
                    "1772": "\t\t\tnj_len += conv->pad0_pre_exp;",
                    "1773": "\t\t}",
                    "1774": "",
                    "1775": "\t\t/* If we have a width update width to hold the padding we need",
                    "1776": "\t\t * for justification.  The result may be negative, which will",
                    "1777": "\t\t * result in no padding.",
                    "1778": "\t\t *",
                    "1779": "\t\t * If a non-negative padding width is present and we're doing",
                    "1780": "\t\t * right-justification, emit the padding now.",
                    "1781": "\t\t */",
                    "1782": "\t\tif (width > 0) {",
                    "1783": "\t\t\twidth -= (int)nj_len;",
                    "1784": "",
                    "1785": "\t\t\tif (!conv->flag_dash) {",
                    "1786": "\t\t\t\tchar pad = ' ';",
                    "1787": "",
                    "1788": "\t\t\t\t/* If we're zero-padding we have to emit the",
                    "1789": "\t\t\t\t * sign first.",
                    "1790": "\t\t\t\t */",
                    "1791": "\t\t\t\tif (conv->flag_zero) {",
                    "1792": "\t\t\t\t\tif (sign != 0) {",
                    "1793": "\t\t\t\t\t\tOUTC(sign);",
                    "1794": "\t\t\t\t\t\tsign = 0;",
                    "1795": "\t\t\t\t\t}",
                    "1796": "\t\t\t\t\tpad = '0';",
                    "1797": "\t\t\t\t}",
                    "1798": "",
                    "1799": "\t\t\t\twhile (width-- > 0) {",
                    "1800": "\t\t\t\t\tOUTC(pad);",
                    "1801": "\t\t\t\t}",
                    "1802": "\t\t\t}",
                    "1803": "\t\t}",
                    "1804": "",
                    "1805": "\t\t/* If we have a sign that hasn't been emitted, now's the",
                    "1806": "\t\t * time....",
                    "1807": "\t\t */",
                    "1808": "\t\tif (sign != 0) {",
                    "1809": "\t\t\tOUTC(sign);",
                    "1810": "\t\t}",
                    "1811": "",
                    "1812": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {",
                    "1813": "\t\t\tconst char *cp = bps;",
                    "1814": "",
                    "1815": "\t\t\tif (conv->specifier_a) {",
                    "1816": "\t\t\t\t/* Only padding is pre_exp */",
                    "1817": "\t\t\t\twhile (*cp != 'p') {",
                    "1818": "\t\t\t\t\tOUTC(*cp);",
                    "1819": "\t\t\t\t\t++cp;",
                    "1820": "\t\t\t\t}",
                    "1821": "\t\t\t} else {",
                    "1822": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1823": "\t\t\t\t\tOUTC(*cp);",
                    "1824": "\t\t\t\t\t++cp;",
                    "1825": "\t\t\t\t}",
                    "1826": "",
                    "1827": "\t\t\t\tpad_len = conv->pad0_value;",
                    "1828": "\t\t\t\tif (!conv->pad_postdp) {",
                    "1829": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1830": "\t\t\t\t\t\tOUTC('0');",
                    "1831": "\t\t\t\t\t}",
                    "1832": "\t\t\t\t}",
                    "1833": "",
                    "1834": "\t\t\t\tif (*cp == '.') {",
                    "1835": "\t\t\t\t\tOUTC(*cp);",
                    "1836": "\t\t\t\t\t++cp;",
                    "1837": "\t\t\t\t\t/* Remaining padding is",
                    "1838": "\t\t\t\t\t * post-dp.",
                    "1839": "\t\t\t\t\t */",
                    "1840": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1841": "\t\t\t\t\t\tOUTC('0');",
                    "1842": "\t\t\t\t\t}",
                    "1843": "\t\t\t\t}",
                    "1844": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1845": "\t\t\t\t\tOUTC(*cp);",
                    "1846": "\t\t\t\t\t++cp;",
                    "1847": "\t\t\t\t}",
                    "1848": "\t\t\t}",
                    "1849": "",
                    "1850": "\t\t\tpad_len = conv->pad0_pre_exp;",
                    "1851": "\t\t\twhile (pad_len-- > 0) {",
                    "1852": "\t\t\t\tOUTC('0');",
                    "1853": "\t\t\t}",
                    "1854": "",
                    "1855": "\t\t\tOUTS(cp, bpe);",
                    "1856": "\t\t} else {",
                    "1857": "\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {",
                    "1858": "\t\t\t\tOUTC('0');",
                    "1859": "\t\t\t}",
                    "1860": "",
                    "1861": "\t\t\tif (conv->altform_0c) {",
                    "1862": "\t\t\t\tOUTC(conv->specifier);",
                    "1863": "\t\t\t}",
                    "1864": "",
                    "1865": "\t\t\tpad_len = conv->pad0_value;",
                    "1866": "\t\t\twhile (pad_len-- > 0) {",
                    "1867": "\t\t\t\tOUTC('0');",
                    "1868": "\t\t\t}",
                    "1869": "",
                    "1870": "\t\t\tOUTS(bps, bpe);",
                    "1871": "\t\t}",
                    "1872": "",
                    "1873": "\t\t/* Finish left justification */",
                    "1874": "\t\twhile (width > 0) {",
                    "1875": "\t\t\tOUTC(' ');",
                    "1876": "\t\t\t--width;",
                    "1877": "\t\t}",
                    "1878": "\t}",
                    "1879": "",
                    "1880": "\treturn count;",
                    "1881": "#undef OUTS",
                    "1882": "#undef OUTC",
                    "1883": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "encode_uint": {
            "name": "encode_uint",
            "file_path": "/home/chenkaiqiu/zephyr/lib/os/cbprintf_complete.c",
            "location_line": 790,
            "function_content": [
                "/* Writes the given value into the buffer in the specified base.\n*\n* Precision is applied *ONLY* within the space allowed.\n*\n* Alternate form value is applied to o, x, and X conversions.\n*\n* The buffer is filled backwards, so the input bpe is the end of the\n* generated representation.  The returned pointer is to the first\n* character of the representation.\n*/\nstatic char *encode_uint(uint_value_type value,\n\t\t\t struct conversion *conv,\n\t\t\t char *bps,\n\t\t\t const char *bpe)\n{\n\tbool upcase = isupper((int)conv->specifier) != 0;\n\tconst unsigned int radix = conversion_radix(conv->specifier);\n\tchar *bp = bps + (bpe - bps);\n\n\tdo {\n\t\tunsigned int lsv = (unsigned int)(value % radix);\n\n\t\t--bp;\n\t\t*bp = (lsv <= 9) ? ('0' + lsv)\n\t\t\t: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);\n\t\tvalue /= radix;\n\t} while ((value != 0) && (bps < bp));\n\n\t/* Record required alternate forms.  This can be determined\n\t * from the radix without re-checking specifier.\n\t */\n\tif (conv->flag_hash) {\n\t\tif (radix == 8) {\n\t\t\tconv->altform_0 = true;\n\t\t} else if (radix == 16) {\n\t\t\tconv->altform_0c = true;\n\t\t} else {\n\t\t\t;\n\t\t}\n\t}\n\n\treturn bp;\n}\n",
                {
                    "790": "static char *encode_uint(uint_value_type value,",
                    "791": "\t\t\t struct conversion *conv,",
                    "792": "\t\t\t char *bps,",
                    "793": "\t\t\t const char *bpe)",
                    "794": "{",
                    "795": "\tbool upcase = isupper((int)conv->specifier) != 0;",
                    "796": "\tconst unsigned int radix = conversion_radix(conv->specifier);",
                    "797": "\tchar *bp = bps + (bpe - bps);",
                    "798": "",
                    "799": "\tdo {",
                    "800": "\t\tunsigned int lsv = (unsigned int)(value % radix);",
                    "801": "",
                    "802": "\t\t--bp;",
                    "803": "\t\t*bp = (lsv <= 9) ? ('0' + lsv)",
                    "804": "\t\t\t: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);",
                    "805": "\t\tvalue /= radix;",
                    "806": "\t} while ((value != 0) && (bps < bp));",
                    "807": "",
                    "808": "\t/* Record required alternate forms.  This can be determined",
                    "809": "\t * from the radix without re-checking specifier.",
                    "810": "\t */",
                    "811": "\tif (conv->flag_hash) {",
                    "812": "\t\tif (radix == 8) {",
                    "813": "\t\t\tconv->altform_0 = true;",
                    "814": "\t\t} else if (radix == 16) {",
                    "815": "\t\t\tconv->altform_0c = true;",
                    "816": "\t\t} else {",
                    "817": "\t\t\t;",
                    "818": "\t\t}",
                    "819": "\t}",
                    "820": "",
                    "821": "\treturn bp;",
                    "822": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "extract_decimal": {
            "name": "extract_decimal",
            "file_path": "/home/chenkaiqiu/zephyr/lib/os/cbprintf_complete.c",
            "location_line": 318,
            "function_content": [
                "/** Get a size represented as a sequence of decimal digits.\n*\n* @param[inout] str where to read from.  Updated to point to the first\n* unconsumed character.  There must be at least one non-digit character in\n* the referenced text.\n*\n* @return the decoded integer value.\n*/\nstatic size_t extract_decimal(const char **str)\n{\n\tconst char *sp = *str;\n\tsize_t val = 0;\n\n\twhile (isdigit((int)(unsigned char)*sp) != 0) {\n\t\tval = 10U * val + *sp++ - '0';\n\t}\n\t*str = sp;\n\treturn val;\n}\n",
                {
                    "318": "static size_t extract_decimal(const char **str)",
                    "319": "{",
                    "320": "\tconst char *sp = *str;",
                    "321": "\tsize_t val = 0;",
                    "322": "",
                    "323": "\twhile (isdigit((int)(unsigned char)*sp) != 0) {",
                    "324": "\t\tval = 10U * val + *sp++ - '0';",
                    "325": "\t}",
                    "326": "\t*str = sp;",
                    "327": "\treturn val;",
                    "328": "}"
                }
            ],
            "function_content_in_lines": {}
        }
    },
    "mmioinfo_interestingmmioexpr_dict": {},
    "mmioinfo_mmioexpr_dict": {},
    "mmioinfo_interestingmmiofunc_contains_dict": {}
}