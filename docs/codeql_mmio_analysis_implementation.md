# 基于静态分析的驱动信息获取方法实现机制汇报

## 一、项目背景与目标

本报告介绍的驱动函数接口静态分析与识别模块，是嵌入式固件安全分析平台的核心组成部分。该模块采用CodeQL静态分析和数据流追踪技术，实现了对嵌入式驱动程序中硬件访问模式的自动化识别与分类，为固件重托管、硬件抽象层仿真以及安全测试提供了关键的数据支撑。

算法的总体目标是通过静态分析技术，自动识别嵌入式固件源代码中与硬件交互相关的函数接口，包括直接寄存器访问、中断处理、DMA操作等，建立硬件依赖关系的完整映射。这种自动化分析能够大幅减少人工分析的工作量，提高分析的准确性和一致性。

## 二、整体设计思路

我们的整体设计思路是构建一个基于CodeQL的静态分析框架，通过定义专门的类和谓词来识别和分类嵌入式代码中的MMIO（内存映射I/O）操作。这个框架包含多个层次的分析能力，从底层的寄存器访问识别到上层的函数分类，形成完整的分析链条。

为了提高分析效率，我们采用了分层查询策略。底层查询专注于识别MMIO结构体和字段访问，中层查询通过数据流追踪技术分析MMIO数据的传播路径，上层查询则基于底层的识别结果进行函数分类和依赖关系分析。整个系统支持缓存机制，避免重复分析，大大提高了处理大规模代码库的效率。

## 三、MMIO结构体识别机制

MMIO结构体识别是整个静态分析的基础。在嵌入式系统中，硬件寄存器通常通过结构体进行抽象，每个结构体对应一个硬件外设，结构体的成员对应硬件寄存器。识别这些结构体是后续所有分析的前提。

我们设计了多种识别模式来覆盖不同的代码风格。第一种是MMIO直接访问模式，通过检测结构体指针被赋值为常量地址的情况来识别。例如，当代码中出现类似USART_TypeDef *usart = (USART_TypeDef *)0x40011000这样的赋值时，我们就可以识别出USART_TypeDef是一个MMIO结构体。

第二种是MMIO描述符注册模式，通过数据流追踪技术，从数组或配置表中追踪到结构体指针的初始化过程。这种模式适用于结构体指针通过配置表或数组间接初始化的情况，能够识别出更复杂的MMIO结构体使用模式。

第三种是非注册模式，直接将常量作为指针传入MMIO函数参数的模式。这种模式适用于函数调用中直接使用常量地址作为参数的情况，例如HAL_USART_Transmit((USART_TypeDef *)0x40011000, data, len)。

第四种是直接将常量作为指针指向对应的MMIO操作结构体的模式。这种模式适用于在字段访问表达式中直接使用常量地址的情况，例如((USART_TypeDef *)0x40011000)->DR = data。

通过这四种识别模式的组合，我们能够覆盖绝大多数嵌入式代码中的MMIO结构体使用场景，确保分析的完整性。

## 四、MMIO字段访问识别机制

识别出MMIO结构体后，下一步是识别对这些结构体字段的访问操作。MMIO字段访问是实际硬件寄存器读写操作的体现，是分析硬件依赖关系的关键。

我们定义了MMIOFieldAccess类来表示所有MMIO字段访问。这个类涵盖了多种访问模式。第一种是标准的指针字段访问模式，例如usart->DR，这种模式通过指针访问结构体成员。第二种是值字段访问模式，例如usart.DR，这种模式通过值访问结构体成员。第三种是嵌套字段访问模式，例如huart->Instance->DR，这种模式通过多层指针访问结构体成员。

除了这些标准模式外，我们还支持一些特殊的访问模式。例如，Ambiq微控制器的驱动代码使用BLEIFn(ui32Module)->CLKCFG这样的访问模式，其中字段访问的限定符是一个函数调用。我们还支持直接使用常量地址作为限定符的访问模式，例如((USART_TypeDef *)0x40011000)->DR。

通过识别这些MMIO字段访问，我们能够确定代码中哪些操作是实际的硬件寄存器读写，哪些是普通的软件操作。这种区分对于后续的函数分类和依赖分析至关重要。

## 五、数据流追踪机制

数据流追踪是静态分析的核心技术之一，它能够分析数据在程序中的传播路径。在我们的系统中，数据流追踪用于分析MMIO数据的传播，即从硬件寄存器读取的数据如何传播到软件变量，以及软件数据如何传播到硬件寄存器。

我们实现了两个数据流配置模块。MMIOFlowConfiguration模块专门用于追踪MMIO数据的流，它的源点是MMIO字段访问，汇点是非MMIO字段访问或函数参数。这个模块还定义了额外的流步骤，用于处理赋值操作中的数据传播。

GeneralFlowConfiguration模块是一个更通用的数据流配置，它的源点和汇点可以是任何表达式或参数。这个模块主要用于追踪一般的数据流，不限于MMIO操作。

通过数据流追踪，我们能够识别出MMIO数据的完整传播路径。例如，当从硬件寄存器读取数据后，这些数据可能经过一系列的赋值、转换、函数调用等操作，最终到达某个软件变量或函数参数。追踪这些路径对于理解代码的行为和识别潜在的硬件依赖非常重要。

## 六、MMIO函数识别机制

MMIO函数识别是静态分析的重要目标之一。MMIO函数是指包含MMIO操作的函数，这些函数直接或间接地与硬件交互。识别这些函数对于理解代码的硬件依赖关系至关重要。

我们定义了MMIOFunction类来表示所有MMIO函数。一个函数被认为是MMIO函数，如果它直接包含MMIO字段访问，或者它调用了内联函数或弱函数，而这些被调用的函数是MMIO函数。

这种递归定义能够处理复杂的函数调用关系。例如，一个函数可能不直接包含MMIO操作，但它调用了另一个包含MMIO操作的函数。通过递归分析，我们能够识别出所有与硬件交互的函数，无论这种交互是直接的还是间接的。

除了MMIO函数外，我们还定义了DriverFunction类来表示驱动函数。驱动函数是指访问驱动结构体但不直接访问MMIO结构体的函数。这些函数通常位于驱动层，介于应用层和硬件抽象层之间。

通过区分MMIO函数和驱动函数，我们能够建立清晰的函数层次结构，理解代码的架构和依赖关系。

## 七、MMIO表达式追踪机制

MMIO表达式追踪是数据流追踪的扩展，它不仅追踪数据的流，还追踪表达式本身的传播。我们定义了多种MMIO追踪表达式类来表示不同类型的追踪结果。

MMIODirectTracedExpr表示直接从MMIO字段访问追踪到的表达式。这种表达式表示存在一条从MMIO字段访问到该表达式的数据流路径。例如，当代码中出现uint32_t data = usart->DR时，data变量就是一个MMIODirectTracedExpr。

MMIODRTracedExpr表示数据寄存器追踪表达式。这种表达式表示存在一条从该表达式到某个MMIODirectTracedExpr的数据流路径。这种追踪用于分析数据如何从软件变量传播到硬件寄存器。

MMIOITTracedExpr表示中断追踪表达式，MMIODMATracedExpr表示DMA追踪表达式。这些专门的追踪类用于分析特定类型的硬件操作。

通过这些追踪表达式，我们能够建立完整的MMIO数据传播图，理解数据如何在硬件和软件之间流动。这种理解对于代码重构、硬件抽象层构建以及安全分析都非常重要。

## 八、查询收集机制

为了方便使用CodeQL分析结果，我们设计了多个查询收集器。这些查询收集器将CodeQL的查询结果转换为结构化的数据，便于后续的处理和分析。

info_mmio_function_collector查询收集器用于收集所有MMIO函数的基本信息，包括函数名称、文件路径、起始行号和结束行号。这个查询还过滤掉了内联函数和弱函数，因为这些函数通常不是实际执行的函数。

mmioinfo_mmioexpr_collector查询收集器用于收集所有MMIO字段访问的详细信息，包括表达式字符串、所属函数名称、文件路径、行号、表达式类型和封闭元素类型。这个查询提供了MMIO操作的详细视图。

mmioinfo_interestingmmioexpr_collector查询收集器用于收集所有有趣的MMIO表达式。有趣的MMIO表达式是指那些在有趣的MMIO函数中的MMIO表达式。这种查询能够过滤掉一些不重要的MMIO操作，专注于关键的操作。

mmioinfo_interestingmmiofunccontains_collector查询收集器用于收集有趣的MMIO函数中包含的数据结构类型信息。这个查询能够识别出MMIO函数中使用的结构体、枚举等类型，帮助理解函数的数据模型。

通过这些查询收集器，我们能够从CodeQL分析结果中提取出丰富的信息，为后续的分析和处理提供数据基础。

## 九、Python封装与缓存机制

为了方便使用CodeQL分析功能，我们设计了Python封装层。这个封装层提供了高级的API，隐藏了CodeQL的底层细节，使得用户能够方便地进行静态分析。

MmioCodebaseInfo类是封装层的核心类，它管理所有MMIO相关的信息。这个类包含多个字典，分别存储MMIO函数、驱动函数、缓冲函数、MMIO表达式等信息。这些字典以函数名称为键，以详细信息为值，提供了快速查找的能力。

封装层实现了完善的缓存机制。当分析一个代码库时，系统会首先检查是否存在缓存文件。如果缓存文件存在且数据完整，系统会直接从缓存加载数据，避免重复的CodeQL分析。如果缓存不存在或数据不完整，系统会执行完整的分析流程，并将结果保存到缓存中。

缓存机制大大提高了分析效率，特别是在开发过程中需要多次分析同一个代码库时。缓存文件以JSON格式存储，包含所有分析结果，便于版本控制和数据交换。

## 十、信息收集流程

信息收集流程是整个静态分析系统的执行流程。这个流程确保所有必要的信息都被收集，并且收集的顺序是正确的。

当调用collect_infos方法时，系统会首先检查缓存。如果不是强制刷新且缓存存在，系统会直接从缓存加载数据。否则，系统会按照预定义的顺序执行多个收集器。

收集器的执行顺序是精心设计的。首先收集MMIO函数信息，因为这些函数是分析的核心。然后收集驱动函数信息和缓冲函数信息，这些信息提供了函数的上下文。接着收集MMIO表达式信息，这些信息提供了详细的操作视图。最后收集MMIO函数包含信息，这些信息提供了数据模型信息。

每个收集器都包含在try-except块中，确保一个收集器的失败不会影响其他收集器的执行。这种设计提高了系统的健壮性，即使部分分析失败，系统仍然能够提供部分有用的结果。

## 十一、常量表达式识别机制

常量表达式识别是静态分析的重要辅助功能。在MMIO分析中，我们需要识别常量表达式，特别是大数值常量表达式，因为这些常量通常表示硬件地址。

我们定义了isConstantExpr谓词来识别常量表达式。一个表达式被认为是常量表达式，如果它是一个字面量，或者它是一个二元运算，且两个操作数都是常量表达式。这个定义能够识别复杂的常量表达式，例如0x40011000 + 0x100。

isConstantBigValueExpr谓词专门用于识别大数值常量表达式。大数值常量是指大于26843545640x10000000的常量。这个阈值的选择基于嵌入式系统中硬件地址的典型范围，大多数硬件寄存器地址都大于这个值。

isConstantZeroExpr谓词用于识别零常量表达式。零常量在MMIO分析中需要特殊处理，因为零地址通常不是有效的硬件地址。

通过这些常量表达式识别机制，我们能够准确地识别出硬件地址常量，这对于MMIO结构体识别和字段访问识别至关重要。

## 十二、缓冲区指针识别机制

缓冲区指针识别是静态分析的另一个重要功能。在MMIO分析中，我们需要区分MMIO指针和普通缓冲区指针，因为它们的用途和处理方式不同。

我们定义了isBufferPtrType谓词来识别缓冲区指针类型。一个类型被认为是缓冲区指针类型，如果它是指针类型，且它指向的类型不是结构体、指针、函数指针或枚举。这个定义确保了缓冲区指针是指向基本数据类型或数组的指针，而不是指向复杂结构的指针。

BufferPtrType类封装了这个谓词，提供了一个方便的类型检查接口。通过这个类，我们能够在查询中方便地检查一个表达式是否是缓冲区指针。

缓冲区指针识别对于理解代码的数据流非常重要。例如，当从硬件寄存器读取数据到缓冲区时，我们需要识别出缓冲区指针，以便正确地分析数据的传播路径。

## 十三、内联函数处理机制

内联函数处理是静态分析的一个挑战。在嵌入式代码中，很多函数被声明为内联函数或弱函数，这些函数在编译时会被展开或替换。如果直接分析这些函数，可能会得到不准确的结果。

我们定义了isInlineFunction谓词来识别内联函数。一个函数被认为是内联函数，如果它被声明为内联函数，或者它有weak属性，或者它有always_inline属性。这些属性通常用于函数的多态实现或编译器优化。

在MMIO函数识别中，我们特别处理内联函数。当一个函数调用内联函数时，我们会递归分析被调用的内联函数，看它是否是MMIO函数。这种递归分析确保了我们能够识别出通过内联函数间接进行的MMIO操作。

通过正确处理内联函数，我们能够避免漏掉通过内联函数进行的硬件操作，确保分析的完整性。

## 十四、字段访问比较机制

字段访问比较是数据流追踪的重要辅助功能。在追踪数据流时，我们需要判断两个字段访问是否表示同一个字段，以便正确地建立数据流路径。

我们定义了isSameFieldAccess谓词来比较两个字段访问是否相同。两个字段访问被认为是相同的，如果它们访问同一个字段，且它们不是同一个表达式。这个定义考虑了指针字段访问和值字段访问的等价性。

我们还定义了isSameArrayExpr谓词来比较两个数组表达式是否相同。这个谓词用于处理数组访问的比较，考虑了数组基址的比较和字段访问的比较。

isSameExpr谓词是一个通用的表达式比较谓词，它能够比较字段访问和数组表达式。这个谓词在数据流追踪中被广泛使用，用于建立数据流路径。

通过这些比较机制，我们能够准确地建立数据流路径，理解数据在程序中的传播。

## 十五、应用场景与价值

这套基于静态分析的驱动信息获取方法具有广泛的应用场景和重要的价值。

在固件安全分析方面，这套方法能够自动识别所有与硬件交互的函数，帮助安全分析人员理解固件的硬件依赖关系，识别潜在的安全漏洞。例如，通过分析MMIO操作，可以识别出未经验证的硬件输入，或者识别出可能被攻击的硬件接口。

在固件重托管方面，这套方法能够识别出所有需要替换的硬件依赖代码，为代码重写提供准确的指导。通过自动识别MMIO函数和驱动函数，可以大大减少人工分析的工作量，提高重托管的效率。

在硬件抽象层构建方面，这套方法能够分析现有驱动代码的硬件访问模式，为构建新的硬件抽象层提供参考。通过理解MMIO操作的类型和数据流，可以设计出更合理的抽象层接口。

在代码重构方面，这套方法能够识别出代码中的硬件依赖，帮助开发者理解代码的结构，进行有针对性的重构。例如，通过识别MMIO函数，可以确定哪些函数需要重构，哪些函数可以保持不变。

## 十六、总结

这套基于静态分析的驱动信息获取方法，通过CodeQL静态分析和数据流追踪技术，实现了对嵌入式驱动程序中硬件访问模式的自动化识别与分类。系统采用分层查询策略，从底层的寄存器访问识别到上层的函数分类，形成完整的分析链条。

系统的核心优势包括自动化程度高、分析准确、覆盖全面、性能优异、扩展性强等。通过这套方法，可以大大提高嵌入式固件分析的效率和准确性，减少人工分析的工作量，为固件安全分析、重托管、硬件抽象层构建等提供关键的数据支撑。

未来，我们将继续优化CodeQL查询的性能，扩展更多的硬件访问模式识别，支持更多的嵌入式平台和编译器特性。我们相信，这套方法将在嵌入式固件分析领域发挥越来越重要的作用。
