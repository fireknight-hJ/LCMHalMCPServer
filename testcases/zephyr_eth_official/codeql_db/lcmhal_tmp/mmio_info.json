{
    "mmio_functions": {
        "next": {
            "name": "next",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 48,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *next(struct _timeout *t)\n{\n\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);\n\n\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);\n}\n",
                {
                    "48": "static struct _timeout *next(struct _timeout *t)",
                    "49": "{",
                    "50": "\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);",
                    "51": "",
                    "52": "\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);",
                    "53": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_poll_signal_raise": {
            "name": "z_impl_k_poll_signal_raise",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 522,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)\n{\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tstruct k_poll_event *poll_event;\n\n\tsig->result = result;\n\tsig->signaled = 1U;\n\n\tpoll_event = (struct k_poll_event *)sys_dlist_get(&sig->poll_events);\n\tif (poll_event == NULL) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);\n\n\t\treturn 0;\n\t}\n\n\tint rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);\n\n\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);\n\n\tz_reschedule(&lock, key);\n\treturn rc;\n}\n",
                {
                    "522": "int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)",
                    "523": "{",
                    "524": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "525": "\tstruct k_poll_event *poll_event;",
                    "526": "",
                    "527": "\tsig->result = result;",
                    "528": "\tsig->signaled = 1U;",
                    "529": "",
                    "530": "\tpoll_event = (struct k_poll_event *)sys_dlist_get(&sig->poll_events);",
                    "531": "\tif (poll_event == NULL) {",
                    "532": "\t\tk_spin_unlock(&lock, key);",
                    "533": "",
                    "534": "\t\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);",
                    "535": "",
                    "536": "\t\treturn 0;",
                    "537": "\t}",
                    "538": "",
                    "539": "\tint rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);",
                    "540": "",
                    "541": "\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);",
                    "542": "",
                    "543": "\tz_reschedule(&lock, key);",
                    "544": "\treturn rc;",
                    "545": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_poll_signal_init": {
            "name": "z_impl_k_poll_signal_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 475,
            "function_content": [
                "/* Poller is not poll or triggered mode. No action needed.*/\nvoid z_impl_k_poll_signal_init(struct k_poll_signal *sig)\n{\n\tsys_dlist_init(&sig->poll_events);\n\tsig->signaled = 0U;\n\t/* signal->result is left uninitialized */\n\tk_object_init(sig);\n\n\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_init, sig);\n}\n",
                {
                    "475": "void z_impl_k_poll_signal_init(struct k_poll_signal *sig)",
                    "476": "{",
                    "477": "\tsys_dlist_init(&sig->poll_events);",
                    "478": "\tsig->signaled = 0U;",
                    "479": "\t/* signal->result is left uninitialized */",
                    "480": "\tk_object_init(sig);",
                    "481": "",
                    "482": "\tSYS_PORT_TRACING_FUNC(k_poll_api, signal_init, sig);",
                    "483": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_poll": {
            "name": "z_impl_k_poll",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 283,
            "function_content": [
                "/* Event is not one of those identified in is_condition_met()\n* catching non-polling events, or is marked for just check,\n* or not marked for polling. No action needed.\n*/\nint z_impl_k_poll(struct k_poll_event *events, int num_events,\n\t\t  k_timeout_t timeout)\n{\n\tint events_registered;\n\tk_spinlock_key_t key;\n\tstruct z_poller *poller = &_current->poller;\n\n\tpoller->is_polling = true;\n\tpoller->mode = MODE_POLL;\n\n\t__ASSERT(!arch_is_in_isr(), \"\");\n\t__ASSERT(events != NULL, \"NULL events\\n\");\n\t__ASSERT(num_events >= 0, \"<0 events\\n\");\n\n\tSYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);\n\n\tevents_registered = register_events(events, num_events, poller,\n\t\t\t\t\t    K_TIMEOUT_EQ(timeout, K_NO_WAIT));\n\n\tkey = k_spin_lock(&lock);\n\n\t/*\n\t * If we're not polling anymore, it means that at least one event\n\t * condition is met, either when looping through the events here or\n\t * because one of the events registered has had its state changed.\n\t */\n\tif (!poller->is_polling) {\n\t\tclear_event_registrations(events, events_registered, key);\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, 0);\n\n\t\treturn 0;\n\t}\n\n\tpoller->is_polling = false;\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, -EAGAIN);\n\n\t\treturn -EAGAIN;\n\t}\n\n\tstatic _wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);\n\n\tint swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);\n\n\t/*\n\t * Clear all event registrations. If events happen while we're in this\n\t * loop, and we already had one that triggered, that's OK: they will\n\t * end up in the list of events that are ready; if we timed out, and\n\t * events happen while we're in this loop, that is OK as well since\n\t * we've already know the return code (-EAGAIN), and even if they are\n\t * added to the list of events that occurred, the user has to check the\n\t * return code first, which invalidates the whole list of event states.\n\t */\n\tkey = k_spin_lock(&lock);\n\tclear_event_registrations(events, events_registered, key);\n\tk_spin_unlock(&lock, key);\n\n\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);\n\n\treturn swap_rc;\n}\n",
                {
                    "283": "int z_impl_k_poll(struct k_poll_event *events, int num_events,",
                    "284": "\t\t  k_timeout_t timeout)",
                    "285": "{",
                    "286": "\tint events_registered;",
                    "287": "\tk_spinlock_key_t key;",
                    "288": "\tstruct z_poller *poller = &_current->poller;",
                    "289": "",
                    "290": "\tpoller->is_polling = true;",
                    "291": "\tpoller->mode = MODE_POLL;",
                    "292": "",
                    "293": "\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "294": "\t__ASSERT(events != NULL, \"NULL events\\n\");",
                    "295": "\t__ASSERT(num_events >= 0, \"<0 events\\n\");",
                    "296": "",
                    "297": "\tSYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);",
                    "298": "",
                    "299": "\tevents_registered = register_events(events, num_events, poller,",
                    "300": "\t\t\t\t\t    K_TIMEOUT_EQ(timeout, K_NO_WAIT));",
                    "301": "",
                    "302": "\tkey = k_spin_lock(&lock);",
                    "303": "",
                    "304": "\t/*",
                    "305": "\t * If we're not polling anymore, it means that at least one event",
                    "306": "\t * condition is met, either when looping through the events here or",
                    "307": "\t * because one of the events registered has had its state changed.",
                    "308": "\t */",
                    "309": "\tif (!poller->is_polling) {",
                    "310": "\t\tclear_event_registrations(events, events_registered, key);",
                    "311": "\t\tk_spin_unlock(&lock, key);",
                    "312": "",
                    "313": "\t\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, 0);",
                    "314": "",
                    "315": "\t\treturn 0;",
                    "316": "\t}",
                    "317": "",
                    "318": "\tpoller->is_polling = false;",
                    "319": "",
                    "320": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "321": "\t\tk_spin_unlock(&lock, key);",
                    "322": "",
                    "323": "\t\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, -EAGAIN);",
                    "324": "",
                    "325": "\t\treturn -EAGAIN;",
                    "326": "\t}",
                    "327": "",
                    "328": "\tstatic _wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);",
                    "329": "",
                    "330": "\tint swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);",
                    "331": "",
                    "332": "\t/*",
                    "333": "\t * Clear all event registrations. If events happen while we're in this",
                    "334": "\t * loop, and we already had one that triggered, that's OK: they will",
                    "335": "\t * end up in the list of events that are ready; if we timed out, and",
                    "336": "\t * events happen while we're in this loop, that is OK as well since",
                    "337": "\t * we've already know the return code (-EAGAIN), and even if they are",
                    "338": "\t * added to the list of events that occurred, the user has to check the",
                    "339": "\t * return code first, which invalidates the whole list of event states.",
                    "340": "\t */",
                    "341": "\tkey = k_spin_lock(&lock);",
                    "342": "\tclear_event_registrations(events, events_registered, key);",
                    "343": "\tk_spin_unlock(&lock, key);",
                    "344": "",
                    "345": "\tSYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);",
                    "346": "",
                    "347": "\treturn swap_rc;",
                    "348": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_pipe_init": {
            "name": "z_impl_k_pipe_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 67,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_PIPE */\nvoid z_impl_k_pipe_init(struct k_pipe *pipe, uint8_t *buffer, size_t buffer_size)\n{\n\tring_buf_init(&pipe->buf, buffer_size, buffer);\n\tpipe->flags = PIPE_FLAG_OPEN;\n\tpipe->waiting = 0;\n\n\tpipe->lock = (struct k_spinlock){};\n\tz_waitq_init(&pipe->data);\n\tz_waitq_init(&pipe->space);\n\tk_object_init(pipe);\n\n#ifdef CONFIG_POLL\n\tsys_dlist_init(&pipe->poll_events);\n#endif /* CONFIG_POLL */\n#ifdef CONFIG_OBJ_CORE_PIPE\n\tk_obj_core_init_and_link(K_OBJ_CORE(pipe), &obj_type_pipe);\n#endif /* CONFIG_OBJ_CORE_PIPE */\n\tSYS_PORT_TRACING_OBJ_INIT(k_pipe, pipe, buffer, buffer_size);\n}\n",
                {
                    "67": "void z_impl_k_pipe_init(struct k_pipe *pipe, uint8_t *buffer, size_t buffer_size)",
                    "68": "{",
                    "69": "\tring_buf_init(&pipe->buf, buffer_size, buffer);",
                    "70": "\tpipe->flags = PIPE_FLAG_OPEN;",
                    "71": "\tpipe->waiting = 0;",
                    "72": "",
                    "73": "\tpipe->lock = (struct k_spinlock){};",
                    "74": "\tz_waitq_init(&pipe->data);",
                    "75": "\tz_waitq_init(&pipe->space);",
                    "76": "\tk_object_init(pipe);",
                    "77": "",
                    "78": "#ifdef CONFIG_POLL",
                    "79": "\tsys_dlist_init(&pipe->poll_events);",
                    "80": "#endif /* CONFIG_POLL */",
                    "81": "#ifdef CONFIG_OBJ_CORE_PIPE",
                    "82": "\tk_obj_core_init_and_link(K_OBJ_CORE(pipe), &obj_type_pipe);",
                    "83": "#endif /* CONFIG_OBJ_CORE_PIPE */",
                    "84": "\tSYS_PORT_TRACING_OBJ_INIT(k_pipe, pipe, buffer, buffer_size);",
                    "85": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_purge": {
            "name": "z_impl_k_msgq_purge",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 435,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_impl_k_msgq_purge(struct k_msgq *msgq)\n{\n\tk_spinlock_key_t key;\n\tstruct k_thread *pending_thread;\n\tbool resched = false;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);\n\n\t/* wake up any threads that are waiting to write */\n\tfor (pending_thread = z_unpend_first_thread(&msgq->wait_q);\n\t     pending_thread != NULL;\n\t     pending_thread = z_unpend_first_thread(&msgq->wait_q)) {\n\t\tarch_thread_return_value_set(pending_thread, -ENOMSG);\n\t\tz_ready_thread(pending_thread);\n\t\tresched = true;\n\t}\n\n\tmsgq->used_msgs = 0;\n\tmsgq->read_ptr = msgq->write_ptr;\n\n\tif (resched) {\n\t\tz_reschedule(&msgq->lock, key);\n\t} else {\n\t\tk_spin_unlock(&msgq->lock, key);\n\t}\n}\n",
                {
                    "435": "void z_impl_k_msgq_purge(struct k_msgq *msgq)",
                    "436": "{",
                    "437": "\tk_spinlock_key_t key;",
                    "438": "\tstruct k_thread *pending_thread;",
                    "439": "\tbool resched = false;",
                    "440": "",
                    "441": "\tkey = k_spin_lock(&msgq->lock);",
                    "442": "",
                    "443": "\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);",
                    "444": "",
                    "445": "\t/* wake up any threads that are waiting to write */",
                    "446": "\tfor (pending_thread = z_unpend_first_thread(&msgq->wait_q);",
                    "447": "\t     pending_thread != NULL;",
                    "448": "\t     pending_thread = z_unpend_first_thread(&msgq->wait_q)) {",
                    "449": "\t\tarch_thread_return_value_set(pending_thread, -ENOMSG);",
                    "450": "\t\tz_ready_thread(pending_thread);",
                    "451": "\t\tresched = true;",
                    "452": "\t}",
                    "453": "",
                    "454": "\tmsgq->used_msgs = 0;",
                    "455": "\tmsgq->read_ptr = msgq->write_ptr;",
                    "456": "",
                    "457": "\tif (resched) {",
                    "458": "\t\tz_reschedule(&msgq->lock, key);",
                    "459": "\t} else {",
                    "460": "\t\tk_spin_unlock(&msgq->lock, key);",
                    "461": "\t}",
                    "462": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_get": {
            "name": "z_impl_k_msgq_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 274,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)\n{\n\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");\n\n\tk_spinlock_key_t key;\n\tstruct k_thread *pending_thread;\n\tint result;\n\tbool resched = false;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);\n\n\tif (msgq->used_msgs > 0U) {\n\t\t/* take first available message from queue */\n\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);\n\t\tmsgq->read_ptr += msgq->msg_size;\n\t\tif (msgq->read_ptr == msgq->buffer_end) {\n\t\t\tmsgq->read_ptr = msgq->buffer_start;\n\t\t}\n\t\tmsgq->used_msgs--;\n\n\t\t/* handle first thread waiting to write (if any) */\n\t\tpending_thread = z_unpend_first_thread(&msgq->wait_q);\n\t\tif (unlikely(pending_thread != NULL)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);\n\n\t\t\t/* add thread's message to queue */\n\t\t\t__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&\n\t\t\t\t\tmsgq->write_ptr < msgq->buffer_end);\n\t\t\t(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,\n\t\t\t       msgq->msg_size);\n\t\t\tmsgq->write_ptr += msgq->msg_size;\n\t\t\tif (msgq->write_ptr == msgq->buffer_end) {\n\t\t\t\tmsgq->write_ptr = msgq->buffer_start;\n\t\t\t}\n\t\t\tmsgq->used_msgs++;\n\n\t\t\t/* wake up waiting thread */\n\t\t\tarch_thread_return_value_set(pending_thread, 0);\n\t\t\tz_ready_thread(pending_thread);\n\t\t\tresched = true;\n\t\t}\n\t\tresult = 0;\n\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t/* don't wait for a message to become available */\n\t\tresult = -ENOMSG;\n\t} else {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);\n\n\t\t/* wait for get message success or timeout */\n\t\t_current->base.swap_data = data;\n\n\t\tresult = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);\n\t\treturn result;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);\n\n\tif (resched) {\n\t\tz_reschedule(&msgq->lock, key);\n\t} else {\n\t\tk_spin_unlock(&msgq->lock, key);\n\t}\n\n\treturn result;\n}\n",
                {
                    "274": "int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)",
                    "275": "{",
                    "276": "\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");",
                    "277": "",
                    "278": "\tk_spinlock_key_t key;",
                    "279": "\tstruct k_thread *pending_thread;",
                    "280": "\tint result;",
                    "281": "\tbool resched = false;",
                    "282": "",
                    "283": "\tkey = k_spin_lock(&msgq->lock);",
                    "284": "",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);",
                    "286": "",
                    "287": "\tif (msgq->used_msgs > 0U) {",
                    "288": "\t\t/* take first available message from queue */",
                    "289": "\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);",
                    "290": "\t\tmsgq->read_ptr += msgq->msg_size;",
                    "291": "\t\tif (msgq->read_ptr == msgq->buffer_end) {",
                    "292": "\t\t\tmsgq->read_ptr = msgq->buffer_start;",
                    "293": "\t\t}",
                    "294": "\t\tmsgq->used_msgs--;",
                    "295": "",
                    "296": "\t\t/* handle first thread waiting to write (if any) */",
                    "297": "\t\tpending_thread = z_unpend_first_thread(&msgq->wait_q);",
                    "298": "\t\tif (unlikely(pending_thread != NULL)) {",
                    "299": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);",
                    "300": "",
                    "301": "\t\t\t/* add thread's message to queue */",
                    "302": "\t\t\t__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&",
                    "303": "\t\t\t\t\tmsgq->write_ptr < msgq->buffer_end);",
                    "304": "\t\t\t(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,",
                    "305": "\t\t\t       msgq->msg_size);",
                    "306": "\t\t\tmsgq->write_ptr += msgq->msg_size;",
                    "307": "\t\t\tif (msgq->write_ptr == msgq->buffer_end) {",
                    "308": "\t\t\t\tmsgq->write_ptr = msgq->buffer_start;",
                    "309": "\t\t\t}",
                    "310": "\t\t\tmsgq->used_msgs++;",
                    "311": "",
                    "312": "\t\t\t/* wake up waiting thread */",
                    "313": "\t\t\tarch_thread_return_value_set(pending_thread, 0);",
                    "314": "\t\t\tz_ready_thread(pending_thread);",
                    "315": "\t\t\tresched = true;",
                    "316": "\t\t}",
                    "317": "\t\tresult = 0;",
                    "318": "\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "319": "\t\t/* don't wait for a message to become available */",
                    "320": "\t\tresult = -ENOMSG;",
                    "321": "\t} else {",
                    "322": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);",
                    "323": "",
                    "324": "\t\t/* wait for get message success or timeout */",
                    "325": "\t\t_current->base.swap_data = data;",
                    "326": "",
                    "327": "\t\tresult = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);",
                    "328": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);",
                    "329": "\t\treturn result;",
                    "330": "\t}",
                    "331": "",
                    "332": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);",
                    "333": "",
                    "334": "\tif (resched) {",
                    "335": "\t\tz_reschedule(&msgq->lock, key);",
                    "336": "\t} else {",
                    "337": "\t\tk_spin_unlock(&msgq->lock, key);",
                    "338": "\t}",
                    "339": "",
                    "340": "\treturn result;",
                    "341": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_put_front": {
            "name": "z_impl_k_msgq_put_front",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 230,
            "function_content": [
                "/* wait for put message success, failure, or timeout */\nint z_impl_k_msgq_put_front(struct k_msgq *msgq, const void *data)\n{\n\treturn put_msg_in_queue(msgq, data, K_NO_WAIT, false);\n}\n",
                {
                    "230": "int z_impl_k_msgq_put_front(struct k_msgq *msgq, const void *data)",
                    "231": "{",
                    "232": "\treturn put_msg_in_queue(msgq, data, K_NO_WAIT, false);",
                    "233": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_put": {
            "name": "z_impl_k_msgq_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 225,
            "function_content": [
                "/* wait for put message success, failure, or timeout */\nint z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)\n{\n\treturn put_msg_in_queue(msgq, data, timeout, true);\n}\n",
                {
                    "225": "int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)",
                    "226": "{",
                    "227": "\treturn put_msg_in_queue(msgq, data, timeout, true);",
                    "228": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_sem_reset": {
            "name": "z_impl_k_sem_reset",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sem.c",
            "location_line": 166,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_impl_k_sem_reset(struct k_sem *sem)\n{\n\tstruct k_thread *thread;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tbool resched = false;\n\n\twhile (true) {\n\t\tthread = z_unpend_first_thread(&sem->wait_q);\n\t\tif (thread == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tresched = true;\n\t\tarch_thread_return_value_set(thread, -EAGAIN);\n\t\tz_ready_thread(thread);\n\t}\n\tsem->count = 0;\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);\n\n\tresched = handle_poll_events(sem) || resched;\n\n\tif (resched) {\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tk_spin_unlock(&lock, key);\n\t}\n}\n",
                {
                    "166": "void z_impl_k_sem_reset(struct k_sem *sem)",
                    "167": "{",
                    "168": "\tstruct k_thread *thread;",
                    "169": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "170": "\tbool resched = false;",
                    "171": "",
                    "172": "\twhile (true) {",
                    "173": "\t\tthread = z_unpend_first_thread(&sem->wait_q);",
                    "174": "\t\tif (thread == NULL) {",
                    "175": "\t\t\tbreak;",
                    "176": "\t\t}",
                    "177": "\t\tresched = true;",
                    "178": "\t\tarch_thread_return_value_set(thread, -EAGAIN);",
                    "179": "\t\tz_ready_thread(thread);",
                    "180": "\t}",
                    "181": "\tsem->count = 0;",
                    "182": "",
                    "183": "\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);",
                    "184": "",
                    "185": "\tresched = handle_poll_events(sem) || resched;",
                    "186": "",
                    "187": "\tif (resched) {",
                    "188": "\t\tz_reschedule(&lock, key);",
                    "189": "\t} else {",
                    "190": "\t\tk_spin_unlock(&lock, key);",
                    "191": "\t}",
                    "192": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_sem_give": {
            "name": "z_impl_k_sem_give",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sem.c",
            "location_line": 95,
            "function_content": [
                "#endif /* CONFIG_POLL */\nvoid z_impl_k_sem_give(struct k_sem *sem)\n{\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tstruct k_thread *thread;\n\tbool resched;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);\n\n\tthread = z_unpend_first_thread(&sem->wait_q);\n\n\tif (unlikely(thread != NULL)) {\n\t\tarch_thread_return_value_set(thread, 0);\n\t\tz_ready_thread(thread);\n\t\tresched = true;\n\t} else {\n\t\tsem->count += (sem->count != sem->limit) ? 1U : 0U;\n\t\tresched = handle_poll_events(sem);\n\t}\n\n\tif (unlikely(resched)) {\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);\n}\n",
                {
                    "95": "void z_impl_k_sem_give(struct k_sem *sem)",
                    "96": "{",
                    "97": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "98": "\tstruct k_thread *thread;",
                    "99": "\tbool resched;",
                    "100": "",
                    "101": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);",
                    "102": "",
                    "103": "\tthread = z_unpend_first_thread(&sem->wait_q);",
                    "104": "",
                    "105": "\tif (unlikely(thread != NULL)) {",
                    "106": "\t\tarch_thread_return_value_set(thread, 0);",
                    "107": "\t\tz_ready_thread(thread);",
                    "108": "\t\tresched = true;",
                    "109": "\t} else {",
                    "110": "\t\tsem->count += (sem->count != sem->limit) ? 1U : 0U;",
                    "111": "\t\tresched = handle_poll_events(sem);",
                    "112": "\t}",
                    "113": "",
                    "114": "\tif (unlikely(resched)) {",
                    "115": "\t\tz_reschedule(&lock, key);",
                    "116": "\t} else {",
                    "117": "\t\tk_spin_unlock(&lock, key);",
                    "118": "\t}",
                    "119": "",
                    "120": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);",
                    "121": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_sem_init": {
            "name": "z_impl_k_sem_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sem.c",
            "location_line": 45,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_SEM */\nint z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,\n\t\t      unsigned int limit)\n{\n\t/*\n\t * Limit cannot be zero and count cannot be greater than limit\n\t */\n\tCHECKIF(limit == 0U || initial_count > limit) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);\n\n\t\treturn -EINVAL;\n\t}\n\n\tsem->count = initial_count;\n\tsem->limit = limit;\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);\n\n\tz_waitq_init(&sem->wait_q);\n#if defined(CONFIG_POLL)\n\tsys_dlist_init(&sem->poll_events);\n#endif /* CONFIG_POLL */\n\tk_object_init(sem);\n\n#ifdef CONFIG_OBJ_CORE_SEM\n\tk_obj_core_init_and_link(K_OBJ_CORE(sem), &obj_type_sem);\n#endif /* CONFIG_OBJ_CORE_SEM */\n\n\treturn 0;\n}\n",
                {
                    "45": "int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,",
                    "46": "\t\t      unsigned int limit)",
                    "47": "{",
                    "48": "\t/*",
                    "49": "\t * Limit cannot be zero and count cannot be greater than limit",
                    "50": "\t */",
                    "51": "\tCHECKIF(limit == 0U || initial_count > limit) {",
                    "52": "\t\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);",
                    "53": "",
                    "54": "\t\treturn -EINVAL;",
                    "55": "\t}",
                    "56": "",
                    "57": "\tsem->count = initial_count;",
                    "58": "\tsem->limit = limit;",
                    "59": "",
                    "60": "\tSYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);",
                    "61": "",
                    "62": "\tz_waitq_init(&sem->wait_q);",
                    "63": "#if defined(CONFIG_POLL)",
                    "64": "\tsys_dlist_init(&sem->poll_events);",
                    "65": "#endif /* CONFIG_POLL */",
                    "66": "\tk_object_init(sem);",
                    "67": "",
                    "68": "#ifdef CONFIG_OBJ_CORE_SEM",
                    "69": "\tk_obj_core_init_and_link(K_OBJ_CORE(sem), &obj_type_sem);",
                    "70": "#endif /* CONFIG_OBJ_CORE_SEM */",
                    "71": "",
                    "72": "\treturn 0;",
                    "73": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_condvar_broadcast": {
            "name": "z_impl_k_condvar_broadcast",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/condvar.c",
            "location_line": 76,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_condvar_broadcast(struct k_condvar *condvar)\n{\n\tstruct k_thread *pending_thread;\n\tk_spinlock_key_t key;\n\tint woken = 0;\n\n\tkey = k_spin_lock(&lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, broadcast, condvar);\n\n\t/* wake up any threads that are waiting to write */\n\tfor (pending_thread = z_unpend_first_thread(&condvar->wait_q); pending_thread != NULL;\n\t\t pending_thread = z_unpend_first_thread(&condvar->wait_q)) {\n\t\twoken++;\n\t\tarch_thread_return_value_set(pending_thread, 0);\n\t\tz_ready_thread(pending_thread);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, broadcast, condvar, woken);\n\n\n\tif (woken == 0) {\n\t\tk_spin_unlock(&lock, key);\n\t} else {\n\t\tz_reschedule(&lock, key);\n\t}\n\n\treturn woken;\n}\n",
                {
                    "76": "int z_impl_k_condvar_broadcast(struct k_condvar *condvar)",
                    "77": "{",
                    "78": "\tstruct k_thread *pending_thread;",
                    "79": "\tk_spinlock_key_t key;",
                    "80": "\tint woken = 0;",
                    "81": "",
                    "82": "\tkey = k_spin_lock(&lock);",
                    "83": "",
                    "84": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, broadcast, condvar);",
                    "85": "",
                    "86": "\t/* wake up any threads that are waiting to write */",
                    "87": "\tfor (pending_thread = z_unpend_first_thread(&condvar->wait_q); pending_thread != NULL;",
                    "88": "\t\t pending_thread = z_unpend_first_thread(&condvar->wait_q)) {",
                    "89": "\t\twoken++;",
                    "90": "\t\tarch_thread_return_value_set(pending_thread, 0);",
                    "91": "\t\tz_ready_thread(pending_thread);",
                    "92": "\t}",
                    "93": "",
                    "94": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, broadcast, condvar, woken);",
                    "95": "",
                    "96": "",
                    "97": "\tif (woken == 0) {",
                    "98": "\t\tk_spin_unlock(&lock, key);",
                    "99": "\t} else {",
                    "100": "\t\tz_reschedule(&lock, key);",
                    "101": "\t}",
                    "102": "",
                    "103": "\treturn woken;",
                    "104": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_condvar_signal": {
            "name": "z_impl_k_condvar_signal",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/condvar.c",
            "location_line": 44,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_condvar_signal(struct k_condvar *condvar)\n{\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, signal, condvar);\n\n\tstruct k_thread *thread = z_unpend_first_thread(&condvar->wait_q);\n\n\tif (unlikely(thread != NULL)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_condvar, signal, condvar, K_FOREVER);\n\n\t\tarch_thread_return_value_set(thread, 0);\n\t\tz_ready_thread(thread);\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, signal, condvar, 0);\n\n\treturn 0;\n}\n",
                {
                    "44": "int z_impl_k_condvar_signal(struct k_condvar *condvar)",
                    "45": "{",
                    "46": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "47": "",
                    "48": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, signal, condvar);",
                    "49": "",
                    "50": "\tstruct k_thread *thread = z_unpend_first_thread(&condvar->wait_q);",
                    "51": "",
                    "52": "\tif (unlikely(thread != NULL)) {",
                    "53": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_condvar, signal, condvar, K_FOREVER);",
                    "54": "",
                    "55": "\t\tarch_thread_return_value_set(thread, 0);",
                    "56": "\t\tz_ready_thread(thread);",
                    "57": "\t\tz_reschedule(&lock, key);",
                    "58": "\t} else {",
                    "59": "\t\tk_spin_unlock(&lock, key);",
                    "60": "\t}",
                    "61": "",
                    "62": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, signal, condvar, 0);",
                    "63": "",
                    "64": "\treturn 0;",
                    "65": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_condvar_init": {
            "name": "z_impl_k_condvar_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/condvar.c",
            "location_line": 21,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_CONDVAR */\nint z_impl_k_condvar_init(struct k_condvar *condvar)\n{\n\tz_waitq_init(&condvar->wait_q);\n\tk_object_init(condvar);\n\n#ifdef CONFIG_OBJ_CORE_CONDVAR\n\tk_obj_core_init_and_link(K_OBJ_CORE(condvar), &obj_type_condvar);\n#endif /* CONFIG_OBJ_CORE_CONDVAR */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_condvar, condvar, 0);\n\n\treturn 0;\n}\n",
                {
                    "21": "int z_impl_k_condvar_init(struct k_condvar *condvar)",
                    "22": "{",
                    "23": "\tz_waitq_init(&condvar->wait_q);",
                    "24": "\tk_object_init(condvar);",
                    "25": "",
                    "26": "#ifdef CONFIG_OBJ_CORE_CONDVAR",
                    "27": "\tk_obj_core_init_and_link(K_OBJ_CORE(condvar), &obj_type_condvar);",
                    "28": "#endif /* CONFIG_OBJ_CORE_CONDVAR */",
                    "29": "",
                    "30": "\tSYS_PORT_TRACING_OBJ_INIT(k_condvar, condvar, 0);",
                    "31": "",
                    "32": "\treturn 0;",
                    "33": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_mutex_unlock": {
            "name": "z_impl_k_mutex_unlock",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mutex.c",
            "location_line": 211,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_mutex_unlock(struct k_mutex *mutex)\n{\n\tstruct k_thread *new_owner;\n\n\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);\n\n\tCHECKIF(mutex->owner == NULL) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);\n\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * The current thread does not own the mutex.\n\t */\n\tCHECKIF(mutex->owner != _current) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);\n\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * Attempt to unlock a mutex which is unlocked. mutex->lock_count\n\t * cannot be zero if the current thread is equal to mutex->owner,\n\t * therefore no underflow check is required. Use assert to catch\n\t * undefined behavior.\n\t */\n\t__ASSERT_NO_MSG(mutex->lock_count > 0U);\n\n\tLOG_DBG(\"mutex %p lock_count: %d\", mutex, mutex->lock_count);\n\n\t/*\n\t * If we are the owner and count is greater than 1, then decrement\n\t * the count and return and keep current thread as the owner.\n\t */\n\tif (mutex->lock_count > 1U) {\n\t\tmutex->lock_count--;\n\t\tgoto k_mutex_unlock_return;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tadjust_owner_prio(mutex, mutex->owner_orig_prio);\n\n\t/* Get the new owner, if any */\n\tnew_owner = z_unpend_first_thread(&mutex->wait_q);\n\n\tmutex->owner = new_owner;\n\n\tLOG_DBG(\"new owner of mutex %p: %p (prio: %d)\",\n\t\tmutex, new_owner, new_owner ? new_owner->base.prio : -1000);\n\n\tif (unlikely(new_owner != NULL)) {\n\t\t/*\n\t\t * new owner is already of higher or equal prio than first\n\t\t * waiter since the wait queue is priority-based: no need to\n\t\t * adjust its priority\n\t\t */\n\t\tmutex->owner_orig_prio = new_owner->base.prio;\n\t\tarch_thread_return_value_set(new_owner, 0);\n\t\tz_ready_thread(new_owner);\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tmutex->lock_count = 0U;\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\nk_mutex_unlock_return:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);\n\n\treturn 0;\n}\n",
                {
                    "211": "int z_impl_k_mutex_unlock(struct k_mutex *mutex)",
                    "212": "{",
                    "213": "\tstruct k_thread *new_owner;",
                    "214": "",
                    "215": "\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");",
                    "216": "",
                    "217": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);",
                    "218": "",
                    "219": "\tCHECKIF(mutex->owner == NULL) {",
                    "220": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);",
                    "221": "",
                    "222": "\t\treturn -EINVAL;",
                    "223": "\t}",
                    "224": "\t/*",
                    "225": "\t * The current thread does not own the mutex.",
                    "226": "\t */",
                    "227": "\tCHECKIF(mutex->owner != _current) {",
                    "228": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);",
                    "229": "",
                    "230": "\t\treturn -EPERM;",
                    "231": "\t}",
                    "232": "",
                    "233": "\t/*",
                    "234": "\t * Attempt to unlock a mutex which is unlocked. mutex->lock_count",
                    "235": "\t * cannot be zero if the current thread is equal to mutex->owner,",
                    "236": "\t * therefore no underflow check is required. Use assert to catch",
                    "237": "\t * undefined behavior.",
                    "238": "\t */",
                    "239": "\t__ASSERT_NO_MSG(mutex->lock_count > 0U);",
                    "240": "",
                    "241": "\tLOG_DBG(\"mutex %p lock_count: %d\", mutex, mutex->lock_count);",
                    "242": "",
                    "243": "\t/*",
                    "244": "\t * If we are the owner and count is greater than 1, then decrement",
                    "245": "\t * the count and return and keep current thread as the owner.",
                    "246": "\t */",
                    "247": "\tif (mutex->lock_count > 1U) {",
                    "248": "\t\tmutex->lock_count--;",
                    "249": "\t\tgoto k_mutex_unlock_return;",
                    "250": "\t}",
                    "251": "",
                    "252": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "253": "",
                    "254": "\tadjust_owner_prio(mutex, mutex->owner_orig_prio);",
                    "255": "",
                    "256": "\t/* Get the new owner, if any */",
                    "257": "\tnew_owner = z_unpend_first_thread(&mutex->wait_q);",
                    "258": "",
                    "259": "\tmutex->owner = new_owner;",
                    "260": "",
                    "261": "\tLOG_DBG(\"new owner of mutex %p: %p (prio: %d)\",",
                    "262": "\t\tmutex, new_owner, new_owner ? new_owner->base.prio : -1000);",
                    "263": "",
                    "264": "\tif (unlikely(new_owner != NULL)) {",
                    "265": "\t\t/*",
                    "266": "\t\t * new owner is already of higher or equal prio than first",
                    "267": "\t\t * waiter since the wait queue is priority-based: no need to",
                    "268": "\t\t * adjust its priority",
                    "269": "\t\t */",
                    "270": "\t\tmutex->owner_orig_prio = new_owner->base.prio;",
                    "271": "\t\tarch_thread_return_value_set(new_owner, 0);",
                    "272": "\t\tz_ready_thread(new_owner);",
                    "273": "\t\tz_reschedule(&lock, key);",
                    "274": "\t} else {",
                    "275": "\t\tmutex->lock_count = 0U;",
                    "276": "\t\tk_spin_unlock(&lock, key);",
                    "277": "\t}",
                    "278": "",
                    "279": "",
                    "280": "k_mutex_unlock_return:",
                    "281": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);",
                    "282": "",
                    "283": "\treturn 0;",
                    "284": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_mutex_lock": {
            "name": "z_impl_k_mutex_lock",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mutex.c",
            "location_line": 105,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)\n{\n\tint new_prio;\n\tk_spinlock_key_t key;\n\tbool resched = false;\n\n\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);\n\n\tkey = k_spin_lock(&lock);\n\n\tif (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {\n\n\t\tmutex->owner_orig_prio = (mutex->lock_count == 0U) ?\n\t\t\t\t\t_current->base.prio :\n\t\t\t\t\tmutex->owner_orig_prio;\n\n\t\tmutex->lock_count++;\n\t\tmutex->owner = _current;\n\n\t\tLOG_DBG(\"%p took mutex %p, count: %d, orig prio: %d\",\n\t\t\t_current, mutex, mutex->lock_count,\n\t\t\tmutex->owner_orig_prio);\n\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);\n\n\t\treturn -EBUSY;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);\n\n\tnew_prio = new_prio_for_inheritance(_current->base.prio,\n\t\t\t\t\t    mutex->owner->base.prio);\n\n\tLOG_DBG(\"adjusting prio up on mutex %p\", mutex);\n\n\tif (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {\n\t\tresched = adjust_owner_prio(mutex, new_prio);\n\t}\n\n\tint got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);\n\n\tLOG_DBG(\"on mutex %p got_mutex value: %d\", mutex, got_mutex);\n\n\tLOG_DBG(\"%p got mutex %p (y/n): %c\", _current, mutex,\n\t\tgot_mutex ? 'y' : 'n');\n\n\tif (got_mutex == 0) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);\n\t\treturn 0;\n\t}\n\n\t/* timed out */\n\n\tLOG_DBG(\"%p timeout on mutex %p\", _current, mutex);\n\n\tkey = k_spin_lock(&lock);\n\n\t/*\n\t * Check if mutex was unlocked after this thread was unpended.\n\t * If so, skip adjusting owner's priority down.\n\t */\n\tif (likely(mutex->owner != NULL)) {\n\t\tstruct k_thread *waiter = z_waitq_head(&mutex->wait_q);\n\n\t\tnew_prio = (waiter != NULL) ?\n\t\t\tnew_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :\n\t\t\tmutex->owner_orig_prio;\n\n\t\tLOG_DBG(\"adjusting prio down on mutex %p\", mutex);\n\n\t\tresched = adjust_owner_prio(mutex, new_prio) || resched;\n\t}\n\n\tif (resched) {\n\t\tz_reschedule(&lock, key);\n\t} else {\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);\n\n\treturn -EAGAIN;\n}\n",
                {
                    "105": "int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)",
                    "106": "{",
                    "107": "\tint new_prio;",
                    "108": "\tk_spinlock_key_t key;",
                    "109": "\tbool resched = false;",
                    "110": "",
                    "111": "\t__ASSERT(!arch_is_in_isr(), \"mutexes cannot be used inside ISRs\");",
                    "112": "",
                    "113": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);",
                    "114": "",
                    "115": "\tkey = k_spin_lock(&lock);",
                    "116": "",
                    "117": "\tif (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {",
                    "118": "",
                    "119": "\t\tmutex->owner_orig_prio = (mutex->lock_count == 0U) ?",
                    "120": "\t\t\t\t\t_current->base.prio :",
                    "121": "\t\t\t\t\tmutex->owner_orig_prio;",
                    "122": "",
                    "123": "\t\tmutex->lock_count++;",
                    "124": "\t\tmutex->owner = _current;",
                    "125": "",
                    "126": "\t\tLOG_DBG(\"%p took mutex %p, count: %d, orig prio: %d\",",
                    "127": "\t\t\t_current, mutex, mutex->lock_count,",
                    "128": "\t\t\tmutex->owner_orig_prio);",
                    "129": "",
                    "130": "\t\tk_spin_unlock(&lock, key);",
                    "131": "",
                    "132": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);",
                    "133": "",
                    "134": "\t\treturn 0;",
                    "135": "\t}",
                    "136": "",
                    "137": "\tif (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {",
                    "138": "\t\tk_spin_unlock(&lock, key);",
                    "139": "",
                    "140": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);",
                    "141": "",
                    "142": "\t\treturn -EBUSY;",
                    "143": "\t}",
                    "144": "",
                    "145": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);",
                    "146": "",
                    "147": "\tnew_prio = new_prio_for_inheritance(_current->base.prio,",
                    "148": "\t\t\t\t\t    mutex->owner->base.prio);",
                    "149": "",
                    "150": "\tLOG_DBG(\"adjusting prio up on mutex %p\", mutex);",
                    "151": "",
                    "152": "\tif (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {",
                    "153": "\t\tresched = adjust_owner_prio(mutex, new_prio);",
                    "154": "\t}",
                    "155": "",
                    "156": "\tint got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);",
                    "157": "",
                    "158": "\tLOG_DBG(\"on mutex %p got_mutex value: %d\", mutex, got_mutex);",
                    "159": "",
                    "160": "\tLOG_DBG(\"%p got mutex %p (y/n): %c\", _current, mutex,",
                    "161": "\t\tgot_mutex ? 'y' : 'n');",
                    "162": "",
                    "163": "\tif (got_mutex == 0) {",
                    "164": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);",
                    "165": "\t\treturn 0;",
                    "166": "\t}",
                    "167": "",
                    "168": "\t/* timed out */",
                    "169": "",
                    "170": "\tLOG_DBG(\"%p timeout on mutex %p\", _current, mutex);",
                    "171": "",
                    "172": "\tkey = k_spin_lock(&lock);",
                    "173": "",
                    "174": "\t/*",
                    "175": "\t * Check if mutex was unlocked after this thread was unpended.",
                    "176": "\t * If so, skip adjusting owner's priority down.",
                    "177": "\t */",
                    "178": "\tif (likely(mutex->owner != NULL)) {",
                    "179": "\t\tstruct k_thread *waiter = z_waitq_head(&mutex->wait_q);",
                    "180": "",
                    "181": "\t\tnew_prio = (waiter != NULL) ?",
                    "182": "\t\t\tnew_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :",
                    "183": "\t\t\tmutex->owner_orig_prio;",
                    "184": "",
                    "185": "\t\tLOG_DBG(\"adjusting prio down on mutex %p\", mutex);",
                    "186": "",
                    "187": "\t\tresched = adjust_owner_prio(mutex, new_prio) || resched;",
                    "188": "\t}",
                    "189": "",
                    "190": "\tif (resched) {",
                    "191": "\t\tz_reschedule(&lock, key);",
                    "192": "\t} else {",
                    "193": "\t\tk_spin_unlock(&lock, key);",
                    "194": "\t}",
                    "195": "",
                    "196": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);",
                    "197": "",
                    "198": "\treturn -EAGAIN;",
                    "199": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_mutex_init": {
            "name": "z_impl_k_mutex_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mutex.c",
            "location_line": 55,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MUTEX */\nint z_impl_k_mutex_init(struct k_mutex *mutex)\n{\n\tmutex->owner = NULL;\n\tmutex->lock_count = 0U;\n\n\tz_waitq_init(&mutex->wait_q);\n\n\tk_object_init(mutex);\n\n#ifdef CONFIG_OBJ_CORE_MUTEX\n\tk_obj_core_init_and_link(K_OBJ_CORE(mutex), &obj_type_mutex);\n#endif /* CONFIG_OBJ_CORE_MUTEX */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);\n\n\treturn 0;\n}\n",
                {
                    "55": "int z_impl_k_mutex_init(struct k_mutex *mutex)",
                    "56": "{",
                    "57": "\tmutex->owner = NULL;",
                    "58": "\tmutex->lock_count = 0U;",
                    "59": "",
                    "60": "\tz_waitq_init(&mutex->wait_q);",
                    "61": "",
                    "62": "\tk_object_init(mutex);",
                    "63": "",
                    "64": "#ifdef CONFIG_OBJ_CORE_MUTEX",
                    "65": "\tk_obj_core_init_and_link(K_OBJ_CORE(mutex), &obj_type_mutex);",
                    "66": "#endif /* CONFIG_OBJ_CORE_MUTEX */",
                    "67": "",
                    "68": "\tSYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);",
                    "69": "",
                    "70": "\treturn 0;",
                    "71": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_stack_push": {
            "name": "z_impl_k_stack_push",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/stack.c",
            "location_line": 101,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)\n{\n\tstruct k_thread *first_pending_thread;\n\tint ret = 0;\n\tk_spinlock_key_t key = k_spin_lock(&stack->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, push, stack);\n\n\tCHECKIF(stack->next == stack->top) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfirst_pending_thread = z_unpend_first_thread(&stack->wait_q);\n\n\tif (unlikely(first_pending_thread != NULL)) {\n\t\tz_thread_return_value_set_with_data(first_pending_thread,\n\t\t\t\t\t\t   0, (void *)data);\n\n\t\tz_ready_thread(first_pending_thread);\n\t\tz_reschedule(&stack->lock, key);\n\t\tgoto end;\n\t} else {\n\t\t*(stack->next) = data;\n\t\tstack->next++;\n\t\tgoto out;\n\t}\n\nout:\n\tk_spin_unlock(&stack->lock, key);\n\nend:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, push, stack, ret);\n\n\treturn ret;\n}\n",
                {
                    "101": "int z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)",
                    "102": "{",
                    "103": "\tstruct k_thread *first_pending_thread;",
                    "104": "\tint ret = 0;",
                    "105": "\tk_spinlock_key_t key = k_spin_lock(&stack->lock);",
                    "106": "",
                    "107": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, push, stack);",
                    "108": "",
                    "109": "\tCHECKIF(stack->next == stack->top) {",
                    "110": "\t\tret = -ENOMEM;",
                    "111": "\t\tgoto out;",
                    "112": "\t}",
                    "113": "",
                    "114": "\tfirst_pending_thread = z_unpend_first_thread(&stack->wait_q);",
                    "115": "",
                    "116": "\tif (unlikely(first_pending_thread != NULL)) {",
                    "117": "\t\tz_thread_return_value_set_with_data(first_pending_thread,",
                    "118": "\t\t\t\t\t\t   0, (void *)data);",
                    "119": "",
                    "120": "\t\tz_ready_thread(first_pending_thread);",
                    "121": "\t\tz_reschedule(&stack->lock, key);",
                    "122": "\t\tgoto end;",
                    "123": "\t} else {",
                    "124": "\t\t*(stack->next) = data;",
                    "125": "\t\tstack->next++;",
                    "126": "\t\tgoto out;",
                    "127": "\t}",
                    "128": "",
                    "129": "out:",
                    "130": "\tk_spin_unlock(&stack->lock, key);",
                    "131": "",
                    "132": "end:",
                    "133": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, push, stack, ret);",
                    "134": "",
                    "135": "\treturn ret;",
                    "136": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_cancel_wait": {
            "name": "z_impl_k_queue_cancel_wait",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 99,
            "function_content": [
                "#endif /* CONFIG_POLL */\nvoid z_impl_k_queue_cancel_wait(struct k_queue *queue)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC(k_queue, cancel_wait, queue);\n\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tstruct k_thread *first_pending_thread;\n\tbool resched = false;\n\n\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);\n\n\tif (first_pending_thread != NULL) {\n\t\tresched = true;\n\t\tprepare_thread_to_run(first_pending_thread, NULL);\n\t}\n\n\tresched = handle_poll_events(queue, K_POLL_STATE_CANCELLED) || resched;\n\n\tif (resched) {\n\t\tz_reschedule(&queue->lock, key);\n\t} else {\n\t\tk_spin_unlock(&queue->lock, key);\n\t}\n}\n",
                {
                    "99": "void z_impl_k_queue_cancel_wait(struct k_queue *queue)",
                    "100": "{",
                    "101": "\tSYS_PORT_TRACING_OBJ_FUNC(k_queue, cancel_wait, queue);",
                    "102": "",
                    "103": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "104": "\tstruct k_thread *first_pending_thread;",
                    "105": "\tbool resched = false;",
                    "106": "",
                    "107": "\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);",
                    "108": "",
                    "109": "\tif (first_pending_thread != NULL) {",
                    "110": "\t\tresched = true;",
                    "111": "\t\tprepare_thread_to_run(first_pending_thread, NULL);",
                    "112": "\t}",
                    "113": "",
                    "114": "\tresched = handle_poll_events(queue, K_POLL_STATE_CANCELLED) || resched;",
                    "115": "",
                    "116": "\tif (resched) {",
                    "117": "\t\tz_reschedule(&queue->lock, key);",
                    "118": "\t} else {",
                    "119": "\t\tk_spin_unlock(&queue->lock, key);",
                    "120": "\t}",
                    "121": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_init": {
            "name": "z_impl_k_queue_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 58,
            "function_content": [
                "/* Data was directly placed in the queue, the first word\n* reserved for the linked list. User mode isn't allowed to\n* do this, although it can get data sent this way.\n*/\nvoid z_impl_k_queue_init(struct k_queue *queue)\n{\n\tsys_sflist_init(&queue->data_q);\n\tqueue->lock = (struct k_spinlock) {};\n\tz_waitq_init(&queue->wait_q);\n#if defined(CONFIG_POLL)\n\tsys_dlist_init(&queue->poll_events);\n#endif\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_queue, queue);\n\n\tk_object_init(queue);\n}\n",
                {
                    "58": "void z_impl_k_queue_init(struct k_queue *queue)",
                    "59": "{",
                    "60": "\tsys_sflist_init(&queue->data_q);",
                    "61": "\tqueue->lock = (struct k_spinlock) {};",
                    "62": "\tz_waitq_init(&queue->wait_q);",
                    "63": "#if defined(CONFIG_POLL)",
                    "64": "\tsys_dlist_init(&queue->poll_events);",
                    "65": "#endif",
                    "66": "",
                    "67": "\tSYS_PORT_TRACING_OBJ_INIT(k_queue, queue);",
                    "68": "",
                    "69": "\tk_object_init(queue);",
                    "70": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_timer_status_sync": {
            "name": "z_impl_k_timer_status_sync",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timer.c",
            "location_line": 314,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nuint32_t z_impl_k_timer_status_sync(struct k_timer *timer)\n{\n\t__ASSERT(!arch_is_in_isr(), \"\");\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, status_sync, timer);\n\n\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tuint32_t result;\n\n\t\tdo {\n\t\t\tunsigned int key = irq_lock();\n\n\t\t\tif (!z_is_inactive_timeout(&timer->timeout)) {\n\t\t\t\tresult = *(volatile uint32_t *)&timer->status;\n\t\t\t\ttimer->status = 0U;\n\t\t\t\tif (result > 0) {\n\t\t\t\t\tirq_unlock(key);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tk_cpu_atomic_idle(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = timer->status;\n\t\t\t\tirq_unlock(key);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\n\t\treturn result;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tuint32_t result = timer->status;\n\n\tif (result == 0U) {\n\t\tif (!z_is_inactive_timeout(&timer->timeout)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);\n\n\t\t\t/* wait for timer to expire or stop */\n\t\t\t(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);\n\n\t\t\t/* get updated timer status */\n\t\t\tkey = k_spin_lock(&lock);\n\t\t\tresult = timer->status;\n\t\t} else {\n\t\t\t/* timer is already stopped */\n\t\t}\n\t} else {\n\t\t/* timer has already expired at least once */\n\t}\n\n\ttimer->status = 0U;\n\tk_spin_unlock(&lock, key);\n\n\t/**\n\t * @note\tNew tracing hook\n\t */\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);\n\n\treturn result;\n}\n",
                {
                    "314": "uint32_t z_impl_k_timer_status_sync(struct k_timer *timer)",
                    "315": "{",
                    "316": "\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "317": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, status_sync, timer);",
                    "318": "",
                    "319": "\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "320": "\t\tuint32_t result;",
                    "321": "",
                    "322": "\t\tdo {",
                    "323": "\t\t\tunsigned int key = irq_lock();",
                    "324": "",
                    "325": "\t\t\tif (!z_is_inactive_timeout(&timer->timeout)) {",
                    "326": "\t\t\t\tresult = *(volatile uint32_t *)&timer->status;",
                    "327": "\t\t\t\ttimer->status = 0U;",
                    "328": "\t\t\t\tif (result > 0) {",
                    "329": "\t\t\t\t\tirq_unlock(key);",
                    "330": "\t\t\t\t\tbreak;",
                    "331": "\t\t\t\t} else {",
                    "332": "\t\t\t\t\tk_cpu_atomic_idle(key);",
                    "333": "\t\t\t\t}",
                    "334": "\t\t\t} else {",
                    "335": "\t\t\t\tresult = timer->status;",
                    "336": "\t\t\t\tirq_unlock(key);",
                    "337": "\t\t\t\tbreak;",
                    "338": "\t\t\t}",
                    "339": "\t\t} while (true);",
                    "340": "",
                    "341": "\t\treturn result;",
                    "342": "\t}",
                    "343": "",
                    "344": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "345": "\tuint32_t result = timer->status;",
                    "346": "",
                    "347": "\tif (result == 0U) {",
                    "348": "\t\tif (!z_is_inactive_timeout(&timer->timeout)) {",
                    "349": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);",
                    "350": "",
                    "351": "\t\t\t/* wait for timer to expire or stop */",
                    "352": "\t\t\t(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);",
                    "353": "",
                    "354": "\t\t\t/* get updated timer status */",
                    "355": "\t\t\tkey = k_spin_lock(&lock);",
                    "356": "\t\t\tresult = timer->status;",
                    "357": "\t\t} else {",
                    "358": "\t\t\t/* timer is already stopped */",
                    "359": "\t\t}",
                    "360": "\t} else {",
                    "361": "\t\t/* timer has already expired at least once */",
                    "362": "\t}",
                    "363": "",
                    "364": "\ttimer->status = 0U;",
                    "365": "\tk_spin_unlock(&lock, key);",
                    "366": "",
                    "367": "\t/**",
                    "368": "\t * @note\tNew tracing hook",
                    "369": "\t */",
                    "370": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);",
                    "371": "",
                    "372": "\treturn result;",
                    "373": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_thread_suspend": {
            "name": "z_impl_k_thread_suspend",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 491,
            "function_content": [
                "/* NOTE: the scheduler lock has been released.  Don't put\n* logic here, it's likely to be racy/deadlocky even if you\n* re-take the lock!\n*/\nvoid z_impl_k_thread_suspend(k_tid_t thread)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, suspend, thread);\n\n\t/* Special case \"suspend the current thread\" as it doesn't\n\t * need the async complexity below.\n\t */\n\tif (!IS_ENABLED(CONFIG_SMP) && (thread == _current) && !arch_is_in_isr()) {\n\t\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);\n\n\t\tz_mark_thread_as_suspended(thread);\n\t\tz_metairq_preempted_clear(thread);\n\t\tdequeue_thread(thread);\n\t\tupdate_cache(1);\n\t\tz_swap(&_sched_spinlock, key);\n\t\treturn;\n\t}\n\n\tk_spinlock_key_t  key = k_spin_lock(&_sched_spinlock);\n\n\tif (unlikely(z_is_thread_suspended(thread))) {\n\n\t\t/* The target thread is already suspended. Nothing to do. */\n\n\t\tk_spin_unlock(&_sched_spinlock, key);\n\t\treturn;\n\t}\n\n\tz_thread_halt(thread, key, false);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, suspend, thread);\n}\n",
                {
                    "491": "void z_impl_k_thread_suspend(k_tid_t thread)",
                    "492": "{",
                    "493": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, suspend, thread);",
                    "494": "",
                    "495": "\t/* Special case \"suspend the current thread\" as it doesn't",
                    "496": "\t * need the async complexity below.",
                    "497": "\t */",
                    "498": "\tif (!IS_ENABLED(CONFIG_SMP) && (thread == _current) && !arch_is_in_isr()) {",
                    "499": "\t\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);",
                    "500": "",
                    "501": "\t\tz_mark_thread_as_suspended(thread);",
                    "502": "\t\tz_metairq_preempted_clear(thread);",
                    "503": "\t\tdequeue_thread(thread);",
                    "504": "\t\tupdate_cache(1);",
                    "505": "\t\tz_swap(&_sched_spinlock, key);",
                    "506": "\t\treturn;",
                    "507": "\t}",
                    "508": "",
                    "509": "\tk_spinlock_key_t  key = k_spin_lock(&_sched_spinlock);",
                    "510": "",
                    "511": "\tif (unlikely(z_is_thread_suspended(thread))) {",
                    "512": "",
                    "513": "\t\t/* The target thread is already suspended. Nothing to do. */",
                    "514": "",
                    "515": "\t\tk_spin_unlock(&_sched_spinlock, key);",
                    "516": "\t\treturn;",
                    "517": "\t}",
                    "518": "",
                    "519": "\tz_thread_halt(thread, key, false);",
                    "520": "",
                    "521": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, suspend, thread);",
                    "522": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_reschedule": {
            "name": "z_impl_k_reschedule",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1109,
            "function_content": [
                "#endif /* CONFIG_SCHED_DEADLINE */\nvoid z_impl_k_reschedule(void)\n{\n\tk_spinlock_key_t key;\n\n\tkey = k_spin_lock(&_sched_spinlock);\n\n\tupdate_cache(0);\n\n\tz_reschedule(&_sched_spinlock, key);\n}\n",
                {
                    "1109": "void z_impl_k_reschedule(void)",
                    "1110": "{",
                    "1111": "\tk_spinlock_key_t key;",
                    "1112": "",
                    "1113": "\tkey = k_spin_lock(&_sched_spinlock);",
                    "1114": "",
                    "1115": "\tupdate_cache(0);",
                    "1116": "",
                    "1117": "\tz_reschedule(&_sched_spinlock, key);",
                    "1118": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_yield": {
            "name": "z_impl_k_yield",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1134,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_impl_k_yield(void)\n{\n\t__ASSERT(!arch_is_in_isr(), \"\");\n\n\tSYS_PORT_TRACING_FUNC(k_thread, yield);\n\n\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);\n\n\trunq_yield();\n\n\tupdate_cache(1);\n\tz_swap(&_sched_spinlock, key);\n}\n",
                {
                    "1134": "void z_impl_k_yield(void)",
                    "1135": "{",
                    "1136": "\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "1137": "",
                    "1138": "\tSYS_PORT_TRACING_FUNC(k_thread, yield);",
                    "1139": "",
                    "1140": "\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);",
                    "1141": "",
                    "1142": "\trunq_yield();",
                    "1143": "",
                    "1144": "\tupdate_cache(1);",
                    "1145": "\tz_swap(&_sched_spinlock, key);",
                    "1146": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timer_expiration_handler": {
            "name": "z_timer_expiration_handler",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timer.c",
            "location_line": 71,
            "function_content": [
                "/**\n* @brief Handle expiration of a kernel timer object.\n*\n* @param t  Timeout used by the timer.\n*/\nvoid z_timer_expiration_handler(struct _timeout *t)\n{\n\tstruct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);\n\tstruct k_thread *thread;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\t/* In sys_clock_announce(), when a timeout expires, it is first removed\n\t * from the timeout list, then its expiration handler is called (with\n\t * unlocked interrupts). For kernel timers, the expiration handler is\n\t * this function. Usually, the timeout structure related to the timer\n\t * that is handled here will not be linked to the timeout list at this\n\t * point. But it may happen that before this function is executed and\n\t * interrupts are locked again, a given timer gets restarted from an\n\t * interrupt context that has a priority higher than the system timer\n\t * interrupt. Then, the timeout structure for this timer will turn out\n\t * to be linked to the timeout list. And in such case, since the timer\n\t * was restarted, its expiration handler should not be executed then,\n\t * so the function exits immediately.\n\t */\n\tif (sys_dnode_is_linked(&t->node)) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\t/*\n\t * if the timer is periodic, start it again; don't add _TICK_ALIGN\n\t * since we're already aligned to a tick boundary\n\t */\n\tif (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&\n\t    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {\n\t\tk_timeout_t next = timer->period;\n\n\t\t/* see note about z_add_timeout() in z_impl_k_timer_start() */\n\t\tnext.ticks = max(next.ticks - 1, 0);\n\n#ifdef CONFIG_TIMEOUT_64BIT\n\t\t/* Exploit the fact that uptime during a kernel\n\t\t * timeout handler reflects the time of the scheduled\n\t\t * event and not real time to get some inexpensive\n\t\t * protection against late interrupts.  If we're\n\t\t * delayed for any reason, we still end up calculating\n\t\t * the next expiration as a regular stride from where\n\t\t * we \"should\" have run.  Requires absolute timeouts.\n\t\t * (Note offset by one: we're nominally at the\n\t\t * beginning of a tick, so need to defeat the \"round\n\t\t * down\" behavior on timeout addition).\n\t\t */\n\t\tnext = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);\n#endif /* CONFIG_TIMEOUT_64BIT */\n\t\tz_add_timeout(&timer->timeout, z_timer_expiration_handler,\n\t\t\t      next);\n\t}\n\n\t/* update timer's status */\n\ttimer->status += 1U;\n\n\tz_timer_observer_on_expiry(timer);\n\n\t/* invoke timer expiry function */\n\tif (timer->expiry_fn != NULL) {\n\t\t/* Unlock for user handler. */\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, expiry, timer);\n\n\t\ttimer->expiry_fn(timer);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, expiry, timer);\n\n\t\tkey = k_spin_lock(&lock);\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\tthread = z_waitq_head(&timer->wait_q);\n\n\tif (thread == NULL) {\n\t\tk_spin_unlock(&lock, key);\n\t\treturn;\n\t}\n\n\tz_unpend_thread_no_timeout(thread);\n\n\tarch_thread_return_value_set(thread, 0);\n\n\tk_spin_unlock(&lock, key);\n\n\tz_ready_thread(thread);\n}\n",
                {
                    "71": "void z_timer_expiration_handler(struct _timeout *t)",
                    "72": "{",
                    "73": "\tstruct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);",
                    "74": "\tstruct k_thread *thread;",
                    "75": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "76": "",
                    "77": "\t/* In sys_clock_announce(), when a timeout expires, it is first removed",
                    "78": "\t * from the timeout list, then its expiration handler is called (with",
                    "79": "\t * unlocked interrupts). For kernel timers, the expiration handler is",
                    "80": "\t * this function. Usually, the timeout structure related to the timer",
                    "81": "\t * that is handled here will not be linked to the timeout list at this",
                    "82": "\t * point. But it may happen that before this function is executed and",
                    "83": "\t * interrupts are locked again, a given timer gets restarted from an",
                    "84": "\t * interrupt context that has a priority higher than the system timer",
                    "85": "\t * interrupt. Then, the timeout structure for this timer will turn out",
                    "86": "\t * to be linked to the timeout list. And in such case, since the timer",
                    "87": "\t * was restarted, its expiration handler should not be executed then,",
                    "88": "\t * so the function exits immediately.",
                    "89": "\t */",
                    "90": "\tif (sys_dnode_is_linked(&t->node)) {",
                    "91": "\t\tk_spin_unlock(&lock, key);",
                    "92": "\t\treturn;",
                    "93": "\t}",
                    "94": "",
                    "95": "\t/*",
                    "96": "\t * if the timer is periodic, start it again; don't add _TICK_ALIGN",
                    "97": "\t * since we're already aligned to a tick boundary",
                    "98": "\t */",
                    "99": "\tif (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&",
                    "100": "\t    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {",
                    "101": "\t\tk_timeout_t next = timer->period;",
                    "102": "",
                    "103": "\t\t/* see note about z_add_timeout() in z_impl_k_timer_start() */",
                    "104": "\t\tnext.ticks = max(next.ticks - 1, 0);",
                    "105": "",
                    "106": "#ifdef CONFIG_TIMEOUT_64BIT",
                    "107": "\t\t/* Exploit the fact that uptime during a kernel",
                    "108": "\t\t * timeout handler reflects the time of the scheduled",
                    "109": "\t\t * event and not real time to get some inexpensive",
                    "110": "\t\t * protection against late interrupts.  If we're",
                    "111": "\t\t * delayed for any reason, we still end up calculating",
                    "112": "\t\t * the next expiration as a regular stride from where",
                    "113": "\t\t * we \"should\" have run.  Requires absolute timeouts.",
                    "114": "\t\t * (Note offset by one: we're nominally at the",
                    "115": "\t\t * beginning of a tick, so need to defeat the \"round",
                    "116": "\t\t * down\" behavior on timeout addition).",
                    "117": "\t\t */",
                    "118": "\t\tnext = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);",
                    "119": "#endif /* CONFIG_TIMEOUT_64BIT */",
                    "120": "\t\tz_add_timeout(&timer->timeout, z_timer_expiration_handler,",
                    "121": "\t\t\t      next);",
                    "122": "\t}",
                    "123": "",
                    "124": "\t/* update timer's status */",
                    "125": "\ttimer->status += 1U;",
                    "126": "",
                    "127": "\tz_timer_observer_on_expiry(timer);",
                    "128": "",
                    "129": "\t/* invoke timer expiry function */",
                    "130": "\tif (timer->expiry_fn != NULL) {",
                    "131": "\t\t/* Unlock for user handler. */",
                    "132": "\t\tk_spin_unlock(&lock, key);",
                    "133": "",
                    "134": "\t\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_timer, expiry, timer);",
                    "135": "",
                    "136": "\t\ttimer->expiry_fn(timer);",
                    "137": "",
                    "138": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, expiry, timer);",
                    "139": "",
                    "140": "\t\tkey = k_spin_lock(&lock);",
                    "141": "\t}",
                    "142": "",
                    "143": "\tif (!IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "144": "\t\tk_spin_unlock(&lock, key);",
                    "145": "\t\treturn;",
                    "146": "\t}",
                    "147": "",
                    "148": "\tthread = z_waitq_head(&timer->wait_q);",
                    "149": "",
                    "150": "\tif (thread == NULL) {",
                    "151": "\t\tk_spin_unlock(&lock, key);",
                    "152": "\t\treturn;",
                    "153": "\t}",
                    "154": "",
                    "155": "\tz_unpend_thread_no_timeout(thread);",
                    "156": "",
                    "157": "\tarch_thread_return_value_set(thread, 0);",
                    "158": "",
                    "159": "\tk_spin_unlock(&lock, key);",
                    "160": "",
                    "161": "\tz_ready_thread(thread);",
                    "162": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_poll_event_init": {
            "name": "k_poll_event_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 43,
            "function_content": [
                "/* Single subsystem lock.  Locking per-event would be better on highly\n* contended SMP systems, but the original locking scheme here is\n* subtle (it relies on releasing/reacquiring the lock in areas for\n* latency control and it's sometimes hard to see exactly what data is\n* \"inside\" a given critical section).  Do the synchronization port\n* later as an optimization.\n*/\nvoid k_poll_event_init(struct k_poll_event *event, uint32_t type,\n\t\t       int mode, void *obj)\n{\n\t__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,\n\t\t \"only NOTIFY_ONLY mode is supported\\n\");\n\t__ASSERT(type < (BIT(_POLL_NUM_TYPES)), \"invalid type\\n\");\n\t__ASSERT(obj != NULL, \"must provide an object\\n\");\n\n\tevent->poller = NULL;\n\t/* event->tag is left uninitialized: the user will set it if needed */\n\tevent->type = type;\n\tevent->state = K_POLL_STATE_NOT_READY;\n\tevent->mode = mode;\n\tevent->unused = 0U;\n\tevent->obj = obj;\n\n\tSYS_PORT_TRACING_FUNC(k_poll_api, event_init, event);\n}\n",
                {
                    "43": "void k_poll_event_init(struct k_poll_event *event, uint32_t type,",
                    "44": "\t\t       int mode, void *obj)",
                    "45": "{",
                    "46": "\t__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,",
                    "47": "\t\t \"only NOTIFY_ONLY mode is supported\\n\");",
                    "48": "\t__ASSERT(type < (BIT(_POLL_NUM_TYPES)), \"invalid type\\n\");",
                    "49": "\t__ASSERT(obj != NULL, \"must provide an object\\n\");",
                    "50": "",
                    "51": "\tevent->poller = NULL;",
                    "52": "\t/* event->tag is left uninitialized: the user will set it if needed */",
                    "53": "\tevent->type = type;",
                    "54": "\tevent->state = K_POLL_STATE_NOT_READY;",
                    "55": "\tevent->mode = mode;",
                    "56": "\tevent->unused = 0U;",
                    "57": "\tevent->obj = obj;",
                    "58": "",
                    "59": "\tSYS_PORT_TRACING_FUNC(k_poll_api, event_init, event);",
                    "60": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_init": {
            "name": "k_heap_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/kheap.c",
            "location_line": 26,
            "function_content": [
                "/* Number of statically defined heaps */\nvoid k_heap_init(struct k_heap *heap, void *mem, size_t bytes)\n{\n\tz_waitq_init(&heap->wait_q);\n\theap->lock = (struct k_spinlock) {};\n\tsys_heap_init(&heap->heap, mem, bytes);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);\n}\n",
                {
                    "26": "void k_heap_init(struct k_heap *heap, void *mem, size_t bytes)",
                    "27": "{",
                    "28": "\tz_waitq_init(&heap->wait_q);",
                    "29": "\theap->lock = (struct k_spinlock) {};",
                    "30": "\tsys_heap_init(&heap->heap, mem, bytes);",
                    "31": "",
                    "32": "\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);",
                    "33": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_free": {
            "name": "k_mem_slab_free",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 271,
            "function_content": [
                "/* wait for a free block or timeout */\nvoid k_mem_slab_free(struct k_mem_slab *slab, void *mem)\n{\n\tif (!slab_ptr_is_good(slab, mem)) {\n\t\t__ASSERT(false, \"Invalid memory pointer provided\");\n\t\tk_panic();\n\t\treturn;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&slab->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);\n\tif (unlikely(slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tstruct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);\n\n\t\tif (unlikely(pending_thread != NULL)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);\n\n\t\t\tz_thread_return_value_set_with_data(pending_thread, 0, mem);\n\t\t\tz_ready_thread(pending_thread);\n\t\t\tz_reschedule(&slab->lock, key);\n\t\t\treturn;\n\t\t}\n\t}\n\t*(char **) mem = slab->free_list;\n\tslab->free_list = (char *) mem;\n\tslab->info.num_used--;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);\n\n\tk_spin_unlock(&slab->lock, key);\n}\n",
                {
                    "271": "void k_mem_slab_free(struct k_mem_slab *slab, void *mem)",
                    "272": "{",
                    "273": "\tif (!slab_ptr_is_good(slab, mem)) {",
                    "274": "\t\t__ASSERT(false, \"Invalid memory pointer provided\");",
                    "275": "\t\tk_panic();",
                    "276": "\t\treturn;",
                    "277": "\t}",
                    "278": "",
                    "279": "\tk_spinlock_key_t key = k_spin_lock(&slab->lock);",
                    "280": "",
                    "281": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);",
                    "282": "\tif (unlikely(slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "283": "\t\tstruct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);",
                    "284": "",
                    "285": "\t\tif (unlikely(pending_thread != NULL)) {",
                    "286": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);",
                    "287": "",
                    "288": "\t\t\tz_thread_return_value_set_with_data(pending_thread, 0, mem);",
                    "289": "\t\t\tz_ready_thread(pending_thread);",
                    "290": "\t\t\tz_reschedule(&slab->lock, key);",
                    "291": "\t\t\treturn;",
                    "292": "\t\t}",
                    "293": "\t}",
                    "294": "\t*(char **) mem = slab->free_list;",
                    "295": "\tslab->free_list = (char *) mem;",
                    "296": "\tslab->info.num_used--;",
                    "297": "",
                    "298": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);",
                    "299": "",
                    "300": "\tk_spin_unlock(&slab->lock, key);",
                    "301": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_init": {
            "name": "k_mem_slab_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 172,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\nint k_mem_slab_init(struct k_mem_slab *slab, void *buffer,\n\t\t    size_t block_size, uint32_t num_blocks)\n{\n\tint rc;\n\n\tslab->info.num_blocks = num_blocks;\n\tslab->info.block_size = block_size;\n\tslab->buffer = buffer;\n\tslab->info.num_used = 0U;\n\tslab->lock = (struct k_spinlock) {};\n\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\tslab->info.max_used = 0U;\n#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */\n\n\trc = create_free_list(slab);\n\tif (rc < 0) {\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_OBJ_CORE_MEM_SLAB\n\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);\n#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\n#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB\n\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,\n\t\t\t\t  sizeof(struct k_mem_slab_info));\n#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */\n\n\tz_waitq_init(&slab->wait_q);\n\tk_object_init(slab);\nout:\n\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);\n\n\treturn rc;\n}\n",
                {
                    "172": "int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,",
                    "173": "\t\t    size_t block_size, uint32_t num_blocks)",
                    "174": "{",
                    "175": "\tint rc;",
                    "176": "",
                    "177": "\tslab->info.num_blocks = num_blocks;",
                    "178": "\tslab->info.block_size = block_size;",
                    "179": "\tslab->buffer = buffer;",
                    "180": "\tslab->info.num_used = 0U;",
                    "181": "\tslab->lock = (struct k_spinlock) {};",
                    "182": "",
                    "183": "#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION",
                    "184": "\tslab->info.max_used = 0U;",
                    "185": "#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */",
                    "186": "",
                    "187": "\trc = create_free_list(slab);",
                    "188": "\tif (rc < 0) {",
                    "189": "\t\tgoto out;",
                    "190": "\t}",
                    "191": "",
                    "192": "#ifdef CONFIG_OBJ_CORE_MEM_SLAB",
                    "193": "\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);",
                    "194": "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */",
                    "195": "#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB",
                    "196": "\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,",
                    "197": "\t\t\t\t  sizeof(struct k_mem_slab_info));",
                    "198": "#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */",
                    "199": "",
                    "200": "\tz_waitq_init(&slab->wait_q);",
                    "201": "\tk_object_init(slab);",
                    "202": "out:",
                    "203": "\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);",
                    "204": "",
                    "205": "\treturn rc;",
                    "206": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_get": {
            "name": "k_mbox_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 382,
            "function_content": [
                "/* keep message around for later data retrieval */\nint k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,\n\t       k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_mbox_msg *tx_msg;\n\tk_spinlock_key_t key;\n\tint result;\n\n\t/* save receiver id so it can be used during message matching */\n\trx_msg->tx_target_thread = _current;\n\n\t/* search mailbox's tx queue for a compatible sender */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {\n\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take sender out of mailbox's tx queue */\n\t\t\tz_unpend_thread(sending_thread);\n\n\t\t\tk_spin_unlock(&mbox->lock, key);\n\n\t\t\t/* consume message data immediately, if needed */\n\t\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* didn't find a matching sender */\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);\n\n\t\t/* don't wait for a matching sender to appear */\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);\n\n\t/* wait until a matching sender appears or a timeout occurs */\n\t_current->base.swap_data = rx_msg;\n\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);\n\n\t/* consume message data immediately, if needed */\n\tif (result == 0) {\n\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\n\treturn result;\n}\n",
                {
                    "382": "int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,",
                    "383": "\t       k_timeout_t timeout)",
                    "384": "{",
                    "385": "\tstruct k_thread *sending_thread;",
                    "386": "\tstruct k_mbox_msg *tx_msg;",
                    "387": "\tk_spinlock_key_t key;",
                    "388": "\tint result;",
                    "389": "",
                    "390": "\t/* save receiver id so it can be used during message matching */",
                    "391": "\trx_msg->tx_target_thread = _current;",
                    "392": "",
                    "393": "\t/* search mailbox's tx queue for a compatible sender */",
                    "394": "\tkey = k_spin_lock(&mbox->lock);",
                    "395": "",
                    "396": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);",
                    "397": "",
                    "398": "\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {",
                    "399": "\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;",
                    "400": "",
                    "401": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "402": "\t\t\t/* take sender out of mailbox's tx queue */",
                    "403": "\t\t\tz_unpend_thread(sending_thread);",
                    "404": "",
                    "405": "\t\t\tk_spin_unlock(&mbox->lock, key);",
                    "406": "",
                    "407": "\t\t\t/* consume message data immediately, if needed */",
                    "408": "\t\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "409": "",
                    "410": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "411": "\t\t\treturn result;",
                    "412": "\t\t}",
                    "413": "\t}",
                    "414": "",
                    "415": "\t/* didn't find a matching sender */",
                    "416": "",
                    "417": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "418": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);",
                    "419": "",
                    "420": "\t\t/* don't wait for a matching sender to appear */",
                    "421": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "422": "\t\treturn -ENOMSG;",
                    "423": "\t}",
                    "424": "",
                    "425": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);",
                    "426": "",
                    "427": "\t/* wait until a matching sender appears or a timeout occurs */",
                    "428": "\t_current->base.swap_data = rx_msg;",
                    "429": "\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);",
                    "430": "",
                    "431": "\t/* consume message data immediately, if needed */",
                    "432": "\tif (result == 0) {",
                    "433": "\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "434": "\t}",
                    "435": "",
                    "436": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "437": "",
                    "438": "\treturn result;",
                    "439": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_init": {
            "name": "k_mbox_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 87,
            "function_content": [
                "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS > 0 */\nvoid k_mbox_init(struct k_mbox *mbox)\n{\n\tz_waitq_init(&mbox->tx_msg_queue);\n\tz_waitq_init(&mbox->rx_msg_queue);\n\tmbox->lock = (struct k_spinlock) {};\n\n#ifdef CONFIG_OBJ_CORE_MAILBOX\n\tk_obj_core_init_and_link(K_OBJ_CORE(mbox), &obj_type_mailbox);\n#endif /* CONFIG_OBJ_CORE_MAILBOX */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_mbox, mbox);\n}\n",
                {
                    "87": "void k_mbox_init(struct k_mbox *mbox)",
                    "88": "{",
                    "89": "\tz_waitq_init(&mbox->tx_msg_queue);",
                    "90": "\tz_waitq_init(&mbox->rx_msg_queue);",
                    "91": "\tmbox->lock = (struct k_spinlock) {};",
                    "92": "",
                    "93": "#ifdef CONFIG_OBJ_CORE_MAILBOX",
                    "94": "\tk_obj_core_init_and_link(K_OBJ_CORE(mbox), &obj_type_mailbox);",
                    "95": "#endif /* CONFIG_OBJ_CORE_MAILBOX */",
                    "96": "",
                    "97": "\tSYS_PORT_TRACING_OBJ_INIT(k_mbox, mbox);",
                    "98": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_cleanup": {
            "name": "k_msgq_cleanup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 106,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_msgq_cleanup(struct k_msgq *msgq)\n{\n\tint ret = 0;\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);\n\n\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {\n\t\tk_free(msgq->buffer_start);\n\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;\n\t}\n\nexit:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, ret);\n\treturn ret;\n}\n",
                {
                    "106": "int k_msgq_cleanup(struct k_msgq *msgq)",
                    "107": "{",
                    "108": "\tint ret = 0;",
                    "109": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);",
                    "110": "",
                    "111": "\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {",
                    "112": "\t\tret = -EBUSY;",
                    "113": "\t\tgoto exit;",
                    "114": "\t}",
                    "115": "",
                    "116": "\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {",
                    "117": "\t\tk_free(msgq->buffer_start);",
                    "118": "\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;",
                    "119": "\t}",
                    "120": "",
                    "121": "exit:",
                    "122": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, ret);",
                    "123": "\treturn ret;",
                    "124": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_init": {
            "name": "k_msgq_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 43,
            "function_content": [
                "#endif /* CONFIG_POLL */\nvoid k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,\n\t\t uint32_t max_msgs)\n{\n\tmsgq->msg_size = msg_size;\n\tmsgq->max_msgs = max_msgs;\n\tmsgq->buffer_start = buffer;\n\tmsgq->buffer_end = buffer + (max_msgs * msg_size);\n\tmsgq->read_ptr = buffer;\n\tmsgq->write_ptr = buffer;\n\tmsgq->used_msgs = 0;\n\tmsgq->flags = 0;\n\tz_waitq_init(&msgq->wait_q);\n\tmsgq->lock = (struct k_spinlock) {};\n#ifdef CONFIG_POLL\n\tsys_dlist_init(&msgq->poll_events);\n#endif\t/* CONFIG_POLL */\n\n#ifdef CONFIG_OBJ_CORE_MSGQ\n\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);\n#endif /* CONFIG_OBJ_CORE_MSGQ */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);\n\n\tk_object_init(msgq);\n}\n",
                {
                    "43": "void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,",
                    "44": "\t\t uint32_t max_msgs)",
                    "45": "{",
                    "46": "\tmsgq->msg_size = msg_size;",
                    "47": "\tmsgq->max_msgs = max_msgs;",
                    "48": "\tmsgq->buffer_start = buffer;",
                    "49": "\tmsgq->buffer_end = buffer + (max_msgs * msg_size);",
                    "50": "\tmsgq->read_ptr = buffer;",
                    "51": "\tmsgq->write_ptr = buffer;",
                    "52": "\tmsgq->used_msgs = 0;",
                    "53": "\tmsgq->flags = 0;",
                    "54": "\tz_waitq_init(&msgq->wait_q);",
                    "55": "\tmsgq->lock = (struct k_spinlock) {};",
                    "56": "#ifdef CONFIG_POLL",
                    "57": "\tsys_dlist_init(&msgq->poll_events);",
                    "58": "#endif\t/* CONFIG_POLL */",
                    "59": "",
                    "60": "#ifdef CONFIG_OBJ_CORE_MSGQ",
                    "61": "\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);",
                    "62": "#endif /* CONFIG_OBJ_CORE_MSGQ */",
                    "63": "",
                    "64": "\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);",
                    "65": "",
                    "66": "\tk_object_init(msgq);",
                    "67": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_poll_submit_to_queue": {
            "name": "k_work_poll_submit_to_queue",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 661,
            "function_content": [
                "/*\n* If we reached here, the work is either being registered in\n* the k_work_poll_submit_to_queue(), executed or is pending.\n* Only in the last case we have a chance to cancel it, but\n* unfortunately there is no public API performing this task.\n*/\nint k_work_poll_submit_to_queue(struct k_work_q *work_q,\n\t\t\t\tstruct k_work_poll *work,\n\t\t\t\tstruct k_poll_event *events,\n\t\t\t\tint num_events,\n\t\t\t\tk_timeout_t timeout)\n{\n\tint events_registered;\n\tk_spinlock_key_t key;\n\n\t__ASSERT(work_q != NULL, \"NULL work_q\\n\");\n\t__ASSERT(work != NULL, \"NULL work\\n\");\n\t__ASSERT(events != NULL, \"NULL events\\n\");\n\t__ASSERT(num_events >= 0, \"<0 events\\n\");\n\n\tSYS_PORT_TRACING_FUNC_ENTER(k_work_poll, submit_to_queue, work_q, work, timeout);\n\n\t/* Take ownership of the work if it is possible. */\n\tkey = k_spin_lock(&lock);\n\tif (work->workq != NULL) {\n\t\tif (work->workq == work_q) {\n\t\t\tint retval;\n\n\t\t\tretval = triggered_work_cancel(work, key);\n\t\t\tif (retval < 0) {\n\t\t\t\tk_spin_unlock(&lock, key);\n\n\t\t\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q,\n\t\t\t\t\twork, timeout, retval);\n\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t} else {\n\t\t\tk_spin_unlock(&lock, key);\n\n\t\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q,\n\t\t\t\twork, timeout, -EADDRINUSE);\n\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\t}\n\n\n\twork->poller.is_polling = true;\n\twork->workq = work_q;\n\twork->poller.mode = MODE_NONE;\n\tk_spin_unlock(&lock, key);\n\n\t/* Save list of events. */\n\twork->events = events;\n\twork->num_events = num_events;\n\n\t/* Clear result */\n\twork->poll_result = -EINPROGRESS;\n\n\t/* Register events */\n\tevents_registered = register_events(events, num_events,\n\t\t\t\t\t    &work->poller, false);\n\n\tkey = k_spin_lock(&lock);\n\tif (work->poller.is_polling && !K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t/*\n\t\t * Poller is still polling.\n\t\t * No event is ready and all are watched.\n\t\t */\n\t\t__ASSERT(num_events == events_registered,\n\t\t\t \"Some events were not registered!\\n\");\n\n\t\t/* Setup timeout if such action is requested */\n\t\tif (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\t\tz_add_timeout(&work->timeout,\n\t\t\t\t      triggered_work_expiration_handler,\n\t\t\t\t      timeout);\n\t\t}\n\n\t\t/* From now, any event will result in submitted work. */\n\t\twork->poller.mode = MODE_TRIGGERED;\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q, work, timeout, 0);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The K_NO_WAIT timeout was specified or at least one event\n\t * was ready at registration time or changed state since\n\t * registration. Hopefully, the poller mode was not set, so\n\t * work was not submitted to workqueue.\n\t */\n\n\t/*\n\t * If poller is still polling, no watched event occurred. This means\n\t * we reached here due to K_NO_WAIT timeout \"expiration\".\n\t */\n\tif (work->poller.is_polling) {\n\t\twork->poller.is_polling = false;\n\t\twork->poll_result = -EAGAIN;\n\t} else {\n\t\twork->poll_result = 0;\n\t}\n\n\t/* Clear registrations. */\n\tclear_event_registrations(events, events_registered, key);\n\tk_spin_unlock(&lock, key);\n\n\t/* Submit work. */\n\tk_work_submit_to_queue(work_q, &work->work);\n\n\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q, work, timeout, 0);\n\n\treturn 0;\n}\n",
                {
                    "661": "int k_work_poll_submit_to_queue(struct k_work_q *work_q,",
                    "662": "\t\t\t\tstruct k_work_poll *work,",
                    "663": "\t\t\t\tstruct k_poll_event *events,",
                    "664": "\t\t\t\tint num_events,",
                    "665": "\t\t\t\tk_timeout_t timeout)",
                    "666": "{",
                    "667": "\tint events_registered;",
                    "668": "\tk_spinlock_key_t key;",
                    "669": "",
                    "670": "\t__ASSERT(work_q != NULL, \"NULL work_q\\n\");",
                    "671": "\t__ASSERT(work != NULL, \"NULL work\\n\");",
                    "672": "\t__ASSERT(events != NULL, \"NULL events\\n\");",
                    "673": "\t__ASSERT(num_events >= 0, \"<0 events\\n\");",
                    "674": "",
                    "675": "\tSYS_PORT_TRACING_FUNC_ENTER(k_work_poll, submit_to_queue, work_q, work, timeout);",
                    "676": "",
                    "677": "\t/* Take ownership of the work if it is possible. */",
                    "678": "\tkey = k_spin_lock(&lock);",
                    "679": "\tif (work->workq != NULL) {",
                    "680": "\t\tif (work->workq == work_q) {",
                    "681": "\t\t\tint retval;",
                    "682": "",
                    "683": "\t\t\tretval = triggered_work_cancel(work, key);",
                    "684": "\t\t\tif (retval < 0) {",
                    "685": "\t\t\t\tk_spin_unlock(&lock, key);",
                    "686": "",
                    "687": "\t\t\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q,",
                    "688": "\t\t\t\t\twork, timeout, retval);",
                    "689": "",
                    "690": "\t\t\t\treturn retval;",
                    "691": "\t\t\t}",
                    "692": "\t\t} else {",
                    "693": "\t\t\tk_spin_unlock(&lock, key);",
                    "694": "",
                    "695": "\t\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q,",
                    "696": "\t\t\t\twork, timeout, -EADDRINUSE);",
                    "697": "",
                    "698": "\t\t\treturn -EADDRINUSE;",
                    "699": "\t\t}",
                    "700": "\t}",
                    "701": "",
                    "702": "",
                    "703": "\twork->poller.is_polling = true;",
                    "704": "\twork->workq = work_q;",
                    "705": "\twork->poller.mode = MODE_NONE;",
                    "706": "\tk_spin_unlock(&lock, key);",
                    "707": "",
                    "708": "\t/* Save list of events. */",
                    "709": "\twork->events = events;",
                    "710": "\twork->num_events = num_events;",
                    "711": "",
                    "712": "\t/* Clear result */",
                    "713": "\twork->poll_result = -EINPROGRESS;",
                    "714": "",
                    "715": "\t/* Register events */",
                    "716": "\tevents_registered = register_events(events, num_events,",
                    "717": "\t\t\t\t\t    &work->poller, false);",
                    "718": "",
                    "719": "\tkey = k_spin_lock(&lock);",
                    "720": "\tif (work->poller.is_polling && !K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "721": "\t\t/*",
                    "722": "\t\t * Poller is still polling.",
                    "723": "\t\t * No event is ready and all are watched.",
                    "724": "\t\t */",
                    "725": "\t\t__ASSERT(num_events == events_registered,",
                    "726": "\t\t\t \"Some events were not registered!\\n\");",
                    "727": "",
                    "728": "\t\t/* Setup timeout if such action is requested */",
                    "729": "\t\tif (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {",
                    "730": "\t\t\tz_add_timeout(&work->timeout,",
                    "731": "\t\t\t\t      triggered_work_expiration_handler,",
                    "732": "\t\t\t\t      timeout);",
                    "733": "\t\t}",
                    "734": "",
                    "735": "\t\t/* From now, any event will result in submitted work. */",
                    "736": "\t\twork->poller.mode = MODE_TRIGGERED;",
                    "737": "\t\tk_spin_unlock(&lock, key);",
                    "738": "",
                    "739": "\t\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q, work, timeout, 0);",
                    "740": "",
                    "741": "\t\treturn 0;",
                    "742": "\t}",
                    "743": "",
                    "744": "\t/*",
                    "745": "\t * The K_NO_WAIT timeout was specified or at least one event",
                    "746": "\t * was ready at registration time or changed state since",
                    "747": "\t * registration. Hopefully, the poller mode was not set, so",
                    "748": "\t * work was not submitted to workqueue.",
                    "749": "\t */",
                    "750": "",
                    "751": "\t/*",
                    "752": "\t * If poller is still polling, no watched event occurred. This means",
                    "753": "\t * we reached here due to K_NO_WAIT timeout \"expiration\".",
                    "754": "\t */",
                    "755": "\tif (work->poller.is_polling) {",
                    "756": "\t\twork->poller.is_polling = false;",
                    "757": "\t\twork->poll_result = -EAGAIN;",
                    "758": "\t} else {",
                    "759": "\t\twork->poll_result = 0;",
                    "760": "\t}",
                    "761": "",
                    "762": "\t/* Clear registrations. */",
                    "763": "\tclear_event_registrations(events, events_registered, key);",
                    "764": "\tk_spin_unlock(&lock, key);",
                    "765": "",
                    "766": "\t/* Submit work. */",
                    "767": "\tk_work_submit_to_queue(work_q, &work->work);",
                    "768": "",
                    "769": "\tSYS_PORT_TRACING_FUNC_EXIT(k_work_poll, submit_to_queue, work_q, work, timeout, 0);",
                    "770": "",
                    "771": "\treturn 0;",
                    "772": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_poll_init": {
            "name": "k_work_poll_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 648,
            "function_content": [
                "/*\n* If we reached here, the work is either being registered in\n* the k_work_poll_submit_to_queue(), executed or is pending.\n* Only in the last case we have a chance to cancel it, but\n* unfortunately there is no public API performing this task.\n*/\nvoid k_work_poll_init(struct k_work_poll *work,\n\t\t      k_work_handler_t handler)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_poll, init, work);\n\n\t*work = (struct k_work_poll) {};\n\tk_work_init(&work->work, triggered_work_handler);\n\twork->real_handler = handler;\n\tz_init_timeout(&work->timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_poll, init, work);\n}\n",
                {
                    "648": "void k_work_poll_init(struct k_work_poll *work,",
                    "649": "\t\t      k_work_handler_t handler)",
                    "650": "{",
                    "651": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_poll, init, work);",
                    "652": "",
                    "653": "\t*work = (struct k_work_poll) {};",
                    "654": "\tk_work_init(&work->work, triggered_work_handler);",
                    "655": "\twork->real_handler = handler;",
                    "656": "\tz_init_timeout(&work->timeout);",
                    "657": "",
                    "658": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_poll, init, work);",
                    "659": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_cancel_delayable_sync": {
            "name": "k_work_cancel_delayable_sync",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 1194,
            "function_content": [
                "/* Schedule the work item with the new parameters. */\nbool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,\n\t\t\t\t  struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);\n\n\tstruct z_work_canceller *canceller = &sync->canceller;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tbool pending = (work_delayable_busy_get_locked(dwork) != 0U);\n\tbool need_wait = false;\n\n\tif (pending) {\n\t\t(void)cancel_delayable_async_locked(dwork);\n\t\tneed_wait = cancel_sync_locked(&dwork->work, canceller);\n\t}\n\n\tk_spin_unlock(&lock, key);\n\n\tif (need_wait) {\n\t\tk_sem_take(&canceller->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);\n\treturn pending;\n}\n",
                {
                    "1194": "bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,",
                    "1195": "\t\t\t\t  struct k_work_sync *sync)",
                    "1196": "{",
                    "1197": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "1198": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "1199": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "1200": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "1201": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));",
                    "1202": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "1203": "",
                    "1204": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);",
                    "1205": "",
                    "1206": "\tstruct z_work_canceller *canceller = &sync->canceller;",
                    "1207": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "1208": "\tbool pending = (work_delayable_busy_get_locked(dwork) != 0U);",
                    "1209": "\tbool need_wait = false;",
                    "1210": "",
                    "1211": "\tif (pending) {",
                    "1212": "\t\t(void)cancel_delayable_async_locked(dwork);",
                    "1213": "\t\tneed_wait = cancel_sync_locked(&dwork->work, canceller);",
                    "1214": "\t}",
                    "1215": "",
                    "1216": "\tk_spin_unlock(&lock, key);",
                    "1217": "",
                    "1218": "\tif (need_wait) {",
                    "1219": "\t\tk_sem_take(&canceller->sem, K_FOREVER);",
                    "1220": "\t}",
                    "1221": "",
                    "1222": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);",
                    "1223": "\treturn pending;",
                    "1224": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_flush_delayable": {
            "name": "k_work_flush_delayable",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 1226,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nbool k_work_flush_delayable(struct k_work_delayable *dwork,\n\t\t\t    struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush_delayable, dwork, sync);\n\n\tstruct k_work *work = &dwork->work;\n\tstruct z_work_flusher *flusher = &sync->flusher;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\t/* If it's idle release the lock and return immediately. */\n\tif (work_busy_get_locked(work) == 0U) {\n\t\tk_spin_unlock(&lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, false);\n\n\t\treturn false;\n\t}\n\n\t/* If unscheduling did something then submit it.  Ignore a\n\t * failed submission (e.g. when cancelling).\n\t */\n\tif (unschedule_locked(dwork)) {\n\t\tstruct k_work_q *queue = dwork->queue;\n\n\t\t(void)submit_to_queue_locked(work, &queue);\n\t}\n\n\t/* Wait for it to finish */\n\tbool need_flush = work_flush_locked(work, flusher);\n\n\tk_spin_unlock(&lock, key);\n\n\t/* If necessary wait until the flusher item completes */\n\tif (need_flush) {\n\t\tk_sem_take(&flusher->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, need_flush);\n\n\treturn need_flush;\n}\n",
                {
                    "1226": "bool k_work_flush_delayable(struct k_work_delayable *dwork,",
                    "1227": "\t\t\t    struct k_work_sync *sync)",
                    "1228": "{",
                    "1229": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "1230": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "1231": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "1232": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "1233": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));",
                    "1234": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "1235": "",
                    "1236": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush_delayable, dwork, sync);",
                    "1237": "",
                    "1238": "\tstruct k_work *work = &dwork->work;",
                    "1239": "\tstruct z_work_flusher *flusher = &sync->flusher;",
                    "1240": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "1241": "",
                    "1242": "\t/* If it's idle release the lock and return immediately. */",
                    "1243": "\tif (work_busy_get_locked(work) == 0U) {",
                    "1244": "\t\tk_spin_unlock(&lock, key);",
                    "1245": "",
                    "1246": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, false);",
                    "1247": "",
                    "1248": "\t\treturn false;",
                    "1249": "\t}",
                    "1250": "",
                    "1251": "\t/* If unscheduling did something then submit it.  Ignore a",
                    "1252": "\t * failed submission (e.g. when cancelling).",
                    "1253": "\t */",
                    "1254": "\tif (unschedule_locked(dwork)) {",
                    "1255": "\t\tstruct k_work_q *queue = dwork->queue;",
                    "1256": "",
                    "1257": "\t\t(void)submit_to_queue_locked(work, &queue);",
                    "1258": "\t}",
                    "1259": "",
                    "1260": "\t/* Wait for it to finish */",
                    "1261": "\tbool need_flush = work_flush_locked(work, flusher);",
                    "1262": "",
                    "1263": "\tk_spin_unlock(&lock, key);",
                    "1264": "",
                    "1265": "\t/* If necessary wait until the flusher item completes */",
                    "1266": "\tif (need_flush) {",
                    "1267": "\t\tk_sem_take(&flusher->sem, K_FOREVER);",
                    "1268": "\t}",
                    "1269": "",
                    "1270": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush_delayable, dwork, sync, need_flush);",
                    "1271": "",
                    "1272": "\treturn need_flush;",
                    "1273": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_init_delayable": {
            "name": "k_work_init_delayable",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 989,
            "function_content": [
                "/* If the work is still marked delayed (should be) then clear that\n* state and submit it to the queue.  If successful the queue will be\n* notified of new work at the next reschedule point.\n*\n* If not successful there is no notification that the work has been\n* abandoned.  Sorry.\n*/\nvoid k_work_init_delayable(struct k_work_delayable *dwork,\n\t\t\t    k_work_handler_t handler)\n{\n\t__ASSERT_NO_MSG(dwork != NULL);\n\t__ASSERT_NO_MSG(handler != NULL);\n\n\t*dwork = (struct k_work_delayable)Z_WORK_DELAYABLE_INITIALIZER(handler);\n\n\tz_init_timeout(&dwork->timeout);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_work_delayable, dwork);\n}\n",
                {
                    "989": "void k_work_init_delayable(struct k_work_delayable *dwork,",
                    "990": "\t\t\t    k_work_handler_t handler)",
                    "991": "{",
                    "992": "\t__ASSERT_NO_MSG(dwork != NULL);",
                    "993": "\t__ASSERT_NO_MSG(handler != NULL);",
                    "994": "",
                    "995": "\t*dwork = (struct k_work_delayable)Z_WORK_DELAYABLE_INITIALIZER(handler);",
                    "996": "",
                    "997": "\tz_init_timeout(&dwork->timeout);",
                    "998": "",
                    "999": "\tSYS_PORT_TRACING_OBJ_INIT(k_work_delayable, dwork);",
                    "1000": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_queue_run": {
            "name": "k_work_queue_run",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 782,
            "function_content": [
                "/* Optionally yield to prevent the work queue from\n* starving other threads.\n*/\nvoid k_work_queue_run(struct k_work_q *queue, const struct k_work_queue_config *cfg)\n{\n\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));\n\n\tuint32_t flags = K_WORK_QUEUE_STARTED;\n\n\tif ((cfg != NULL) && cfg->no_yield) {\n\t\tflags |= K_WORK_QUEUE_NO_YIELD;\n\t}\n\n\tif ((cfg != NULL) && (cfg->name != NULL)) {\n\t\tk_thread_name_set(_current, cfg->name);\n\t}\n\n#if defined(CONFIG_WORKQUEUE_WORK_TIMEOUT)\n\tif ((cfg != NULL) && (cfg->work_timeout_ms)) {\n\t\tqueue->work_timeout = K_MSEC(cfg->work_timeout_ms);\n\t} else {\n\t\tqueue->work_timeout = K_FOREVER;\n\t}\n#endif /* defined(CONFIG_WORKQUEUE_WORK_TIMEOUT) */\n\n\tsys_slist_init(&queue->pending);\n\tz_waitq_init(&queue->notifyq);\n\tz_waitq_init(&queue->drainq);\n\tqueue->thread_id = _current;\n\tflags_set(&queue->flags, flags);\n\twork_queue_main(queue, NULL, NULL);\n}\n",
                {
                    "782": "void k_work_queue_run(struct k_work_q *queue, const struct k_work_queue_config *cfg)",
                    "783": "{",
                    "784": "\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));",
                    "785": "",
                    "786": "\tuint32_t flags = K_WORK_QUEUE_STARTED;",
                    "787": "",
                    "788": "\tif ((cfg != NULL) && cfg->no_yield) {",
                    "789": "\t\tflags |= K_WORK_QUEUE_NO_YIELD;",
                    "790": "\t}",
                    "791": "",
                    "792": "\tif ((cfg != NULL) && (cfg->name != NULL)) {",
                    "793": "\t\tk_thread_name_set(_current, cfg->name);",
                    "794": "\t}",
                    "795": "",
                    "796": "#if defined(CONFIG_WORKQUEUE_WORK_TIMEOUT)",
                    "797": "\tif ((cfg != NULL) && (cfg->work_timeout_ms)) {",
                    "798": "\t\tqueue->work_timeout = K_MSEC(cfg->work_timeout_ms);",
                    "799": "\t} else {",
                    "800": "\t\tqueue->work_timeout = K_FOREVER;",
                    "801": "\t}",
                    "802": "#endif /* defined(CONFIG_WORKQUEUE_WORK_TIMEOUT) */",
                    "803": "",
                    "804": "\tsys_slist_init(&queue->pending);",
                    "805": "\tz_waitq_init(&queue->notifyq);",
                    "806": "\tz_waitq_init(&queue->drainq);",
                    "807": "\tqueue->thread_id = _current;",
                    "808": "\tflags_set(&queue->flags, flags);",
                    "809": "\twork_queue_main(queue, NULL, NULL);",
                    "810": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_queue_start": {
            "name": "k_work_queue_start",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 812,
            "function_content": [
                "#endif /* defined(CONFIG_WORKQUEUE_WORK_TIMEOUT) */\nvoid k_work_queue_start(struct k_work_q *queue,\n\t\t\tk_thread_stack_t *stack,\n\t\t\tsize_t stack_size,\n\t\t\tint prio,\n\t\t\tconst struct k_work_queue_config *cfg)\n{\n\t__ASSERT_NO_MSG(queue);\n\t__ASSERT_NO_MSG(stack);\n\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));\n\n\tuint32_t flags = K_WORK_QUEUE_STARTED;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);\n\n\tsys_slist_init(&queue->pending);\n\tz_waitq_init(&queue->notifyq);\n\tz_waitq_init(&queue->drainq);\n\n\tif ((cfg != NULL) && cfg->no_yield) {\n\t\tflags |= K_WORK_QUEUE_NO_YIELD;\n\t}\n\n\t/* It hasn't actually been started yet, but all the state is in place\n\t * so we can submit things and once the thread gets control it's ready\n\t * to roll.\n\t */\n\tflags_set(&queue->flags, flags);\n\n\t(void)k_thread_create(&queue->thread, stack, stack_size,\n\t\t\t      work_queue_main, queue, NULL, NULL,\n\t\t\t      prio, 0, K_FOREVER);\n\n\tif ((cfg != NULL) && (cfg->name != NULL)) {\n\t\tk_thread_name_set(&queue->thread, cfg->name);\n\t}\n\n\tif ((cfg != NULL) && (cfg->essential)) {\n\t\tqueue->thread.base.user_options |= K_ESSENTIAL;\n\t}\n\n#if defined(CONFIG_WORKQUEUE_WORK_TIMEOUT)\n\tif ((cfg != NULL) && (cfg->work_timeout_ms)) {\n\t\tqueue->work_timeout = K_MSEC(cfg->work_timeout_ms);\n\t} else {\n\t\tqueue->work_timeout = K_FOREVER;\n\t}\n#endif /* defined(CONFIG_WORKQUEUE_WORK_TIMEOUT) */\n\n\tk_thread_start(&queue->thread);\n\tqueue->thread_id = &queue->thread;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);\n}\n",
                {
                    "812": "void k_work_queue_start(struct k_work_q *queue,",
                    "813": "\t\t\tk_thread_stack_t *stack,",
                    "814": "\t\t\tsize_t stack_size,",
                    "815": "\t\t\tint prio,",
                    "816": "\t\t\tconst struct k_work_queue_config *cfg)",
                    "817": "{",
                    "818": "\t__ASSERT_NO_MSG(queue);",
                    "819": "\t__ASSERT_NO_MSG(stack);",
                    "820": "\t__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));",
                    "821": "",
                    "822": "\tuint32_t flags = K_WORK_QUEUE_STARTED;",
                    "823": "",
                    "824": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);",
                    "825": "",
                    "826": "\tsys_slist_init(&queue->pending);",
                    "827": "\tz_waitq_init(&queue->notifyq);",
                    "828": "\tz_waitq_init(&queue->drainq);",
                    "829": "",
                    "830": "\tif ((cfg != NULL) && cfg->no_yield) {",
                    "831": "\t\tflags |= K_WORK_QUEUE_NO_YIELD;",
                    "832": "\t}",
                    "833": "",
                    "834": "\t/* It hasn't actually been started yet, but all the state is in place",
                    "835": "\t * so we can submit things and once the thread gets control it's ready",
                    "836": "\t * to roll.",
                    "837": "\t */",
                    "838": "\tflags_set(&queue->flags, flags);",
                    "839": "",
                    "840": "\t(void)k_thread_create(&queue->thread, stack, stack_size,",
                    "841": "\t\t\t      work_queue_main, queue, NULL, NULL,",
                    "842": "\t\t\t      prio, 0, K_FOREVER);",
                    "843": "",
                    "844": "\tif ((cfg != NULL) && (cfg->name != NULL)) {",
                    "845": "\t\tk_thread_name_set(&queue->thread, cfg->name);",
                    "846": "\t}",
                    "847": "",
                    "848": "\tif ((cfg != NULL) && (cfg->essential)) {",
                    "849": "\t\tqueue->thread.base.user_options |= K_ESSENTIAL;",
                    "850": "\t}",
                    "851": "",
                    "852": "#if defined(CONFIG_WORKQUEUE_WORK_TIMEOUT)",
                    "853": "\tif ((cfg != NULL) && (cfg->work_timeout_ms)) {",
                    "854": "\t\tqueue->work_timeout = K_MSEC(cfg->work_timeout_ms);",
                    "855": "\t} else {",
                    "856": "\t\tqueue->work_timeout = K_FOREVER;",
                    "857": "\t}",
                    "858": "#endif /* defined(CONFIG_WORKQUEUE_WORK_TIMEOUT) */",
                    "859": "",
                    "860": "\tk_thread_start(&queue->thread);",
                    "861": "\tqueue->thread_id = &queue->thread;",
                    "862": "",
                    "863": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);",
                    "864": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_cancel_sync": {
            "name": "k_work_cancel_sync",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 570,
            "function_content": [
                "/* If something's still running then we have to wait for\n* completion, which is indicated when finish_cancel() gets\n* invoked.\n*/\nbool k_work_cancel_sync(struct k_work *work,\n\t\t\tstruct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(work != NULL);\n\t__ASSERT_NO_MSG(sync != NULL);\n\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_sync, work, sync);\n\n\tstruct z_work_canceller *canceller = &sync->canceller;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\tbool pending = (work_busy_get_locked(work) != 0U);\n\tbool need_wait = false;\n\n\tif (pending) {\n\t\t(void)cancel_async_locked(work);\n\t\tneed_wait = cancel_sync_locked(work, canceller);\n\t}\n\n\tk_spin_unlock(&lock, key);\n\n\tif (need_wait) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, cancel_sync, work, sync);\n\n\t\tk_sem_take(&canceller->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_sync, work, sync, pending);\n\treturn pending;\n}\n",
                {
                    "570": "bool k_work_cancel_sync(struct k_work *work,",
                    "571": "\t\t\tstruct k_work_sync *sync)",
                    "572": "{",
                    "573": "\t__ASSERT_NO_MSG(work != NULL);",
                    "574": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "575": "\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));",
                    "576": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "577": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "578": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));",
                    "579": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "580": "",
                    "581": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_sync, work, sync);",
                    "582": "",
                    "583": "\tstruct z_work_canceller *canceller = &sync->canceller;",
                    "584": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "585": "\tbool pending = (work_busy_get_locked(work) != 0U);",
                    "586": "\tbool need_wait = false;",
                    "587": "",
                    "588": "\tif (pending) {",
                    "589": "\t\t(void)cancel_async_locked(work);",
                    "590": "\t\tneed_wait = cancel_sync_locked(work, canceller);",
                    "591": "\t}",
                    "592": "",
                    "593": "\tk_spin_unlock(&lock, key);",
                    "594": "",
                    "595": "\tif (need_wait) {",
                    "596": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, cancel_sync, work, sync);",
                    "597": "",
                    "598": "\t\tk_sem_take(&canceller->sem, K_FOREVER);",
                    "599": "\t}",
                    "600": "",
                    "601": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_sync, work, sync, pending);",
                    "602": "\treturn pending;",
                    "603": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_work_flush": {
            "name": "k_work_flush",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/work.c",
            "location_line": 458,
            "function_content": [
                "/* Flush the work item if necessary.\n*\n* Flushing is necessary only if the work is either queued or running.\n*\n* Invoked with work lock held by key.\n* Sleeps.\n*\n* @param work the work item that is to be flushed\n* @param flusher state used to synchronize the flush\n*\n* @retval true if work is queued or running.  If this happens the\n* caller must take the flusher semaphore after releasing the lock.\n*\n* @retval false otherwise.  No wait required.\n*/\nbool k_work_flush(struct k_work *work,\n\t\t  struct k_work_sync *sync)\n{\n\t__ASSERT_NO_MSG(work != NULL);\n\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(sync != NULL);\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush, work);\n\n\tstruct z_work_flusher *flusher = &sync->flusher;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tbool need_flush = work_flush_locked(work, flusher);\n\n\tk_spin_unlock(&lock, key);\n\n\t/* If necessary wait until the flusher item completes */\n\tif (need_flush) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, flush, work, K_FOREVER);\n\n\t\tk_sem_take(&flusher->sem, K_FOREVER);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush, work, need_flush);\n\n\treturn need_flush;\n}\n",
                {
                    "458": "bool k_work_flush(struct k_work *work,",
                    "459": "\t\t  struct k_work_sync *sync)",
                    "460": "{",
                    "461": "\t__ASSERT_NO_MSG(work != NULL);",
                    "462": "\t__ASSERT_NO_MSG(!flag_test(&work->flags, K_WORK_DELAYABLE_BIT));",
                    "463": "\t__ASSERT_NO_MSG(!k_is_in_isr());",
                    "464": "\t__ASSERT_NO_MSG(sync != NULL);",
                    "465": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "466": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(sync));",
                    "467": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "468": "",
                    "469": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, flush, work);",
                    "470": "",
                    "471": "\tstruct z_work_flusher *flusher = &sync->flusher;",
                    "472": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "473": "",
                    "474": "\tbool need_flush = work_flush_locked(work, flusher);",
                    "475": "",
                    "476": "\tk_spin_unlock(&lock, key);",
                    "477": "",
                    "478": "\t/* If necessary wait until the flusher item completes */",
                    "479": "\tif (need_flush) {",
                    "480": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_work, flush, work, K_FOREVER);",
                    "481": "",
                    "482": "\t\tk_sem_take(&flusher->sem, K_FOREVER);",
                    "483": "\t}",
                    "484": "",
                    "485": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, flush, work, need_flush);",
                    "486": "",
                    "487": "\treturn need_flush;",
                    "488": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_stack_cleanup": {
            "name": "k_stack_cleanup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/stack.c",
            "location_line": 80,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_stack_cleanup(struct k_stack *stack)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);\n\n\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {\n\t\tk_free(stack->base);\n\t\tstack->base = NULL;\n\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);\n\n\treturn 0;\n}\n",
                {
                    "80": "int k_stack_cleanup(struct k_stack *stack)",
                    "81": "{",
                    "82": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);",
                    "83": "",
                    "84": "\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {",
                    "85": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);",
                    "86": "",
                    "87": "\t\treturn -EAGAIN;",
                    "88": "\t}",
                    "89": "",
                    "90": "\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {",
                    "91": "\t\tk_free(stack->base);",
                    "92": "\t\tstack->base = NULL;",
                    "93": "\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;",
                    "94": "\t}",
                    "95": "",
                    "96": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);",
                    "97": "",
                    "98": "\treturn 0;",
                    "99": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_stack_init": {
            "name": "k_stack_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/stack.c",
            "location_line": 27,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_STACK */\nvoid k_stack_init(struct k_stack *stack, stack_data_t *buffer,\n\t\t  uint32_t num_entries)\n{\n\tz_waitq_init(&stack->wait_q);\n\tstack->lock = (struct k_spinlock) {};\n\tstack->next = buffer;\n\tstack->base = buffer;\n\tstack->top = stack->base + num_entries;\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_stack, stack);\n\tk_object_init(stack);\n\n#ifdef CONFIG_OBJ_CORE_STACK\n\tk_obj_core_init_and_link(K_OBJ_CORE(stack), &obj_type_stack);\n#endif /* CONFIG_OBJ_CORE_STACK */\n}\n",
                {
                    "27": "void k_stack_init(struct k_stack *stack, stack_data_t *buffer,",
                    "28": "\t\t  uint32_t num_entries)",
                    "29": "{",
                    "30": "\tz_waitq_init(&stack->wait_q);",
                    "31": "\tstack->lock = (struct k_spinlock) {};",
                    "32": "\tstack->next = buffer;",
                    "33": "\tstack->base = buffer;",
                    "34": "\tstack->top = stack->base + num_entries;",
                    "35": "",
                    "36": "\tSYS_PORT_TRACING_OBJ_INIT(k_stack, stack);",
                    "37": "\tk_object_init(stack);",
                    "38": "",
                    "39": "#ifdef CONFIG_OBJ_CORE_STACK",
                    "40": "\tk_obj_core_init_and_link(K_OBJ_CORE(stack), &obj_type_stack);",
                    "41": "#endif /* CONFIG_OBJ_CORE_STACK */",
                    "42": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_append_list": {
            "name": "k_queue_append_list",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 257,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_queue_append_list(struct k_queue *queue, void *head, void *tail)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append_list, queue);\n\tbool resched = false;\n\n\t/* invalid head or tail of list */\n\tCHECKIF((head == NULL) || (tail == NULL)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, -EINVAL);\n\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tstruct k_thread *thread = NULL;\n\n\tif (head != NULL) {\n\t\tthread = z_unpend_first_thread(&queue->wait_q);\n\t}\n\n\twhile ((head != NULL) && (thread != NULL)) {\n\t\tresched = true;\n\t\tprepare_thread_to_run(thread, head);\n\t\thead = *(void **)head;\n\t\tthread = z_unpend_first_thread(&queue->wait_q);\n\t}\n\n\tif (head != NULL) {\n\t\tsys_sflist_append_list(&queue->data_q, head, tail);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, 0);\n\n\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE) || resched;\n\n\tif (resched) {\n\t\tz_reschedule(&queue->lock, key);\n\t} else {\n\t\tk_spin_unlock(&queue->lock, key);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "257": "int k_queue_append_list(struct k_queue *queue, void *head, void *tail)",
                    "258": "{",
                    "259": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append_list, queue);",
                    "260": "\tbool resched = false;",
                    "261": "",
                    "262": "\t/* invalid head or tail of list */",
                    "263": "\tCHECKIF((head == NULL) || (tail == NULL)) {",
                    "264": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, -EINVAL);",
                    "265": "",
                    "266": "\t\treturn -EINVAL;",
                    "267": "\t}",
                    "268": "",
                    "269": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "270": "\tstruct k_thread *thread = NULL;",
                    "271": "",
                    "272": "\tif (head != NULL) {",
                    "273": "\t\tthread = z_unpend_first_thread(&queue->wait_q);",
                    "274": "\t}",
                    "275": "",
                    "276": "\twhile ((head != NULL) && (thread != NULL)) {",
                    "277": "\t\tresched = true;",
                    "278": "\t\tprepare_thread_to_run(thread, head);",
                    "279": "\t\thead = *(void **)head;",
                    "280": "\t\tthread = z_unpend_first_thread(&queue->wait_q);",
                    "281": "\t}",
                    "282": "",
                    "283": "\tif (head != NULL) {",
                    "284": "\t\tsys_sflist_append_list(&queue->data_q, head, tail);",
                    "285": "\t}",
                    "286": "",
                    "287": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, 0);",
                    "288": "",
                    "289": "\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE) || resched;",
                    "290": "",
                    "291": "\tif (resched) {",
                    "292": "\t\tz_reschedule(&queue->lock, key);",
                    "293": "\t} else {",
                    "294": "\t\tk_spin_unlock(&queue->lock, key);",
                    "295": "\t}",
                    "296": "",
                    "297": "\treturn 0;",
                    "298": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_timer_init": {
            "name": "k_timer_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timer.c",
            "location_line": 165,
            "function_content": [
                "/* Unlock for user handler. */\nvoid k_timer_init(struct k_timer *timer,\n\t\t\t k_timer_expiry_t expiry_fn,\n\t\t\t k_timer_stop_t stop_fn)\n{\n\ttimer->expiry_fn = expiry_fn;\n\ttimer->stop_fn = stop_fn;\n\ttimer->status = 0U;\n\n\tif (IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tz_waitq_init(&timer->wait_q);\n\t}\n\n\tz_init_timeout(&timer->timeout);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_timer, timer);\n\n\ttimer->user_data = NULL;\n\n\tk_object_init(timer);\n\n#ifdef CONFIG_OBJ_CORE_TIMER\n\tk_obj_core_init_and_link(K_OBJ_CORE(timer), &obj_type_timer);\n#endif /* CONFIG_OBJ_CORE_TIMER */\n\n\tz_timer_observer_on_init(timer);\n}\n",
                {
                    "165": "void k_timer_init(struct k_timer *timer,",
                    "166": "\t\t\t k_timer_expiry_t expiry_fn,",
                    "167": "\t\t\t k_timer_stop_t stop_fn)",
                    "168": "{",
                    "169": "\ttimer->expiry_fn = expiry_fn;",
                    "170": "\ttimer->stop_fn = stop_fn;",
                    "171": "\ttimer->status = 0U;",
                    "172": "",
                    "173": "\tif (IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "174": "\t\tz_waitq_init(&timer->wait_q);",
                    "175": "\t}",
                    "176": "",
                    "177": "\tz_init_timeout(&timer->timeout);",
                    "178": "",
                    "179": "\tSYS_PORT_TRACING_OBJ_INIT(k_timer, timer);",
                    "180": "",
                    "181": "\ttimer->user_data = NULL;",
                    "182": "",
                    "183": "\tk_object_init(timer);",
                    "184": "",
                    "185": "#ifdef CONFIG_OBJ_CORE_TIMER",
                    "186": "\tk_obj_core_init_and_link(K_OBJ_CORE(timer), &obj_type_timer);",
                    "187": "#endif /* CONFIG_OBJ_CORE_TIMER */",
                    "188": "",
                    "189": "\tz_timer_observer_on_init(timer);",
                    "190": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_sched_unlock": {
            "name": "k_sched_unlock",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 836,
            "function_content": [
                "#endif /* CONFIG_SMP */\nvoid k_sched_unlock(void)\n{\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\t__ASSERT(_current->base.sched_locked != 0U, \"\");\n\t\t__ASSERT(!arch_is_in_isr(), \"\");\n\n\t\t++_current->base.sched_locked;\n\t\tupdate_cache(0);\n\t}\n\n\tLOG_DBG(\"scheduler unlocked (%p:%d)\",\n\t\t_current, _current->base.sched_locked);\n\n\tSYS_PORT_TRACING_FUNC(k_thread, sched_unlock);\n\n\tz_reschedule_unlocked();\n}\n",
                {
                    "836": "void k_sched_unlock(void)",
                    "837": "{",
                    "838": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "839": "\t\t__ASSERT(_current->base.sched_locked != 0U, \"\");",
                    "840": "\t\t__ASSERT(!arch_is_in_isr(), \"\");",
                    "841": "",
                    "842": "\t\t++_current->base.sched_locked;",
                    "843": "\t\tupdate_cache(0);",
                    "844": "\t}",
                    "845": "",
                    "846": "\tLOG_DBG(\"scheduler unlocked (%p:%d)\",",
                    "847": "\t\t_current, _current->base.sched_locked);",
                    "848": "",
                    "849": "\tSYS_PORT_TRACING_FUNC(k_thread, sched_unlock);",
                    "850": "",
                    "851": "\tz_reschedule_unlocked();",
                    "852": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timeout_remaining": {
            "name": "z_timeout_remaining",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 194,
            "function_content": [
                "/* must be locked */\nk_ticks_t z_timeout_remaining(const struct _timeout *timeout)\n{\n\tk_ticks_t ticks = 0;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tif (!z_is_inactive_timeout(timeout)) {\n\t\t\tticks = timeout_rem(timeout) - elapsed();\n\t\t}\n\t}\n\n\treturn ticks;\n}\n",
                {
                    "194": "k_ticks_t z_timeout_remaining(const struct _timeout *timeout)",
                    "195": "{",
                    "196": "\tk_ticks_t ticks = 0;",
                    "197": "",
                    "198": "\tK_SPINLOCK(&timeout_lock) {",
                    "199": "\t\tif (!z_is_inactive_timeout(timeout)) {",
                    "200": "\t\t\tticks = timeout_rem(timeout) - elapsed();",
                    "201": "\t\t}",
                    "202": "\t}",
                    "203": "",
                    "204": "\treturn ticks;",
                    "205": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_timeout_expires": {
            "name": "z_timeout_expires",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 208,
            "function_content": [
                "/* must be locked */\nk_ticks_t z_timeout_expires(const struct _timeout *timeout)\n{\n\tk_ticks_t ticks = 0;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tticks = curr_tick;\n\t\tif (!z_is_inactive_timeout(timeout)) {\n\t\t\tticks += timeout_rem(timeout);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n",
                {
                    "208": "k_ticks_t z_timeout_expires(const struct _timeout *timeout)",
                    "209": "{",
                    "210": "\tk_ticks_t ticks = 0;",
                    "211": "",
                    "212": "\tK_SPINLOCK(&timeout_lock) {",
                    "213": "\t\tticks = curr_tick;",
                    "214": "\t\tif (!z_is_inactive_timeout(timeout)) {",
                    "215": "\t\t\tticks += timeout_rem(timeout);",
                    "216": "\t\t}",
                    "217": "\t}",
                    "218": "",
                    "219": "\treturn ticks;",
                    "220": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_abort_timeout": {
            "name": "z_abort_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 159,
            "function_content": [
                "/* In case of absolute timeout that is first to expire\n* elapsed need to be read from the system clock.\n*/\nint z_abort_timeout(struct _timeout *to)\n{\n\tint ret = -EINVAL;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tif (sys_dnode_is_linked(&to->node)) {\n\t\t\tbool is_first = (to == first());\n\n\t\t\tremove_timeout(to);\n\t\t\tto->dticks = TIMEOUT_DTICKS_ABORTED;\n\t\t\tret = 0;\n\t\t\tif (is_first) {\n\t\t\t\tsys_clock_set_timeout(next_timeout(elapsed()), false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
                {
                    "159": "int z_abort_timeout(struct _timeout *to)",
                    "160": "{",
                    "161": "\tint ret = -EINVAL;",
                    "162": "",
                    "163": "\tK_SPINLOCK(&timeout_lock) {",
                    "164": "\t\tif (sys_dnode_is_linked(&to->node)) {",
                    "165": "\t\t\tbool is_first = (to == first());",
                    "166": "",
                    "167": "\t\t\tremove_timeout(to);",
                    "168": "\t\t\tto->dticks = TIMEOUT_DTICKS_ABORTED;",
                    "169": "\t\t\tret = 0;",
                    "170": "\t\t\tif (is_first) {",
                    "171": "\t\t\t\tsys_clock_set_timeout(next_timeout(elapsed()), false);",
                    "172": "\t\t\t}",
                    "173": "\t\t}",
                    "174": "\t}",
                    "175": "",
                    "176": "\treturn ret;",
                    "177": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_add_timeout": {
            "name": "z_add_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 100,
            "function_content": [
                "/* While sys_clock_announce() is executing, new relative timeouts will be\n* scheduled relatively to the currently firing timeout's original tick\n* value (=curr_tick) rather than relative to the current\n* sys_clock_elapsed().\n*\n* This means that timeouts being scheduled from within timeout callbacks\n* will be scheduled at well-defined offsets from the currently firing\n* timeout.\n*\n* As a side effect, the same will happen if an ISR with higher priority\n* preempts a timeout callback and schedules a timeout.\n*\n* The distinction is implemented by looking at announce_remaining which\n* will be non-zero while sys_clock_announce() is executing and zero\n* otherwise.\n*/\nk_ticks_t z_add_timeout(struct _timeout *to, _timeout_func_t fn, k_timeout_t timeout)\n{\n\tk_ticks_t ticks = 0;\n\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(to));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\t__ASSERT(!sys_dnode_is_linked(&to->node), \"\");\n\tto->fn = fn;\n\n\tK_SPINLOCK(&timeout_lock) {\n\t\tstruct _timeout *t;\n\t\tint32_t ticks_elapsed;\n\t\tbool has_elapsed = false;\n\n\t\tif (Z_IS_TIMEOUT_RELATIVE(timeout)) {\n\t\t\tticks_elapsed = elapsed();\n\t\t\thas_elapsed = true;\n\t\t\tto->dticks = timeout.ticks + 1 + ticks_elapsed;\n\t\t\tticks = curr_tick + to->dticks;\n\t\t} else {\n\t\t\tk_ticks_t dticks = Z_TICK_ABS(timeout.ticks) - curr_tick;\n\n\t\t\tto->dticks = max(1, dticks);\n\t\t\tticks = timeout.ticks;\n\t\t}\n\n\t\tfor (t = first(); t != NULL; t = next(t)) {\n\t\t\tif (t->dticks > to->dticks) {\n\t\t\t\tt->dticks -= to->dticks;\n\t\t\t\tsys_dlist_insert(&t->node, &to->node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tto->dticks -= t->dticks;\n\t\t}\n\n\t\tif (t == NULL) {\n\t\t\tsys_dlist_append(&timeout_list, &to->node);\n\t\t}\n\n\t\tif (to == first() && announce_remaining == 0) {\n\t\t\tif (!has_elapsed) {\n\t\t\t\t/* In case of absolute timeout that is first to expire\n\t\t\t\t * elapsed need to be read from the system clock.\n\t\t\t\t */\n\t\t\t\tticks_elapsed = elapsed();\n\t\t\t}\n\t\t\tsys_clock_set_timeout(next_timeout(ticks_elapsed), false);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n",
                {
                    "100": "k_ticks_t z_add_timeout(struct _timeout *to, _timeout_func_t fn, k_timeout_t timeout)",
                    "101": "{",
                    "102": "\tk_ticks_t ticks = 0;",
                    "103": "",
                    "104": "\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {",
                    "105": "\t\treturn 0;",
                    "106": "\t}",
                    "107": "",
                    "108": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "109": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(to));",
                    "110": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "111": "",
                    "112": "\t__ASSERT(!sys_dnode_is_linked(&to->node), \"\");",
                    "113": "\tto->fn = fn;",
                    "114": "",
                    "115": "\tK_SPINLOCK(&timeout_lock) {",
                    "116": "\t\tstruct _timeout *t;",
                    "117": "\t\tint32_t ticks_elapsed;",
                    "118": "\t\tbool has_elapsed = false;",
                    "119": "",
                    "120": "\t\tif (Z_IS_TIMEOUT_RELATIVE(timeout)) {",
                    "121": "\t\t\tticks_elapsed = elapsed();",
                    "122": "\t\t\thas_elapsed = true;",
                    "123": "\t\t\tto->dticks = timeout.ticks + 1 + ticks_elapsed;",
                    "124": "\t\t\tticks = curr_tick + to->dticks;",
                    "125": "\t\t} else {",
                    "126": "\t\t\tk_ticks_t dticks = Z_TICK_ABS(timeout.ticks) - curr_tick;",
                    "127": "",
                    "128": "\t\t\tto->dticks = max(1, dticks);",
                    "129": "\t\t\tticks = timeout.ticks;",
                    "130": "\t\t}",
                    "131": "",
                    "132": "\t\tfor (t = first(); t != NULL; t = next(t)) {",
                    "133": "\t\t\tif (t->dticks > to->dticks) {",
                    "134": "\t\t\t\tt->dticks -= to->dticks;",
                    "135": "\t\t\t\tsys_dlist_insert(&t->node, &to->node);",
                    "136": "\t\t\t\tbreak;",
                    "137": "\t\t\t}",
                    "138": "\t\t\tto->dticks -= t->dticks;",
                    "139": "\t\t}",
                    "140": "",
                    "141": "\t\tif (t == NULL) {",
                    "142": "\t\t\tsys_dlist_append(&timeout_list, &to->node);",
                    "143": "\t\t}",
                    "144": "",
                    "145": "\t\tif (to == first() && announce_remaining == 0) {",
                    "146": "\t\t\tif (!has_elapsed) {",
                    "147": "\t\t\t\t/* In case of absolute timeout that is first to expire",
                    "148": "\t\t\t\t * elapsed need to be read from the system clock.",
                    "149": "\t\t\t\t */",
                    "150": "\t\t\t\tticks_elapsed = elapsed();",
                    "151": "\t\t\t}",
                    "152": "\t\t\tsys_clock_set_timeout(next_timeout(ticks_elapsed), false);",
                    "153": "\t\t}",
                    "154": "\t}",
                    "155": "",
                    "156": "\treturn ticks;",
                    "157": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_abort": {
            "name": "z_thread_abort",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1409,
            "function_content": [
                "/* Finally update the halting thread state, on which\n* other CPUs might be spinning (see\n* thread_halt_spin()).\n*/\nvoid z_thread_abort(struct k_thread *thread)\n{\n\tbool essential = z_is_thread_essential(thread);\n\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);\n\n\tif (z_is_thread_dead(thread)) {\n\t\tk_spin_unlock(&_sched_spinlock, key);\n\t\treturn;\n\t}\n\n\tz_thread_halt(thread, key, true);\n\n\tif (essential) {\n\t\t__ASSERT(!essential, \"aborted essential thread %p\", thread);\n\t\tk_panic();\n\t}\n}\n",
                {
                    "1409": "void z_thread_abort(struct k_thread *thread)",
                    "1410": "{",
                    "1411": "\tbool essential = z_is_thread_essential(thread);",
                    "1412": "\tk_spinlock_key_t key = k_spin_lock(&_sched_spinlock);",
                    "1413": "",
                    "1414": "\tif (z_is_thread_dead(thread)) {",
                    "1415": "\t\tk_spin_unlock(&_sched_spinlock, key);",
                    "1416": "\t\treturn;",
                    "1417": "\t}",
                    "1418": "",
                    "1419": "\tz_thread_halt(thread, key, true);",
                    "1420": "",
                    "1421": "\tif (essential) {",
                    "1422": "\t\t__ASSERT(!essential, \"aborted essential thread %p\", thread);",
                    "1423": "\t\tk_panic();",
                    "1424": "\t}",
                    "1425": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_handle_obj_poll_events": {
            "name": "z_handle_obj_poll_events",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 460,
            "function_content": [
                "/* Poller is not poll or triggered mode. No action needed.*/\nbool z_handle_obj_poll_events(sys_dlist_t *events, uint32_t state)\n{\n\tstruct k_poll_event *poll_event;\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tpoll_event = (struct k_poll_event *)sys_dlist_get(events);\n\tif (poll_event != NULL) {\n\t\t(void) signal_poll_event(poll_event, state);\n\t}\n\n\tk_spin_unlock(&lock, key);\n\n\treturn (poll_event != NULL);\n}\n",
                {
                    "460": "bool z_handle_obj_poll_events(sys_dlist_t *events, uint32_t state)",
                    "461": "{",
                    "462": "\tstruct k_poll_event *poll_event;",
                    "463": "\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "464": "",
                    "465": "\tpoll_event = (struct k_poll_event *)sys_dlist_get(events);",
                    "466": "\tif (poll_event != NULL) {",
                    "467": "\t\t(void) signal_poll_event(poll_event, state);",
                    "468": "\t}",
                    "469": "",
                    "470": "\tk_spin_unlock(&lock, key);",
                    "471": "",
                    "472": "\treturn (poll_event != NULL);",
                    "473": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_setup_new_thread": {
            "name": "z_setup_new_thread",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/thread.c",
            "location_line": 579,
            "function_content": [
                "/*\n* The provided stack_size value is presumed to be either the result of\n* K_THREAD_STACK_SIZEOF(stack), or the size value passed to the instance\n* of K_THREAD_STACK_DEFINE() which defined 'stack'.\n*/\nchar *z_setup_new_thread(struct k_thread *new_thread,\n\t\t\t k_thread_stack_t *stack, size_t stack_size,\n\t\t\t k_thread_entry_t entry,\n\t\t\t void *p1, void *p2, void *p3,\n\t\t\t int prio, uint32_t options, const char *name)\n{\n\tchar *stack_ptr;\n\n\tZ_ASSERT_VALID_PRIO(prio, entry);\n\n#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP\n\tk_thread_abort_cleanup_check_reuse(new_thread);\n#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */\n\n#ifdef CONFIG_OBJ_CORE_THREAD\n\tk_obj_core_init_and_link(K_OBJ_CORE(new_thread), &obj_type_thread);\n#ifdef CONFIG_OBJ_CORE_STATS_THREAD\n\tk_obj_core_stats_register(K_OBJ_CORE(new_thread),\n\t\t\t\t  &new_thread->base.usage,\n\t\t\t\t  sizeof(new_thread->base.usage));\n#endif /* CONFIG_OBJ_CORE_STATS_THREAD */\n#endif /* CONFIG_OBJ_CORE_THREAD */\n\n#ifdef CONFIG_USERSPACE\n\t__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),\n\t\t \"user thread %p with kernel-only stack %p\",\n\t\t new_thread, stack);\n\tk_object_init(new_thread);\n\tk_object_init(stack);\n\tnew_thread->stack_obj = stack;\n\tnew_thread->syscall_frame = NULL;\n\n\t/* Any given thread has access to itself */\n\tk_object_access_grant(new_thread, new_thread);\n#endif /* CONFIG_USERSPACE */\n\tz_waitq_init(&new_thread->join_queue);\n\n\t/* Initialize various struct k_thread members */\n\tz_init_thread_base(&new_thread->base, prio, _THREAD_SLEEPING, options);\n\tstack_ptr = setup_thread_stack(new_thread, stack, stack_size);\n\n#ifdef CONFIG_HW_SHADOW_STACK\n\tsetup_shadow_stack(new_thread, stack);\n#endif\n\n#ifdef CONFIG_KERNEL_COHERENCE\n\t/* Check that the thread object is safe, but that the stack is\n\t * still cached!\n\t */\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(new_thread));\n\n\t/* When dynamic thread stack is available, the stack may come from\n\t * uncached area.\n\t */\n#ifndef CONFIG_DYNAMIC_THREAD\n\t__ASSERT_NO_MSG(!sys_cache_is_mem_coherent(stack));\n#endif  /* CONFIG_DYNAMIC_THREAD */\n\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\tarch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);\n\n\t/* static threads overwrite it afterwards with real value */\n\tnew_thread->init_data = NULL;\n\n#ifdef CONFIG_USE_SWITCH\n\t/* switch_handle must be non-null except when inside z_swap()\n\t * for synchronization reasons.  Historically some notional\n\t * USE_SWITCH architectures have actually ignored the field\n\t */\n\t__ASSERT(new_thread->switch_handle != NULL,\n\t\t \"arch layer failed to initialize switch_handle\");\n#endif /* CONFIG_USE_SWITCH */\n#ifdef CONFIG_THREAD_CUSTOM_DATA\n\t/* Initialize custom data field (value is opaque to kernel) */\n\tnew_thread->custom_data = NULL;\n#endif /* CONFIG_THREAD_CUSTOM_DATA */\n#ifdef CONFIG_EVENTS\n\tnew_thread->no_wake_on_timeout = false;\n#endif /* CONFIG_EVENTS */\n#ifdef CONFIG_THREAD_MONITOR\n\tnew_thread->entry.pEntry = entry;\n\tnew_thread->entry.parameter1 = p1;\n\tnew_thread->entry.parameter2 = p2;\n\tnew_thread->entry.parameter3 = p3;\n\n\tk_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);\n\n\tnew_thread->next_thread = _kernel.threads;\n\t_kernel.threads = new_thread;\n\tk_spin_unlock(&z_thread_monitor_lock, key);\n#endif /* CONFIG_THREAD_MONITOR */\n#ifdef CONFIG_THREAD_NAME\n\tif (name != NULL) {\n\t\tstrncpy(new_thread->name, name,\n\t\t\tCONFIG_THREAD_MAX_NAME_LEN - 1);\n\t\t/* Ensure NULL termination, truncate if longer */\n\t\tnew_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\\0';\n#ifdef CONFIG_ARCH_HAS_THREAD_NAME_HOOK\n\t\tarch_thread_name_set(new_thread, name);\n#endif /* CONFIG_ARCH_HAS_THREAD_NAME_HOOK */\n\t} else {\n\t\tnew_thread->name[0] = '\\0';\n\t}\n#endif /* CONFIG_THREAD_NAME */\n#ifdef CONFIG_SCHED_CPU_MASK\n\tif (IS_ENABLED(CONFIG_SCHED_CPU_MASK_PIN_ONLY)) {\n\t\tnew_thread->base.cpu_mask = 1; /* must specify only one cpu */\n\t} else {\n\t\tnew_thread->base.cpu_mask = -1; /* allow all cpus */\n\t}\n#endif /* CONFIG_SCHED_CPU_MASK */\n#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN\n\t/* _current may be null if the dummy thread is not used */\n\tif (!_current) {\n\t\tnew_thread->resource_pool = NULL;\n\t\treturn stack_ptr;\n\t}\n#endif /* CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN */\n#ifdef CONFIG_USERSPACE\n\tz_mem_domain_init_thread(new_thread);\n\n\tif ((options & K_INHERIT_PERMS) != 0U) {\n\t\tk_thread_perms_inherit(_current, new_thread);\n\t}\n#endif /* CONFIG_USERSPACE */\n#ifdef CONFIG_SCHED_DEADLINE\n\tnew_thread->base.prio_deadline = 0;\n#endif /* CONFIG_SCHED_DEADLINE */\n\tnew_thread->resource_pool = _current->resource_pool;\n\n#ifdef CONFIG_SMP\n\tz_waitq_init(&new_thread->halt_queue);\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_SCHED_THREAD_USAGE\n\tnew_thread->base.usage = (struct k_cycle_stats) {};\n\tnew_thread->base.usage.track_usage =\n\t\tCONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;\n#endif /* CONFIG_SCHED_THREAD_USAGE */\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);\n\n\treturn stack_ptr;\n}\n",
                {
                    "579": "char *z_setup_new_thread(struct k_thread *new_thread,",
                    "580": "\t\t\t k_thread_stack_t *stack, size_t stack_size,",
                    "581": "\t\t\t k_thread_entry_t entry,",
                    "582": "\t\t\t void *p1, void *p2, void *p3,",
                    "583": "\t\t\t int prio, uint32_t options, const char *name)",
                    "584": "{",
                    "585": "\tchar *stack_ptr;",
                    "586": "",
                    "587": "\tZ_ASSERT_VALID_PRIO(prio, entry);",
                    "588": "",
                    "589": "#ifdef CONFIG_THREAD_ABORT_NEED_CLEANUP",
                    "590": "\tk_thread_abort_cleanup_check_reuse(new_thread);",
                    "591": "#endif /* CONFIG_THREAD_ABORT_NEED_CLEANUP */",
                    "592": "",
                    "593": "#ifdef CONFIG_OBJ_CORE_THREAD",
                    "594": "\tk_obj_core_init_and_link(K_OBJ_CORE(new_thread), &obj_type_thread);",
                    "595": "#ifdef CONFIG_OBJ_CORE_STATS_THREAD",
                    "596": "\tk_obj_core_stats_register(K_OBJ_CORE(new_thread),",
                    "597": "\t\t\t\t  &new_thread->base.usage,",
                    "598": "\t\t\t\t  sizeof(new_thread->base.usage));",
                    "599": "#endif /* CONFIG_OBJ_CORE_STATS_THREAD */",
                    "600": "#endif /* CONFIG_OBJ_CORE_THREAD */",
                    "601": "",
                    "602": "#ifdef CONFIG_USERSPACE",
                    "603": "\t__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),",
                    "604": "\t\t \"user thread %p with kernel-only stack %p\",",
                    "605": "\t\t new_thread, stack);",
                    "606": "\tk_object_init(new_thread);",
                    "607": "\tk_object_init(stack);",
                    "608": "\tnew_thread->stack_obj = stack;",
                    "609": "\tnew_thread->syscall_frame = NULL;",
                    "610": "",
                    "611": "\t/* Any given thread has access to itself */",
                    "612": "\tk_object_access_grant(new_thread, new_thread);",
                    "613": "#endif /* CONFIG_USERSPACE */",
                    "614": "\tz_waitq_init(&new_thread->join_queue);",
                    "615": "",
                    "616": "\t/* Initialize various struct k_thread members */",
                    "617": "\tz_init_thread_base(&new_thread->base, prio, _THREAD_SLEEPING, options);",
                    "618": "\tstack_ptr = setup_thread_stack(new_thread, stack, stack_size);",
                    "619": "",
                    "620": "#ifdef CONFIG_HW_SHADOW_STACK",
                    "621": "\tsetup_shadow_stack(new_thread, stack);",
                    "622": "#endif",
                    "623": "",
                    "624": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "625": "\t/* Check that the thread object is safe, but that the stack is",
                    "626": "\t * still cached!",
                    "627": "\t */",
                    "628": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(new_thread));",
                    "629": "",
                    "630": "\t/* When dynamic thread stack is available, the stack may come from",
                    "631": "\t * uncached area.",
                    "632": "\t */",
                    "633": "#ifndef CONFIG_DYNAMIC_THREAD",
                    "634": "\t__ASSERT_NO_MSG(!sys_cache_is_mem_coherent(stack));",
                    "635": "#endif  /* CONFIG_DYNAMIC_THREAD */",
                    "636": "",
                    "637": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "638": "",
                    "639": "\tarch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);",
                    "640": "",
                    "641": "\t/* static threads overwrite it afterwards with real value */",
                    "642": "\tnew_thread->init_data = NULL;",
                    "643": "",
                    "644": "#ifdef CONFIG_USE_SWITCH",
                    "645": "\t/* switch_handle must be non-null except when inside z_swap()",
                    "646": "\t * for synchronization reasons.  Historically some notional",
                    "647": "\t * USE_SWITCH architectures have actually ignored the field",
                    "648": "\t */",
                    "649": "\t__ASSERT(new_thread->switch_handle != NULL,",
                    "650": "\t\t \"arch layer failed to initialize switch_handle\");",
                    "651": "#endif /* CONFIG_USE_SWITCH */",
                    "652": "#ifdef CONFIG_THREAD_CUSTOM_DATA",
                    "653": "\t/* Initialize custom data field (value is opaque to kernel) */",
                    "654": "\tnew_thread->custom_data = NULL;",
                    "655": "#endif /* CONFIG_THREAD_CUSTOM_DATA */",
                    "656": "#ifdef CONFIG_EVENTS",
                    "657": "\tnew_thread->no_wake_on_timeout = false;",
                    "658": "#endif /* CONFIG_EVENTS */",
                    "659": "#ifdef CONFIG_THREAD_MONITOR",
                    "660": "\tnew_thread->entry.pEntry = entry;",
                    "661": "\tnew_thread->entry.parameter1 = p1;",
                    "662": "\tnew_thread->entry.parameter2 = p2;",
                    "663": "\tnew_thread->entry.parameter3 = p3;",
                    "664": "",
                    "665": "\tk_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);",
                    "666": "",
                    "667": "\tnew_thread->next_thread = _kernel.threads;",
                    "668": "\t_kernel.threads = new_thread;",
                    "669": "\tk_spin_unlock(&z_thread_monitor_lock, key);",
                    "670": "#endif /* CONFIG_THREAD_MONITOR */",
                    "671": "#ifdef CONFIG_THREAD_NAME",
                    "672": "\tif (name != NULL) {",
                    "673": "\t\tstrncpy(new_thread->name, name,",
                    "674": "\t\t\tCONFIG_THREAD_MAX_NAME_LEN - 1);",
                    "675": "\t\t/* Ensure NULL termination, truncate if longer */",
                    "676": "\t\tnew_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\\0';",
                    "677": "#ifdef CONFIG_ARCH_HAS_THREAD_NAME_HOOK",
                    "678": "\t\tarch_thread_name_set(new_thread, name);",
                    "679": "#endif /* CONFIG_ARCH_HAS_THREAD_NAME_HOOK */",
                    "680": "\t} else {",
                    "681": "\t\tnew_thread->name[0] = '\\0';",
                    "682": "\t}",
                    "683": "#endif /* CONFIG_THREAD_NAME */",
                    "684": "#ifdef CONFIG_SCHED_CPU_MASK",
                    "685": "\tif (IS_ENABLED(CONFIG_SCHED_CPU_MASK_PIN_ONLY)) {",
                    "686": "\t\tnew_thread->base.cpu_mask = 1; /* must specify only one cpu */",
                    "687": "\t} else {",
                    "688": "\t\tnew_thread->base.cpu_mask = -1; /* allow all cpus */",
                    "689": "\t}",
                    "690": "#endif /* CONFIG_SCHED_CPU_MASK */",
                    "691": "#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN",
                    "692": "\t/* _current may be null if the dummy thread is not used */",
                    "693": "\tif (!_current) {",
                    "694": "\t\tnew_thread->resource_pool = NULL;",
                    "695": "\t\treturn stack_ptr;",
                    "696": "\t}",
                    "697": "#endif /* CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN */",
                    "698": "#ifdef CONFIG_USERSPACE",
                    "699": "\tz_mem_domain_init_thread(new_thread);",
                    "700": "",
                    "701": "\tif ((options & K_INHERIT_PERMS) != 0U) {",
                    "702": "\t\tk_thread_perms_inherit(_current, new_thread);",
                    "703": "\t}",
                    "704": "#endif /* CONFIG_USERSPACE */",
                    "705": "#ifdef CONFIG_SCHED_DEADLINE",
                    "706": "\tnew_thread->base.prio_deadline = 0;",
                    "707": "#endif /* CONFIG_SCHED_DEADLINE */",
                    "708": "\tnew_thread->resource_pool = _current->resource_pool;",
                    "709": "",
                    "710": "#ifdef CONFIG_SMP",
                    "711": "\tz_waitq_init(&new_thread->halt_queue);",
                    "712": "#endif /* CONFIG_SMP */",
                    "713": "",
                    "714": "#ifdef CONFIG_SCHED_THREAD_USAGE",
                    "715": "\tnew_thread->base.usage = (struct k_cycle_stats) {};",
                    "716": "\tnew_thread->base.usage.track_usage =",
                    "717": "\t\tCONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;",
                    "718": "#endif /* CONFIG_SCHED_THREAD_USAGE */",
                    "719": "",
                    "720": "\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);",
                    "721": "",
                    "722": "\treturn stack_ptr;",
                    "723": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_init_thread_base": {
            "name": "z_init_thread_base",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/thread.c",
            "location_line": 879,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_init_thread_base(struct _thread_base *thread_base, int priority,\n\t\t       uint32_t initial_state, unsigned int options)\n{\n\t/* k_q_node is initialized upon first insertion in a list */\n\tthread_base->pended_on = NULL;\n\tthread_base->user_options = (uint16_t)options;\n\tthread_base->thread_state = (uint8_t)initial_state;\n\n\tthread_base->prio = priority;\n\n\tthread_base->sched_locked = 0U;\n\n#ifdef CONFIG_SMP\n\tthread_base->is_idle = 0;\n\n\t/*\n\t * Pretend that the thread was last executing on CPU0 to prevent\n\t * out-of-bounds memory accesses to the _kernel.cpus[] array.\n\t */\n\tthread_base->cpu = 0;\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_TIMESLICE_PER_THREAD\n\tthread_base->slice_ticks = 0;\n\tthread_base->slice_expired = NULL;\n#endif /* CONFIG_TIMESLICE_PER_THREAD */\n\n\t/* swap_data does not need to be initialized */\n\n\tz_init_thread_timeout(thread_base);\n}\n",
                {
                    "879": "void z_init_thread_base(struct _thread_base *thread_base, int priority,",
                    "880": "\t\t       uint32_t initial_state, unsigned int options)",
                    "881": "{",
                    "882": "\t/* k_q_node is initialized upon first insertion in a list */",
                    "883": "\tthread_base->pended_on = NULL;",
                    "884": "\tthread_base->user_options = (uint16_t)options;",
                    "885": "\tthread_base->thread_state = (uint8_t)initial_state;",
                    "886": "",
                    "887": "\tthread_base->prio = priority;",
                    "888": "",
                    "889": "\tthread_base->sched_locked = 0U;",
                    "890": "",
                    "891": "#ifdef CONFIG_SMP",
                    "892": "\tthread_base->is_idle = 0;",
                    "893": "",
                    "894": "\t/*",
                    "895": "\t * Pretend that the thread was last executing on CPU0 to prevent",
                    "896": "\t * out-of-bounds memory accesses to the _kernel.cpus[] array.",
                    "897": "\t */",
                    "898": "\tthread_base->cpu = 0;",
                    "899": "#endif /* CONFIG_SMP */",
                    "900": "",
                    "901": "#ifdef CONFIG_TIMESLICE_PER_THREAD",
                    "902": "\tthread_base->slice_ticks = 0;",
                    "903": "\tthread_base->slice_expired = NULL;",
                    "904": "#endif /* CONFIG_TIMESLICE_PER_THREAD */",
                    "905": "",
                    "906": "\t/* swap_data does not need to be initialized */",
                    "907": "",
                    "908": "\tz_init_thread_timeout(thread_base);",
                    "909": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_waitq_walk": {
            "name": "z_sched_waitq_walk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1562,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nint z_sched_waitq_walk(_wait_q_t  *wait_q,\n\t\t       int (*func)(struct k_thread *, void *), void *data)\n{\n\tstruct k_thread *thread;\n\tint  status = 0;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {\n\n\t\t\t/*\n\t\t\t * Invoke the callback function on each waiting thread\n\t\t\t * for as long as there are both waiting threads AND\n\t\t\t * it returns 0.\n\t\t\t */\n\n\t\t\tstatus = func(thread, data);\n\t\t\tif (status != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n",
                {
                    "1562": "int z_sched_waitq_walk(_wait_q_t  *wait_q,",
                    "1563": "\t\t       int (*func)(struct k_thread *, void *), void *data)",
                    "1564": "{",
                    "1565": "\tstruct k_thread *thread;",
                    "1566": "\tint  status = 0;",
                    "1567": "",
                    "1568": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1569": "\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {",
                    "1570": "",
                    "1571": "\t\t\t/*",
                    "1572": "\t\t\t * Invoke the callback function on each waiting thread",
                    "1573": "\t\t\t * for as long as there are both waiting threads AND",
                    "1574": "\t\t\t * it returns 0.",
                    "1575": "\t\t\t */",
                    "1576": "",
                    "1577": "\t\t\tstatus = func(thread, data);",
                    "1578": "\t\t\tif (status != 0) {",
                    "1579": "\t\t\t\tbreak;",
                    "1580": "\t\t\t}",
                    "1581": "\t\t}",
                    "1582": "\t}",
                    "1583": "",
                    "1584": "\treturn status;",
                    "1585": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wake_thread": {
            "name": "z_sched_wake_thread",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 625,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nvoid z_sched_wake_thread(struct k_thread *thread, bool is_timeout)\n{\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tbool killed = (thread->base.thread_state &\n\t\t\t\t(_THREAD_DEAD | _THREAD_ABORTING));\n\n#ifdef CONFIG_EVENTS\n\t\tbool do_nothing = thread->no_wake_on_timeout && is_timeout;\n\n\t\tthread->no_wake_on_timeout = false;\n\n\t\tif (do_nothing) {\n\t\t\tcontinue;\n\t\t}\n#endif /* CONFIG_EVENTS */\n\n\t\tif (!killed) {\n\t\t\t/* The thread is not being killed */\n\t\t\tif (thread->base.pended_on != NULL) {\n\t\t\t\tunpend_thread_no_timeout(thread);\n\t\t\t}\n\t\t\tz_mark_thread_as_not_sleeping(thread);\n\t\t\tready_thread(thread);\n\t\t}\n\t}\n\n}\n",
                {
                    "625": "void z_sched_wake_thread(struct k_thread *thread, bool is_timeout)",
                    "626": "{",
                    "627": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "628": "\t\tbool killed = (thread->base.thread_state &",
                    "629": "\t\t\t\t(_THREAD_DEAD | _THREAD_ABORTING));",
                    "630": "",
                    "631": "#ifdef CONFIG_EVENTS",
                    "632": "\t\tbool do_nothing = thread->no_wake_on_timeout && is_timeout;",
                    "633": "",
                    "634": "\t\tthread->no_wake_on_timeout = false;",
                    "635": "",
                    "636": "\t\tif (do_nothing) {",
                    "637": "\t\t\tcontinue;",
                    "638": "\t\t}",
                    "639": "#endif /* CONFIG_EVENTS */",
                    "640": "",
                    "641": "\t\tif (!killed) {",
                    "642": "\t\t\t/* The thread is not being killed */",
                    "643": "\t\t\tif (thread->base.pended_on != NULL) {",
                    "644": "\t\t\t\tunpend_thread_no_timeout(thread);",
                    "645": "\t\t\t}",
                    "646": "\t\t\tz_mark_thread_as_not_sleeping(thread);",
                    "647": "\t\t\tready_thread(thread);",
                    "648": "\t\t}",
                    "649": "\t}",
                    "650": "",
                    "651": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wake": {
            "name": "z_sched_wake",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1529,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nbool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)\n{\n\tstruct k_thread *thread;\n\tbool ret = false;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tz_thread_return_value_set_with_data(thread,\n\t\t\t\t\t\t\t    swap_retval,\n\t\t\t\t\t\t\t    swap_data);\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t\tz_abort_thread_timeout(thread);\n\t\t\tready_thread(thread);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
                {
                    "1529": "bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)",
                    "1530": "{",
                    "1531": "\tstruct k_thread *thread;",
                    "1532": "\tbool ret = false;",
                    "1533": "",
                    "1534": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1535": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "1536": "",
                    "1537": "\t\tif (thread != NULL) {",
                    "1538": "\t\t\tz_thread_return_value_set_with_data(thread,",
                    "1539": "\t\t\t\t\t\t\t    swap_retval,",
                    "1540": "\t\t\t\t\t\t\t    swap_data);",
                    "1541": "\t\t\tunpend_thread_no_timeout(thread);",
                    "1542": "\t\t\tz_abort_thread_timeout(thread);",
                    "1543": "\t\t\tready_thread(thread);",
                    "1544": "\t\t\tret = true;",
                    "1545": "\t\t}",
                    "1546": "\t}",
                    "1547": "",
                    "1548": "\treturn ret;",
                    "1549": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "move_current_to_end_of_prio_q": {
            "name": "move_current_to_end_of_prio_q",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 284,
            "function_content": [
                "#endif /* CONFIG_SMP */\nvoid move_current_to_end_of_prio_q(void)\n{\n\trunq_yield();\n\n\tupdate_cache(1);\n}\n",
                {
                    "284": "void move_current_to_end_of_prio_q(void)",
                    "285": "{",
                    "286": "\trunq_yield();",
                    "287": "",
                    "288": "\tupdate_cache(1);",
                    "289": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_requeue_current": {
            "name": "z_requeue_current",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 145,
            "function_content": [
                "/* Called out of z_swap() when CONFIG_SMP.  The current thread can\n* never live in the run queue until we are inexorably on the context\n* switch path on SMP, otherwise there is a deadlock condition where a\n* set of CPUs pick a cycle of threads to run and wait for them all to\n* context switch forever.\n*/\nvoid z_requeue_current(struct k_thread *thread)\n{\n\tif (z_is_thread_queued(thread)) {\n\t\trunq_add(thread);\n\t}\n\tsignal_pending_ipi();\n}\n",
                {
                    "145": "void z_requeue_current(struct k_thread *thread)",
                    "146": "{",
                    "147": "\tif (z_is_thread_queued(thread)) {",
                    "148": "\t\trunq_add(thread);",
                    "149": "\t}",
                    "150": "\tsignal_pending_ipi();",
                    "151": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_prio_set": {
            "name": "z_thread_prio_set",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 713,
            "function_content": [
                "/* Priority set utility that does no rescheduling, it just changes the\n* run queue state, returning true if a reschedule is needed later.\n*/\nbool z_thread_prio_set(struct k_thread *thread, int prio)\n{\n\tbool need_sched = 0;\n\tint old_prio = thread->base.prio;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tneed_sched = z_is_thread_ready(thread);\n\n\t\tif (need_sched) {\n\t\t\tif (!IS_ENABLED(CONFIG_SMP) || z_is_thread_queued(thread)) {\n\t\t\t\tdequeue_thread(thread);\n\t\t\t\tthread->base.prio = prio;\n\t\t\t\tqueue_thread(thread);\n\n\t\t\t\tif (old_prio > prio) {\n\t\t\t\t\tflag_ipi(ipi_mask_create(thread));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is a running thread on SMP. Update its\n\t\t\t\t * priority, but do not requeue it. An IPI is\n\t\t\t\t * needed if the priority is both being lowered\n\t\t\t\t * and it is running on another CPU.\n\t\t\t\t */\n\n\t\t\t\tthread->base.prio = prio;\n\n\t\t\t\tstruct _cpu *cpu;\n\n\t\t\t\tcpu = thread_active_elsewhere(thread);\n\t\t\t\tif ((cpu != NULL) && (old_prio < prio)) {\n\t\t\t\t\tflag_ipi(IPI_CPU_MASK(cpu->id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdate_cache(1);\n\t\t} else if (z_is_thread_pending(thread)) {\n\t\t\t/* Thread is pending, remove it from the waitq\n\t\t\t * and reinsert it with the new priority to avoid\n\t\t\t * violating waitq ordering and rb assumptions.\n\t\t\t */\n\t\t\t_wait_q_t *wait_q = pended_on_thread(thread);\n\n\t\t\t_priq_wait_remove(&wait_q->waitq, thread);\n\t\t\tthread->base.prio = prio;\n\t\t\t_priq_wait_add(&wait_q->waitq, thread);\n\t\t} else {\n\t\t\tthread->base.prio = prio;\n\t\t}\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);\n\n\treturn need_sched;\n}\n",
                {
                    "713": "bool z_thread_prio_set(struct k_thread *thread, int prio)",
                    "714": "{",
                    "715": "\tbool need_sched = 0;",
                    "716": "\tint old_prio = thread->base.prio;",
                    "717": "",
                    "718": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "719": "\t\tneed_sched = z_is_thread_ready(thread);",
                    "720": "",
                    "721": "\t\tif (need_sched) {",
                    "722": "\t\t\tif (!IS_ENABLED(CONFIG_SMP) || z_is_thread_queued(thread)) {",
                    "723": "\t\t\t\tdequeue_thread(thread);",
                    "724": "\t\t\t\tthread->base.prio = prio;",
                    "725": "\t\t\t\tqueue_thread(thread);",
                    "726": "",
                    "727": "\t\t\t\tif (old_prio > prio) {",
                    "728": "\t\t\t\t\tflag_ipi(ipi_mask_create(thread));",
                    "729": "\t\t\t\t}",
                    "730": "\t\t\t} else {",
                    "731": "\t\t\t\t/*",
                    "732": "\t\t\t\t * This is a running thread on SMP. Update its",
                    "733": "\t\t\t\t * priority, but do not requeue it. An IPI is",
                    "734": "\t\t\t\t * needed if the priority is both being lowered",
                    "735": "\t\t\t\t * and it is running on another CPU.",
                    "736": "\t\t\t\t */",
                    "737": "",
                    "738": "\t\t\t\tthread->base.prio = prio;",
                    "739": "",
                    "740": "\t\t\t\tstruct _cpu *cpu;",
                    "741": "",
                    "742": "\t\t\t\tcpu = thread_active_elsewhere(thread);",
                    "743": "\t\t\t\tif ((cpu != NULL) && (old_prio < prio)) {",
                    "744": "\t\t\t\t\tflag_ipi(IPI_CPU_MASK(cpu->id));",
                    "745": "\t\t\t\t}",
                    "746": "\t\t\t}",
                    "747": "",
                    "748": "\t\t\tupdate_cache(1);",
                    "749": "\t\t} else if (z_is_thread_pending(thread)) {",
                    "750": "\t\t\t/* Thread is pending, remove it from the waitq",
                    "751": "\t\t\t * and reinsert it with the new priority to avoid",
                    "752": "\t\t\t * violating waitq ordering and rb assumptions.",
                    "753": "\t\t\t */",
                    "754": "\t\t\t_wait_q_t *wait_q = pended_on_thread(thread);",
                    "755": "",
                    "756": "\t\t\t_priq_wait_remove(&wait_q->waitq, thread);",
                    "757": "\t\t\tthread->base.prio = prio;",
                    "758": "\t\t\t_priq_wait_add(&wait_q->waitq, thread);",
                    "759": "\t\t} else {",
                    "760": "\t\t\tthread->base.prio = prio;",
                    "761": "\t\t}",
                    "762": "\t}",
                    "763": "",
                    "764": "\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);",
                    "765": "",
                    "766": "\treturn need_sched;",
                    "767": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend_all": {
            "name": "z_unpend_all",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 989,
            "function_content": [
                "#endif /* CONFIG_USE_SWITCH */\nint z_unpend_all(_wait_q_t *wait_q)\n{\n\tint need_sched = 0;\n\tstruct k_thread *thread;\n\n\tfor (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {\n\t\tz_unpend_thread(thread);\n\t\tz_ready_thread(thread);\n\t\tneed_sched = 1;\n\t}\n\n\treturn need_sched;\n}\n",
                {
                    "989": "int z_unpend_all(_wait_q_t *wait_q)",
                    "990": "{",
                    "991": "\tint need_sched = 0;",
                    "992": "\tstruct k_thread *thread;",
                    "993": "",
                    "994": "\tfor (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {",
                    "995": "\t\tz_unpend_thread(thread);",
                    "996": "\t\tz_ready_thread(thread);",
                    "997": "\t\tneed_sched = 1;",
                    "998": "\t}",
                    "999": "",
                    "1000": "\treturn need_sched;",
                    "1001": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend1_no_timeout": {
            "name": "z_unpend1_no_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 686,
            "function_content": [
                "/* We do a \"lock swap\" prior to calling z_swap(), such that\n* the caller's lock gets released as desired.  But we ensure\n* that we hold the scheduler lock and leave local interrupts\n* masked until we reach the context switch.  z_swap() itself\n* has similar code; the duplication is because it's a legacy\n* API that doesn't expect to be called with scheduler lock\n* held.\n*/\nstruct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)\n{\n\tstruct k_thread *thread = NULL;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t}\n\t}\n\n\treturn thread;\n}\n",
                {
                    "686": "struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)",
                    "687": "{",
                    "688": "\tstruct k_thread *thread = NULL;",
                    "689": "",
                    "690": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "691": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "692": "",
                    "693": "\t\tif (thread != NULL) {",
                    "694": "\t\t\tunpend_thread_no_timeout(thread);",
                    "695": "\t\t}",
                    "696": "\t}",
                    "697": "",
                    "698": "\treturn thread;",
                    "699": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_unpend_thread_no_timeout": {
            "name": "z_unpend_thread_no_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 616,
            "function_content": [
                "#endif /* CONFIG_KERNEL_COHERENCE */\nvoid z_unpend_thread_no_timeout(struct k_thread *thread)\n{\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tif (thread->base.pended_on != NULL) {\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t}\n\t}\n}\n",
                {
                    "616": "void z_unpend_thread_no_timeout(struct k_thread *thread)",
                    "617": "{",
                    "618": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "619": "\t\tif (thread->base.pended_on != NULL) {",
                    "620": "\t\t\tunpend_thread_no_timeout(thread);",
                    "621": "\t\t}",
                    "622": "\t}",
                    "623": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_data_match": {
            "name": "net_buf_data_match",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 713,
            "function_content": [
                "/* Unreachable */\nsize_t net_buf_data_match(const struct net_buf *buf, size_t offset, const void *data, size_t len)\n{\n\tconst uint8_t *dptr = data;\n\tconst uint8_t *bptr;\n\tsize_t compared = 0;\n\tsize_t to_compare;\n\n\tif (!buf || !data) {\n\t\treturn compared;\n\t}\n\n\t/* find the right fragment to start comparison */\n\twhile (buf && offset >= buf->len) {\n\t\toffset -= buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\twhile (buf && len > 0) {\n\t\tbptr = buf->data + offset;\n\t\tto_compare = min(len, buf->len - offset);\n\n\t\tfor (size_t i = 0; i < to_compare; ++i) {\n\t\t\tif (dptr[compared] != bptr[i]) {\n\t\t\t\treturn compared;\n\t\t\t}\n\t\t\tcompared++;\n\t\t}\n\n\t\tlen -= to_compare;\n\t\tbuf = buf->frags;\n\t\toffset = 0;\n\t}\n\n\treturn compared;\n}\n",
                {
                    "713": "size_t net_buf_data_match(const struct net_buf *buf, size_t offset, const void *data, size_t len)",
                    "714": "{",
                    "715": "\tconst uint8_t *dptr = data;",
                    "716": "\tconst uint8_t *bptr;",
                    "717": "\tsize_t compared = 0;",
                    "718": "\tsize_t to_compare;",
                    "719": "",
                    "720": "\tif (!buf || !data) {",
                    "721": "\t\treturn compared;",
                    "722": "\t}",
                    "723": "",
                    "724": "\t/* find the right fragment to start comparison */",
                    "725": "\twhile (buf && offset >= buf->len) {",
                    "726": "\t\toffset -= buf->len;",
                    "727": "\t\tbuf = buf->frags;",
                    "728": "\t}",
                    "729": "",
                    "730": "\twhile (buf && len > 0) {",
                    "731": "\t\tbptr = buf->data + offset;",
                    "732": "\t\tto_compare = min(len, buf->len - offset);",
                    "733": "",
                    "734": "\t\tfor (size_t i = 0; i < to_compare; ++i) {",
                    "735": "\t\t\tif (dptr[compared] != bptr[i]) {",
                    "736": "\t\t\t\treturn compared;",
                    "737": "\t\t\t}",
                    "738": "\t\t\tcompared++;",
                    "739": "\t\t}",
                    "740": "",
                    "741": "\t\tlen -= to_compare;",
                    "742": "\t\tbuf = buf->frags;",
                    "743": "\t\toffset = 0;",
                    "744": "\t}",
                    "745": "",
                    "746": "\treturn compared;",
                    "747": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_append_bytes": {
            "name": "net_buf_append_bytes",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 666,
            "function_content": [
                "/* This helper routine will append multiple bytes, if there is no place for\n* the data in current fragment then create new fragment and add it to\n* the buffer. It assumes that the buffer has at least one fragment.\n*/\nsize_t net_buf_append_bytes(struct net_buf *buf, size_t len,\n\t\t\t    const void *value, k_timeout_t timeout,\n\t\t\t    net_buf_allocator_cb allocate_cb, void *user_data)\n{\n\tstruct net_buf *frag = net_buf_frag_last(buf);\n\tsize_t added_len = 0;\n\tconst uint8_t *value8 = value;\n\tsize_t max_size;\n\n\tdo {\n\t\tuint16_t count = min(len, net_buf_tailroom(frag));\n\n\t\tnet_buf_add_mem(frag, value8, count);\n\t\tlen -= count;\n\t\tadded_len += count;\n\t\tvalue8 += count;\n\n\t\tif (len == 0) {\n\t\t\treturn added_len;\n\t\t}\n\n\t\tif (allocate_cb) {\n\t\t\tfrag = allocate_cb(timeout, user_data);\n\t\t} else {\n\t\t\tstruct net_buf_pool *pool;\n\n\t\t\t/* Allocate from the original pool if no callback has\n\t\t\t * been provided.\n\t\t\t */\n\t\t\tpool = net_buf_pool_get(buf->pool_id);\n\t\t\tmax_size = pool->alloc->max_alloc_size;\n\t\t\tfrag = net_buf_alloc_len(pool,\n\t\t\t\t\t\t max_size ? min(len, max_size) : len,\n\t\t\t\t\t\t timeout);\n\t\t}\n\n\t\tif (!frag) {\n\t\t\treturn added_len;\n\t\t}\n\n\t\tnet_buf_frag_add(buf, frag);\n\t} while (1);\n\n\t/* Unreachable */\n\treturn 0;\n}\n",
                {
                    "666": "size_t net_buf_append_bytes(struct net_buf *buf, size_t len,",
                    "667": "\t\t\t    const void *value, k_timeout_t timeout,",
                    "668": "\t\t\t    net_buf_allocator_cb allocate_cb, void *user_data)",
                    "669": "{",
                    "670": "\tstruct net_buf *frag = net_buf_frag_last(buf);",
                    "671": "\tsize_t added_len = 0;",
                    "672": "\tconst uint8_t *value8 = value;",
                    "673": "\tsize_t max_size;",
                    "674": "",
                    "675": "\tdo {",
                    "676": "\t\tuint16_t count = min(len, net_buf_tailroom(frag));",
                    "677": "",
                    "678": "\t\tnet_buf_add_mem(frag, value8, count);",
                    "679": "\t\tlen -= count;",
                    "680": "\t\tadded_len += count;",
                    "681": "\t\tvalue8 += count;",
                    "682": "",
                    "683": "\t\tif (len == 0) {",
                    "684": "\t\t\treturn added_len;",
                    "685": "\t\t}",
                    "686": "",
                    "687": "\t\tif (allocate_cb) {",
                    "688": "\t\t\tfrag = allocate_cb(timeout, user_data);",
                    "689": "\t\t} else {",
                    "690": "\t\t\tstruct net_buf_pool *pool;",
                    "691": "",
                    "692": "\t\t\t/* Allocate from the original pool if no callback has",
                    "693": "\t\t\t * been provided.",
                    "694": "\t\t\t */",
                    "695": "\t\t\tpool = net_buf_pool_get(buf->pool_id);",
                    "696": "\t\t\tmax_size = pool->alloc->max_alloc_size;",
                    "697": "\t\t\tfrag = net_buf_alloc_len(pool,",
                    "698": "\t\t\t\t\t\t max_size ? min(len, max_size) : len,",
                    "699": "\t\t\t\t\t\t timeout);",
                    "700": "\t\t}",
                    "701": "",
                    "702": "\t\tif (!frag) {",
                    "703": "\t\t\treturn added_len;",
                    "704": "\t\t}",
                    "705": "",
                    "706": "\t\tnet_buf_frag_add(buf, frag);",
                    "707": "\t} while (1);",
                    "708": "",
                    "709": "\t/* Unreachable */",
                    "710": "\treturn 0;",
                    "711": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_linearize": {
            "name": "net_buf_linearize",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 626,
            "function_content": [
                "/* Take ownership of the fragment reference */\nsize_t net_buf_linearize(void *dst, size_t dst_len, const struct net_buf *src,\n\t\t\t size_t offset, size_t len)\n{\n\tconst struct net_buf *frag;\n\tsize_t to_copy;\n\tsize_t copied;\n\n\tlen = min(len, dst_len);\n\n\tfrag = src;\n\n\t/* find the right fragment to start copying from */\n\twhile (frag && offset >= frag->len) {\n\t\toffset -= frag->len;\n\t\tfrag = frag->frags;\n\t}\n\n\t/* traverse the fragment chain until len bytes are copied */\n\tcopied = 0;\n\twhile (frag && len > 0) {\n\t\tto_copy = min(len, frag->len - offset);\n\t\tmemcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);\n\n\t\tcopied += to_copy;\n\n\t\t/* to_copy is always <= len */\n\t\tlen -= to_copy;\n\t\tfrag = frag->frags;\n\n\t\t/* after the first iteration, this value will be 0 */\n\t\toffset = 0;\n\t}\n\n\treturn copied;\n}\n",
                {
                    "626": "size_t net_buf_linearize(void *dst, size_t dst_len, const struct net_buf *src,",
                    "627": "\t\t\t size_t offset, size_t len)",
                    "628": "{",
                    "629": "\tconst struct net_buf *frag;",
                    "630": "\tsize_t to_copy;",
                    "631": "\tsize_t copied;",
                    "632": "",
                    "633": "\tlen = min(len, dst_len);",
                    "634": "",
                    "635": "\tfrag = src;",
                    "636": "",
                    "637": "\t/* find the right fragment to start copying from */",
                    "638": "\twhile (frag && offset >= frag->len) {",
                    "639": "\t\toffset -= frag->len;",
                    "640": "\t\tfrag = frag->frags;",
                    "641": "\t}",
                    "642": "",
                    "643": "\t/* traverse the fragment chain until len bytes are copied */",
                    "644": "\tcopied = 0;",
                    "645": "\twhile (frag && len > 0) {",
                    "646": "\t\tto_copy = min(len, frag->len - offset);",
                    "647": "\t\tmemcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);",
                    "648": "",
                    "649": "\t\tcopied += to_copy;",
                    "650": "",
                    "651": "\t\t/* to_copy is always <= len */",
                    "652": "\t\tlen -= to_copy;",
                    "653": "\t\tfrag = frag->frags;",
                    "654": "",
                    "655": "\t\t/* after the first iteration, this value will be 0 */",
                    "656": "\t\toffset = 0;",
                    "657": "\t}",
                    "658": "",
                    "659": "\treturn copied;",
                    "660": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_clone": {
            "name": "net_buf_clone",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 494,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nstruct net_buf *net_buf_clone(struct net_buf *buf, k_timeout_t timeout)\n{\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tstruct net_buf_pool *pool;\n\tstruct net_buf *clone;\n\n\t__ASSERT_NO_MSG(buf);\n\n\tpool = net_buf_pool_get(buf->pool_id);\n\n\tclone = net_buf_alloc_len(pool, 0, timeout);\n\tif (!clone) {\n\t\treturn NULL;\n\t}\n\n\t/* If the pool supports data referencing use that. Otherwise\n\t * we need to allocate new data and make a copy.\n\t */\n\tif (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {\n\t\tclone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;\n\t\tclone->data = buf->data;\n\t\tclone->len = buf->len;\n\t\tclone->size = buf->size;\n\t} else {\n\t\tsize_t size = buf->size;\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\n\t\tclone->__buf = data_alloc(clone, &size, timeout);\n\t\tif (!clone->__buf || size < buf->size) {\n\t\t\tnet_buf_destroy(clone);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tclone->size = size;\n\t\tclone->data = clone->__buf + net_buf_headroom(buf);\n\t\tnet_buf_add_mem(clone, buf->data, buf->len);\n\t}\n\n\t/* user_data_size should be the same for buffers from the same pool */\n\t__ASSERT(buf->user_data_size == clone->user_data_size, \"Unexpected user data size\");\n\n\tmemcpy(clone->user_data, buf->user_data, clone->user_data_size);\n\n\treturn clone;\n}\n",
                {
                    "494": "struct net_buf *net_buf_clone(struct net_buf *buf, k_timeout_t timeout)",
                    "495": "{",
                    "496": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "497": "\tstruct net_buf_pool *pool;",
                    "498": "\tstruct net_buf *clone;",
                    "499": "",
                    "500": "\t__ASSERT_NO_MSG(buf);",
                    "501": "",
                    "502": "\tpool = net_buf_pool_get(buf->pool_id);",
                    "503": "",
                    "504": "\tclone = net_buf_alloc_len(pool, 0, timeout);",
                    "505": "\tif (!clone) {",
                    "506": "\t\treturn NULL;",
                    "507": "\t}",
                    "508": "",
                    "509": "\t/* If the pool supports data referencing use that. Otherwise",
                    "510": "\t * we need to allocate new data and make a copy.",
                    "511": "\t */",
                    "512": "\tif (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {",
                    "513": "\t\tclone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;",
                    "514": "\t\tclone->data = buf->data;",
                    "515": "\t\tclone->len = buf->len;",
                    "516": "\t\tclone->size = buf->size;",
                    "517": "\t} else {",
                    "518": "\t\tsize_t size = buf->size;",
                    "519": "",
                    "520": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "521": "",
                    "522": "\t\tclone->__buf = data_alloc(clone, &size, timeout);",
                    "523": "\t\tif (!clone->__buf || size < buf->size) {",
                    "524": "\t\t\tnet_buf_destroy(clone);",
                    "525": "\t\t\treturn NULL;",
                    "526": "\t\t}",
                    "527": "",
                    "528": "\t\tclone->size = size;",
                    "529": "\t\tclone->data = clone->__buf + net_buf_headroom(buf);",
                    "530": "\t\tnet_buf_add_mem(clone, buf->data, buf->len);",
                    "531": "\t}",
                    "532": "",
                    "533": "\t/* user_data_size should be the same for buffers from the same pool */",
                    "534": "\t__ASSERT(buf->user_data_size == clone->user_data_size, \"Unexpected user data size\");",
                    "535": "",
                    "536": "\tmemcpy(clone->user_data, buf->user_data, clone->user_data_size);",
                    "537": "",
                    "538": "\treturn clone;",
                    "539": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_unref": {
            "name": "net_buf_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 440,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nvoid net_buf_unref(struct net_buf *buf)\n#endif\n{\n\t__ASSERT_NO_MSG(buf);\n\n\twhile (buf) {\n\t\tstruct net_buf *frags = buf->frags;\n\t\tstruct net_buf_pool *pool;\n\n\t\t__ASSERT(buf->ref, \"buf %p double free\", buf);\n\t\tif (!buf->ref) {\n#if defined(CONFIG_NET_BUF_LOG)\n\t\t\tNET_BUF_ERR(\"%s():%d: buf %p double free\", func, line,\n\t\t\t\t    buf);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tNET_BUF_DBG(\"buf %p ref %u pool_id %u frags %p\", buf, buf->ref,\n\t\t\t    buf->pool_id, buf->frags);\n\n\t\tif (--buf->ref > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tbuf->data = NULL;\n\t\tbuf->frags = NULL;\n\n\t\tpool = net_buf_pool_get(buf->pool_id);\n\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\tatomic_inc(&pool->avail_count);\n\t\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);\n#endif\n\n\t\tif (pool->destroy) {\n\t\t\tpool->destroy(buf);\n\t\t} else {\n\t\t\tnet_buf_destroy(buf);\n\t\t}\n\n\t\tbuf = frags;\n\t}\n}\n",
                {
                    "440": "void net_buf_unref(struct net_buf *buf)",
                    "441": "#endif",
                    "442": "{",
                    "443": "\t__ASSERT_NO_MSG(buf);",
                    "444": "",
                    "445": "\twhile (buf) {",
                    "446": "\t\tstruct net_buf *frags = buf->frags;",
                    "447": "\t\tstruct net_buf_pool *pool;",
                    "448": "",
                    "449": "\t\t__ASSERT(buf->ref, \"buf %p double free\", buf);",
                    "450": "\t\tif (!buf->ref) {",
                    "451": "#if defined(CONFIG_NET_BUF_LOG)",
                    "452": "\t\t\tNET_BUF_ERR(\"%s():%d: buf %p double free\", func, line,",
                    "453": "\t\t\t\t    buf);",
                    "454": "#endif",
                    "455": "\t\t\treturn;",
                    "456": "\t\t}",
                    "457": "\t\tNET_BUF_DBG(\"buf %p ref %u pool_id %u frags %p\", buf, buf->ref,",
                    "458": "\t\t\t    buf->pool_id, buf->frags);",
                    "459": "",
                    "460": "\t\tif (--buf->ref > 0) {",
                    "461": "\t\t\treturn;",
                    "462": "\t\t}",
                    "463": "",
                    "464": "\t\tbuf->data = NULL;",
                    "465": "\t\tbuf->frags = NULL;",
                    "466": "",
                    "467": "\t\tpool = net_buf_pool_get(buf->pool_id);",
                    "468": "",
                    "469": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "470": "\t\tatomic_inc(&pool->avail_count);",
                    "471": "\t\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);",
                    "472": "#endif",
                    "473": "",
                    "474": "\t\tif (pool->destroy) {",
                    "475": "\t\t\tpool->destroy(buf);",
                    "476": "\t\t} else {",
                    "477": "\t\t\tnet_buf_destroy(buf);",
                    "478": "\t\t}",
                    "479": "",
                    "480": "\t\tbuf = frags;",
                    "481": "\t}",
                    "482": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_reset": {
            "name": "net_buf_reset",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 88,
            "function_content": [
                "/* Linker-defined symbol bound to the static pool structs */\nvoid net_buf_reset(struct net_buf *buf)\n{\n\t__ASSERT_NO_MSG(buf->frags == NULL);\n\n\tnet_buf_simple_reset(&buf->b);\n}\n",
                {
                    "88": "void net_buf_reset(struct net_buf *buf)",
                    "89": "{",
                    "90": "\t__ASSERT_NO_MSG(buf->frags == NULL);",
                    "91": "",
                    "92": "\tnet_buf_simple_reset(&buf->b);",
                    "93": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_alloc_with_data": {
            "name": "net_buf_alloc_with_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 385,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nstruct net_buf *net_buf_alloc_with_data(struct net_buf_pool *pool,\n\t\t\t\t\tvoid *data, size_t size,\n\t\t\t\t\tk_timeout_t timeout)\n#endif\n{\n\tstruct net_buf *buf;\n\n#if defined(CONFIG_NET_BUF_LOG)\n\tbuf = net_buf_alloc_len_debug(pool, 0, timeout, func, line);\n#else\n\tbuf = net_buf_alloc_len(pool, 0, timeout);\n#endif\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tnet_buf_simple_init_with_data(&buf->b, data, size);\n\tbuf->flags = NET_BUF_EXTERNAL_DATA;\n\n\treturn buf;\n}\n",
                {
                    "385": "struct net_buf *net_buf_alloc_with_data(struct net_buf_pool *pool,",
                    "386": "\t\t\t\t\tvoid *data, size_t size,",
                    "387": "\t\t\t\t\tk_timeout_t timeout)",
                    "388": "#endif",
                    "389": "{",
                    "390": "\tstruct net_buf *buf;",
                    "391": "",
                    "392": "#if defined(CONFIG_NET_BUF_LOG)",
                    "393": "\tbuf = net_buf_alloc_len_debug(pool, 0, timeout, func, line);",
                    "394": "#else",
                    "395": "\tbuf = net_buf_alloc_len(pool, 0, timeout);",
                    "396": "#endif",
                    "397": "\tif (!buf) {",
                    "398": "\t\treturn NULL;",
                    "399": "\t}",
                    "400": "",
                    "401": "\tnet_buf_simple_init_with_data(&buf->b, data, size);",
                    "402": "\tbuf->flags = NET_BUF_EXTERNAL_DATA;",
                    "403": "",
                    "404": "\treturn buf;",
                    "405": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_alloc_len": {
            "name": "net_buf_alloc_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 249,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE > 0 */\nstruct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,\n\t\t\t\t  k_timeout_t timeout)\n#endif\n{\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tstruct net_buf *buf;\n\tk_spinlock_key_t key;\n\n\t__ASSERT_NO_MSG(pool);\n\n\tNET_BUF_DBG(\"%s():%d: pool %p size %zu\", func, line, pool, size);\n\n\t/* We need to prevent race conditions\n\t * when accessing pool->uninit_count.\n\t */\n\tkey = k_spin_lock(&pool->lock);\n\n\t/* If there are uninitialized buffers we're guaranteed to succeed\n\t * with the allocation one way or another.\n\t */\n\tif (pool->uninit_count) {\n\t\tuint16_t uninit_count;\n\n\t\t/* If this is not the first access to the pool, we can\n\t\t * be opportunistic and try to fetch a previously used\n\t\t * buffer from the LIFO with K_NO_WAIT.\n\t\t */\n\t\tif (pool->uninit_count < pool->buf_count) {\n\t\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);\n\t\t\tif (buf) {\n\t\t\t\tk_spin_unlock(&pool->lock, key);\n\t\t\t\tgoto success;\n\t\t\t}\n\t\t}\n\n\t\tuninit_count = pool->uninit_count--;\n\t\tk_spin_unlock(&pool->lock, key);\n\n\t\tbuf = pool_get_uninit(pool, uninit_count);\n\t\tgoto success;\n\t}\n\n\tk_spin_unlock(&pool->lock, key);\n\n#if defined(CONFIG_NET_BUF_LOG) && (CONFIG_NET_BUF_LOG_LEVEL >= LOG_LEVEL_WRN)\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\tuint32_t ref = k_uptime_get_32();\n\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);\n\t\twhile (!buf) {\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s low on buffers.\",\n\t\t\t\t     func, line, pool->name);\n#else\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p low on buffers.\",\n\t\t\t\t     func, line, pool);\n#endif\n\t\t\tbuf = k_lifo_get(&pool->free, WARN_ALLOC_INTERVAL);\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s blocked for %u secs\",\n\t\t\t\t     func, line, pool->name,\n\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);\n#else\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p blocked for %u secs\",\n\t\t\t\t     func, line, pool,\n\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);\n#endif\n\t\t}\n\t} else {\n\t\tbuf = k_lifo_get(&pool->free, timeout);\n\t}\n#else\n\tbuf = k_lifo_get(&pool->free, timeout);\n#endif\n\tif (!buf) {\n\t\tNET_BUF_ERR(\"%s():%d: Failed to get free buffer\", func, line);\n\t\treturn NULL;\n\t}\n\nsuccess:\n\tNET_BUF_DBG(\"allocated buf %p\", buf);\n\n\tif (size) {\n\t\t__maybe_unused size_t req_size = size;\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\t\tbuf->__buf = data_alloc(buf, &size, timeout);\n\t\tif (!buf->__buf) {\n\t\t\tNET_BUF_ERR(\"%s():%d: Failed to allocate data\",\n\t\t\t\t    func, line);\n\t\t\tnet_buf_destroy(buf);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t__ASSERT_NO_MSG(req_size <= size);\n\t} else {\n\t\tbuf->__buf = NULL;\n\t}\n\n\tbuf->ref   = 1U;\n\tbuf->flags = 0U;\n\tbuf->frags = NULL;\n\tbuf->size  = size;\n\tmemset(buf->user_data, 0, buf->user_data_size);\n\tnet_buf_reset(buf);\n\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\tatomic_dec(&pool->avail_count);\n\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);\n\tpool->max_used = max(pool->max_used,\n\t\t\t     pool->buf_count - atomic_get(&pool->avail_count));\n#endif\n\treturn buf;\n}\n",
                {
                    "249": "struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,",
                    "250": "\t\t\t\t  k_timeout_t timeout)",
                    "251": "#endif",
                    "252": "{",
                    "253": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "254": "\tstruct net_buf *buf;",
                    "255": "\tk_spinlock_key_t key;",
                    "256": "",
                    "257": "\t__ASSERT_NO_MSG(pool);",
                    "258": "",
                    "259": "\tNET_BUF_DBG(\"%s():%d: pool %p size %zu\", func, line, pool, size);",
                    "260": "",
                    "261": "\t/* We need to prevent race conditions",
                    "262": "\t * when accessing pool->uninit_count.",
                    "263": "\t */",
                    "264": "\tkey = k_spin_lock(&pool->lock);",
                    "265": "",
                    "266": "\t/* If there are uninitialized buffers we're guaranteed to succeed",
                    "267": "\t * with the allocation one way or another.",
                    "268": "\t */",
                    "269": "\tif (pool->uninit_count) {",
                    "270": "\t\tuint16_t uninit_count;",
                    "271": "",
                    "272": "\t\t/* If this is not the first access to the pool, we can",
                    "273": "\t\t * be opportunistic and try to fetch a previously used",
                    "274": "\t\t * buffer from the LIFO with K_NO_WAIT.",
                    "275": "\t\t */",
                    "276": "\t\tif (pool->uninit_count < pool->buf_count) {",
                    "277": "\t\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);",
                    "278": "\t\t\tif (buf) {",
                    "279": "\t\t\t\tk_spin_unlock(&pool->lock, key);",
                    "280": "\t\t\t\tgoto success;",
                    "281": "\t\t\t}",
                    "282": "\t\t}",
                    "283": "",
                    "284": "\t\tuninit_count = pool->uninit_count--;",
                    "285": "\t\tk_spin_unlock(&pool->lock, key);",
                    "286": "",
                    "287": "\t\tbuf = pool_get_uninit(pool, uninit_count);",
                    "288": "\t\tgoto success;",
                    "289": "\t}",
                    "290": "",
                    "291": "\tk_spin_unlock(&pool->lock, key);",
                    "292": "",
                    "293": "#if defined(CONFIG_NET_BUF_LOG) && (CONFIG_NET_BUF_LOG_LEVEL >= LOG_LEVEL_WRN)",
                    "294": "\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {",
                    "295": "\t\tuint32_t ref = k_uptime_get_32();",
                    "296": "\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);",
                    "297": "\t\twhile (!buf) {",
                    "298": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "299": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s low on buffers.\",",
                    "300": "\t\t\t\t     func, line, pool->name);",
                    "301": "#else",
                    "302": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p low on buffers.\",",
                    "303": "\t\t\t\t     func, line, pool);",
                    "304": "#endif",
                    "305": "\t\t\tbuf = k_lifo_get(&pool->free, WARN_ALLOC_INTERVAL);",
                    "306": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "307": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s blocked for %u secs\",",
                    "308": "\t\t\t\t     func, line, pool->name,",
                    "309": "\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);",
                    "310": "#else",
                    "311": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p blocked for %u secs\",",
                    "312": "\t\t\t\t     func, line, pool,",
                    "313": "\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);",
                    "314": "#endif",
                    "315": "\t\t}",
                    "316": "\t} else {",
                    "317": "\t\tbuf = k_lifo_get(&pool->free, timeout);",
                    "318": "\t}",
                    "319": "#else",
                    "320": "\tbuf = k_lifo_get(&pool->free, timeout);",
                    "321": "#endif",
                    "322": "\tif (!buf) {",
                    "323": "\t\tNET_BUF_ERR(\"%s():%d: Failed to get free buffer\", func, line);",
                    "324": "\t\treturn NULL;",
                    "325": "\t}",
                    "326": "",
                    "327": "success:",
                    "328": "\tNET_BUF_DBG(\"allocated buf %p\", buf);",
                    "329": "",
                    "330": "\tif (size) {",
                    "331": "\t\t__maybe_unused size_t req_size = size;",
                    "332": "",
                    "333": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "334": "\t\tbuf->__buf = data_alloc(buf, &size, timeout);",
                    "335": "\t\tif (!buf->__buf) {",
                    "336": "\t\t\tNET_BUF_ERR(\"%s():%d: Failed to allocate data\",",
                    "337": "\t\t\t\t    func, line);",
                    "338": "\t\t\tnet_buf_destroy(buf);",
                    "339": "\t\t\treturn NULL;",
                    "340": "\t\t}",
                    "341": "",
                    "342": "\t\t__ASSERT_NO_MSG(req_size <= size);",
                    "343": "\t} else {",
                    "344": "\t\tbuf->__buf = NULL;",
                    "345": "\t}",
                    "346": "",
                    "347": "\tbuf->ref   = 1U;",
                    "348": "\tbuf->flags = 0U;",
                    "349": "\tbuf->frags = NULL;",
                    "350": "\tbuf->size  = size;",
                    "351": "\tmemset(buf->user_data, 0, buf->user_data_size);",
                    "352": "\tnet_buf_reset(buf);",
                    "353": "",
                    "354": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "355": "\tatomic_dec(&pool->avail_count);",
                    "356": "\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);",
                    "357": "\tpool->max_used = max(pool->max_used,",
                    "358": "\t\t\t     pool->buf_count - atomic_get(&pool->avail_count));",
                    "359": "#endif",
                    "360": "\treturn buf;",
                    "361": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_try_send_data": {
            "name": "net_try_send_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_core.c",
            "location_line": 370,
            "function_content": [
                "/* The source check must be done after the destination check\n* as having src 127.0.0.0/8 is perfectly ok if dst is in\n* localhost subnet too.\n*/\nint net_try_send_data(struct net_pkt *pkt, k_timeout_t timeout)\n{\n\tstruct net_if *iface;\n\tint family;\n\tint status;\n\tint ret;\n\n\tSYS_PORT_TRACING_FUNC_ENTER(net, send_data, pkt);\n\n\tif (!pkt || !pkt->frags) {\n\t\tret = -ENODATA;\n\t\tgoto err;\n\t}\n\n\tif (!net_pkt_iface(pkt)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!net_if_is_up(net_pkt_iface(pkt))) {\n\t\tret = -ENETDOWN;\n\t\tgoto err;\n\t}\n\n\tnet_pkt_trim_buffer(pkt);\n\tnet_pkt_cursor_init(pkt);\n\n\tstatus = check_ip(pkt);\n\tif (status < 0) {\n\t\t/* Special handling for ENOMSG which is returned if packet\n\t\t * TTL is 0 or hop limit is 0. This is not an error as it is\n\t\t * perfectly valid case to set the limit to 0. In this case\n\t\t * we just silently drop the packet by returning 0.\n\t\t */\n\t\tif (status == -ENOMSG) {\n\t\t\tnet_pkt_unref(pkt);\n\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\n\t\treturn status;\n\t} else if (status > 0) {\n\t\t/* Packet is destined back to us so send it directly\n\t\t * to RX processing.\n\t\t */\n\t\tNET_DBG(\"Loopback pkt %p back to us\", pkt);\n\t\tnet_pkt_set_loopback(pkt, true);\n\t\tnet_pkt_set_l2_processed(pkt, true);\n\t\tnet_queue_rx(net_pkt_iface(pkt), pkt);\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n#if defined(CONFIG_NET_IPV4) || defined(CONFIG_NET_IPV6)\n\tif (process_multicast(pkt)) {\n\t\tstruct net_pkt *clone = net_pkt_clone(pkt, K_NO_WAIT);\n\n\t\tif (clone != NULL) {\n\t\t\tnet_pkt_set_iface(clone, net_pkt_iface(pkt));\n\t\t\tif (net_recv_data(net_pkt_iface(clone), clone) < 0) {\n\t\t\t\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {\n\t\t\t\t\tswitch (net_pkt_family(pkt)) {\n#if defined(CONFIG_NET_IPV4)\n\t\t\t\t\tcase NET_AF_INET:\n\t\t\t\t\t\tnet_stats_update_ipv4_sent(net_pkt_iface(pkt));\n\t\t\t\t\t\tbreak;\n#endif\n#if defined(CONFIG_NET_IPV6)\n\t\t\t\t\tcase NET_AF_INET6:\n\t\t\t\t\t\tnet_stats_update_ipv6_sent(net_pkt_iface(pkt));\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnet_pkt_unref(clone);\n\t\t\t}\n\t\t} else {\n\t\t\tNET_DBG(\"Failed to clone multicast packet\");\n\t\t}\n\t}\n#endif\n\n\t/* The pkt might contain garbage already after the call to\n\t * net_if_try_send_data(), so do not use pkt after that call.\n\t * Remember the iface and family for statistics update.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {\n\t\tiface = net_pkt_iface(pkt);\n\t\tfamily = net_pkt_family(pkt);\n\t}\n\n\tif (net_if_try_send_data(net_pkt_iface(pkt), pkt, timeout) == NET_DROP) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {\n\t\tswitch (family) {\n\t\tcase NET_AF_INET:\n\t\t\tnet_stats_update_ipv4_sent(iface);\n\t\t\tbreak;\n\t\tcase NET_AF_INET6:\n\t\t\tnet_stats_update_ipv6_sent(iface);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\nerr:\n\tSYS_PORT_TRACING_FUNC_EXIT(net, send_data, pkt, ret);\n\n\treturn ret;\n}\n",
                {
                    "370": "int net_try_send_data(struct net_pkt *pkt, k_timeout_t timeout)",
                    "371": "{",
                    "372": "\tstruct net_if *iface;",
                    "373": "\tint family;",
                    "374": "\tint status;",
                    "375": "\tint ret;",
                    "376": "",
                    "377": "\tSYS_PORT_TRACING_FUNC_ENTER(net, send_data, pkt);",
                    "378": "",
                    "379": "\tif (!pkt || !pkt->frags) {",
                    "380": "\t\tret = -ENODATA;",
                    "381": "\t\tgoto err;",
                    "382": "\t}",
                    "383": "",
                    "384": "\tif (!net_pkt_iface(pkt)) {",
                    "385": "\t\tret = -EINVAL;",
                    "386": "\t\tgoto err;",
                    "387": "\t}",
                    "388": "",
                    "389": "\tif (!net_if_is_up(net_pkt_iface(pkt))) {",
                    "390": "\t\tret = -ENETDOWN;",
                    "391": "\t\tgoto err;",
                    "392": "\t}",
                    "393": "",
                    "394": "\tnet_pkt_trim_buffer(pkt);",
                    "395": "\tnet_pkt_cursor_init(pkt);",
                    "396": "",
                    "397": "\tstatus = check_ip(pkt);",
                    "398": "\tif (status < 0) {",
                    "399": "\t\t/* Special handling for ENOMSG which is returned if packet",
                    "400": "\t\t * TTL is 0 or hop limit is 0. This is not an error as it is",
                    "401": "\t\t * perfectly valid case to set the limit to 0. In this case",
                    "402": "\t\t * we just silently drop the packet by returning 0.",
                    "403": "\t\t */",
                    "404": "\t\tif (status == -ENOMSG) {",
                    "405": "\t\t\tnet_pkt_unref(pkt);",
                    "406": "\t\t\tret = 0;",
                    "407": "\t\t\tgoto err;",
                    "408": "\t\t}",
                    "409": "",
                    "410": "\t\treturn status;",
                    "411": "\t} else if (status > 0) {",
                    "412": "\t\t/* Packet is destined back to us so send it directly",
                    "413": "\t\t * to RX processing.",
                    "414": "\t\t */",
                    "415": "\t\tNET_DBG(\"Loopback pkt %p back to us\", pkt);",
                    "416": "\t\tnet_pkt_set_loopback(pkt, true);",
                    "417": "\t\tnet_pkt_set_l2_processed(pkt, true);",
                    "418": "\t\tnet_queue_rx(net_pkt_iface(pkt), pkt);",
                    "419": "\t\tret = 0;",
                    "420": "\t\tgoto err;",
                    "421": "\t}",
                    "422": "",
                    "423": "#if defined(CONFIG_NET_IPV4) || defined(CONFIG_NET_IPV6)",
                    "424": "\tif (process_multicast(pkt)) {",
                    "425": "\t\tstruct net_pkt *clone = net_pkt_clone(pkt, K_NO_WAIT);",
                    "426": "",
                    "427": "\t\tif (clone != NULL) {",
                    "428": "\t\t\tnet_pkt_set_iface(clone, net_pkt_iface(pkt));",
                    "429": "\t\t\tif (net_recv_data(net_pkt_iface(clone), clone) < 0) {",
                    "430": "\t\t\t\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {",
                    "431": "\t\t\t\t\tswitch (net_pkt_family(pkt)) {",
                    "432": "#if defined(CONFIG_NET_IPV4)",
                    "433": "\t\t\t\t\tcase NET_AF_INET:",
                    "434": "\t\t\t\t\t\tnet_stats_update_ipv4_sent(net_pkt_iface(pkt));",
                    "435": "\t\t\t\t\t\tbreak;",
                    "436": "#endif",
                    "437": "#if defined(CONFIG_NET_IPV6)",
                    "438": "\t\t\t\t\tcase NET_AF_INET6:",
                    "439": "\t\t\t\t\t\tnet_stats_update_ipv6_sent(net_pkt_iface(pkt));",
                    "440": "\t\t\t\t\t\tbreak;",
                    "441": "#endif",
                    "442": "\t\t\t\t\t}",
                    "443": "\t\t\t\t}",
                    "444": "\t\t\t\tnet_pkt_unref(clone);",
                    "445": "\t\t\t}",
                    "446": "\t\t} else {",
                    "447": "\t\t\tNET_DBG(\"Failed to clone multicast packet\");",
                    "448": "\t\t}",
                    "449": "\t}",
                    "450": "#endif",
                    "451": "",
                    "452": "\t/* The pkt might contain garbage already after the call to",
                    "453": "\t * net_if_try_send_data(), so do not use pkt after that call.",
                    "454": "\t * Remember the iface and family for statistics update.",
                    "455": "\t */",
                    "456": "\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {",
                    "457": "\t\tiface = net_pkt_iface(pkt);",
                    "458": "\t\tfamily = net_pkt_family(pkt);",
                    "459": "\t}",
                    "460": "",
                    "461": "\tif (net_if_try_send_data(net_pkt_iface(pkt), pkt, timeout) == NET_DROP) {",
                    "462": "\t\tret = -EIO;",
                    "463": "\t\tgoto err;",
                    "464": "\t}",
                    "465": "",
                    "466": "\tif (IS_ENABLED(CONFIG_NET_STATISTICS)) {",
                    "467": "\t\tswitch (family) {",
                    "468": "\t\tcase NET_AF_INET:",
                    "469": "\t\t\tnet_stats_update_ipv4_sent(iface);",
                    "470": "\t\t\tbreak;",
                    "471": "\t\tcase NET_AF_INET6:",
                    "472": "\t\t\tnet_stats_update_ipv6_sent(iface);",
                    "473": "\t\t\tbreak;",
                    "474": "\t\t}",
                    "475": "\t}",
                    "476": "",
                    "477": "\tret = 0;",
                    "478": "",
                    "479": "err:",
                    "480": "\tSYS_PORT_TRACING_FUNC_EXIT(net, send_data, pkt, ret);",
                    "481": "",
                    "482": "\treturn ret;",
                    "483": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_recv_data": {
            "name": "net_recv_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_core.c",
            "location_line": 549,
            "function_content": [
                "/* Called by driver when a packet has been received */\nint net_recv_data(struct net_if *iface, struct net_pkt *pkt)\n{\n\tint ret;\n#if defined(CONFIG_NET_DSA) && !defined(CONFIG_NET_DSA_DEPRECATED)\n\tstruct ethernet_context *eth_ctx = net_if_l2_data(iface);\n\n\t/* DSA driver handles first to untag and to redirect to user interface. */\n\tif (eth_ctx != NULL && (eth_ctx->dsa_port == DSA_CONDUIT_PORT)) {\n\t\tiface = dsa_recv(iface, pkt);\n\t}\n#endif\n\n\tSYS_PORT_TRACING_FUNC_ENTER(net, recv_data, iface, pkt);\n\n\tif (!pkt || !iface) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (net_pkt_is_empty(pkt)) {\n\t\tret = -ENODATA;\n\t\tgoto err;\n\t}\n\n\tif (!net_if_flag_is_set(iface, NET_IF_UP)) {\n\t\tret = -ENETDOWN;\n\t\tgoto err;\n\t}\n\n\tnet_pkt_set_overwrite(pkt, true);\n\tnet_pkt_cursor_init(pkt);\n\n\tNET_DBG(\"prio %d iface %p pkt %p len %zu\", net_pkt_priority(pkt),\n\t\tiface, pkt, net_pkt_get_len(pkt));\n\n\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {\n\t\tnet_pkt_set_orig_iface(pkt, iface);\n\t}\n\n\tnet_pkt_set_iface(pkt, iface);\n\n\tif (!net_pkt_filter_recv_ok(pkt)) {\n\t\t/* Silently drop the packet, but update the statistics in order\n\t\t * to be able to monitor filter activity.\n\t\t */\n\t\tnet_stats_update_filter_rx_drop(net_pkt_iface(pkt));\n\t\tnet_pkt_unref(pkt);\n\t} else {\n\t\tnet_queue_rx(iface, pkt);\n\t}\n\n\tret = 0;\n\nerr:\n\tSYS_PORT_TRACING_FUNC_EXIT(net, recv_data, iface, pkt, ret);\n\n\treturn ret;\n}\n",
                {
                    "549": "int net_recv_data(struct net_if *iface, struct net_pkt *pkt)",
                    "550": "{",
                    "551": "\tint ret;",
                    "552": "#if defined(CONFIG_NET_DSA) && !defined(CONFIG_NET_DSA_DEPRECATED)",
                    "553": "\tstruct ethernet_context *eth_ctx = net_if_l2_data(iface);",
                    "554": "",
                    "555": "\t/* DSA driver handles first to untag and to redirect to user interface. */",
                    "556": "\tif (eth_ctx != NULL && (eth_ctx->dsa_port == DSA_CONDUIT_PORT)) {",
                    "557": "\t\tiface = dsa_recv(iface, pkt);",
                    "558": "\t}",
                    "559": "#endif",
                    "560": "",
                    "561": "\tSYS_PORT_TRACING_FUNC_ENTER(net, recv_data, iface, pkt);",
                    "562": "",
                    "563": "\tif (!pkt || !iface) {",
                    "564": "\t\tret = -EINVAL;",
                    "565": "\t\tgoto err;",
                    "566": "\t}",
                    "567": "",
                    "568": "\tif (net_pkt_is_empty(pkt)) {",
                    "569": "\t\tret = -ENODATA;",
                    "570": "\t\tgoto err;",
                    "571": "\t}",
                    "572": "",
                    "573": "\tif (!net_if_flag_is_set(iface, NET_IF_UP)) {",
                    "574": "\t\tret = -ENETDOWN;",
                    "575": "\t\tgoto err;",
                    "576": "\t}",
                    "577": "",
                    "578": "\tnet_pkt_set_overwrite(pkt, true);",
                    "579": "\tnet_pkt_cursor_init(pkt);",
                    "580": "",
                    "581": "\tNET_DBG(\"prio %d iface %p pkt %p len %zu\", net_pkt_priority(pkt),",
                    "582": "\t\tiface, pkt, net_pkt_get_len(pkt));",
                    "583": "",
                    "584": "\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {",
                    "585": "\t\tnet_pkt_set_orig_iface(pkt, iface);",
                    "586": "\t}",
                    "587": "",
                    "588": "\tnet_pkt_set_iface(pkt, iface);",
                    "589": "",
                    "590": "\tif (!net_pkt_filter_recv_ok(pkt)) {",
                    "591": "\t\t/* Silently drop the packet, but update the statistics in order",
                    "592": "\t\t * to be able to monitor filter activity.",
                    "593": "\t\t */",
                    "594": "\t\tnet_stats_update_filter_rx_drop(net_pkt_iface(pkt));",
                    "595": "\t\tnet_pkt_unref(pkt);",
                    "596": "\t} else {",
                    "597": "\t\tnet_queue_rx(iface, pkt);",
                    "598": "\t}",
                    "599": "",
                    "600": "\tret = 0;",
                    "601": "",
                    "602": "err:",
                    "603": "\tSYS_PORT_TRACING_FUNC_EXIT(net, recv_data, iface, pkt, ret);",
                    "604": "",
                    "605": "\treturn ret;",
                    "606": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_net_addr_ntop": {
            "name": "z_impl_net_addr_ntop",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 160,
            "function_content": [
                "/*\n* Copyright (c) 2016 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nchar *z_impl_net_addr_ntop(net_sa_family_t family, const void *src,\n\t\t\t   char *dst, size_t size)\n{\n\tstruct net_in_addr addr = { 0 };\n\tstruct net_in6_addr addr6 = { 0 };\n\tuint16_t *w = NULL;\n\tint i;\n\tuint8_t longest = 1U;\n\tint pos = -1;\n\tchar delim = ':';\n\tuint8_t zeros[8] = { 0 };\n\tchar *ptr = dst;\n\tint len = -1;\n\tuint16_t value;\n\tbool needcolon = false;\n\tbool mapped = false;\n\n\tswitch (family) {\n\tcase NET_AF_INET6:\n\t\tif (size < NET_INET6_ADDRSTRLEN) {\n\t\t\t/* POSIX definition is the size - includes nil */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnet_ipv6_addr_copy_raw(addr6.s6_addr, src);\n\t\tw = (uint16_t *)addr6.s6_addr16;\n\t\tlen = 8;\n\n\t\tif (net_ipv6_addr_is_v4_mapped(&addr6)) {\n\t\t\tmapped = true;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tfor (int j = i; j < 8; j++) {\n\t\t\t\tif (w[j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tzeros[i]++;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (zeros[i] > longest) {\n\t\t\t\tlongest = zeros[i];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\n\t\tif (longest == 1U) {\n\t\t\tpos = -1;\n\t\t}\n\t\tbreak;\n\n\tcase NET_AF_INET:\n\t\tif (size < NET_INET_ADDRSTRLEN) {\n\t\t\t/* POSIX definition is the size - includes nil */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnet_ipv4_addr_copy_raw(addr.s4_addr, src);\n\t\tlen = 4;\n\t\tdelim = '.';\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\nprint_mapped:\n\tfor (i = 0; i < len; i++) {\n\t\t/* IPv4 address a.b.c.d */\n\t\tif (len == 4) {\n\t\t\tuint8_t l;\n\n\t\t\tvalue = (uint16_t)addr.s4_addr[i];\n\n\t\t\t/* net_byte_to_udec() eats 0 */\n\t\t\tif (value == 0U) {\n\t\t\t\t*ptr++ = '0';\n\t\t\t\t*ptr++ = delim;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tl = net_value_to_udec(ptr, value, 0);\n\n\t\t\tptr += l;\n\t\t\t*ptr++ = delim;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mapped && (i > 5)) {\n\t\t\tdelim = '.';\n\t\t\tlen = 4;\n\t\t\taddr.s_addr = addr6.s6_addr32[3];\n\t\t\t*ptr++ = ':';\n\t\t\tfamily = NET_AF_INET;\n\t\t\tgoto print_mapped;\n\t\t}\n\n\t\t/* IPv6 address */\n\t\tif (i == pos) {\n\t\t\tif (needcolon || i == 0U) {\n\t\t\t\t*ptr++ = ':';\n\t\t\t}\n\n\t\t\t*ptr++ = ':';\n\t\t\tneedcolon = false;\n\t\t\ti += (int)longest - 1;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (needcolon) {\n\t\t\t*ptr++ = ':';\n\t\t}\n\n\t\tvalue = sys_be16_to_cpu(UNALIGNED_GET(&w[i]));\n\t\tuint8_t bh = value >> 8;\n\t\tuint8_t bl = value & 0xff;\n\n\t\tif (bh) {\n\t\t\t/* Convert high byte to hex without padding */\n\t\t\tptr = net_byte_to_hex(ptr, bh, 'a', false);\n\n\t\t\t/* Always pad the low byte, since high byte is non - zero */\n\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', true);\n\t\t} else {\n\t\t\t/* For the case where the high byte is zero, only process the low byte\n\t\t\t * Do not pad the low byte, since high byte is zero\n\t\t\t */\n\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', false);\n\t\t}\n\n\t\tneedcolon = true;\n\t}\n\n\tif (family == NET_AF_INET) {\n\t\t*(ptr - 1) = '\\0';\n\t} else {\n\t\t*ptr = '\\0';\n\t}\n\n\treturn dst;\n}\n",
                {
                    "160": "char *z_impl_net_addr_ntop(net_sa_family_t family, const void *src,",
                    "161": "\t\t\t   char *dst, size_t size)",
                    "162": "{",
                    "163": "\tstruct net_in_addr addr = { 0 };",
                    "164": "\tstruct net_in6_addr addr6 = { 0 };",
                    "165": "\tuint16_t *w = NULL;",
                    "166": "\tint i;",
                    "167": "\tuint8_t longest = 1U;",
                    "168": "\tint pos = -1;",
                    "169": "\tchar delim = ':';",
                    "170": "\tuint8_t zeros[8] = { 0 };",
                    "171": "\tchar *ptr = dst;",
                    "172": "\tint len = -1;",
                    "173": "\tuint16_t value;",
                    "174": "\tbool needcolon = false;",
                    "175": "\tbool mapped = false;",
                    "176": "",
                    "177": "\tswitch (family) {",
                    "178": "\tcase NET_AF_INET6:",
                    "179": "\t\tif (size < NET_INET6_ADDRSTRLEN) {",
                    "180": "\t\t\t/* POSIX definition is the size - includes nil */",
                    "181": "\t\t\treturn NULL;",
                    "182": "\t\t}",
                    "183": "",
                    "184": "\t\tnet_ipv6_addr_copy_raw(addr6.s6_addr, src);",
                    "185": "\t\tw = (uint16_t *)addr6.s6_addr16;",
                    "186": "\t\tlen = 8;",
                    "187": "",
                    "188": "\t\tif (net_ipv6_addr_is_v4_mapped(&addr6)) {",
                    "189": "\t\t\tmapped = true;",
                    "190": "\t\t}",
                    "191": "",
                    "192": "\t\tfor (i = 0; i < 8; i++) {",
                    "193": "\t\t\tfor (int j = i; j < 8; j++) {",
                    "194": "\t\t\t\tif (w[j] != 0) {",
                    "195": "\t\t\t\t\tbreak;",
                    "196": "\t\t\t\t}",
                    "197": "",
                    "198": "\t\t\t\tzeros[i]++;",
                    "199": "\t\t\t}",
                    "200": "\t\t}",
                    "201": "",
                    "202": "\t\tfor (i = 0; i < 8; i++) {",
                    "203": "\t\t\tif (zeros[i] > longest) {",
                    "204": "\t\t\t\tlongest = zeros[i];",
                    "205": "\t\t\t\tpos = i;",
                    "206": "\t\t\t}",
                    "207": "\t\t}",
                    "208": "",
                    "209": "\t\tif (longest == 1U) {",
                    "210": "\t\t\tpos = -1;",
                    "211": "\t\t}",
                    "212": "\t\tbreak;",
                    "213": "",
                    "214": "\tcase NET_AF_INET:",
                    "215": "\t\tif (size < NET_INET_ADDRSTRLEN) {",
                    "216": "\t\t\t/* POSIX definition is the size - includes nil */",
                    "217": "\t\t\treturn NULL;",
                    "218": "\t\t}",
                    "219": "",
                    "220": "\t\tnet_ipv4_addr_copy_raw(addr.s4_addr, src);",
                    "221": "\t\tlen = 4;",
                    "222": "\t\tdelim = '.';",
                    "223": "\t\tbreak;",
                    "224": "",
                    "225": "\tdefault:",
                    "226": "\t\treturn NULL;",
                    "227": "\t}",
                    "228": "",
                    "229": "print_mapped:",
                    "230": "\tfor (i = 0; i < len; i++) {",
                    "231": "\t\t/* IPv4 address a.b.c.d */",
                    "232": "\t\tif (len == 4) {",
                    "233": "\t\t\tuint8_t l;",
                    "234": "",
                    "235": "\t\t\tvalue = (uint16_t)addr.s4_addr[i];",
                    "236": "",
                    "237": "\t\t\t/* net_byte_to_udec() eats 0 */",
                    "238": "\t\t\tif (value == 0U) {",
                    "239": "\t\t\t\t*ptr++ = '0';",
                    "240": "\t\t\t\t*ptr++ = delim;",
                    "241": "\t\t\t\tcontinue;",
                    "242": "\t\t\t}",
                    "243": "",
                    "244": "\t\t\tl = net_value_to_udec(ptr, value, 0);",
                    "245": "",
                    "246": "\t\t\tptr += l;",
                    "247": "\t\t\t*ptr++ = delim;",
                    "248": "",
                    "249": "\t\t\tcontinue;",
                    "250": "\t\t}",
                    "251": "",
                    "252": "\t\tif (mapped && (i > 5)) {",
                    "253": "\t\t\tdelim = '.';",
                    "254": "\t\t\tlen = 4;",
                    "255": "\t\t\taddr.s_addr = addr6.s6_addr32[3];",
                    "256": "\t\t\t*ptr++ = ':';",
                    "257": "\t\t\tfamily = NET_AF_INET;",
                    "258": "\t\t\tgoto print_mapped;",
                    "259": "\t\t}",
                    "260": "",
                    "261": "\t\t/* IPv6 address */",
                    "262": "\t\tif (i == pos) {",
                    "263": "\t\t\tif (needcolon || i == 0U) {",
                    "264": "\t\t\t\t*ptr++ = ':';",
                    "265": "\t\t\t}",
                    "266": "",
                    "267": "\t\t\t*ptr++ = ':';",
                    "268": "\t\t\tneedcolon = false;",
                    "269": "\t\t\ti += (int)longest - 1;",
                    "270": "",
                    "271": "\t\t\tcontinue;",
                    "272": "\t\t}",
                    "273": "",
                    "274": "\t\tif (needcolon) {",
                    "275": "\t\t\t*ptr++ = ':';",
                    "276": "\t\t}",
                    "277": "",
                    "278": "\t\tvalue = sys_be16_to_cpu(UNALIGNED_GET(&w[i]));",
                    "279": "\t\tuint8_t bh = value >> 8;",
                    "280": "\t\tuint8_t bl = value & 0xff;",
                    "281": "",
                    "282": "\t\tif (bh) {",
                    "283": "\t\t\t/* Convert high byte to hex without padding */",
                    "284": "\t\t\tptr = net_byte_to_hex(ptr, bh, 'a', false);",
                    "285": "",
                    "286": "\t\t\t/* Always pad the low byte, since high byte is non - zero */",
                    "287": "\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', true);",
                    "288": "\t\t} else {",
                    "289": "\t\t\t/* For the case where the high byte is zero, only process the low byte",
                    "290": "\t\t\t * Do not pad the low byte, since high byte is zero",
                    "291": "\t\t\t */",
                    "292": "\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', false);",
                    "293": "\t\t}",
                    "294": "",
                    "295": "\t\tneedcolon = true;",
                    "296": "\t}",
                    "297": "",
                    "298": "\tif (family == NET_AF_INET) {",
                    "299": "\t\t*(ptr - 1) = '\\0';",
                    "300": "\t} else {",
                    "301": "\t\t*ptr = '\\0';",
                    "302": "\t}",
                    "303": "",
                    "304": "\treturn dst;",
                    "305": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_net_addr_pton": {
            "name": "z_impl_net_addr_pton",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 343,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_net_addr_pton(net_sa_family_t family, const char *src,\n\t\t\t void *dst)\n{\n\tif (family == NET_AF_INET) {\n\t\tstruct net_in_addr *addr = (struct net_in_addr *)dst;\n\t\tuint8_t index = 0, digits = 0;\n\t\tuint16_t value = 0, count = 0;\n\n\t\t(void)memset(addr, 0, sizeof(struct net_in_addr));\n\n\t\t/* A valid IPv4 address that can be used with inet_pton\n\t\t * must be in the standard dotted-decimal notation:\n\t\t *\n\t\t *    - Four octets, each ranging from 0 to 255\n\t\t *    - Separated by dots (.)\n\t\t *    - No leading zeros in each octet\n\t\t */\n\n\t\twhile (index < sizeof(struct net_in_addr)) {\n\t\t\tif (*src == '\\0' || *src == '.') {\n\t\t\t\tif (*src == '.') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tif ((digits > 1 && value < 10) ||\n\t\t\t\t    (digits > 2 && value < 100)) {\n\t\t\t\t\t/* Preceding zeroes */\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (digits == 0 || value > UINT8_MAX) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\taddr->s4_addr[index] = value;\n\n\t\t\t\tif (*src == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t\tdigits = 0;\n\t\t\t\tvalue = 0;\n\t\t\t} else if ('0' <= *src && *src <= '9') {\n\t\t\t\tif (++digits > 3) {\n\t\t\t\t\t/* Number too large */\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tvalue *= 10;\n\t\t\t\tvalue += *src - '0';\n\t\t\t} else {\n\t\t\t\t/* Invalid character */\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsrc++;\n\t\t}\n\n\t\tif (count != 3) {\n\t\t\t/* Three dots needed */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else if (family == NET_AF_INET6) {\n\t\t/* If the string contains a '.', it means it's of the form\n\t\t * X:X:X:X:X:X:x.x.x.x, and contains only 6 16-bit pieces\n\t\t */\n\t\tint expected_groups = strchr(src, '.') ? 6 : 8;\n\t\tstruct net_in6_addr *addr = (struct net_in6_addr *)dst;\n\t\tint i, len;\n\n\t\tif (*src == ':') {\n\t\t\t/* Ignore a leading colon, makes parsing neater */\n\t\t\tsrc++;\n\t\t}\n\n\t\tlen = strlen(src);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!(src[i] >= '0' && src[i] <= '9') &&\n\t\t\t    !(src[i] >= 'A' && src[i] <= 'F') &&\n\t\t\t    !(src[i] >= 'a' && src[i] <= 'f') &&\n\t\t\t    src[i] != '.' && src[i] != ':') {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < expected_groups; i++) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!src || *src == '\\0') {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (*src != ':') {\n\t\t\t\t/* Normal IPv6 16-bit piece */\n\t\t\t\tUNALIGNED_PUT(net_htons(strtol(src, NULL, 16)),\n\t\t\t\t\t      &addr->s6_addr16[i]);\n\t\t\t\tsrc = strchr(src, ':');\n\t\t\t\tif (src) {\n\t\t\t\t\tsrc++;\n\t\t\t\t} else {\n\t\t\t\t\tif (i < expected_groups - 1) {\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Two colons in a row */\n\n\t\t\tfor (; i < expected_groups; i++) {\n\t\t\t\tUNALIGNED_PUT(0, &addr->s6_addr16[i]);\n\t\t\t}\n\n\t\t\ttmp = strrchr(src, ':');\n\t\t\tif (src == tmp && (expected_groups == 6 || !src[1])) {\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (expected_groups == 6) {\n\t\t\t\t/* we need to drop the trailing\n\t\t\t\t * colon since it's between the\n\t\t\t\t * ipv6 and ipv4 addresses, rather than being\n\t\t\t\t * a part of the ipv6 address\n\t\t\t\t */\n\t\t\t\ttmp--;\n\t\t\t}\n\n\t\t\t/* Calculate the amount of skipped zeros */\n\t\t\ti = expected_groups - 1;\n\t\t\tdo {\n\t\t\t\tif (*tmp == ':') {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\tif (i < 0) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} while (tmp-- != src);\n\n\t\t\tsrc++;\n\t\t}\n\n\t\tif (expected_groups == 6) {\n\t\t\t/* Parse the IPv4 part */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tif (!src || !*src) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\taddr->s6_addr[12 + i] = strtol(src, NULL, 10);\n\n\t\t\t\tsrc = strchr(src, '.');\n\t\t\t\tif (src) {\n\t\t\t\t\tsrc++;\n\t\t\t\t} else {\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "343": "int z_impl_net_addr_pton(net_sa_family_t family, const char *src,",
                    "344": "\t\t\t void *dst)",
                    "345": "{",
                    "346": "\tif (family == NET_AF_INET) {",
                    "347": "\t\tstruct net_in_addr *addr = (struct net_in_addr *)dst;",
                    "348": "\t\tuint8_t index = 0, digits = 0;",
                    "349": "\t\tuint16_t value = 0, count = 0;",
                    "350": "",
                    "351": "\t\t(void)memset(addr, 0, sizeof(struct net_in_addr));",
                    "352": "",
                    "353": "\t\t/* A valid IPv4 address that can be used with inet_pton",
                    "354": "\t\t * must be in the standard dotted-decimal notation:",
                    "355": "\t\t *",
                    "356": "\t\t *    - Four octets, each ranging from 0 to 255",
                    "357": "\t\t *    - Separated by dots (.)",
                    "358": "\t\t *    - No leading zeros in each octet",
                    "359": "\t\t */",
                    "360": "",
                    "361": "\t\twhile (index < sizeof(struct net_in_addr)) {",
                    "362": "\t\t\tif (*src == '\\0' || *src == '.') {",
                    "363": "\t\t\t\tif (*src == '.') {",
                    "364": "\t\t\t\t\tcount++;",
                    "365": "\t\t\t\t}",
                    "366": "",
                    "367": "\t\t\t\tif ((digits > 1 && value < 10) ||",
                    "368": "\t\t\t\t    (digits > 2 && value < 100)) {",
                    "369": "\t\t\t\t\t/* Preceding zeroes */",
                    "370": "\t\t\t\t\treturn -EINVAL;",
                    "371": "\t\t\t\t}",
                    "372": "",
                    "373": "\t\t\t\tif (digits == 0 || value > UINT8_MAX) {",
                    "374": "\t\t\t\t\treturn -EINVAL;",
                    "375": "\t\t\t\t}",
                    "376": "",
                    "377": "\t\t\t\taddr->s4_addr[index] = value;",
                    "378": "",
                    "379": "\t\t\t\tif (*src == '\\0') {",
                    "380": "\t\t\t\t\tbreak;",
                    "381": "\t\t\t\t}",
                    "382": "",
                    "383": "\t\t\t\tindex++;",
                    "384": "\t\t\t\tdigits = 0;",
                    "385": "\t\t\t\tvalue = 0;",
                    "386": "\t\t\t} else if ('0' <= *src && *src <= '9') {",
                    "387": "\t\t\t\tif (++digits > 3) {",
                    "388": "\t\t\t\t\t/* Number too large */",
                    "389": "\t\t\t\t\treturn -EINVAL;",
                    "390": "\t\t\t\t}",
                    "391": "",
                    "392": "\t\t\t\tvalue *= 10;",
                    "393": "\t\t\t\tvalue += *src - '0';",
                    "394": "\t\t\t} else {",
                    "395": "\t\t\t\t/* Invalid character */",
                    "396": "\t\t\t\treturn -EINVAL;",
                    "397": "\t\t\t}",
                    "398": "",
                    "399": "\t\t\tsrc++;",
                    "400": "\t\t}",
                    "401": "",
                    "402": "\t\tif (count != 3) {",
                    "403": "\t\t\t/* Three dots needed */",
                    "404": "\t\t\treturn -EINVAL;",
                    "405": "\t\t}",
                    "406": "",
                    "407": "\t} else if (family == NET_AF_INET6) {",
                    "408": "\t\t/* If the string contains a '.', it means it's of the form",
                    "409": "\t\t * X:X:X:X:X:X:x.x.x.x, and contains only 6 16-bit pieces",
                    "410": "\t\t */",
                    "411": "\t\tint expected_groups = strchr(src, '.') ? 6 : 8;",
                    "412": "\t\tstruct net_in6_addr *addr = (struct net_in6_addr *)dst;",
                    "413": "\t\tint i, len;",
                    "414": "",
                    "415": "\t\tif (*src == ':') {",
                    "416": "\t\t\t/* Ignore a leading colon, makes parsing neater */",
                    "417": "\t\t\tsrc++;",
                    "418": "\t\t}",
                    "419": "",
                    "420": "\t\tlen = strlen(src);",
                    "421": "\t\tfor (i = 0; i < len; i++) {",
                    "422": "\t\t\tif (!(src[i] >= '0' && src[i] <= '9') &&",
                    "423": "\t\t\t    !(src[i] >= 'A' && src[i] <= 'F') &&",
                    "424": "\t\t\t    !(src[i] >= 'a' && src[i] <= 'f') &&",
                    "425": "\t\t\t    src[i] != '.' && src[i] != ':') {",
                    "426": "\t\t\t\treturn -EINVAL;",
                    "427": "\t\t\t}",
                    "428": "\t\t}",
                    "429": "",
                    "430": "\t\tfor (i = 0; i < expected_groups; i++) {",
                    "431": "\t\t\tchar *tmp;",
                    "432": "",
                    "433": "\t\t\tif (!src || *src == '\\0') {",
                    "434": "\t\t\t\treturn -EINVAL;",
                    "435": "\t\t\t}",
                    "436": "",
                    "437": "\t\t\tif (*src != ':') {",
                    "438": "\t\t\t\t/* Normal IPv6 16-bit piece */",
                    "439": "\t\t\t\tUNALIGNED_PUT(net_htons(strtol(src, NULL, 16)),",
                    "440": "\t\t\t\t\t      &addr->s6_addr16[i]);",
                    "441": "\t\t\t\tsrc = strchr(src, ':');",
                    "442": "\t\t\t\tif (src) {",
                    "443": "\t\t\t\t\tsrc++;",
                    "444": "\t\t\t\t} else {",
                    "445": "\t\t\t\t\tif (i < expected_groups - 1) {",
                    "446": "\t\t\t\t\t\treturn -EINVAL;",
                    "447": "\t\t\t\t\t}",
                    "448": "\t\t\t\t}",
                    "449": "",
                    "450": "\t\t\t\tcontinue;",
                    "451": "\t\t\t}",
                    "452": "",
                    "453": "\t\t\t/* Two colons in a row */",
                    "454": "",
                    "455": "\t\t\tfor (; i < expected_groups; i++) {",
                    "456": "\t\t\t\tUNALIGNED_PUT(0, &addr->s6_addr16[i]);",
                    "457": "\t\t\t}",
                    "458": "",
                    "459": "\t\t\ttmp = strrchr(src, ':');",
                    "460": "\t\t\tif (src == tmp && (expected_groups == 6 || !src[1])) {",
                    "461": "\t\t\t\tsrc++;",
                    "462": "\t\t\t\tbreak;",
                    "463": "\t\t\t}",
                    "464": "",
                    "465": "\t\t\tif (expected_groups == 6) {",
                    "466": "\t\t\t\t/* we need to drop the trailing",
                    "467": "\t\t\t\t * colon since it's between the",
                    "468": "\t\t\t\t * ipv6 and ipv4 addresses, rather than being",
                    "469": "\t\t\t\t * a part of the ipv6 address",
                    "470": "\t\t\t\t */",
                    "471": "\t\t\t\ttmp--;",
                    "472": "\t\t\t}",
                    "473": "",
                    "474": "\t\t\t/* Calculate the amount of skipped zeros */",
                    "475": "\t\t\ti = expected_groups - 1;",
                    "476": "\t\t\tdo {",
                    "477": "\t\t\t\tif (*tmp == ':') {",
                    "478": "\t\t\t\t\ti--;",
                    "479": "\t\t\t\t}",
                    "480": "",
                    "481": "\t\t\t\tif (i < 0) {",
                    "482": "\t\t\t\t\treturn -EINVAL;",
                    "483": "\t\t\t\t}",
                    "484": "\t\t\t} while (tmp-- != src);",
                    "485": "",
                    "486": "\t\t\tsrc++;",
                    "487": "\t\t}",
                    "488": "",
                    "489": "\t\tif (expected_groups == 6) {",
                    "490": "\t\t\t/* Parse the IPv4 part */",
                    "491": "\t\t\tfor (i = 0; i < 4; i++) {",
                    "492": "\t\t\t\tif (!src || !*src) {",
                    "493": "\t\t\t\t\treturn -EINVAL;",
                    "494": "\t\t\t\t}",
                    "495": "",
                    "496": "\t\t\t\taddr->s6_addr[12 + i] = strtol(src, NULL, 10);",
                    "497": "",
                    "498": "\t\t\t\tsrc = strchr(src, '.');",
                    "499": "\t\t\t\tif (src) {",
                    "500": "\t\t\t\t\tsrc++;",
                    "501": "\t\t\t\t} else {",
                    "502": "\t\t\t\t\tif (i < 3) {",
                    "503": "\t\t\t\t\t\treturn -EINVAL;",
                    "504": "\t\t\t\t\t}",
                    "505": "\t\t\t\t}",
                    "506": "\t\t\t}",
                    "507": "\t\t}",
                    "508": "\t} else {",
                    "509": "\t\treturn -EINVAL;",
                    "510": "\t}",
                    "511": "",
                    "512": "\treturn 0;",
                    "513": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_mask_len_to_netmask": {
            "name": "net_mask_len_to_netmask",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 1056,
            "function_content": [
                "/* We cannot accept empty string here */\nint net_mask_len_to_netmask(net_sa_family_t family, uint8_t mask_len, struct net_sockaddr *mask)\n{\n\tif (family == NET_AF_INET) {\n\t\tstruct net_in_addr *addr4 = &net_sin(mask)->sin_addr;\n\t\tstruct net_sockaddr_in *mask4 = (struct net_sockaddr_in *)mask;\n\n\t\tif (mask_len > 32) {\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tmemset(mask4, 0, sizeof(struct net_sockaddr_in));\n\n\t\tmask4->sin_family = NET_AF_INET;\n\t\tmask4->sin_port = 0;\n\t\taddr4->s_addr = net_htonl(UINT32_MAX << (32 - mask_len));\n\n\t} else if (family == NET_AF_INET6) {\n\t\tstruct net_in6_addr *addr6 = &net_sin6(mask)->sin6_addr;\n\t\tstruct net_sockaddr_in6 *mask6 = (struct net_sockaddr_in6 *)mask;\n\t\tuint32_t mask_val[4] = { 0 };\n\n\t\tif (mask_len > 128) {\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tmemset(mask6, 0, sizeof(struct net_sockaddr_in6));\n\n\t\tmask6->sin6_family = NET_AF_INET6;\n\t\tmask6->sin6_port = 0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint bits = mask_len - i * 32;\n\n\t\t\tif (bits >= 32) {\n\t\t\t\tmask_val[i] = UINT32_MAX;\n\t\t\t} else if (bits > 0) {\n\t\t\t\tmask_val[i] = net_htonl(UINT32_MAX << (32 - bits));\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(addr6->s6_addr32, mask_val, sizeof(mask_val));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1056": "int net_mask_len_to_netmask(net_sa_family_t family, uint8_t mask_len, struct net_sockaddr *mask)",
                    "1057": "{",
                    "1058": "\tif (family == NET_AF_INET) {",
                    "1059": "\t\tstruct net_in_addr *addr4 = &net_sin(mask)->sin_addr;",
                    "1060": "\t\tstruct net_sockaddr_in *mask4 = (struct net_sockaddr_in *)mask;",
                    "1061": "",
                    "1062": "\t\tif (mask_len > 32) {",
                    "1063": "\t\t\treturn -ERANGE;",
                    "1064": "\t\t}",
                    "1065": "",
                    "1066": "\t\tmemset(mask4, 0, sizeof(struct net_sockaddr_in));",
                    "1067": "",
                    "1068": "\t\tmask4->sin_family = NET_AF_INET;",
                    "1069": "\t\tmask4->sin_port = 0;",
                    "1070": "\t\taddr4->s_addr = net_htonl(UINT32_MAX << (32 - mask_len));",
                    "1071": "",
                    "1072": "\t} else if (family == NET_AF_INET6) {",
                    "1073": "\t\tstruct net_in6_addr *addr6 = &net_sin6(mask)->sin6_addr;",
                    "1074": "\t\tstruct net_sockaddr_in6 *mask6 = (struct net_sockaddr_in6 *)mask;",
                    "1075": "\t\tuint32_t mask_val[4] = { 0 };",
                    "1076": "",
                    "1077": "\t\tif (mask_len > 128) {",
                    "1078": "\t\t\treturn -ERANGE;",
                    "1079": "\t\t}",
                    "1080": "",
                    "1081": "\t\tmemset(mask6, 0, sizeof(struct net_sockaddr_in6));",
                    "1082": "",
                    "1083": "\t\tmask6->sin6_family = NET_AF_INET6;",
                    "1084": "\t\tmask6->sin6_port = 0;",
                    "1085": "",
                    "1086": "\t\tfor (int i = 0; i < 4; i++) {",
                    "1087": "\t\t\tint bits = mask_len - i * 32;",
                    "1088": "",
                    "1089": "\t\t\tif (bits >= 32) {",
                    "1090": "\t\t\t\tmask_val[i] = UINT32_MAX;",
                    "1091": "\t\t\t} else if (bits > 0) {",
                    "1092": "\t\t\t\tmask_val[i] = net_htonl(UINT32_MAX << (32 - bits));",
                    "1093": "\t\t\t}",
                    "1094": "\t\t}",
                    "1095": "",
                    "1096": "\t\tmemcpy(addr6->s6_addr32, mask_val, sizeof(mask_val));",
                    "1097": "\t} else {",
                    "1098": "\t\treturn -EINVAL;",
                    "1099": "\t}",
                    "1100": "",
                    "1101": "\treturn 0;",
                    "1102": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_addr_generate_iid": {
            "name": "net_ipv6_addr_generate_iid",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 960,
            "function_content": [
                "/* Check reserved addresses, RFC 5453 ch 3 */\nint net_ipv6_addr_generate_iid(struct net_if *iface,\n\t\t\t       const struct net_in6_addr *prefix,\n\t\t\t       uint8_t *network_id,\n\t\t\t       size_t network_id_len,\n\t\t\t       uint8_t dad_counter,\n\t\t\t       struct net_in6_addr *addr,\n\t\t\t       struct net_linkaddr *lladdr)\n{\n\tstruct net_in6_addr tmp_addr;\n\tuint8_t if_index;\n\n\tif_index = (iface == NULL) ? net_if_get_by_iface(net_if_get_default())\n\t\t: net_if_get_by_iface(iface);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE)) {\n\t\tstruct net_in6_addr tmp_prefix = { 0 };\n\t\tint ret;\n\n\t\tif (prefix == NULL) {\n\t\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_prefix.s6_addr32[0]);\n\t\t} else {\n\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]),\n\t\t\t\t      &tmp_prefix.s6_addr32[0]);\n\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]),\n\t\t\t\t      &tmp_prefix.s6_addr32[1]);\n\t\t}\n\n\t\tret = gen_stable_iid(if_index, &tmp_prefix, network_id, network_id_len,\n\t\t\t\t     dad_counter, (uint8_t *)&tmp_addr + 8,\n\t\t\t\t     sizeof(tmp_addr) / 2);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (prefix == NULL) {\n\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_addr.s6_addr32[0]);\n\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[1]);\n\t} else {\n\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]), &tmp_addr.s6_addr32[0]);\n\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]), &tmp_addr.s6_addr32[1]);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_EUI_64)) {\n\t\tswitch (lladdr->len) {\n\t\tcase 2:\n\t\t\t/* The generated IPv6 shall not toggle the\n\t\t\t * Universal/Local bit. RFC 6282 ch 3.2.2\n\t\t\t */\n\t\t\tif (lladdr->type == NET_LINK_IEEE802154) {\n\t\t\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[2]);\n\t\t\t\ttmp_addr.s6_addr[11] = 0xff;\n\t\t\t\ttmp_addr.s6_addr[12] = 0xfe;\n\t\t\t\ttmp_addr.s6_addr[13] = 0U;\n\t\t\t\ttmp_addr.s6_addr[14] = lladdr->addr[0];\n\t\t\t\ttmp_addr.s6_addr[15] = lladdr->addr[1];\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t/* We do not toggle the Universal/Local bit\n\t\t\t * in Bluetooth. See RFC 7668 ch 3.2.2\n\t\t\t */\n\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, 3);\n\t\t\ttmp_addr.s6_addr[11] = 0xff;\n\t\t\ttmp_addr.s6_addr[12] = 0xfe;\n\t\t\tmemcpy(&tmp_addr.s6_addr[13], lladdr->addr + 3, 3);\n\n\t\t\tif (lladdr->type == NET_LINK_ETHERNET) {\n\t\t\t\ttmp_addr.s6_addr[8] ^= 0x02;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (sizeof(lladdr->addr) < 8) {\n\t\t\t\tNET_ERR(\"Invalid link layer address length %zu, expecting 8\",\n\t\t\t\t\tsizeof(lladdr->addr));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, lladdr->len);\n\t\t\ttmp_addr.s6_addr[8] ^= 0x02;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tNET_DBG(\"%s IID for iface %d %s\",\n\t\tIS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) ? \"Stable\" : \"EUI-64\",\n\t\tif_index, net_sprint_ipv6_addr(&tmp_addr));\n\n\tmemcpy(addr, &tmp_addr, sizeof(*addr));\n\treturn 0;\n}\n",
                {
                    "960": "int net_ipv6_addr_generate_iid(struct net_if *iface,",
                    "961": "\t\t\t       const struct net_in6_addr *prefix,",
                    "962": "\t\t\t       uint8_t *network_id,",
                    "963": "\t\t\t       size_t network_id_len,",
                    "964": "\t\t\t       uint8_t dad_counter,",
                    "965": "\t\t\t       struct net_in6_addr *addr,",
                    "966": "\t\t\t       struct net_linkaddr *lladdr)",
                    "967": "{",
                    "968": "\tstruct net_in6_addr tmp_addr;",
                    "969": "\tuint8_t if_index;",
                    "970": "",
                    "971": "\tif_index = (iface == NULL) ? net_if_get_by_iface(net_if_get_default())",
                    "972": "\t\t: net_if_get_by_iface(iface);",
                    "973": "",
                    "974": "\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE)) {",
                    "975": "\t\tstruct net_in6_addr tmp_prefix = { 0 };",
                    "976": "\t\tint ret;",
                    "977": "",
                    "978": "\t\tif (prefix == NULL) {",
                    "979": "\t\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_prefix.s6_addr32[0]);",
                    "980": "\t\t} else {",
                    "981": "\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]),",
                    "982": "\t\t\t\t      &tmp_prefix.s6_addr32[0]);",
                    "983": "\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]),",
                    "984": "\t\t\t\t      &tmp_prefix.s6_addr32[1]);",
                    "985": "\t\t}",
                    "986": "",
                    "987": "\t\tret = gen_stable_iid(if_index, &tmp_prefix, network_id, network_id_len,",
                    "988": "\t\t\t\t     dad_counter, (uint8_t *)&tmp_addr + 8,",
                    "989": "\t\t\t\t     sizeof(tmp_addr) / 2);",
                    "990": "\t\tif (ret < 0) {",
                    "991": "\t\t\treturn ret;",
                    "992": "\t\t}",
                    "993": "\t}",
                    "994": "",
                    "995": "\tif (prefix == NULL) {",
                    "996": "\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_addr.s6_addr32[0]);",
                    "997": "\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[1]);",
                    "998": "\t} else {",
                    "999": "\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]), &tmp_addr.s6_addr32[0]);",
                    "1000": "\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]), &tmp_addr.s6_addr32[1]);",
                    "1001": "\t}",
                    "1002": "",
                    "1003": "\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_EUI_64)) {",
                    "1004": "\t\tswitch (lladdr->len) {",
                    "1005": "\t\tcase 2:",
                    "1006": "\t\t\t/* The generated IPv6 shall not toggle the",
                    "1007": "\t\t\t * Universal/Local bit. RFC 6282 ch 3.2.2",
                    "1008": "\t\t\t */",
                    "1009": "\t\t\tif (lladdr->type == NET_LINK_IEEE802154) {",
                    "1010": "\t\t\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[2]);",
                    "1011": "\t\t\t\ttmp_addr.s6_addr[11] = 0xff;",
                    "1012": "\t\t\t\ttmp_addr.s6_addr[12] = 0xfe;",
                    "1013": "\t\t\t\ttmp_addr.s6_addr[13] = 0U;",
                    "1014": "\t\t\t\ttmp_addr.s6_addr[14] = lladdr->addr[0];",
                    "1015": "\t\t\t\ttmp_addr.s6_addr[15] = lladdr->addr[1];",
                    "1016": "\t\t\t}",
                    "1017": "",
                    "1018": "\t\t\tbreak;",
                    "1019": "\t\tcase 6:",
                    "1020": "\t\t\t/* We do not toggle the Universal/Local bit",
                    "1021": "\t\t\t * in Bluetooth. See RFC 7668 ch 3.2.2",
                    "1022": "\t\t\t */",
                    "1023": "\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, 3);",
                    "1024": "\t\t\ttmp_addr.s6_addr[11] = 0xff;",
                    "1025": "\t\t\ttmp_addr.s6_addr[12] = 0xfe;",
                    "1026": "\t\t\tmemcpy(&tmp_addr.s6_addr[13], lladdr->addr + 3, 3);",
                    "1027": "",
                    "1028": "\t\t\tif (lladdr->type == NET_LINK_ETHERNET) {",
                    "1029": "\t\t\t\ttmp_addr.s6_addr[8] ^= 0x02;",
                    "1030": "\t\t\t}",
                    "1031": "",
                    "1032": "\t\t\tbreak;",
                    "1033": "\t\tcase 8:",
                    "1034": "\t\t\tif (sizeof(lladdr->addr) < 8) {",
                    "1035": "\t\t\t\tNET_ERR(\"Invalid link layer address length %zu, expecting 8\",",
                    "1036": "\t\t\t\t\tsizeof(lladdr->addr));",
                    "1037": "\t\t\t\treturn -EINVAL;",
                    "1038": "\t\t\t}",
                    "1039": "",
                    "1040": "\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, lladdr->len);",
                    "1041": "\t\t\ttmp_addr.s6_addr[8] ^= 0x02;",
                    "1042": "\t\t\tbreak;",
                    "1043": "\t\t}",
                    "1044": "\t}",
                    "1045": "",
                    "1046": "\tNET_DBG(\"%s IID for iface %d %s\",",
                    "1047": "\t\tIS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) ? \"Stable\" : \"EUI-64\",",
                    "1048": "\t\tif_index, net_sprint_ipv6_addr(&tmp_addr));",
                    "1049": "",
                    "1050": "\tmemcpy(addr, &tmp_addr, sizeof(*addr));",
                    "1051": "\treturn 0;",
                    "1052": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_maddr_lookup": {
            "name": "net_if_ipv6_maddr_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2411,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstruct net_if_mcast_addr *net_if_ipv6_maddr_lookup(const struct net_in6_addr *maddr,\n\t\t\t\t\t\t   struct net_if **ret)\n{\n\treturn net_if_ipv6_maddr_lookup_raw(maddr->s6_addr, ret);\n}\n",
                {
                    "2411": "struct net_if_mcast_addr *net_if_ipv6_maddr_lookup(const struct net_in6_addr *maddr,",
                    "2412": "\t\t\t\t\t\t   struct net_if **ret)",
                    "2413": "{",
                    "2414": "\treturn net_if_ipv6_maddr_lookup_raw(maddr->s6_addr, ret);",
                    "2415": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_addr_lookup": {
            "name": "net_if_ipv6_addr_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1871,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE_IPV6 */\nstruct net_if_addr *net_if_ipv6_addr_lookup(const struct net_in6_addr *addr,\n\t\t\t\t\t    struct net_if **ret)\n{\n\treturn net_if_ipv6_addr_lookup_raw(addr->s6_addr, ret);\n}\n",
                {
                    "1871": "struct net_if_addr *net_if_ipv6_addr_lookup(const struct net_in6_addr *addr,",
                    "1872": "\t\t\t\t\t    struct net_if **ret)",
                    "1873": "{",
                    "1874": "\treturn net_if_ipv6_addr_lookup_raw(addr->s6_addr, ret);",
                    "1875": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_get_global_addr": {
            "name": "net_if_ipv6_get_global_addr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2521,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstruct net_in6_addr *net_if_ipv6_get_global_addr(enum net_addr_state state,\n\t\t\t\t\t     struct net_if **iface)\n{\n\tstruct net_in6_addr *addr = NULL;\n\n\tSTRUCT_SECTION_FOREACH(net_if, tmp) {\n\t\tif (iface && *iface && tmp != *iface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnet_if_lock(tmp);\n\t\taddr = check_global_addr(tmp, state);\n\t\tif (addr) {\n\t\t\tif (iface) {\n\t\t\t\t*iface = tmp;\n\t\t\t}\n\n\t\t\tnet_if_unlock(tmp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnet_if_unlock(tmp);\n\t}\n\nout:\n\n\treturn addr;\n}\n",
                {
                    "2521": "struct net_in6_addr *net_if_ipv6_get_global_addr(enum net_addr_state state,",
                    "2522": "\t\t\t\t\t     struct net_if **iface)",
                    "2523": "{",
                    "2524": "\tstruct net_in6_addr *addr = NULL;",
                    "2525": "",
                    "2526": "\tSTRUCT_SECTION_FOREACH(net_if, tmp) {",
                    "2527": "\t\tif (iface && *iface && tmp != *iface) {",
                    "2528": "\t\t\tcontinue;",
                    "2529": "\t\t}",
                    "2530": "",
                    "2531": "\t\tnet_if_lock(tmp);",
                    "2532": "\t\taddr = check_global_addr(tmp, state);",
                    "2533": "\t\tif (addr) {",
                    "2534": "\t\t\tif (iface) {",
                    "2535": "\t\t\t\t*iface = tmp;",
                    "2536": "\t\t\t}",
                    "2537": "",
                    "2538": "\t\t\tnet_if_unlock(tmp);",
                    "2539": "\t\t\tgoto out;",
                    "2540": "\t\t}",
                    "2541": "",
                    "2542": "\t\tnet_if_unlock(tmp);",
                    "2543": "\t}",
                    "2544": "",
                    "2545": "out:",
                    "2546": "",
                    "2547": "\treturn addr;",
                    "2548": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_dad_failed": {
            "name": "net_if_ipv6_dad_failed",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1417,
            "function_content": [
                "/* Start DAD for all the addresses without holding the iface lock\n* to avoid any possible mutex deadlock issues.\n*/\nvoid net_if_ipv6_dad_failed(struct net_if *iface, const struct net_in6_addr *addr)\n{\n\tstruct net_if_addr *ifaddr;\n\tuint32_t timeout, preferred_lifetime;\n\n\tnet_if_lock(iface);\n\n\tifaddr = net_if_ipv6_addr_lookup(addr, &iface);\n\tif (!ifaddr) {\n\t\tNET_ERR(\"Cannot find %s address in interface %p\",\n\t\t\tnet_sprint_ipv6_addr(addr), iface);\n\t\tgoto out;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) || IS_ENABLED(CONFIG_NET_IPV6_PE)) {\n\t\tifaddr->dad_count++;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_PE)) {\n\t\ttimeout = COND_CODE_1(CONFIG_NET_IPV6_PE,\n\t\t\t\t      (ifaddr->addr_timeout), (0));\n\t\tpreferred_lifetime = COND_CODE_1(CONFIG_NET_IPV6_PE,\n\t\t\t\t\t\t (ifaddr->addr_preferred_lifetime), (0U));\n\n\t\tif (!net_ipv6_pe_check_dad(ifaddr->dad_count)) {\n\t\t\tNET_ERR(\"Cannot generate PE address for interface %p\",\n\t\t\t\tiface);\n\t\t\tiface->pe_enabled = false;\n\t\t\tnet_mgmt_event_notify(NET_EVENT_IPV6_PE_DISABLED, iface);\n\t\t}\n\t}\n\n\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_FAILED, iface,\n\t\t\t\t\t&ifaddr->address.in6_addr,\n\t\t\t\t\tsizeof(struct net_in6_addr));\n\n\t/* The old address needs to be removed from the interface before we can\n\t * start new DAD for the new PE address as the amount of address slots\n\t * is limited.\n\t */\n\tnet_if_ipv6_addr_rm(iface, addr);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_PE) && iface->pe_enabled) {\n\t\tnet_if_unlock(iface);\n\n\t\tnet_ipv6_pe_start(iface, addr, timeout, preferred_lifetime);\n\t\treturn;\n\t}\n\nout:\n\tnet_if_unlock(iface);\n}\n",
                {
                    "1417": "void net_if_ipv6_dad_failed(struct net_if *iface, const struct net_in6_addr *addr)",
                    "1418": "{",
                    "1419": "\tstruct net_if_addr *ifaddr;",
                    "1420": "\tuint32_t timeout, preferred_lifetime;",
                    "1421": "",
                    "1422": "\tnet_if_lock(iface);",
                    "1423": "",
                    "1424": "\tifaddr = net_if_ipv6_addr_lookup(addr, &iface);",
                    "1425": "\tif (!ifaddr) {",
                    "1426": "\t\tNET_ERR(\"Cannot find %s address in interface %p\",",
                    "1427": "\t\t\tnet_sprint_ipv6_addr(addr), iface);",
                    "1428": "\t\tgoto out;",
                    "1429": "\t}",
                    "1430": "",
                    "1431": "\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) || IS_ENABLED(CONFIG_NET_IPV6_PE)) {",
                    "1432": "\t\tifaddr->dad_count++;",
                    "1433": "\t}",
                    "1434": "",
                    "1435": "\tif (IS_ENABLED(CONFIG_NET_IPV6_PE)) {",
                    "1436": "\t\ttimeout = COND_CODE_1(CONFIG_NET_IPV6_PE,",
                    "1437": "\t\t\t\t      (ifaddr->addr_timeout), (0));",
                    "1438": "\t\tpreferred_lifetime = COND_CODE_1(CONFIG_NET_IPV6_PE,",
                    "1439": "\t\t\t\t\t\t (ifaddr->addr_preferred_lifetime), (0U));",
                    "1440": "",
                    "1441": "\t\tif (!net_ipv6_pe_check_dad(ifaddr->dad_count)) {",
                    "1442": "\t\t\tNET_ERR(\"Cannot generate PE address for interface %p\",",
                    "1443": "\t\t\t\tiface);",
                    "1444": "\t\t\tiface->pe_enabled = false;",
                    "1445": "\t\t\tnet_mgmt_event_notify(NET_EVENT_IPV6_PE_DISABLED, iface);",
                    "1446": "\t\t}",
                    "1447": "\t}",
                    "1448": "",
                    "1449": "\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_FAILED, iface,",
                    "1450": "\t\t\t\t\t&ifaddr->address.in6_addr,",
                    "1451": "\t\t\t\t\tsizeof(struct net_in6_addr));",
                    "1452": "",
                    "1453": "\t/* The old address needs to be removed from the interface before we can",
                    "1454": "\t * start new DAD for the new PE address as the amount of address slots",
                    "1455": "\t * is limited.",
                    "1456": "\t */",
                    "1457": "\tnet_if_ipv6_addr_rm(iface, addr);",
                    "1458": "",
                    "1459": "\tif (IS_ENABLED(CONFIG_NET_IPV6_PE) && iface->pe_enabled) {",
                    "1460": "\t\tnet_if_unlock(iface);",
                    "1461": "",
                    "1462": "\t\tnet_ipv6_pe_start(iface, addr, timeout, preferred_lifetime);",
                    "1463": "\t\treturn;",
                    "1464": "\t}",
                    "1465": "",
                    "1466": "out:",
                    "1467": "\tnet_if_unlock(iface);",
                    "1468": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_get_ll": {
            "name": "net_if_ipv6_get_ll",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2439,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstruct net_in6_addr *net_if_ipv6_get_ll(struct net_if *iface,\n\t\t\t\t    enum net_addr_state addr_state)\n{\n\tstruct net_in6_addr *addr = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\n\tnet_if_lock(iface);\n\n\tipv6 = iface->config.ip.ipv6;\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (!ipv6->unicast[i].is_used ||\n\t\t    (addr_state != NET_ADDR_ANY_STATE &&\n\t\t     ipv6->unicast[i].addr_state != addr_state) ||\n\t\t    ipv6->unicast[i].address.family != NET_AF_INET6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {\n\t\t\taddr = &ipv6->unicast[i].address.in6_addr;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn addr;\n}\n",
                {
                    "2439": "struct net_in6_addr *net_if_ipv6_get_ll(struct net_if *iface,",
                    "2440": "\t\t\t\t    enum net_addr_state addr_state)",
                    "2441": "{",
                    "2442": "\tstruct net_in6_addr *addr = NULL;",
                    "2443": "\tstruct net_if_ipv6 *ipv6;",
                    "2444": "",
                    "2445": "\tnet_if_lock(iface);",
                    "2446": "",
                    "2447": "\tipv6 = iface->config.ip.ipv6;",
                    "2448": "\tif (!ipv6) {",
                    "2449": "\t\tgoto out;",
                    "2450": "\t}",
                    "2451": "",
                    "2452": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "2453": "\t\tif (!ipv6->unicast[i].is_used ||",
                    "2454": "\t\t    (addr_state != NET_ADDR_ANY_STATE &&",
                    "2455": "\t\t     ipv6->unicast[i].addr_state != addr_state) ||",
                    "2456": "\t\t    ipv6->unicast[i].address.family != NET_AF_INET6) {",
                    "2457": "\t\t\tcontinue;",
                    "2458": "\t\t}",
                    "2459": "",
                    "2460": "\t\tif (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {",
                    "2461": "\t\t\taddr = &ipv6->unicast[i].address.in6_addr;",
                    "2462": "\t\t\tgoto out;",
                    "2463": "\t\t}",
                    "2464": "\t}",
                    "2465": "",
                    "2466": "out:",
                    "2467": "\tnet_if_unlock(iface);",
                    "2468": "",
                    "2469": "\treturn addr;",
                    "2470": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_select_src_addr_hint": {
            "name": "net_if_ipv6_select_src_addr_hint",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 3300,
            "function_content": [
                "/* By default prefer always public address if found */\nconst struct net_in6_addr *net_if_ipv6_select_src_addr_hint(struct net_if *dst_iface,\n\t\t\t\t\t\t\tconst struct net_in6_addr *dst,\n\t\t\t\t\t\t\tint flags)\n{\n\tconst struct net_in6_addr *src = NULL;\n\tuint8_t best_match = 0U;\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {\n\t\tstruct net_if_ipv6_prefix *prefix;\n\t\tuint8_t prefix_len = 128;\n\n\t\tprefix = net_if_ipv6_prefix_get(dst_iface, dst);\n\t\tif (prefix) {\n\t\t\tprefix_len = prefix->len;\n\t\t}\n\n\t\t/* If caller has supplied interface, then use that */\n\t\tif (dst_iface) {\n\t\t\tsrc = net_if_ipv6_get_best_match(dst_iface, dst,\n\t\t\t\t\t\t\t prefix_len,\n\t\t\t\t\t\t\t &best_match,\n\t\t\t\t\t\t\t flags);\n\t\t} else {\n\t\t\tSTRUCT_SECTION_FOREACH(net_if, iface) {\n\t\t\t\tstruct net_in6_addr *addr;\n\n\t\t\t\taddr = net_if_ipv6_get_best_match(iface, dst,\n\t\t\t\t\t\t\t\t  prefix_len,\n\t\t\t\t\t\t\t\t  &best_match,\n\t\t\t\t\t\t\t\t  flags);\n\t\t\t\tif (addr) {\n\t\t\t\t\tsrc = addr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tif (dst_iface) {\n\t\t\tsrc = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);\n\t\t} else {\n\t\t\tstruct net_in6_addr *addr;\n\n\t\t\taddr = net_if_ipv6_get_ll(net_if_get_default(), NET_ADDR_PREFERRED);\n\t\t\tif (addr) {\n\t\t\t\tsrc = addr;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tSTRUCT_SECTION_FOREACH(net_if, iface) {\n\t\t\t\taddr = net_if_ipv6_get_ll(iface,\n\t\t\t\t\t\t\t  NET_ADDR_PREFERRED);\n\t\t\t\tif (addr) {\n\t\t\t\t\tsrc = addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!src) {\n\t\tsrc = net_ipv6_unspecified_address();\n\t}\n\nout:\n\treturn src;\n}\n",
                {
                    "3300": "const struct net_in6_addr *net_if_ipv6_select_src_addr_hint(struct net_if *dst_iface,",
                    "3301": "\t\t\t\t\t\t\tconst struct net_in6_addr *dst,",
                    "3302": "\t\t\t\t\t\t\tint flags)",
                    "3303": "{",
                    "3304": "\tconst struct net_in6_addr *src = NULL;",
                    "3305": "\tuint8_t best_match = 0U;",
                    "3306": "",
                    "3307": "\tif (dst == NULL) {",
                    "3308": "\t\treturn NULL;",
                    "3309": "\t}",
                    "3310": "",
                    "3311": "\tif (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {",
                    "3312": "\t\tstruct net_if_ipv6_prefix *prefix;",
                    "3313": "\t\tuint8_t prefix_len = 128;",
                    "3314": "",
                    "3315": "\t\tprefix = net_if_ipv6_prefix_get(dst_iface, dst);",
                    "3316": "\t\tif (prefix) {",
                    "3317": "\t\t\tprefix_len = prefix->len;",
                    "3318": "\t\t}",
                    "3319": "",
                    "3320": "\t\t/* If caller has supplied interface, then use that */",
                    "3321": "\t\tif (dst_iface) {",
                    "3322": "\t\t\tsrc = net_if_ipv6_get_best_match(dst_iface, dst,",
                    "3323": "\t\t\t\t\t\t\t prefix_len,",
                    "3324": "\t\t\t\t\t\t\t &best_match,",
                    "3325": "\t\t\t\t\t\t\t flags);",
                    "3326": "\t\t} else {",
                    "3327": "\t\t\tSTRUCT_SECTION_FOREACH(net_if, iface) {",
                    "3328": "\t\t\t\tstruct net_in6_addr *addr;",
                    "3329": "",
                    "3330": "\t\t\t\taddr = net_if_ipv6_get_best_match(iface, dst,",
                    "3331": "\t\t\t\t\t\t\t\t  prefix_len,",
                    "3332": "\t\t\t\t\t\t\t\t  &best_match,",
                    "3333": "\t\t\t\t\t\t\t\t  flags);",
                    "3334": "\t\t\t\tif (addr) {",
                    "3335": "\t\t\t\t\tsrc = addr;",
                    "3336": "\t\t\t\t}",
                    "3337": "\t\t\t}",
                    "3338": "\t\t}",
                    "3339": "",
                    "3340": "\t} else {",
                    "3341": "\t\tif (dst_iface) {",
                    "3342": "\t\t\tsrc = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);",
                    "3343": "\t\t} else {",
                    "3344": "\t\t\tstruct net_in6_addr *addr;",
                    "3345": "",
                    "3346": "\t\t\taddr = net_if_ipv6_get_ll(net_if_get_default(), NET_ADDR_PREFERRED);",
                    "3347": "\t\t\tif (addr) {",
                    "3348": "\t\t\t\tsrc = addr;",
                    "3349": "\t\t\t\tgoto out;",
                    "3350": "\t\t\t}",
                    "3351": "",
                    "3352": "\t\t\tSTRUCT_SECTION_FOREACH(net_if, iface) {",
                    "3353": "\t\t\t\taddr = net_if_ipv6_get_ll(iface,",
                    "3354": "\t\t\t\t\t\t\t  NET_ADDR_PREFERRED);",
                    "3355": "\t\t\t\tif (addr) {",
                    "3356": "\t\t\t\t\tsrc = addr;",
                    "3357": "\t\t\t\t\tbreak;",
                    "3358": "\t\t\t\t}",
                    "3359": "\t\t\t}",
                    "3360": "\t\t}",
                    "3361": "\t}",
                    "3362": "",
                    "3363": "\tif (!src) {",
                    "3364": "\t\tsrc = net_ipv6_unspecified_address();",
                    "3365": "\t}",
                    "3366": "",
                    "3367": "out:",
                    "3368": "\treturn src;",
                    "3369": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_addr_onlink": {
            "name": "net_if_ipv6_addr_onlink",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2930,
            "function_content": [
                "/* Remove also all auto addresses if the they have the same\n* prefix.\n*/\nbool net_if_ipv6_addr_onlink(struct net_if **iface, const struct net_in6_addr *addr)\n{\n\tbool ret = false;\n\n\tSTRUCT_SECTION_FOREACH(net_if, tmp) {\n\t\tstruct net_if_ipv6 *ipv6;\n\n\t\tif (iface && *iface && *iface != tmp) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnet_if_lock(tmp);\n\n\t\tipv6 = tmp->config.ip.ipv6;\n\t\tif (!ipv6) {\n\t\t\tnet_if_unlock(tmp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tARRAY_FOR_EACH(ipv6->prefix, i) {\n\t\t\tif (ipv6->prefix[i].is_used &&\n\t\t\t    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,\n\t\t\t\t\t       addr->s6_addr,\n\t\t\t\t\t       ipv6->prefix[i].len)) {\n\t\t\t\tif (iface) {\n\t\t\t\t\t*iface = tmp;\n\t\t\t\t}\n\n\t\t\t\tret = true;\n\t\t\t\tnet_if_unlock(tmp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tnet_if_unlock(tmp);\n\t}\n\nout:\n\treturn ret;\n}\n",
                {
                    "2930": "bool net_if_ipv6_addr_onlink(struct net_if **iface, const struct net_in6_addr *addr)",
                    "2931": "{",
                    "2932": "\tbool ret = false;",
                    "2933": "",
                    "2934": "\tSTRUCT_SECTION_FOREACH(net_if, tmp) {",
                    "2935": "\t\tstruct net_if_ipv6 *ipv6;",
                    "2936": "",
                    "2937": "\t\tif (iface && *iface && *iface != tmp) {",
                    "2938": "\t\t\tcontinue;",
                    "2939": "\t\t}",
                    "2940": "",
                    "2941": "\t\tnet_if_lock(tmp);",
                    "2942": "",
                    "2943": "\t\tipv6 = tmp->config.ip.ipv6;",
                    "2944": "\t\tif (!ipv6) {",
                    "2945": "\t\t\tnet_if_unlock(tmp);",
                    "2946": "\t\t\tcontinue;",
                    "2947": "\t\t}",
                    "2948": "",
                    "2949": "\t\tARRAY_FOR_EACH(ipv6->prefix, i) {",
                    "2950": "\t\t\tif (ipv6->prefix[i].is_used &&",
                    "2951": "\t\t\t    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,",
                    "2952": "\t\t\t\t\t       addr->s6_addr,",
                    "2953": "\t\t\t\t\t       ipv6->prefix[i].len)) {",
                    "2954": "\t\t\t\tif (iface) {",
                    "2955": "\t\t\t\t\t*iface = tmp;",
                    "2956": "\t\t\t\t}",
                    "2957": "",
                    "2958": "\t\t\t\tret = true;",
                    "2959": "\t\t\t\tnet_if_unlock(tmp);",
                    "2960": "\t\t\t\tgoto out;",
                    "2961": "\t\t\t}",
                    "2962": "\t\t}",
                    "2963": "",
                    "2964": "\t\tnet_if_unlock(tmp);",
                    "2965": "\t}",
                    "2966": "",
                    "2967": "out:",
                    "2968": "\treturn ret;",
                    "2969": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_prefix_lookup": {
            "name": "net_if_ipv6_prefix_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2898,
            "function_content": [
                "/* Remove also all auto addresses if the they have the same\n* prefix.\n*/\nstruct net_if_ipv6_prefix *net_if_ipv6_prefix_lookup(struct net_if *iface,\n\t\t\t\t\t\t     const struct net_in6_addr *addr,\n\t\t\t\t\t\t     uint8_t len)\n{\n\tstruct net_if_ipv6_prefix *prefix = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\n\tnet_if_lock(iface);\n\n\tipv6 = iface->config.ip.ipv6;\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->prefix, i) {\n\t\tif (!ipv6->prefix[i].is_used) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,\n\t\t\t\t       addr->s6_addr, len)) {\n\t\t\tprefix = &ipv6->prefix[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn prefix;\n}\n",
                {
                    "2898": "struct net_if_ipv6_prefix *net_if_ipv6_prefix_lookup(struct net_if *iface,",
                    "2899": "\t\t\t\t\t\t     const struct net_in6_addr *addr,",
                    "2900": "\t\t\t\t\t\t     uint8_t len)",
                    "2901": "{",
                    "2902": "\tstruct net_if_ipv6_prefix *prefix = NULL;",
                    "2903": "\tstruct net_if_ipv6 *ipv6;",
                    "2904": "",
                    "2905": "\tnet_if_lock(iface);",
                    "2906": "",
                    "2907": "\tipv6 = iface->config.ip.ipv6;",
                    "2908": "\tif (!ipv6) {",
                    "2909": "\t\tgoto out;",
                    "2910": "\t}",
                    "2911": "",
                    "2912": "\tARRAY_FOR_EACH(ipv6->prefix, i) {",
                    "2913": "\t\tif (!ipv6->prefix[i].is_used) {",
                    "2914": "\t\t\tcontinue;",
                    "2915": "\t\t}",
                    "2916": "",
                    "2917": "\t\tif (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,",
                    "2918": "\t\t\t\t       addr->s6_addr, len)) {",
                    "2919": "\t\t\tprefix = &ipv6->prefix[i];",
                    "2920": "\t\t\tgoto out;",
                    "2921": "\t\t}",
                    "2922": "\t}",
                    "2923": "",
                    "2924": "out:",
                    "2925": "\tnet_if_unlock(iface);",
                    "2926": "",
                    "2927": "\treturn prefix;",
                    "2928": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_prefix_get": {
            "name": "net_if_ipv6_prefix_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2847,
            "function_content": [
                "/* Remove also all auto addresses if the they have the same\n* prefix.\n*/\nstruct net_if_ipv6_prefix *net_if_ipv6_prefix_get(struct net_if *iface,\n\t\t\t\t\t\t  const struct net_in6_addr *addr)\n{\n\tstruct net_if_ipv6_prefix *prefix = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\n\tif (!iface) {\n\t\tiface = net_if_get_default();\n\t}\n\n\tif (!iface) {\n\t\treturn NULL;\n\t}\n\n\tnet_if_lock(iface);\n\n\tipv6 = iface->config.ip.ipv6;\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->prefix, i) {\n\t\tif (!ipv6->prefix[i].is_used) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,\n\t\t\t\t       addr->s6_addr,\n\t\t\t\t       ipv6->prefix[i].len)) {\n\t\t\tif (!prefix || prefix->len > ipv6->prefix[i].len) {\n\t\t\t\tprefix = &ipv6->prefix[i];\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tif (prefix != NULL) {\n\t\tNET_DBG(\"Found prefix %s/%d for %s\",\n\t\t\tnet_sprint_ipv6_addr(&prefix->prefix),\n\t\t\tprefix->len,\n\t\t\tnet_sprint_ipv6_addr(addr));\n\t} else {\n\t\tNET_DBG(\"No prefix found for %s\",\n\t\t\tnet_sprint_ipv6_addr(addr));\n\t}\n\n\tnet_if_unlock(iface);\n\n\treturn prefix;\n}\n",
                {
                    "2847": "struct net_if_ipv6_prefix *net_if_ipv6_prefix_get(struct net_if *iface,",
                    "2848": "\t\t\t\t\t\t  const struct net_in6_addr *addr)",
                    "2849": "{",
                    "2850": "\tstruct net_if_ipv6_prefix *prefix = NULL;",
                    "2851": "\tstruct net_if_ipv6 *ipv6;",
                    "2852": "",
                    "2853": "\tif (!iface) {",
                    "2854": "\t\tiface = net_if_get_default();",
                    "2855": "\t}",
                    "2856": "",
                    "2857": "\tif (!iface) {",
                    "2858": "\t\treturn NULL;",
                    "2859": "\t}",
                    "2860": "",
                    "2861": "\tnet_if_lock(iface);",
                    "2862": "",
                    "2863": "\tipv6 = iface->config.ip.ipv6;",
                    "2864": "\tif (!ipv6) {",
                    "2865": "\t\tgoto out;",
                    "2866": "\t}",
                    "2867": "",
                    "2868": "\tARRAY_FOR_EACH(ipv6->prefix, i) {",
                    "2869": "\t\tif (!ipv6->prefix[i].is_used) {",
                    "2870": "\t\t\tcontinue;",
                    "2871": "\t\t}",
                    "2872": "",
                    "2873": "\t\tif (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,",
                    "2874": "\t\t\t\t       addr->s6_addr,",
                    "2875": "\t\t\t\t       ipv6->prefix[i].len)) {",
                    "2876": "\t\t\tif (!prefix || prefix->len > ipv6->prefix[i].len) {",
                    "2877": "\t\t\t\tprefix = &ipv6->prefix[i];",
                    "2878": "\t\t\t}",
                    "2879": "\t\t}",
                    "2880": "\t}",
                    "2881": "",
                    "2882": "out:",
                    "2883": "\tif (prefix != NULL) {",
                    "2884": "\t\tNET_DBG(\"Found prefix %s/%d for %s\",",
                    "2885": "\t\t\tnet_sprint_ipv6_addr(&prefix->prefix),",
                    "2886": "\t\t\tprefix->len,",
                    "2887": "\t\t\tnet_sprint_ipv6_addr(addr));",
                    "2888": "\t} else {",
                    "2889": "\t\tNET_DBG(\"No prefix found for %s\",",
                    "2890": "\t\t\tnet_sprint_ipv6_addr(addr));",
                    "2891": "\t}",
                    "2892": "",
                    "2893": "\tnet_if_unlock(iface);",
                    "2894": "",
                    "2895": "\treturn prefix;",
                    "2896": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_maddr_add": {
            "name": "net_if_ipv6_maddr_add",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2241,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstruct net_if_mcast_addr *net_if_ipv6_maddr_add(struct net_if *iface,\n\t\t\t\t\t\tconst struct net_in6_addr *addr)\n{\n\tstruct net_if_mcast_addr *ifmaddr = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\n\tnet_if_lock(iface);\n\n\tif (net_if_config_ipv6_get(iface, &ipv6) < 0) {\n\t\tgoto out;\n\t}\n\n\tif (!net_ipv6_is_addr_mcast(addr)) {\n\t\tNET_DBG(\"Address %s is not a multicast address.\",\n\t\t\tnet_sprint_ipv6_addr(addr));\n\t\tgoto out;\n\t}\n\n\tif (net_if_ipv6_maddr_lookup(addr, &iface)) {\n\t\tNET_WARN(\"Multicast address %s is already registered.\",\n\t\t\tnet_sprint_ipv6_addr(addr));\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->mcast, i) {\n\t\tif (ipv6->mcast[i].is_used) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tipv6->mcast[i].is_used = true;\n\t\tipv6->mcast[i].address.family = NET_AF_INET6;\n\t\tmemcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);\n\n\t\tNET_DBG(\"[%zu] interface %d (%p) address %s added\", i,\n\t\t\tnet_if_get_by_iface(iface), iface,\n\t\t\tnet_sprint_ipv6_addr(addr));\n\n\t\tnet_mgmt_event_notify_with_info(\n\t\t\tNET_EVENT_IPV6_MADDR_ADD, iface,\n\t\t\t&ipv6->mcast[i].address.in6_addr,\n\t\t\tsizeof(struct net_in6_addr));\n\n\t\tifmaddr = &ipv6->mcast[i];\n\t\tgoto out;\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn ifmaddr;\n}\n",
                {
                    "2241": "struct net_if_mcast_addr *net_if_ipv6_maddr_add(struct net_if *iface,",
                    "2242": "\t\t\t\t\t\tconst struct net_in6_addr *addr)",
                    "2243": "{",
                    "2244": "\tstruct net_if_mcast_addr *ifmaddr = NULL;",
                    "2245": "\tstruct net_if_ipv6 *ipv6;",
                    "2246": "",
                    "2247": "\tnet_if_lock(iface);",
                    "2248": "",
                    "2249": "\tif (net_if_config_ipv6_get(iface, &ipv6) < 0) {",
                    "2250": "\t\tgoto out;",
                    "2251": "\t}",
                    "2252": "",
                    "2253": "\tif (!net_ipv6_is_addr_mcast(addr)) {",
                    "2254": "\t\tNET_DBG(\"Address %s is not a multicast address.\",",
                    "2255": "\t\t\tnet_sprint_ipv6_addr(addr));",
                    "2256": "\t\tgoto out;",
                    "2257": "\t}",
                    "2258": "",
                    "2259": "\tif (net_if_ipv6_maddr_lookup(addr, &iface)) {",
                    "2260": "\t\tNET_WARN(\"Multicast address %s is already registered.\",",
                    "2261": "\t\t\tnet_sprint_ipv6_addr(addr));",
                    "2262": "\t\tgoto out;",
                    "2263": "\t}",
                    "2264": "",
                    "2265": "\tARRAY_FOR_EACH(ipv6->mcast, i) {",
                    "2266": "\t\tif (ipv6->mcast[i].is_used) {",
                    "2267": "\t\t\tcontinue;",
                    "2268": "\t\t}",
                    "2269": "",
                    "2270": "\t\tipv6->mcast[i].is_used = true;",
                    "2271": "\t\tipv6->mcast[i].address.family = NET_AF_INET6;",
                    "2272": "\t\tmemcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);",
                    "2273": "",
                    "2274": "\t\tNET_DBG(\"[%zu] interface %d (%p) address %s added\", i,",
                    "2275": "\t\t\tnet_if_get_by_iface(iface), iface,",
                    "2276": "\t\t\tnet_sprint_ipv6_addr(addr));",
                    "2277": "",
                    "2278": "\t\tnet_mgmt_event_notify_with_info(",
                    "2279": "\t\t\tNET_EVENT_IPV6_MADDR_ADD, iface,",
                    "2280": "\t\t\t&ipv6->mcast[i].address.in6_addr,",
                    "2281": "\t\t\tsizeof(struct net_in6_addr));",
                    "2282": "",
                    "2283": "\t\tifmaddr = &ipv6->mcast[i];",
                    "2284": "\t\tgoto out;",
                    "2285": "\t}",
                    "2286": "",
                    "2287": "out:",
                    "2288": "\tnet_if_unlock(iface);",
                    "2289": "",
                    "2290": "\treturn ifmaddr;",
                    "2291": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_addr_add": {
            "name": "net_if_ipv6_addr_add",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2008,
            "function_content": [
                "/* FIXME - set the mcast addr for this node */\nstruct net_if_addr *net_if_ipv6_addr_add(struct net_if *iface,\n\t\t\t\t\t const struct net_in6_addr *addr,\n\t\t\t\t\t enum net_addr_type addr_type,\n\t\t\t\t\t uint32_t vlifetime)\n{\n\tstruct net_if_addr *ifaddr = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\tbool do_dad = false;\n\n\tnet_if_lock(iface);\n\n\tif (net_if_config_ipv6_get(iface, &ipv6) < 0) {\n\t\tgoto out;\n\t}\n\n\tifaddr = ipv6_addr_find(iface, addr);\n\tif (ifaddr) {\n\t\t/* Address already exists, just return it but update ref count\n\t\t * if it was not updated. This could happen if the address was\n\t\t * added and then removed but for example an active connection\n\t\t * was still using it. In this case we must update the ref count\n\t\t * so that the address is not removed if the connection is closed.\n\t\t */\n\t\tif (!ifaddr->is_added) {\n\t\t\tatomic_inc(&ifaddr->atomic_ref);\n\t\t\tifaddr->is_added = true;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (ipv6->unicast[i].is_used) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnet_if_addr_init(&ipv6->unicast[i], addr, addr_type,\n\t\t\t\t vlifetime);\n\n\t\tNET_DBG(\"[%zu] interface %d (%p) address %s type %s added\", i,\n\t\t\tnet_if_get_by_iface(iface), iface,\n\t\t\tnet_sprint_ipv6_addr(addr),\n\t\t\tnet_addr_type2str(addr_type));\n\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6_DAD) &&\n\t\t    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&\n\t\t    !net_ipv6_is_addr_loopback(addr) &&\n\t\t    !net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {\n\t\t\t/* The groups are joined without locks held */\n\t\t\tdo_dad = true;\n\t\t} else {\n\t\t\t/* If DAD is not done for point-to-point links, then\n\t\t\t * the address is usable immediately.\n\t\t\t */\n\t\t\tipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;\n\t\t}\n\n\t\tnet_mgmt_event_notify_with_info(\n\t\t\tNET_EVENT_IPV6_ADDR_ADD, iface,\n\t\t\t&ipv6->unicast[i].address.in6_addr,\n\t\t\tsizeof(struct net_in6_addr));\n\n\t\tifaddr = &ipv6->unicast[i];\n\t\tbreak;\n\t}\n\n\tnet_if_unlock(iface);\n\n\tif (ifaddr != NULL && do_dad) {\n\t\t/* RFC 4862 5.4.2\n\t\t * Before sending a Neighbor Solicitation, an interface\n\t\t * MUST join the all-nodes multicast address and the\n\t\t * solicited-node multicast address of the tentative\n\t\t * address.\n\t\t */\n\t\t/* The allnodes multicast group is only joined once as\n\t\t * net_ipv6_mld_join() checks if we have already\n\t\t * joined.\n\t\t */\n\t\tjoin_mcast_nodes(iface, &ifaddr->address.in6_addr);\n\n\t\tnet_if_ipv6_start_dad(iface, ifaddr);\n\t}\n\n\treturn ifaddr;\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn ifaddr;\n}\n",
                {
                    "2008": "struct net_if_addr *net_if_ipv6_addr_add(struct net_if *iface,",
                    "2009": "\t\t\t\t\t const struct net_in6_addr *addr,",
                    "2010": "\t\t\t\t\t enum net_addr_type addr_type,",
                    "2011": "\t\t\t\t\t uint32_t vlifetime)",
                    "2012": "{",
                    "2013": "\tstruct net_if_addr *ifaddr = NULL;",
                    "2014": "\tstruct net_if_ipv6 *ipv6;",
                    "2015": "\tbool do_dad = false;",
                    "2016": "",
                    "2017": "\tnet_if_lock(iface);",
                    "2018": "",
                    "2019": "\tif (net_if_config_ipv6_get(iface, &ipv6) < 0) {",
                    "2020": "\t\tgoto out;",
                    "2021": "\t}",
                    "2022": "",
                    "2023": "\tifaddr = ipv6_addr_find(iface, addr);",
                    "2024": "\tif (ifaddr) {",
                    "2025": "\t\t/* Address already exists, just return it but update ref count",
                    "2026": "\t\t * if it was not updated. This could happen if the address was",
                    "2027": "\t\t * added and then removed but for example an active connection",
                    "2028": "\t\t * was still using it. In this case we must update the ref count",
                    "2029": "\t\t * so that the address is not removed if the connection is closed.",
                    "2030": "\t\t */",
                    "2031": "\t\tif (!ifaddr->is_added) {",
                    "2032": "\t\t\tatomic_inc(&ifaddr->atomic_ref);",
                    "2033": "\t\t\tifaddr->is_added = true;",
                    "2034": "\t\t}",
                    "2035": "",
                    "2036": "\t\tgoto out;",
                    "2037": "\t}",
                    "2038": "",
                    "2039": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "2040": "\t\tif (ipv6->unicast[i].is_used) {",
                    "2041": "\t\t\tcontinue;",
                    "2042": "\t\t}",
                    "2043": "",
                    "2044": "\t\tnet_if_addr_init(&ipv6->unicast[i], addr, addr_type,",
                    "2045": "\t\t\t\t vlifetime);",
                    "2046": "",
                    "2047": "\t\tNET_DBG(\"[%zu] interface %d (%p) address %s type %s added\", i,",
                    "2048": "\t\t\tnet_if_get_by_iface(iface), iface,",
                    "2049": "\t\t\tnet_sprint_ipv6_addr(addr),",
                    "2050": "\t\t\tnet_addr_type2str(addr_type));",
                    "2051": "",
                    "2052": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6_DAD) &&",
                    "2053": "\t\t    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&",
                    "2054": "\t\t    !net_ipv6_is_addr_loopback(addr) &&",
                    "2055": "\t\t    !net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {",
                    "2056": "\t\t\t/* The groups are joined without locks held */",
                    "2057": "\t\t\tdo_dad = true;",
                    "2058": "\t\t} else {",
                    "2059": "\t\t\t/* If DAD is not done for point-to-point links, then",
                    "2060": "\t\t\t * the address is usable immediately.",
                    "2061": "\t\t\t */",
                    "2062": "\t\t\tipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;",
                    "2063": "\t\t}",
                    "2064": "",
                    "2065": "\t\tnet_mgmt_event_notify_with_info(",
                    "2066": "\t\t\tNET_EVENT_IPV6_ADDR_ADD, iface,",
                    "2067": "\t\t\t&ipv6->unicast[i].address.in6_addr,",
                    "2068": "\t\t\tsizeof(struct net_in6_addr));",
                    "2069": "",
                    "2070": "\t\tifaddr = &ipv6->unicast[i];",
                    "2071": "\t\tbreak;",
                    "2072": "\t}",
                    "2073": "",
                    "2074": "\tnet_if_unlock(iface);",
                    "2075": "",
                    "2076": "\tif (ifaddr != NULL && do_dad) {",
                    "2077": "\t\t/* RFC 4862 5.4.2",
                    "2078": "\t\t * Before sending a Neighbor Solicitation, an interface",
                    "2079": "\t\t * MUST join the all-nodes multicast address and the",
                    "2080": "\t\t * solicited-node multicast address of the tentative",
                    "2081": "\t\t * address.",
                    "2082": "\t\t */",
                    "2083": "\t\t/* The allnodes multicast group is only joined once as",
                    "2084": "\t\t * net_ipv6_mld_join() checks if we have already",
                    "2085": "\t\t * joined.",
                    "2086": "\t\t */",
                    "2087": "\t\tjoin_mcast_nodes(iface, &ifaddr->address.in6_addr);",
                    "2088": "",
                    "2089": "\t\tnet_if_ipv6_start_dad(iface, ifaddr);",
                    "2090": "\t}",
                    "2091": "",
                    "2092": "\treturn ifaddr;",
                    "2093": "",
                    "2094": "out:",
                    "2095": "\tnet_if_unlock(iface);",
                    "2096": "",
                    "2097": "\treturn ifaddr;",
                    "2098": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_addr_lookup_by_iface": {
            "name": "net_if_ipv6_addr_lookup_by_iface",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1911,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE_IPV6 */\nstruct net_if_addr *net_if_ipv6_addr_lookup_by_iface(struct net_if *iface,\n\t\t\t\t\t\t     const struct net_in6_addr *addr)\n{\n\treturn net_if_ipv6_addr_lookup_by_iface_raw(iface, addr->s6_addr);\n}\n",
                {
                    "1911": "struct net_if_addr *net_if_ipv6_addr_lookup_by_iface(struct net_if *iface,",
                    "1912": "\t\t\t\t\t\t     const struct net_in6_addr *addr)",
                    "1913": "{",
                    "1914": "\treturn net_if_ipv6_addr_lookup_by_iface_raw(iface, addr->s6_addr);",
                    "1915": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_start_dad": {
            "name": "net_if_start_dad",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1333,
            "function_content": [
                "/* FUTURE: use schedule, not reschedule. */\nvoid net_if_start_dad(struct net_if *iface)\n{\n\tstruct net_if_addr *ifaddr, *next;\n\tstruct net_if_ipv6 *ipv6;\n\tsys_slist_t dad_needed;\n\tstruct net_in6_addr addr = { };\n\tint ret;\n\n\tnet_if_lock(iface);\n\n\tNET_DBG(\"Starting DAD for iface %d\", net_if_get_by_iface(iface));\n\n\tret = net_if_config_ipv6_get(iface, &ipv6);\n\tif (ret < 0) {\n\t\tif (ret != -ENOTSUP) {\n\t\t\tNET_WARN(\"Cannot do DAD IPv6 config is not valid.\");\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tret = net_ipv6_addr_generate_iid(iface, NULL,\n\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,\n\t\t\t\t\t\t     ((uint8_t *)&ipv6->network_counter),\n\t\t\t\t\t\t     (NULL)),\n\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,\n\t\t\t\t\t\t     (sizeof(ipv6->network_counter)),\n\t\t\t\t\t\t     (0U)),\n\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,\n\t\t\t\t\t\t     (ipv6->iid ? ipv6->iid->dad_count : 0U),\n\t\t\t\t\t\t     (0U)),\n\t\t\t\t\t &addr,\n\t\t\t\t\t net_if_get_link_addr(iface));\n\tif (ret < 0) {\n\t\tNET_WARN(\"IPv6 IID generation issue (%d)\", ret);\n\t\tgoto out;\n\t}\n\n\tifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);\n\tif (!ifaddr) {\n\t\tNET_ERR(\"Cannot add %s address to interface %p, DAD fails\",\n\t\t\tnet_sprint_ipv6_addr(&addr), iface);\n\t\tgoto out;\n\t}\n\n\tIF_ENABLED(CONFIG_NET_IPV6_IID_STABLE, (ipv6->iid = ifaddr));\n\n\t/* Start DAD for all the addresses that were added earlier when\n\t * the interface was down.\n\t */\n\tsys_slist_init(&dad_needed);\n\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (!ipv6->unicast[i].is_used ||\n\t\t    ipv6->unicast[i].address.family != NET_AF_INET6 ||\n\t\t    &ipv6->unicast[i] == ifaddr ||\n\t\t    net_ipv6_is_addr_loopback(\n\t\t\t    &ipv6->unicast[i].address.in6_addr)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsys_slist_prepend(&dad_needed, &ipv6->unicast[i].dad_need_node);\n\t}\n\n\tnet_if_unlock(iface);\n\n\t/* Start DAD for all the addresses without holding the iface lock\n\t * to avoid any possible mutex deadlock issues.\n\t */\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&dad_needed,\n\t\t\t\t\t  ifaddr, next, dad_need_node) {\n\t\tnet_if_ipv6_start_dad(iface, ifaddr);\n\t}\n\n\treturn;\n\nout:\n\tnet_if_unlock(iface);\n}\n",
                {
                    "1333": "void net_if_start_dad(struct net_if *iface)",
                    "1334": "{",
                    "1335": "\tstruct net_if_addr *ifaddr, *next;",
                    "1336": "\tstruct net_if_ipv6 *ipv6;",
                    "1337": "\tsys_slist_t dad_needed;",
                    "1338": "\tstruct net_in6_addr addr = { };",
                    "1339": "\tint ret;",
                    "1340": "",
                    "1341": "\tnet_if_lock(iface);",
                    "1342": "",
                    "1343": "\tNET_DBG(\"Starting DAD for iface %d\", net_if_get_by_iface(iface));",
                    "1344": "",
                    "1345": "\tret = net_if_config_ipv6_get(iface, &ipv6);",
                    "1346": "\tif (ret < 0) {",
                    "1347": "\t\tif (ret != -ENOTSUP) {",
                    "1348": "\t\t\tNET_WARN(\"Cannot do DAD IPv6 config is not valid.\");",
                    "1349": "\t\t}",
                    "1350": "",
                    "1351": "\t\tgoto out;",
                    "1352": "\t}",
                    "1353": "",
                    "1354": "\tif (!ipv6) {",
                    "1355": "\t\tgoto out;",
                    "1356": "\t}",
                    "1357": "",
                    "1358": "\tret = net_ipv6_addr_generate_iid(iface, NULL,",
                    "1359": "\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,",
                    "1360": "\t\t\t\t\t\t     ((uint8_t *)&ipv6->network_counter),",
                    "1361": "\t\t\t\t\t\t     (NULL)),",
                    "1362": "\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,",
                    "1363": "\t\t\t\t\t\t     (sizeof(ipv6->network_counter)),",
                    "1364": "\t\t\t\t\t\t     (0U)),",
                    "1365": "\t\t\t\t\t COND_CODE_1(CONFIG_NET_IPV6_IID_STABLE,",
                    "1366": "\t\t\t\t\t\t     (ipv6->iid ? ipv6->iid->dad_count : 0U),",
                    "1367": "\t\t\t\t\t\t     (0U)),",
                    "1368": "\t\t\t\t\t &addr,",
                    "1369": "\t\t\t\t\t net_if_get_link_addr(iface));",
                    "1370": "\tif (ret < 0) {",
                    "1371": "\t\tNET_WARN(\"IPv6 IID generation issue (%d)\", ret);",
                    "1372": "\t\tgoto out;",
                    "1373": "\t}",
                    "1374": "",
                    "1375": "\tifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);",
                    "1376": "\tif (!ifaddr) {",
                    "1377": "\t\tNET_ERR(\"Cannot add %s address to interface %p, DAD fails\",",
                    "1378": "\t\t\tnet_sprint_ipv6_addr(&addr), iface);",
                    "1379": "\t\tgoto out;",
                    "1380": "\t}",
                    "1381": "",
                    "1382": "\tIF_ENABLED(CONFIG_NET_IPV6_IID_STABLE, (ipv6->iid = ifaddr));",
                    "1383": "",
                    "1384": "\t/* Start DAD for all the addresses that were added earlier when",
                    "1385": "\t * the interface was down.",
                    "1386": "\t */",
                    "1387": "\tsys_slist_init(&dad_needed);",
                    "1388": "",
                    "1389": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "1390": "\t\tif (!ipv6->unicast[i].is_used ||",
                    "1391": "\t\t    ipv6->unicast[i].address.family != NET_AF_INET6 ||",
                    "1392": "\t\t    &ipv6->unicast[i] == ifaddr ||",
                    "1393": "\t\t    net_ipv6_is_addr_loopback(",
                    "1394": "\t\t\t    &ipv6->unicast[i].address.in6_addr)) {",
                    "1395": "\t\t\tcontinue;",
                    "1396": "\t\t}",
                    "1397": "",
                    "1398": "\t\tsys_slist_prepend(&dad_needed, &ipv6->unicast[i].dad_need_node);",
                    "1399": "\t}",
                    "1400": "",
                    "1401": "\tnet_if_unlock(iface);",
                    "1402": "",
                    "1403": "\t/* Start DAD for all the addresses without holding the iface lock",
                    "1404": "\t * to avoid any possible mutex deadlock issues.",
                    "1405": "\t */",
                    "1406": "\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&dad_needed,",
                    "1407": "\t\t\t\t\t  ifaddr, next, dad_need_node) {",
                    "1408": "\t\tnet_if_ipv6_start_dad(iface, ifaddr);",
                    "1409": "\t}",
                    "1410": "",
                    "1411": "\treturn;",
                    "1412": "",
                    "1413": "out:",
                    "1414": "\tnet_if_unlock(iface);",
                    "1415": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_try_queue_tx": {
            "name": "net_if_try_queue_tx",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 344,
            "function_content": [
                "/* Drop packet if interface is not up */\nvoid net_if_try_queue_tx(struct net_if *iface, struct net_pkt *pkt, k_timeout_t timeout)\n{\n\tif (!net_pkt_filter_send_ok(pkt)) {\n\t\t/* Silently drop the packet, but update the statistics in order\n\t\t * to be able to monitor filter activity.\n\t\t */\n\t\tnet_stats_update_filter_tx_drop(net_pkt_iface(pkt));\n\t\tnet_pkt_unref(pkt);\n\t\treturn;\n\t}\n\n\tsize_t len = net_pkt_get_len(pkt);\n\tuint8_t prio = net_pkt_priority(pkt);\n\tuint8_t tc = net_tx_priority2tc(prio);\n\n#if NET_TC_TX_COUNT > 1\n\tNET_DBG(\"TC %d with prio %d pkt %p\", tc, prio, pkt);\n#endif\n\n\t/* For highest priority packet, skip the TX queue and push directly to\n\t * the driver. Also if there are no TX queue/thread, push the packet\n\t * directly to the driver.\n\t */\n\tif (net_tc_tx_is_immediate(tc, prio)) {\n\t\tnet_pkt_set_tx_stats_tick(pkt, k_cycle_get_32());\n\t\tnet_if_tx(net_pkt_iface(pkt), pkt);\n\t} else {\n\t\tif (net_tc_try_submit_to_tx_queue(tc, pkt, timeout) != NET_OK) {\n\t\t\tgoto drop;\n\t\t}\n#if defined(CONFIG_NET_POWER_MANAGEMENT)\n\t\tiface->tx_pending++;\n#endif\n\t}\n\n\tnet_stats_update_tc_sent_pkt(iface, tc);\n\tnet_stats_update_tc_sent_bytes(iface, tc, len);\n\tnet_stats_update_tc_sent_priority(iface, tc, prio);\n\treturn;\n\ndrop:\n\tnet_pkt_unref(pkt);\n\tnet_stats_update_tc_sent_dropped(iface, tc);\n\treturn;\n}\n",
                {
                    "344": "void net_if_try_queue_tx(struct net_if *iface, struct net_pkt *pkt, k_timeout_t timeout)",
                    "345": "{",
                    "346": "\tif (!net_pkt_filter_send_ok(pkt)) {",
                    "347": "\t\t/* Silently drop the packet, but update the statistics in order",
                    "348": "\t\t * to be able to monitor filter activity.",
                    "349": "\t\t */",
                    "350": "\t\tnet_stats_update_filter_tx_drop(net_pkt_iface(pkt));",
                    "351": "\t\tnet_pkt_unref(pkt);",
                    "352": "\t\treturn;",
                    "353": "\t}",
                    "354": "",
                    "355": "\tsize_t len = net_pkt_get_len(pkt);",
                    "356": "\tuint8_t prio = net_pkt_priority(pkt);",
                    "357": "\tuint8_t tc = net_tx_priority2tc(prio);",
                    "358": "",
                    "359": "#if NET_TC_TX_COUNT > 1",
                    "360": "\tNET_DBG(\"TC %d with prio %d pkt %p\", tc, prio, pkt);",
                    "361": "#endif",
                    "362": "",
                    "363": "\t/* For highest priority packet, skip the TX queue and push directly to",
                    "364": "\t * the driver. Also if there are no TX queue/thread, push the packet",
                    "365": "\t * directly to the driver.",
                    "366": "\t */",
                    "367": "\tif (net_tc_tx_is_immediate(tc, prio)) {",
                    "368": "\t\tnet_pkt_set_tx_stats_tick(pkt, k_cycle_get_32());",
                    "369": "\t\tnet_if_tx(net_pkt_iface(pkt), pkt);",
                    "370": "\t} else {",
                    "371": "\t\tif (net_tc_try_submit_to_tx_queue(tc, pkt, timeout) != NET_OK) {",
                    "372": "\t\t\tgoto drop;",
                    "373": "\t\t}",
                    "374": "#if defined(CONFIG_NET_POWER_MANAGEMENT)",
                    "375": "\t\tiface->tx_pending++;",
                    "376": "#endif",
                    "377": "\t}",
                    "378": "",
                    "379": "\tnet_stats_update_tc_sent_pkt(iface, tc);",
                    "380": "\tnet_stats_update_tc_sent_bytes(iface, tc, len);",
                    "381": "\tnet_stats_update_tc_sent_priority(iface, tc, prio);",
                    "382": "\treturn;",
                    "383": "",
                    "384": "drop:",
                    "385": "\tnet_pkt_unref(pkt);",
                    "386": "\tnet_stats_update_tc_sent_dropped(iface, tc);",
                    "387": "\treturn;",
                    "388": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_connect": {
            "name": "net_context_connect",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1355,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6 */\nint net_context_connect(struct net_context *context,\n\t\t\tconst struct net_sockaddr *addr,\n\t\t\tnet_socklen_t addrlen,\n\t\t\tnet_context_connect_cb_t cb,\n\t\t\tk_timeout_t timeout,\n\t\t\tvoid *user_data)\n{\n\tstruct net_sockaddr *laddr = NULL;\n\tstruct net_sockaddr local_addr __unused;\n\tuint16_t lport, rport;\n\tint ret;\n\n\tNET_ASSERT(addr);\n\tNET_ASSERT(PART_OF_ARRAY(contexts, context));\n\n\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\tif (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {\n\t\tret = -EALREADY;\n\t\tgoto unlock;\n\t}\n\n\tif (!net_context_is_used(context)) {\n\t\tret = -EBADF;\n\t\tgoto unlock;\n\t}\n\n\t/* As per POSIX, for non-connection-mode sockets:\n\t * \"If the sa_family member of address is NET_AF_UNSPEC, the socket's peer\n\t *  address shall be reset.\"\"\n\t */\n\tif (IS_ENABLED(CONFIG_NET_UDP) && addr->sa_family == NET_AF_UNSPEC &&\n\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;\n\t\tmemset(&context->remote, 0, sizeof(context->remote));\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\tif (addr->sa_family != net_context_get_family(context)) {\n\t\tNET_ERR(\"Address family %d does not match network context family %d\",\n\t\t\taddr->sa_family, net_context_get_family(context));\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&\n\t    addr->sa_family == NET_AF_PACKET) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tif (net_context_get_state(context) == NET_CONTEXT_LISTENING) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_context_get_family(context) == NET_AF_INET6) {\n\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)\n\t\t\t\t\t\t\t&context->remote;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (net_context_get_proto(context) == NET_IPPROTO_TCP &&\n\t\t    net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmemcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,\n\t\t       sizeof(struct net_in6_addr));\n\n\t\taddr6->sin6_port = net_sin6(addr)->sin6_port;\n\t\taddr6->sin6_family = NET_AF_INET6;\n\n\t\tif (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {\n\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;\n\t\t} else {\n\t\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;\n\t\t}\n\n\t\trport = addr6->sin6_port;\n\n\t\t/* The binding must be done after we have set the remote\n\t\t * address but before checking the local address. Otherwise\n\t\t * the laddr might not be set properly which would then cause\n\t\t * issues when doing net_tcp_connect(). This issue was seen\n\t\t * with socket tests and when connecting to loopback interface.\n\t\t */\n\t\tret = bind_default(context);\n\t\tif (ret) {\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tnet_sin6_ptr(&context->local)->sin6_family = NET_AF_INET6;\n\t\tnet_sin6(&local_addr)->sin6_family = NET_AF_INET6;\n\t\tnet_sin6(&local_addr)->sin6_port = lport =\n\t\t\tnet_sin6((struct net_sockaddr *)&context->local)->sin6_port;\n\n\t\tif (net_sin6_ptr(&context->local)->sin6_addr) {\n\t\t\tnet_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,\n\t\t\t\t     net_sin6_ptr(&context->local)->sin6_addr);\n\n\t\t\tladdr = &local_addr;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t   net_context_get_family(context) == NET_AF_INET) {\n\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)\n\t\t\t\t\t\t\t&context->remote;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (net_context_get_proto(context) == NET_IPPROTO_TCP &&\n\t\t    (net_ipv4_is_addr_mcast(&addr4->sin_addr) ||\n\t\t     net_ipv4_is_addr_bcast(net_context_get_iface(context),\n\t\t\t\t\t    &addr4->sin_addr))) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmemcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,\n\t\t       sizeof(struct net_in_addr));\n\n\t\taddr4->sin_port = net_sin(addr)->sin_port;\n\t\taddr4->sin_family = NET_AF_INET;\n\n\t\tif (addr4->sin_addr.s_addr) {\n\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;\n\t\t} else {\n\t\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;\n\t\t}\n\n\t\trport = addr4->sin_port;\n\n\t\tret = bind_default(context);\n\t\tif (ret) {\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tnet_sin_ptr(&context->local)->sin_family = NET_AF_INET;\n\t\tnet_sin(&local_addr)->sin_family = NET_AF_INET;\n\t\tnet_sin(&local_addr)->sin_port = lport =\n\t\t\tnet_sin((struct net_sockaddr *)&context->local)->sin_port;\n\n\t\tif (net_sin_ptr(&context->local)->sin_addr) {\n\t\t\tnet_ipaddr_copy(&net_sin(&local_addr)->sin_addr,\n\t\t\t\t       net_sin_ptr(&context->local)->sin_addr);\n\n\t\t\tladdr = &local_addr;\n\t\t}\n\t} else {\n\t\tret = -EINVAL; /* Not IPv4 or IPv6 */\n\t\tgoto unlock;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&\n\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {\n\t\tret = net_offload_connect(\n\t\t\tnet_context_get_iface(context),\n\t\t\tcontext,\n\t\t\taddr,\n\t\t\taddrlen,\n\t\t\tcb,\n\t\t\ttimeout,\n\t\t\tuser_data);\n\t\tgoto unlock;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\tif (cb) {\n\t\t\tcb(context, 0, user_data);\n\t\t}\n\n\t\tret = 0;\n\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&\n\t\t   net_context_get_type(context) == NET_SOCK_STREAM) {\n\t\tNET_ASSERT(laddr != NULL);\n\n\t\tret = net_tcp_connect(context, addr, laddr, rport, lport,\n\t\t\t\t      timeout, cb, user_data);\n\t} else {\n\t\tret = -ENOTSUP;\n\t}\n\nunlock:\n\tk_mutex_unlock(&context->lock);\n\n\treturn ret;\n}\n",
                {
                    "1355": "int net_context_connect(struct net_context *context,",
                    "1356": "\t\t\tconst struct net_sockaddr *addr,",
                    "1357": "\t\t\tnet_socklen_t addrlen,",
                    "1358": "\t\t\tnet_context_connect_cb_t cb,",
                    "1359": "\t\t\tk_timeout_t timeout,",
                    "1360": "\t\t\tvoid *user_data)",
                    "1361": "{",
                    "1362": "\tstruct net_sockaddr *laddr = NULL;",
                    "1363": "\tstruct net_sockaddr local_addr __unused;",
                    "1364": "\tuint16_t lport, rport;",
                    "1365": "\tint ret;",
                    "1366": "",
                    "1367": "\tNET_ASSERT(addr);",
                    "1368": "\tNET_ASSERT(PART_OF_ARRAY(contexts, context));",
                    "1369": "",
                    "1370": "\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "1371": "",
                    "1372": "\tif (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {",
                    "1373": "\t\tret = -EALREADY;",
                    "1374": "\t\tgoto unlock;",
                    "1375": "\t}",
                    "1376": "",
                    "1377": "\tif (!net_context_is_used(context)) {",
                    "1378": "\t\tret = -EBADF;",
                    "1379": "\t\tgoto unlock;",
                    "1380": "\t}",
                    "1381": "",
                    "1382": "\t/* As per POSIX, for non-connection-mode sockets:",
                    "1383": "\t * \"If the sa_family member of address is NET_AF_UNSPEC, the socket's peer",
                    "1384": "\t *  address shall be reset.\"\"",
                    "1385": "\t */",
                    "1386": "\tif (IS_ENABLED(CONFIG_NET_UDP) && addr->sa_family == NET_AF_UNSPEC &&",
                    "1387": "\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "1388": "\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;",
                    "1389": "\t\tmemset(&context->remote, 0, sizeof(context->remote));",
                    "1390": "\t\tret = 0;",
                    "1391": "\t\tgoto unlock;",
                    "1392": "\t}",
                    "1393": "",
                    "1394": "\tif (addr->sa_family != net_context_get_family(context)) {",
                    "1395": "\t\tNET_ERR(\"Address family %d does not match network context family %d\",",
                    "1396": "\t\t\taddr->sa_family, net_context_get_family(context));",
                    "1397": "\t\tret = -EINVAL;",
                    "1398": "\t\tgoto unlock;",
                    "1399": "\t}",
                    "1400": "",
                    "1401": "\tif (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&",
                    "1402": "\t    addr->sa_family == NET_AF_PACKET) {",
                    "1403": "\t\tret = -EOPNOTSUPP;",
                    "1404": "\t\tgoto unlock;",
                    "1405": "\t}",
                    "1406": "",
                    "1407": "\tif (net_context_get_state(context) == NET_CONTEXT_LISTENING) {",
                    "1408": "\t\tret = -EOPNOTSUPP;",
                    "1409": "\t\tgoto unlock;",
                    "1410": "\t}",
                    "1411": "",
                    "1412": "\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "1413": "\t    net_context_get_family(context) == NET_AF_INET6) {",
                    "1414": "\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)",
                    "1415": "\t\t\t\t\t\t\t&context->remote;",
                    "1416": "",
                    "1417": "\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {",
                    "1418": "\t\t\tret = -EINVAL;",
                    "1419": "\t\t\tgoto unlock;",
                    "1420": "\t\t}",
                    "1421": "",
                    "1422": "\t\tif (net_context_get_proto(context) == NET_IPPROTO_TCP &&",
                    "1423": "\t\t    net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {",
                    "1424": "\t\t\tret = -EADDRNOTAVAIL;",
                    "1425": "\t\t\tgoto unlock;",
                    "1426": "\t\t}",
                    "1427": "",
                    "1428": "\t\tmemcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,",
                    "1429": "\t\t       sizeof(struct net_in6_addr));",
                    "1430": "",
                    "1431": "\t\taddr6->sin6_port = net_sin6(addr)->sin6_port;",
                    "1432": "\t\taddr6->sin6_family = NET_AF_INET6;",
                    "1433": "",
                    "1434": "\t\tif (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {",
                    "1435": "\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;",
                    "1436": "\t\t} else {",
                    "1437": "\t\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;",
                    "1438": "\t\t}",
                    "1439": "",
                    "1440": "\t\trport = addr6->sin6_port;",
                    "1441": "",
                    "1442": "\t\t/* The binding must be done after we have set the remote",
                    "1443": "\t\t * address but before checking the local address. Otherwise",
                    "1444": "\t\t * the laddr might not be set properly which would then cause",
                    "1445": "\t\t * issues when doing net_tcp_connect(). This issue was seen",
                    "1446": "\t\t * with socket tests and when connecting to loopback interface.",
                    "1447": "\t\t */",
                    "1448": "\t\tret = bind_default(context);",
                    "1449": "\t\tif (ret) {",
                    "1450": "\t\t\tgoto unlock;",
                    "1451": "\t\t}",
                    "1452": "",
                    "1453": "\t\tnet_sin6_ptr(&context->local)->sin6_family = NET_AF_INET6;",
                    "1454": "\t\tnet_sin6(&local_addr)->sin6_family = NET_AF_INET6;",
                    "1455": "\t\tnet_sin6(&local_addr)->sin6_port = lport =",
                    "1456": "\t\t\tnet_sin6((struct net_sockaddr *)&context->local)->sin6_port;",
                    "1457": "",
                    "1458": "\t\tif (net_sin6_ptr(&context->local)->sin6_addr) {",
                    "1459": "\t\t\tnet_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,",
                    "1460": "\t\t\t\t     net_sin6_ptr(&context->local)->sin6_addr);",
                    "1461": "",
                    "1462": "\t\t\tladdr = &local_addr;",
                    "1463": "\t\t}",
                    "1464": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "1465": "\t\t   net_context_get_family(context) == NET_AF_INET) {",
                    "1466": "\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)",
                    "1467": "\t\t\t\t\t\t\t&context->remote;",
                    "1468": "",
                    "1469": "\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {",
                    "1470": "\t\t\tret = -EINVAL;",
                    "1471": "\t\t\tgoto unlock;",
                    "1472": "\t\t}",
                    "1473": "",
                    "1474": "\t\tif (net_context_get_proto(context) == NET_IPPROTO_TCP &&",
                    "1475": "\t\t    (net_ipv4_is_addr_mcast(&addr4->sin_addr) ||",
                    "1476": "\t\t     net_ipv4_is_addr_bcast(net_context_get_iface(context),",
                    "1477": "\t\t\t\t\t    &addr4->sin_addr))) {",
                    "1478": "\t\t\tret = -EADDRNOTAVAIL;",
                    "1479": "\t\t\tgoto unlock;",
                    "1480": "\t\t}",
                    "1481": "",
                    "1482": "\t\tmemcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,",
                    "1483": "\t\t       sizeof(struct net_in_addr));",
                    "1484": "",
                    "1485": "\t\taddr4->sin_port = net_sin(addr)->sin_port;",
                    "1486": "\t\taddr4->sin_family = NET_AF_INET;",
                    "1487": "",
                    "1488": "\t\tif (addr4->sin_addr.s_addr) {",
                    "1489": "\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;",
                    "1490": "\t\t} else {",
                    "1491": "\t\t\tcontext->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;",
                    "1492": "\t\t}",
                    "1493": "",
                    "1494": "\t\trport = addr4->sin_port;",
                    "1495": "",
                    "1496": "\t\tret = bind_default(context);",
                    "1497": "\t\tif (ret) {",
                    "1498": "\t\t\tgoto unlock;",
                    "1499": "\t\t}",
                    "1500": "",
                    "1501": "\t\tnet_sin_ptr(&context->local)->sin_family = NET_AF_INET;",
                    "1502": "\t\tnet_sin(&local_addr)->sin_family = NET_AF_INET;",
                    "1503": "\t\tnet_sin(&local_addr)->sin_port = lport =",
                    "1504": "\t\t\tnet_sin((struct net_sockaddr *)&context->local)->sin_port;",
                    "1505": "",
                    "1506": "\t\tif (net_sin_ptr(&context->local)->sin_addr) {",
                    "1507": "\t\t\tnet_ipaddr_copy(&net_sin(&local_addr)->sin_addr,",
                    "1508": "\t\t\t\t       net_sin_ptr(&context->local)->sin_addr);",
                    "1509": "",
                    "1510": "\t\t\tladdr = &local_addr;",
                    "1511": "\t\t}",
                    "1512": "\t} else {",
                    "1513": "\t\tret = -EINVAL; /* Not IPv4 or IPv6 */",
                    "1514": "\t\tgoto unlock;",
                    "1515": "\t}",
                    "1516": "",
                    "1517": "\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&",
                    "1518": "\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {",
                    "1519": "\t\tret = net_offload_connect(",
                    "1520": "\t\t\tnet_context_get_iface(context),",
                    "1521": "\t\t\tcontext,",
                    "1522": "\t\t\taddr,",
                    "1523": "\t\t\taddrlen,",
                    "1524": "\t\t\tcb,",
                    "1525": "\t\t\ttimeout,",
                    "1526": "\t\t\tuser_data);",
                    "1527": "\t\tgoto unlock;",
                    "1528": "\t}",
                    "1529": "",
                    "1530": "\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "1531": "\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "1532": "\t\tif (cb) {",
                    "1533": "\t\t\tcb(context, 0, user_data);",
                    "1534": "\t\t}",
                    "1535": "",
                    "1536": "\t\tret = 0;",
                    "1537": "\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "1538": "\t\t   net_context_get_type(context) == NET_SOCK_STREAM) {",
                    "1539": "\t\tNET_ASSERT(laddr != NULL);",
                    "1540": "",
                    "1541": "\t\tret = net_tcp_connect(context, addr, laddr, rport, lport,",
                    "1542": "\t\t\t\t      timeout, cb, user_data);",
                    "1543": "\t} else {",
                    "1544": "\t\tret = -ENOTSUP;",
                    "1545": "\t}",
                    "1546": "",
                    "1547": "unlock:",
                    "1548": "\tk_mutex_unlock(&context->lock);",
                    "1549": "",
                    "1550": "\treturn ret;",
                    "1551": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_bind": {
            "name": "net_context_bind",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 878,
            "function_content": [
                "/* If local address is not bound, bind it to NET_INADDR_ANY and random port. */\nint net_context_bind(struct net_context *context, const struct net_sockaddr *addr,\n\t\t     net_socklen_t addrlen)\n{\n\tint ret;\n\n\tNET_ASSERT(addr);\n\tNET_ASSERT(PART_OF_ARRAY(contexts, context));\n\n\t/* If we already have connection handler, then it effectively\n\t * means that it's already bound to an interface/port, and we\n\t * don't support rebinding connection to new address/port in\n\t * the code below. Only applies for stream sockets.\n\t * TODO: Support rebinding.\n\t */\n\tif (net_context_get_type(context) == NET_SOCK_STREAM) {\n\t\tif (context->conn_handler != NULL) {\n\t\t\treturn -EISCONN;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && addr->sa_family == NET_AF_INET6) {\n\t\tstruct net_if *iface = NULL;\n\t\tstruct net_in6_addr *ptr;\n\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)addr;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (net_context_is_bound_to_iface(context)) {\n\t\t\tiface = net_context_get_iface(context);\n\t\t}\n\n\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {\n\t\t\tstruct net_if_mcast_addr *maddr;\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\t\tif (COND_CODE_1(CONFIG_NET_IPV6,\n\t\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0),\n\t\t\t\t\t\t(false))) {\n\t\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,\n\t\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmaddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,\n\t\t\t\t\t\t\t &iface);\n\t\t\tif (!maddr) {\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tptr = &maddr->address.in6_addr;\n\n\t\t} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {\n\t\t\tif (iface == NULL) {\n\t\t\t\tiface = net_if_ipv6_select_src_iface(\n\t\t\t\t\t&net_sin6(&context->remote)->sin6_addr);\n\t\t\t}\n\n\t\t\tptr = (struct net_in6_addr *)net_ipv6_unspecified_address();\n\t\t} else {\n\t\t\tstruct net_if_addr *ifaddr;\n\n\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr)) {\n\t\t\t\tif (iface == NULL) {\n\t\t\t\t\tiface = net_if_get_by_index(addr6->sin6_scope_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tifaddr = net_if_ipv6_addr_lookup(\n\t\t\t\t\t&addr6->sin6_addr,\n\t\t\t\t\tiface == NULL ? &iface : NULL);\n\t\t\tif (!ifaddr) {\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tptr = &ifaddr->address.in6_addr;\n\t\t}\n\n\t\tif (!iface) {\n\t\t\tNET_ERR(\"Cannot bind to %s\",\n\t\t\t\tnet_sprint_ipv6_addr(&addr6->sin6_addr));\n\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\n\t\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\t\tnet_context_set_iface(context, iface);\n\n\t\tnet_sin6_ptr(&context->local)->sin6_family = NET_AF_INET6;\n\t\tnet_sin6_ptr(&context->local)->sin6_addr = ptr;\n\n\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {\n\t\t\tk_mutex_unlock(&context->lock);\n\t\t\treturn net_offload_bind(iface, context, addr, addrlen);\n\t\t}\n\n\t\tret = 0;\n\t\tif (addr6->sin6_port) {\n\t\t\tret = recheck_port(context, iface, context->proto,\n\t\t\t\t\t   addr6->sin6_port, addr);\n\t\t\tif (ret != 0) {\n\t\t\t\tgoto unlock_ipv6;\n\t\t\t}\n\t\t} else {\n\t\t\taddr6->sin6_port =\n\t\t\t\tnet_sin6_ptr(&context->local)->sin6_port;\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE)) {\n\t\t\t\tret = recheck_port(context, iface, context->proto,\n\t\t\t\t\t\t   addr6->sin6_port, addr);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tgoto unlock_ipv6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNET_DBG(\"Context %p binding to %s [%s]:%d iface %d (%p)\",\n\t\t\tcontext,\n\t\t\tnet_proto2str(NET_AF_INET6,\n\t\t\t\t      net_context_get_proto(context)),\n\t\t\tnet_sprint_ipv6_addr(ptr),\n\t\t\tnet_ntohs(addr6->sin6_port),\n\t\t\tnet_if_get_by_iface(iface), iface);\n\n\tunlock_ipv6:\n\t\tk_mutex_unlock(&context->lock);\n\n\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == NET_AF_INET) {\n\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)addr;\n\t\tstruct net_if *iface = NULL;\n\t\tstruct net_if_addr *ifaddr;\n\t\tstruct net_in_addr *ptr;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (net_context_is_bound_to_iface(context)) {\n\t\t\tiface = net_context_get_iface(context);\n\t\t}\n\n\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {\n\t\t\tstruct net_if_mcast_addr *maddr;\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\t\tif (COND_CODE_1(CONFIG_NET_IPV4,\n\t\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0),\n\t\t\t\t\t\t(false))) {\n\t\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,\n\t\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmaddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,\n\t\t\t\t\t\t\t &iface);\n\t\t\tif (!maddr) {\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tptr = &maddr->address.in_addr;\n\n\t\t} else if (UNALIGNED_GET(&addr4->sin_addr.s_addr) == NET_INADDR_ANY) {\n\t\t\tif (iface == NULL) {\n\t\t\t\tiface = net_if_ipv4_select_src_iface(\n\t\t\t\t\t&net_sin(&context->remote)->sin_addr);\n\t\t\t}\n\n\t\t\tptr = (struct net_in_addr *)net_ipv4_unspecified_address();\n\t\t} else {\n\t\t\tifaddr = net_if_ipv4_addr_lookup(\n\t\t\t\t\t&addr4->sin_addr,\n\t\t\t\t\tiface == NULL ? &iface : NULL);\n\t\t\tif (!ifaddr) {\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tptr = &ifaddr->address.in_addr;\n\t\t}\n\n\t\tif (!iface) {\n\t\t\tNET_ERR(\"Cannot bind to %s\",\n\t\t\t\tnet_sprint_ipv4_addr(&addr4->sin_addr));\n\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\n\t\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\t\tnet_context_set_iface(context, iface);\n\n\t\tnet_sin_ptr(&context->local)->sin_family = NET_AF_INET;\n\t\tnet_sin_ptr(&context->local)->sin_addr = ptr;\n\n\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {\n\t\t\tk_mutex_unlock(&context->lock);\n\t\t\treturn net_offload_bind(iface, context, addr, addrlen);\n\t\t}\n\n\t\tret = 0;\n\t\tif (addr4->sin_port) {\n\t\t\tret = recheck_port(context, iface, context->proto,\n\t\t\t\t\t   addr4->sin_port, addr);\n\t\t\tif (ret != 0) {\n\t\t\t\tgoto unlock_ipv4;\n\t\t\t}\n\t\t} else {\n\t\t\taddr4->sin_port =\n\t\t\t\tnet_sin_ptr(&context->local)->sin_port;\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE)) {\n\t\t\t\tret = recheck_port(context, iface, context->proto,\n\t\t\t\t\t\t   addr4->sin_port, addr);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tgoto unlock_ipv4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNET_DBG(\"Context %p binding to %s %s:%d iface %d (%p)\",\n\t\t\tcontext,\n\t\t\tnet_proto2str(NET_AF_INET,\n\t\t\t\t      net_context_get_proto(context)),\n\t\t\tnet_sprint_ipv4_addr(ptr),\n\t\t\tnet_ntohs(addr4->sin_port),\n\t\t\tnet_if_get_by_iface(iface), iface);\n\n\tunlock_ipv4:\n\t\tk_mutex_unlock(&context->lock);\n\n\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&\n\t    addr->sa_family == NET_AF_PACKET) {\n\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)addr;\n\t\tstruct net_if *iface = NULL;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ll_addr->sll_ifindex < 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);\n\n\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && iface != NULL &&\n\t\t    net_if_is_ip_offloaded(iface)) {\n\t\t\tnet_context_set_iface(context, iface);\n\n\t\t\treturn net_offload_bind(iface,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\taddr,\n\t\t\t\t\t\taddrlen);\n\t\t}\n\n\t\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\t\tnet_sll_ptr(&context->local)->sll_family = NET_AF_PACKET;\n\t\tnet_sll_ptr(&context->local)->sll_ifindex =\n\t\t\tll_addr->sll_ifindex;\n\t\tnet_sll_ptr(&context->local)->sll_protocol =\n\t\t\tll_addr->sll_protocol;\n\n\t\tif (iface != NULL) {\n\t\t\tnet_context_set_iface(context, iface);\n\n\t\t\tnet_if_lock(iface);\n\t\t\tnet_sll_ptr(&context->local)->sll_addr =\n\t\t\t\tnet_if_get_link_addr(iface)->addr;\n\t\t\tnet_sll_ptr(&context->local)->sll_halen =\n\t\t\t\tnet_if_get_link_addr(iface)->len;\n\t\t\tnet_if_unlock(iface);\n\t\t}\n\n\t\tNET_DBG(\"Context %p bind to type 0x%04x iface[%d] %p addr %s\",\n\t\t\tcontext, net_htons(net_context_get_proto(context)),\n\t\t\tll_addr->sll_ifindex, iface,\n\t\t\tnet_sprint_ll_addr(\n\t\t\t\tnet_sll_ptr(&context->local)->sll_addr,\n\t\t\t\tnet_sll_ptr(&context->local)->sll_halen));\n\n\t\tk_mutex_unlock(&context->lock);\n\n\t\treturn 0;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && addr->sa_family == NET_AF_CAN) {\n\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)addr;\n\t\tstruct net_if *iface = NULL;\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (can_addr->can_ifindex < 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiface = net_if_get_by_index(can_addr->can_ifindex);\n\t\tif (!iface) {\n\t\t\tNET_ERR(\"Cannot bind to interface index %d\",\n\t\t\t\tcan_addr->can_ifindex);\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&\n\t\t    net_if_is_ip_offloaded(iface)) {\n\t\t\tnet_context_set_iface(context, iface);\n\n\t\t\treturn net_offload_bind(iface,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\taddr,\n\t\t\t\t\t\taddrlen);\n\t\t}\n\n\t\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\t\tnet_context_set_iface(context, iface);\n\t\tnet_context_set_family(context, NET_AF_CAN);\n\n\t\tnet_can_ptr(&context->local)->can_family = NET_AF_CAN;\n\t\tnet_can_ptr(&context->local)->can_ifindex =\n\t\t\tcan_addr->can_ifindex;\n\n\t\tNET_DBG(\"Context %p binding to %d iface[%d] %p\",\n\t\t\tcontext, net_context_get_proto(context),\n\t\t\tcan_addr->can_ifindex, iface);\n\n\t\tk_mutex_unlock(&context->lock);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n",
                {
                    "878": "int net_context_bind(struct net_context *context, const struct net_sockaddr *addr,",
                    "879": "\t\t     net_socklen_t addrlen)",
                    "880": "{",
                    "881": "\tint ret;",
                    "882": "",
                    "883": "\tNET_ASSERT(addr);",
                    "884": "\tNET_ASSERT(PART_OF_ARRAY(contexts, context));",
                    "885": "",
                    "886": "\t/* If we already have connection handler, then it effectively",
                    "887": "\t * means that it's already bound to an interface/port, and we",
                    "888": "\t * don't support rebinding connection to new address/port in",
                    "889": "\t * the code below. Only applies for stream sockets.",
                    "890": "\t * TODO: Support rebinding.",
                    "891": "\t */",
                    "892": "\tif (net_context_get_type(context) == NET_SOCK_STREAM) {",
                    "893": "\t\tif (context->conn_handler != NULL) {",
                    "894": "\t\t\treturn -EISCONN;",
                    "895": "\t\t}",
                    "896": "\t}",
                    "897": "",
                    "898": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && addr->sa_family == NET_AF_INET6) {",
                    "899": "\t\tstruct net_if *iface = NULL;",
                    "900": "\t\tstruct net_in6_addr *ptr;",
                    "901": "\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)addr;",
                    "902": "",
                    "903": "\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {",
                    "904": "\t\t\treturn -EINVAL;",
                    "905": "\t\t}",
                    "906": "",
                    "907": "\t\tif (net_context_is_bound_to_iface(context)) {",
                    "908": "\t\t\tiface = net_context_get_iface(context);",
                    "909": "\t\t}",
                    "910": "",
                    "911": "\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {",
                    "912": "\t\t\tstruct net_if_mcast_addr *maddr;",
                    "913": "",
                    "914": "\t\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "915": "\t\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "916": "\t\t\t\tif (COND_CODE_1(CONFIG_NET_IPV6,",
                    "917": "\t\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0),",
                    "918": "\t\t\t\t\t\t(false))) {",
                    "919": "\t\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,",
                    "920": "\t\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "921": "\t\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));",
                    "922": "\t\t\t\t}",
                    "923": "\t\t\t}",
                    "924": "",
                    "925": "\t\t\tmaddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,",
                    "926": "\t\t\t\t\t\t\t &iface);",
                    "927": "\t\t\tif (!maddr) {",
                    "928": "\t\t\t\treturn -ENOENT;",
                    "929": "\t\t\t}",
                    "930": "",
                    "931": "\t\t\tptr = &maddr->address.in6_addr;",
                    "932": "",
                    "933": "\t\t} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {",
                    "934": "\t\t\tif (iface == NULL) {",
                    "935": "\t\t\t\tiface = net_if_ipv6_select_src_iface(",
                    "936": "\t\t\t\t\t&net_sin6(&context->remote)->sin6_addr);",
                    "937": "\t\t\t}",
                    "938": "",
                    "939": "\t\t\tptr = (struct net_in6_addr *)net_ipv6_unspecified_address();",
                    "940": "\t\t} else {",
                    "941": "\t\t\tstruct net_if_addr *ifaddr;",
                    "942": "",
                    "943": "\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr)) {",
                    "944": "\t\t\t\tif (iface == NULL) {",
                    "945": "\t\t\t\t\tiface = net_if_get_by_index(addr6->sin6_scope_id);",
                    "946": "\t\t\t\t}",
                    "947": "\t\t\t}",
                    "948": "",
                    "949": "\t\t\tifaddr = net_if_ipv6_addr_lookup(",
                    "950": "\t\t\t\t\t&addr6->sin6_addr,",
                    "951": "\t\t\t\t\tiface == NULL ? &iface : NULL);",
                    "952": "\t\t\tif (!ifaddr) {",
                    "953": "\t\t\t\treturn -ENOENT;",
                    "954": "\t\t\t}",
                    "955": "",
                    "956": "\t\t\tptr = &ifaddr->address.in6_addr;",
                    "957": "\t\t}",
                    "958": "",
                    "959": "\t\tif (!iface) {",
                    "960": "\t\t\tNET_ERR(\"Cannot bind to %s\",",
                    "961": "\t\t\t\tnet_sprint_ipv6_addr(&addr6->sin6_addr));",
                    "962": "",
                    "963": "\t\t\treturn -EADDRNOTAVAIL;",
                    "964": "\t\t}",
                    "965": "",
                    "966": "\t\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "967": "",
                    "968": "\t\tnet_context_set_iface(context, iface);",
                    "969": "",
                    "970": "\t\tnet_sin6_ptr(&context->local)->sin6_family = NET_AF_INET6;",
                    "971": "\t\tnet_sin6_ptr(&context->local)->sin6_addr = ptr;",
                    "972": "",
                    "973": "\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {",
                    "974": "\t\t\tk_mutex_unlock(&context->lock);",
                    "975": "\t\t\treturn net_offload_bind(iface, context, addr, addrlen);",
                    "976": "\t\t}",
                    "977": "",
                    "978": "\t\tret = 0;",
                    "979": "\t\tif (addr6->sin6_port) {",
                    "980": "\t\t\tret = recheck_port(context, iface, context->proto,",
                    "981": "\t\t\t\t\t   addr6->sin6_port, addr);",
                    "982": "\t\t\tif (ret != 0) {",
                    "983": "\t\t\t\tgoto unlock_ipv6;",
                    "984": "\t\t\t}",
                    "985": "\t\t} else {",
                    "986": "\t\t\taddr6->sin6_port =",
                    "987": "\t\t\t\tnet_sin6_ptr(&context->local)->sin6_port;",
                    "988": "",
                    "989": "\t\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE)) {",
                    "990": "\t\t\t\tret = recheck_port(context, iface, context->proto,",
                    "991": "\t\t\t\t\t\t   addr6->sin6_port, addr);",
                    "992": "\t\t\t\tif (ret != 0) {",
                    "993": "\t\t\t\t\tgoto unlock_ipv6;",
                    "994": "\t\t\t\t}",
                    "995": "\t\t\t}",
                    "996": "\t\t}",
                    "997": "",
                    "998": "\t\tNET_DBG(\"Context %p binding to %s [%s]:%d iface %d (%p)\",",
                    "999": "\t\t\tcontext,",
                    "1000": "\t\t\tnet_proto2str(NET_AF_INET6,",
                    "1001": "\t\t\t\t      net_context_get_proto(context)),",
                    "1002": "\t\t\tnet_sprint_ipv6_addr(ptr),",
                    "1003": "\t\t\tnet_ntohs(addr6->sin6_port),",
                    "1004": "\t\t\tnet_if_get_by_iface(iface), iface);",
                    "1005": "",
                    "1006": "\tunlock_ipv6:",
                    "1007": "\t\tk_mutex_unlock(&context->lock);",
                    "1008": "",
                    "1009": "\t\treturn ret;",
                    "1010": "\t}",
                    "1011": "",
                    "1012": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == NET_AF_INET) {",
                    "1013": "\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)addr;",
                    "1014": "\t\tstruct net_if *iface = NULL;",
                    "1015": "\t\tstruct net_if_addr *ifaddr;",
                    "1016": "\t\tstruct net_in_addr *ptr;",
                    "1017": "",
                    "1018": "\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {",
                    "1019": "\t\t\treturn -EINVAL;",
                    "1020": "\t\t}",
                    "1021": "",
                    "1022": "\t\tif (net_context_is_bound_to_iface(context)) {",
                    "1023": "\t\t\tiface = net_context_get_iface(context);",
                    "1024": "\t\t}",
                    "1025": "",
                    "1026": "\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {",
                    "1027": "\t\t\tstruct net_if_mcast_addr *maddr;",
                    "1028": "",
                    "1029": "\t\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "1030": "\t\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "1031": "\t\t\t\tif (COND_CODE_1(CONFIG_NET_IPV4,",
                    "1032": "\t\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0),",
                    "1033": "\t\t\t\t\t\t(false))) {",
                    "1034": "\t\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,",
                    "1035": "\t\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "1036": "\t\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));",
                    "1037": "\t\t\t\t}",
                    "1038": "\t\t\t}",
                    "1039": "",
                    "1040": "\t\t\tmaddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,",
                    "1041": "\t\t\t\t\t\t\t &iface);",
                    "1042": "\t\t\tif (!maddr) {",
                    "1043": "\t\t\t\treturn -ENOENT;",
                    "1044": "\t\t\t}",
                    "1045": "",
                    "1046": "\t\t\tptr = &maddr->address.in_addr;",
                    "1047": "",
                    "1048": "\t\t} else if (UNALIGNED_GET(&addr4->sin_addr.s_addr) == NET_INADDR_ANY) {",
                    "1049": "\t\t\tif (iface == NULL) {",
                    "1050": "\t\t\t\tiface = net_if_ipv4_select_src_iface(",
                    "1051": "\t\t\t\t\t&net_sin(&context->remote)->sin_addr);",
                    "1052": "\t\t\t}",
                    "1053": "",
                    "1054": "\t\t\tptr = (struct net_in_addr *)net_ipv4_unspecified_address();",
                    "1055": "\t\t} else {",
                    "1056": "\t\t\tifaddr = net_if_ipv4_addr_lookup(",
                    "1057": "\t\t\t\t\t&addr4->sin_addr,",
                    "1058": "\t\t\t\t\tiface == NULL ? &iface : NULL);",
                    "1059": "\t\t\tif (!ifaddr) {",
                    "1060": "\t\t\t\treturn -ENOENT;",
                    "1061": "\t\t\t}",
                    "1062": "",
                    "1063": "\t\t\tptr = &ifaddr->address.in_addr;",
                    "1064": "\t\t}",
                    "1065": "",
                    "1066": "\t\tif (!iface) {",
                    "1067": "\t\t\tNET_ERR(\"Cannot bind to %s\",",
                    "1068": "\t\t\t\tnet_sprint_ipv4_addr(&addr4->sin_addr));",
                    "1069": "",
                    "1070": "\t\t\treturn -EADDRNOTAVAIL;",
                    "1071": "\t\t}",
                    "1072": "",
                    "1073": "\t\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "1074": "",
                    "1075": "\t\tnet_context_set_iface(context, iface);",
                    "1076": "",
                    "1077": "\t\tnet_sin_ptr(&context->local)->sin_family = NET_AF_INET;",
                    "1078": "\t\tnet_sin_ptr(&context->local)->sin_addr = ptr;",
                    "1079": "",
                    "1080": "\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {",
                    "1081": "\t\t\tk_mutex_unlock(&context->lock);",
                    "1082": "\t\t\treturn net_offload_bind(iface, context, addr, addrlen);",
                    "1083": "\t\t}",
                    "1084": "",
                    "1085": "\t\tret = 0;",
                    "1086": "\t\tif (addr4->sin_port) {",
                    "1087": "\t\t\tret = recheck_port(context, iface, context->proto,",
                    "1088": "\t\t\t\t\t   addr4->sin_port, addr);",
                    "1089": "\t\t\tif (ret != 0) {",
                    "1090": "\t\t\t\tgoto unlock_ipv4;",
                    "1091": "\t\t\t}",
                    "1092": "\t\t} else {",
                    "1093": "\t\t\taddr4->sin_port =",
                    "1094": "\t\t\t\tnet_sin_ptr(&context->local)->sin_port;",
                    "1095": "",
                    "1096": "\t\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE)) {",
                    "1097": "\t\t\t\tret = recheck_port(context, iface, context->proto,",
                    "1098": "\t\t\t\t\t\t   addr4->sin_port, addr);",
                    "1099": "\t\t\t\tif (ret != 0) {",
                    "1100": "\t\t\t\t\tgoto unlock_ipv4;",
                    "1101": "\t\t\t\t}",
                    "1102": "\t\t\t}",
                    "1103": "\t\t}",
                    "1104": "",
                    "1105": "\t\tNET_DBG(\"Context %p binding to %s %s:%d iface %d (%p)\",",
                    "1106": "\t\t\tcontext,",
                    "1107": "\t\t\tnet_proto2str(NET_AF_INET,",
                    "1108": "\t\t\t\t      net_context_get_proto(context)),",
                    "1109": "\t\t\tnet_sprint_ipv4_addr(ptr),",
                    "1110": "\t\t\tnet_ntohs(addr4->sin_port),",
                    "1111": "\t\t\tnet_if_get_by_iface(iface), iface);",
                    "1112": "",
                    "1113": "\tunlock_ipv4:",
                    "1114": "\t\tk_mutex_unlock(&context->lock);",
                    "1115": "",
                    "1116": "\t\treturn ret;",
                    "1117": "\t}",
                    "1118": "",
                    "1119": "\tif (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&",
                    "1120": "\t    addr->sa_family == NET_AF_PACKET) {",
                    "1121": "\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)addr;",
                    "1122": "\t\tstruct net_if *iface = NULL;",
                    "1123": "",
                    "1124": "\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {",
                    "1125": "\t\t\treturn -EINVAL;",
                    "1126": "\t\t}",
                    "1127": "",
                    "1128": "\t\tif (ll_addr->sll_ifindex < 0) {",
                    "1129": "\t\t\treturn -EINVAL;",
                    "1130": "\t\t}",
                    "1131": "",
                    "1132": "\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);",
                    "1133": "",
                    "1134": "\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) && iface != NULL &&",
                    "1135": "\t\t    net_if_is_ip_offloaded(iface)) {",
                    "1136": "\t\t\tnet_context_set_iface(context, iface);",
                    "1137": "",
                    "1138": "\t\t\treturn net_offload_bind(iface,",
                    "1139": "\t\t\t\t\t\tcontext,",
                    "1140": "\t\t\t\t\t\taddr,",
                    "1141": "\t\t\t\t\t\taddrlen);",
                    "1142": "\t\t}",
                    "1143": "",
                    "1144": "\t\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "1145": "",
                    "1146": "\t\tnet_sll_ptr(&context->local)->sll_family = NET_AF_PACKET;",
                    "1147": "\t\tnet_sll_ptr(&context->local)->sll_ifindex =",
                    "1148": "\t\t\tll_addr->sll_ifindex;",
                    "1149": "\t\tnet_sll_ptr(&context->local)->sll_protocol =",
                    "1150": "\t\t\tll_addr->sll_protocol;",
                    "1151": "",
                    "1152": "\t\tif (iface != NULL) {",
                    "1153": "\t\t\tnet_context_set_iface(context, iface);",
                    "1154": "",
                    "1155": "\t\t\tnet_if_lock(iface);",
                    "1156": "\t\t\tnet_sll_ptr(&context->local)->sll_addr =",
                    "1157": "\t\t\t\tnet_if_get_link_addr(iface)->addr;",
                    "1158": "\t\t\tnet_sll_ptr(&context->local)->sll_halen =",
                    "1159": "\t\t\t\tnet_if_get_link_addr(iface)->len;",
                    "1160": "\t\t\tnet_if_unlock(iface);",
                    "1161": "\t\t}",
                    "1162": "",
                    "1163": "\t\tNET_DBG(\"Context %p bind to type 0x%04x iface[%d] %p addr %s\",",
                    "1164": "\t\t\tcontext, net_htons(net_context_get_proto(context)),",
                    "1165": "\t\t\tll_addr->sll_ifindex, iface,",
                    "1166": "\t\t\tnet_sprint_ll_addr(",
                    "1167": "\t\t\t\tnet_sll_ptr(&context->local)->sll_addr,",
                    "1168": "\t\t\t\tnet_sll_ptr(&context->local)->sll_halen));",
                    "1169": "",
                    "1170": "\t\tk_mutex_unlock(&context->lock);",
                    "1171": "",
                    "1172": "\t\treturn 0;",
                    "1173": "\t}",
                    "1174": "",
                    "1175": "\tif (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && addr->sa_family == NET_AF_CAN) {",
                    "1176": "\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)addr;",
                    "1177": "\t\tstruct net_if *iface = NULL;",
                    "1178": "",
                    "1179": "\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {",
                    "1180": "\t\t\treturn -EINVAL;",
                    "1181": "\t\t}",
                    "1182": "",
                    "1183": "\t\tif (can_addr->can_ifindex < 0) {",
                    "1184": "\t\t\treturn -EINVAL;",
                    "1185": "\t\t}",
                    "1186": "",
                    "1187": "\t\tiface = net_if_get_by_index(can_addr->can_ifindex);",
                    "1188": "\t\tif (!iface) {",
                    "1189": "\t\t\tNET_ERR(\"Cannot bind to interface index %d\",",
                    "1190": "\t\t\t\tcan_addr->can_ifindex);",
                    "1191": "\t\t\treturn -EADDRNOTAVAIL;",
                    "1192": "\t\t}",
                    "1193": "",
                    "1194": "\t\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&",
                    "1195": "\t\t    net_if_is_ip_offloaded(iface)) {",
                    "1196": "\t\t\tnet_context_set_iface(context, iface);",
                    "1197": "",
                    "1198": "\t\t\treturn net_offload_bind(iface,",
                    "1199": "\t\t\t\t\t\tcontext,",
                    "1200": "\t\t\t\t\t\taddr,",
                    "1201": "\t\t\t\t\t\taddrlen);",
                    "1202": "\t\t}",
                    "1203": "",
                    "1204": "\t\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "1205": "",
                    "1206": "\t\tnet_context_set_iface(context, iface);",
                    "1207": "\t\tnet_context_set_family(context, NET_AF_CAN);",
                    "1208": "",
                    "1209": "\t\tnet_can_ptr(&context->local)->can_family = NET_AF_CAN;",
                    "1210": "\t\tnet_can_ptr(&context->local)->can_ifindex =",
                    "1211": "\t\t\tcan_addr->can_ifindex;",
                    "1212": "",
                    "1213": "\t\tNET_DBG(\"Context %p binding to %d iface[%d] %p\",",
                    "1214": "\t\t\tcontext, net_context_get_proto(context),",
                    "1215": "\t\t\tcan_addr->can_ifindex, iface);",
                    "1216": "",
                    "1217": "\t\tk_mutex_unlock(&context->lock);",
                    "1218": "",
                    "1219": "\t\treturn 0;",
                    "1220": "\t}",
                    "1221": "",
                    "1222": "\treturn -EINVAL;",
                    "1223": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_create_ipv6_new": {
            "name": "net_context_create_ipv6_new",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1323,
            "function_content": [
                "#endif /* CONFIG_NET_IPV4 */\nint net_context_create_ipv6_new(struct net_context *context,\n\t\t\t\tstruct net_pkt *pkt,\n\t\t\t\tconst struct net_in6_addr *src,\n\t\t\t\tconst struct net_in6_addr *dst)\n{\n\tif (!src) {\n\t\tNET_ASSERT(((\n\t\t\tstruct net_sockaddr_in6_ptr *)&context->local)->sin6_addr);\n\n\t\tsrc = ((struct net_sockaddr_in6_ptr *)&context->local)->sin6_addr;\n\t}\n\n\tif (net_ipv6_is_addr_unspecified(src) || net_ipv6_is_addr_mcast(src)) {\n\t\tsrc = net_if_ipv6_select_src_addr_hint(net_pkt_iface(pkt),\n\t\t\t\t\t\t       (struct net_in6_addr *)dst,\n\t\t\t\t\t\t       context->options.addr_preferences);\n\t}\n\n#if defined(CONFIG_NET_CONTEXT_DSCP_ECN)\n\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(context->options.dscp_ecn));\n\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(context->options.dscp_ecn));\n\t/* Direct priority takes precedence over DSCP */\n\tif (!IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {\n\t\tnet_pkt_set_priority(pkt, net_ipv6_dscp_to_priority(\n\t\t\tnet_ipv6_get_dscp(context->options.dscp_ecn)));\n\t}\n#endif\n\n\treturn net_ipv6_create(pkt, src, dst);\n}\n",
                {
                    "1323": "int net_context_create_ipv6_new(struct net_context *context,",
                    "1324": "\t\t\t\tstruct net_pkt *pkt,",
                    "1325": "\t\t\t\tconst struct net_in6_addr *src,",
                    "1326": "\t\t\t\tconst struct net_in6_addr *dst)",
                    "1327": "{",
                    "1328": "\tif (!src) {",
                    "1329": "\t\tNET_ASSERT(((",
                    "1330": "\t\t\tstruct net_sockaddr_in6_ptr *)&context->local)->sin6_addr);",
                    "1331": "",
                    "1332": "\t\tsrc = ((struct net_sockaddr_in6_ptr *)&context->local)->sin6_addr;",
                    "1333": "\t}",
                    "1334": "",
                    "1335": "\tif (net_ipv6_is_addr_unspecified(src) || net_ipv6_is_addr_mcast(src)) {",
                    "1336": "\t\tsrc = net_if_ipv6_select_src_addr_hint(net_pkt_iface(pkt),",
                    "1337": "\t\t\t\t\t\t       (struct net_in6_addr *)dst,",
                    "1338": "\t\t\t\t\t\t       context->options.addr_preferences);",
                    "1339": "\t}",
                    "1340": "",
                    "1341": "#if defined(CONFIG_NET_CONTEXT_DSCP_ECN)",
                    "1342": "\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(context->options.dscp_ecn));",
                    "1343": "\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(context->options.dscp_ecn));",
                    "1344": "\t/* Direct priority takes precedence over DSCP */",
                    "1345": "\tif (!IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {",
                    "1346": "\t\tnet_pkt_set_priority(pkt, net_ipv6_dscp_to_priority(",
                    "1347": "\t\t\tnet_ipv6_get_dscp(context->options.dscp_ecn)));",
                    "1348": "\t}",
                    "1349": "#endif",
                    "1350": "",
                    "1351": "\treturn net_ipv6_create(pkt, src, dst);",
                    "1352": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_get_contiguous_len": {
            "name": "net_pkt_get_contiguous_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2297,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nsize_t net_pkt_get_contiguous_len(struct net_pkt *pkt)\n{\n\tpkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));\n\n\tif (pkt->cursor.buf && pkt->cursor.pos) {\n\t\tsize_t len;\n\n\t\tlen = net_pkt_is_being_overwritten(pkt) ?\n\t\t\tpkt->cursor.buf->len : net_buf_max_len(pkt->cursor.buf);\n\t\tlen -= pkt->cursor.pos - pkt->cursor.buf->data;\n\n\t\treturn len;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "2297": "size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)",
                    "2298": "{",
                    "2299": "\tpkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));",
                    "2300": "",
                    "2301": "\tif (pkt->cursor.buf && pkt->cursor.pos) {",
                    "2302": "\t\tsize_t len;",
                    "2303": "",
                    "2304": "\t\tlen = net_pkt_is_being_overwritten(pkt) ?",
                    "2305": "\t\t\tpkt->cursor.buf->len : net_buf_max_len(pkt->cursor.buf);",
                    "2306": "\t\tlen -= pkt->cursor.pos - pkt->cursor.buf->data;",
                    "2307": "",
                    "2308": "\t\treturn len;",
                    "2309": "\t}",
                    "2310": "",
                    "2311": "\treturn 0;",
                    "2312": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_get_current_offset": {
            "name": "net_pkt_get_current_offset",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2269,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nuint16_t net_pkt_get_current_offset(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf = pkt->buffer;\n\tuint16_t offset;\n\n\tif (!pkt->cursor.buf || !pkt->cursor.pos) {\n\t\treturn 0;\n\t}\n\n\toffset = 0U;\n\n\twhile (buf != pkt->cursor.buf) {\n\t\toffset += buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\toffset += pkt->cursor.pos - buf->data;\n\n\treturn offset;\n}\n",
                {
                    "2269": "uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)",
                    "2270": "{",
                    "2271": "\tstruct net_buf *buf = pkt->buffer;",
                    "2272": "\tuint16_t offset;",
                    "2273": "",
                    "2274": "\tif (!pkt->cursor.buf || !pkt->cursor.pos) {",
                    "2275": "\t\treturn 0;",
                    "2276": "\t}",
                    "2277": "",
                    "2278": "\toffset = 0U;",
                    "2279": "",
                    "2280": "\twhile (buf != pkt->cursor.buf) {",
                    "2281": "\t\toffset += buf->len;",
                    "2282": "\t\tbuf = buf->frags;",
                    "2283": "\t}",
                    "2284": "",
                    "2285": "\toffset += pkt->cursor.pos - buf->data;",
                    "2286": "",
                    "2287": "\treturn offset;",
                    "2288": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_pull": {
            "name": "net_pkt_pull",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2217,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_pull(struct net_pkt *pkt, size_t length)\n{\n\tstruct net_pkt_cursor *c_op = &pkt->cursor;\n\n\twhile (length) {\n\t\tsize_t left, rem;\n\n\t\tpkt_cursor_advance(pkt, false);\n\n\t\tif (!c_op->buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tleft = c_op->buf->len - (c_op->pos - c_op->buf->data);\n\t\tif (!left) {\n\t\t\tbreak;\n\t\t}\n\n\t\trem = left;\n\t\tif (rem > length) {\n\t\t\trem = length;\n\t\t}\n\n\t\tc_op->buf->len -= rem;\n\t\tleft -= rem;\n\t\tif (left) {\n\t\t\tmemmove(c_op->pos, c_op->pos+rem, left);\n\t\t} else {\n\t\t\tstruct net_buf *buf = pkt->buffer;\n\n\t\t\tif (buf) {\n\t\t\t\tpkt->buffer = buf->frags;\n\t\t\t\tbuf->frags = NULL;\n\t\t\t\tnet_buf_unref(buf);\n\t\t\t}\n\n\t\t\tnet_pkt_cursor_init(pkt);\n\t\t}\n\n\t\tlength -= rem;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "2217": "int net_pkt_pull(struct net_pkt *pkt, size_t length)",
                    "2218": "{",
                    "2219": "\tstruct net_pkt_cursor *c_op = &pkt->cursor;",
                    "2220": "",
                    "2221": "\twhile (length) {",
                    "2222": "\t\tsize_t left, rem;",
                    "2223": "",
                    "2224": "\t\tpkt_cursor_advance(pkt, false);",
                    "2225": "",
                    "2226": "\t\tif (!c_op->buf) {",
                    "2227": "\t\t\tbreak;",
                    "2228": "\t\t}",
                    "2229": "",
                    "2230": "\t\tleft = c_op->buf->len - (c_op->pos - c_op->buf->data);",
                    "2231": "\t\tif (!left) {",
                    "2232": "\t\t\tbreak;",
                    "2233": "\t\t}",
                    "2234": "",
                    "2235": "\t\trem = left;",
                    "2236": "\t\tif (rem > length) {",
                    "2237": "\t\t\trem = length;",
                    "2238": "\t\t}",
                    "2239": "",
                    "2240": "\t\tc_op->buf->len -= rem;",
                    "2241": "\t\tleft -= rem;",
                    "2242": "\t\tif (left) {",
                    "2243": "\t\t\tmemmove(c_op->pos, c_op->pos+rem, left);",
                    "2244": "\t\t} else {",
                    "2245": "\t\t\tstruct net_buf *buf = pkt->buffer;",
                    "2246": "",
                    "2247": "\t\t\tif (buf) {",
                    "2248": "\t\t\t\tpkt->buffer = buf->frags;",
                    "2249": "\t\t\t\tbuf->frags = NULL;",
                    "2250": "\t\t\t\tnet_buf_unref(buf);",
                    "2251": "\t\t\t}",
                    "2252": "",
                    "2253": "\t\t\tnet_pkt_cursor_init(pkt);",
                    "2254": "\t\t}",
                    "2255": "",
                    "2256": "\t\tlength -= rem;",
                    "2257": "\t}",
                    "2258": "",
                    "2259": "\tnet_pkt_cursor_init(pkt);",
                    "2260": "",
                    "2261": "\tif (length) {",
                    "2262": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "2263": "\t\treturn -ENOBUFS;",
                    "2264": "\t}",
                    "2265": "",
                    "2266": "\treturn 0;",
                    "2267": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_update_length": {
            "name": "net_pkt_update_length",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2201,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_update_length(struct net_pkt *pkt, size_t length)\n{\n\tstruct net_buf *buf;\n\n\tfor (buf = pkt->buffer; buf; buf = buf->frags) {\n\t\tif (buf->len < length) {\n\t\t\tlength -= buf->len;\n\t\t} else {\n\t\t\tbuf->len = length;\n\t\t\tlength = 0;\n\t\t}\n\t}\n\n\treturn !length ? 0 : -EINVAL;\n}\n",
                {
                    "2201": "int net_pkt_update_length(struct net_pkt *pkt, size_t length)",
                    "2202": "{",
                    "2203": "\tstruct net_buf *buf;",
                    "2204": "",
                    "2205": "\tfor (buf = pkt->buffer; buf; buf = buf->frags) {",
                    "2206": "\t\tif (buf->len < length) {",
                    "2207": "\t\t\tlength -= buf->len;",
                    "2208": "\t\t} else {",
                    "2209": "\t\t\tbuf->len = length;",
                    "2210": "\t\t\tlength = 0;",
                    "2211": "\t\t}",
                    "2212": "\t}",
                    "2213": "",
                    "2214": "\treturn !length ? 0 : -EINVAL;",
                    "2215": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_remaining_data": {
            "name": "net_pkt_remaining_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2180,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nsize_t net_pkt_remaining_data(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf;\n\tsize_t data_length;\n\n\tif (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {\n\t\treturn 0;\n\t}\n\n\tbuf = pkt->cursor.buf;\n\tdata_length = buf->len - (pkt->cursor.pos - buf->data);\n\n\tbuf = buf->frags;\n\twhile (buf) {\n\t\tdata_length += buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\treturn data_length;\n}\n",
                {
                    "2180": "size_t net_pkt_remaining_data(struct net_pkt *pkt)",
                    "2181": "{",
                    "2182": "\tstruct net_buf *buf;",
                    "2183": "\tsize_t data_length;",
                    "2184": "",
                    "2185": "\tif (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {",
                    "2186": "\t\treturn 0;",
                    "2187": "\t}",
                    "2188": "",
                    "2189": "\tbuf = pkt->cursor.buf;",
                    "2190": "\tdata_length = buf->len - (pkt->cursor.pos - buf->data);",
                    "2191": "",
                    "2192": "\tbuf = buf->frags;",
                    "2193": "\twhile (buf) {",
                    "2194": "\t\tdata_length += buf->len;",
                    "2195": "\t\tbuf = buf->frags;",
                    "2196": "\t}",
                    "2197": "",
                    "2198": "\treturn data_length;",
                    "2199": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_shallow_clone": {
            "name": "net_pkt_shallow_clone",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2155,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nstruct net_pkt *net_pkt_shallow_clone(struct net_pkt *pkt, k_timeout_t timeout)\n{\n\tstruct net_pkt *clone_pkt;\n\tstruct net_buf *buf;\n\n\tclone_pkt = net_pkt_alloc(timeout);\n\tif (!clone_pkt) {\n\t\treturn NULL;\n\t}\n\n\tnet_pkt_set_iface(clone_pkt, net_pkt_iface(pkt));\n\tclone_pkt->buffer = pkt->buffer;\n\tbuf = pkt->buffer;\n\n\tnet_pkt_frag_ref(buf);\n\n\tclone_pkt_attributes(pkt, clone_pkt);\n\n\tnet_pkt_cursor_restore(clone_pkt, &pkt->cursor);\n\n\tNET_DBG(\"Shallow cloned %p to %p\", pkt, clone_pkt);\n\n\treturn clone_pkt;\n}\n",
                {
                    "2155": "struct net_pkt *net_pkt_shallow_clone(struct net_pkt *pkt, k_timeout_t timeout)",
                    "2156": "{",
                    "2157": "\tstruct net_pkt *clone_pkt;",
                    "2158": "\tstruct net_buf *buf;",
                    "2159": "",
                    "2160": "\tclone_pkt = net_pkt_alloc(timeout);",
                    "2161": "\tif (!clone_pkt) {",
                    "2162": "\t\treturn NULL;",
                    "2163": "\t}",
                    "2164": "",
                    "2165": "\tnet_pkt_set_iface(clone_pkt, net_pkt_iface(pkt));",
                    "2166": "\tclone_pkt->buffer = pkt->buffer;",
                    "2167": "\tbuf = pkt->buffer;",
                    "2168": "",
                    "2169": "\tnet_pkt_frag_ref(buf);",
                    "2170": "",
                    "2171": "\tclone_pkt_attributes(pkt, clone_pkt);",
                    "2172": "",
                    "2173": "\tnet_pkt_cursor_restore(clone_pkt, &pkt->cursor);",
                    "2174": "",
                    "2175": "\tNET_DBG(\"Shallow cloned %p to %p\", pkt, clone_pkt);",
                    "2176": "",
                    "2177": "\treturn clone_pkt;",
                    "2178": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_copy": {
            "name": "net_pkt_copy",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1966,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_copy(struct net_pkt *pkt_dst,\n\t\t struct net_pkt *pkt_src,\n\t\t size_t length)\n{\n\tstruct net_pkt_cursor *c_dst = &pkt_dst->cursor;\n\tstruct net_pkt_cursor *c_src = &pkt_src->cursor;\n\n\twhile (c_dst->buf && c_src->buf && length) {\n\t\tsize_t s_len, d_len, len;\n\n\t\tpkt_cursor_advance(pkt_dst, true);\n\t\tpkt_cursor_advance(pkt_src, false);\n\n\t\tif (!c_dst->buf || !c_src->buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\ts_len = c_src->buf->len - (c_src->pos - c_src->buf->data);\n\t\td_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);\n\t\tif (length < s_len && length < d_len) {\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tif (d_len < s_len) {\n\t\t\t\tlen = d_len;\n\t\t\t} else {\n\t\t\t\tlen = s_len;\n\t\t\t}\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(c_dst->pos, c_src->pos, len);\n\n\t\tif (!net_pkt_is_being_overwritten(pkt_dst)) {\n\t\t\tnet_buf_add(c_dst->buf, len);\n\t\t}\n\n\t\tpkt_cursor_update(pkt_dst, len, true);\n\t\tpkt_cursor_update(pkt_src, len, false);\n\n\t\tlength -= len;\n\t}\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1966": "int net_pkt_copy(struct net_pkt *pkt_dst,",
                    "1967": "\t\t struct net_pkt *pkt_src,",
                    "1968": "\t\t size_t length)",
                    "1969": "{",
                    "1970": "\tstruct net_pkt_cursor *c_dst = &pkt_dst->cursor;",
                    "1971": "\tstruct net_pkt_cursor *c_src = &pkt_src->cursor;",
                    "1972": "",
                    "1973": "\twhile (c_dst->buf && c_src->buf && length) {",
                    "1974": "\t\tsize_t s_len, d_len, len;",
                    "1975": "",
                    "1976": "\t\tpkt_cursor_advance(pkt_dst, true);",
                    "1977": "\t\tpkt_cursor_advance(pkt_src, false);",
                    "1978": "",
                    "1979": "\t\tif (!c_dst->buf || !c_src->buf) {",
                    "1980": "\t\t\tbreak;",
                    "1981": "\t\t}",
                    "1982": "",
                    "1983": "\t\ts_len = c_src->buf->len - (c_src->pos - c_src->buf->data);",
                    "1984": "\t\td_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);",
                    "1985": "\t\tif (length < s_len && length < d_len) {",
                    "1986": "\t\t\tlen = length;",
                    "1987": "\t\t} else {",
                    "1988": "\t\t\tif (d_len < s_len) {",
                    "1989": "\t\t\t\tlen = d_len;",
                    "1990": "\t\t\t} else {",
                    "1991": "\t\t\t\tlen = s_len;",
                    "1992": "\t\t\t}",
                    "1993": "\t\t}",
                    "1994": "",
                    "1995": "\t\tif (!len) {",
                    "1996": "\t\t\tbreak;",
                    "1997": "\t\t}",
                    "1998": "",
                    "1999": "\t\tmemcpy(c_dst->pos, c_src->pos, len);",
                    "2000": "",
                    "2001": "\t\tif (!net_pkt_is_being_overwritten(pkt_dst)) {",
                    "2002": "\t\t\tnet_buf_add(c_dst->buf, len);",
                    "2003": "\t\t}",
                    "2004": "",
                    "2005": "\t\tpkt_cursor_update(pkt_dst, len, true);",
                    "2006": "\t\tpkt_cursor_update(pkt_src, len, false);",
                    "2007": "",
                    "2008": "\t\tlength -= len;",
                    "2009": "\t}",
                    "2010": "",
                    "2011": "\tif (length) {",
                    "2012": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "2013": "\t\treturn -ENOBUFS;",
                    "2014": "\t}",
                    "2015": "",
                    "2016": "\treturn 0;",
                    "2017": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_cursor_init": {
            "name": "net_pkt_cursor_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1766,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nvoid net_pkt_cursor_init(struct net_pkt *pkt)\n{\n\tpkt->cursor.buf = pkt->buffer;\n\tif (pkt->cursor.buf) {\n\t\tpkt->cursor.pos = pkt->cursor.buf->data;\n\t} else {\n\t\tpkt->cursor.pos = NULL;\n\t}\n}\n",
                {
                    "1766": "void net_pkt_cursor_init(struct net_pkt *pkt)",
                    "1767": "{",
                    "1768": "\tpkt->cursor.buf = pkt->buffer;",
                    "1769": "\tif (pkt->cursor.buf) {",
                    "1770": "\t\tpkt->cursor.pos = pkt->cursor.buf->data;",
                    "1771": "\t} else {",
                    "1772": "\t\tpkt->cursor.pos = NULL;",
                    "1773": "\t}",
                    "1774": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_remove_tail": {
            "name": "net_pkt_remove_tail",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1224,
            "function_content": [
                "/* + protocol header */\nint net_pkt_remove_tail(struct net_pkt *pkt, size_t length)\n{\n\tstruct net_buf *buf = pkt->buffer;\n\tsize_t remaining_len = net_pkt_get_len(pkt);\n\n\tif (remaining_len < length) {\n\t\treturn -EINVAL;\n\t}\n\n\tremaining_len -= length;\n\n\twhile (buf) {\n\t\tif (buf->len >= remaining_len) {\n\t\t\tbuf->len = remaining_len;\n\n\t\t\tif (buf->frags) {\n\t\t\t\tnet_pkt_frag_unref(buf->frags);\n\t\t\t\tbuf->frags = NULL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tremaining_len -= buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1224": "int net_pkt_remove_tail(struct net_pkt *pkt, size_t length)",
                    "1225": "{",
                    "1226": "\tstruct net_buf *buf = pkt->buffer;",
                    "1227": "\tsize_t remaining_len = net_pkt_get_len(pkt);",
                    "1228": "",
                    "1229": "\tif (remaining_len < length) {",
                    "1230": "\t\treturn -EINVAL;",
                    "1231": "\t}",
                    "1232": "",
                    "1233": "\tremaining_len -= length;",
                    "1234": "",
                    "1235": "\twhile (buf) {",
                    "1236": "\t\tif (buf->len >= remaining_len) {",
                    "1237": "\t\t\tbuf->len = remaining_len;",
                    "1238": "",
                    "1239": "\t\t\tif (buf->frags) {",
                    "1240": "\t\t\t\tnet_pkt_frag_unref(buf->frags);",
                    "1241": "\t\t\t\tbuf->frags = NULL;",
                    "1242": "\t\t\t}",
                    "1243": "",
                    "1244": "\t\t\tbreak;",
                    "1245": "\t\t}",
                    "1246": "",
                    "1247": "\t\tremaining_len -= buf->len;",
                    "1248": "\t\tbuf = buf->frags;",
                    "1249": "\t}",
                    "1250": "",
                    "1251": "\treturn 0;",
                    "1252": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_trim_buffer": {
            "name": "net_pkt_trim_buffer",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1197,
            "function_content": [
                "/* + protocol header */\nvoid net_pkt_trim_buffer(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf, *prev;\n\n\tbuf = pkt->buffer;\n\tprev = buf;\n\n\twhile (buf) {\n\t\tstruct net_buf *next = buf->frags;\n\n\t\tif (!buf->len) {\n\t\t\tif (buf == pkt->buffer) {\n\t\t\t\tpkt->buffer = next;\n\t\t\t} else if (buf == prev->frags) {\n\t\t\t\tprev->frags = next;\n\t\t\t}\n\n\t\t\tbuf->frags = NULL;\n\t\t\tnet_buf_unref(buf);\n\t\t} else {\n\t\t\tprev = buf;\n\t\t}\n\n\t\tbuf = next;\n\t}\n}\n",
                {
                    "1197": "void net_pkt_trim_buffer(struct net_pkt *pkt)",
                    "1198": "{",
                    "1199": "\tstruct net_buf *buf, *prev;",
                    "1200": "",
                    "1201": "\tbuf = pkt->buffer;",
                    "1202": "\tprev = buf;",
                    "1203": "",
                    "1204": "\twhile (buf) {",
                    "1205": "\t\tstruct net_buf *next = buf->frags;",
                    "1206": "",
                    "1207": "\t\tif (!buf->len) {",
                    "1208": "\t\t\tif (buf == pkt->buffer) {",
                    "1209": "\t\t\t\tpkt->buffer = next;",
                    "1210": "\t\t\t} else if (buf == prev->frags) {",
                    "1211": "\t\t\t\tprev->frags = next;",
                    "1212": "\t\t\t}",
                    "1213": "",
                    "1214": "\t\t\tbuf->frags = NULL;",
                    "1215": "\t\t\tnet_buf_unref(buf);",
                    "1216": "\t\t} else {",
                    "1217": "\t\t\tprev = buf;",
                    "1218": "\t\t}",
                    "1219": "",
                    "1220": "\t\tbuf = next;",
                    "1221": "\t}",
                    "1222": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_available_payload_buffer": {
            "name": "net_pkt_available_payload_buffer",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1177,
            "function_content": [
                "/* + protocol header */\nsize_t net_pkt_available_payload_buffer(struct net_pkt *pkt,\n\t\t\t\t\tenum net_ip_protocol proto)\n{\n\tsize_t hdr_len = 0;\n\tsize_t len;\n\n\tif (!pkt) {\n\t\treturn 0;\n\t}\n\n\thdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);\n\tlen = net_pkt_get_len(pkt);\n\n\thdr_len = hdr_len <= len ? 0 : hdr_len - len;\n\n\tlen = net_pkt_available_buffer(pkt) - hdr_len;\n\n\treturn len;\n}\n",
                {
                    "1177": "size_t net_pkt_available_payload_buffer(struct net_pkt *pkt,",
                    "1178": "\t\t\t\t\tenum net_ip_protocol proto)",
                    "1179": "{",
                    "1180": "\tsize_t hdr_len = 0;",
                    "1181": "\tsize_t len;",
                    "1182": "",
                    "1183": "\tif (!pkt) {",
                    "1184": "\t\treturn 0;",
                    "1185": "\t}",
                    "1186": "",
                    "1187": "\thdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);",
                    "1188": "\tlen = net_pkt_get_len(pkt);",
                    "1189": "",
                    "1190": "\thdr_len = hdr_len <= len ? 0 : hdr_len - len;",
                    "1191": "",
                    "1192": "\tlen = net_pkt_available_buffer(pkt) - hdr_len;",
                    "1193": "",
                    "1194": "\treturn len;",
                    "1195": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_available_buffer": {
            "name": "net_pkt_available_buffer",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1168,
            "function_content": [
                "/* + protocol header */\nsize_t net_pkt_available_buffer(struct net_pkt *pkt)\n{\n\tif (!pkt) {\n\t\treturn 0;\n\t}\n\n\treturn pkt_get_max_len(pkt) - net_pkt_get_len(pkt);\n}\n",
                {
                    "1168": "size_t net_pkt_available_buffer(struct net_pkt *pkt)",
                    "1169": "{",
                    "1170": "\tif (!pkt) {",
                    "1171": "\t\treturn 0;",
                    "1172": "\t}",
                    "1173": "",
                    "1174": "\treturn pkt_get_max_len(pkt) - net_pkt_get_len(pkt);",
                    "1175": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_append_buffer": {
            "name": "net_pkt_append_buffer",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1756,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nvoid net_pkt_append_buffer(struct net_pkt *pkt, struct net_buf *buffer)\n{\n\tif (!pkt->buffer) {\n\t\tpkt->buffer = buffer;\n\t\tnet_pkt_cursor_init(pkt);\n\t} else {\n\t\tnet_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);\n\t}\n}\n",
                {
                    "1756": "void net_pkt_append_buffer(struct net_pkt *pkt, struct net_buf *buffer)",
                    "1757": "{",
                    "1758": "\tif (!pkt->buffer) {",
                    "1759": "\t\tpkt->buffer = buffer;",
                    "1760": "\t\tnet_pkt_cursor_init(pkt);",
                    "1761": "\t} else {",
                    "1762": "\t\tnet_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);",
                    "1763": "\t}",
                    "1764": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_alloc_buffer_raw": {
            "name": "net_pkt_alloc_buffer_raw",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1411,
            "function_content": [
                "/* Hide the link layer header for now. The space is used when\n* link layer header needs to be written to the packet by L2 send.\n*/\nint net_pkt_alloc_buffer_raw(struct net_pkt *pkt, size_t size,\n\t\t\t     k_timeout_t timeout)\n#endif\n{\n\tstruct net_buf_pool *pool = NULL;\n\tstruct net_buf *buf;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tNET_DBG(\"Data allocation size %zu\", size);\n\n\tif (pkt->context) {\n\t\tpool = get_data_pool(pkt->context);\n\t}\n\n\tif (!pool) {\n\t\tpool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;\n\t}\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tbuf = pkt_alloc_buffer(pkt, pool, size, 0U, timeout, caller, line);\n#else\n\tbuf = pkt_alloc_buffer(pkt, pool, size, 0U, timeout);\n#endif\n\n\tif (!buf) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_ERR(\"Data buffer (%zd) allocation failed (%s:%d)\",\n\t\t\tsize, caller, line);\n#else\n\t\tNET_ERR(\"Data buffer (%zd) allocation failed.\", size);\n#endif\n\t\treturn -ENOMEM;\n\t}\n\n\tnet_pkt_append_buffer(pkt, buf);\n\n#if defined(CONFIG_NET_BUF_FIXED_DATA_SIZE)\n\t/* net_buf allocators shrink the buffer size to the requested size.\n\t * We don't want this behavior here, so restore the real size of the\n\t * last fragment.\n\t */\n\tbuf = net_buf_frag_last(buf);\n\tbuf->size = CONFIG_NET_BUF_DATA_SIZE;\n#endif\n\n\treturn 0;\n}\n",
                {
                    "1411": "int net_pkt_alloc_buffer_raw(struct net_pkt *pkt, size_t size,",
                    "1412": "\t\t\t     k_timeout_t timeout)",
                    "1413": "#endif",
                    "1414": "{",
                    "1415": "\tstruct net_buf_pool *pool = NULL;",
                    "1416": "\tstruct net_buf *buf;",
                    "1417": "",
                    "1418": "\tif (size == 0) {",
                    "1419": "\t\treturn 0;",
                    "1420": "\t}",
                    "1421": "",
                    "1422": "\tif (k_is_in_isr()) {",
                    "1423": "\t\ttimeout = K_NO_WAIT;",
                    "1424": "\t}",
                    "1425": "",
                    "1426": "\tNET_DBG(\"Data allocation size %zu\", size);",
                    "1427": "",
                    "1428": "\tif (pkt->context) {",
                    "1429": "\t\tpool = get_data_pool(pkt->context);",
                    "1430": "\t}",
                    "1431": "",
                    "1432": "\tif (!pool) {",
                    "1433": "\t\tpool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;",
                    "1434": "\t}",
                    "1435": "",
                    "1436": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "1437": "\tbuf = pkt_alloc_buffer(pkt, pool, size, 0U, timeout, caller, line);",
                    "1438": "#else",
                    "1439": "\tbuf = pkt_alloc_buffer(pkt, pool, size, 0U, timeout);",
                    "1440": "#endif",
                    "1441": "",
                    "1442": "\tif (!buf) {",
                    "1443": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "1444": "\t\tNET_ERR(\"Data buffer (%zd) allocation failed (%s:%d)\",",
                    "1445": "\t\t\tsize, caller, line);",
                    "1446": "#else",
                    "1447": "\t\tNET_ERR(\"Data buffer (%zd) allocation failed.\", size);",
                    "1448": "#endif",
                    "1449": "\t\treturn -ENOMEM;",
                    "1450": "\t}",
                    "1451": "",
                    "1452": "\tnet_pkt_append_buffer(pkt, buf);",
                    "1453": "",
                    "1454": "#if defined(CONFIG_NET_BUF_FIXED_DATA_SIZE)",
                    "1455": "\t/* net_buf allocators shrink the buffer size to the requested size.",
                    "1456": "\t * We don't want this behavior here, so restore the real size of the",
                    "1457": "\t * last fragment.",
                    "1458": "\t */",
                    "1459": "\tbuf = net_buf_frag_last(buf);",
                    "1460": "\tbuf->size = CONFIG_NET_BUF_DATA_SIZE;",
                    "1461": "#endif",
                    "1462": "",
                    "1463": "\treturn 0;",
                    "1464": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_alloc_buffer_with_reserve": {
            "name": "net_pkt_alloc_buffer_with_reserve",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1263,
            "function_content": [
                "/* + protocol header */\nint net_pkt_alloc_buffer_with_reserve(struct net_pkt *pkt,\n\t\t\t\t      size_t size,\n\t\t\t\t      size_t reserve,\n\t\t\t\t      enum net_ip_protocol proto,\n\t\t\t\t      k_timeout_t timeout)\n#endif\n{\n\tstruct net_buf_pool *pool = NULL;\n\tsize_t alloc_len = 0;\n\tsize_t hdr_len = 0;\n\tstruct net_buf *buf;\n\n\tif (!size && proto == 0 && net_pkt_family(pkt) == NET_AF_UNSPEC) {\n\t\treturn 0;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\t/* Verifying existing buffer and take into account free space there */\n\talloc_len = net_pkt_available_buffer(pkt);\n\tif (!alloc_len) {\n\t\t/* In case of no free space, it will account for header\n\t\t * space estimation\n\t\t */\n\t\thdr_len = pkt_estimate_headers_length(pkt,\n\t\t\t\t\t\t      net_pkt_family(pkt),\n\t\t\t\t\t\t      proto);\n\t}\n\n\t/* Calculate the maximum that can be allocated depending on size */\n\talloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);\n\n\tNET_DBG(\"Data allocation maximum size %zu (requested %zu, reserve %zu)\",\n\t\talloc_len, size, reserve);\n\n\tif (pkt->context) {\n\t\tpool = get_data_pool(pkt->context);\n\t}\n\n\tif (!pool) {\n\t\tpool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;\n\t}\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tbuf = pkt_alloc_buffer(pkt, pool, alloc_len, reserve,\n\t\t\t       timeout, caller, line);\n#else\n\tbuf = pkt_alloc_buffer(pkt, pool, alloc_len, reserve, timeout);\n#endif\n\n\tif (!buf) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_ERR(\"Data buffer (%zu) allocation failed (%s:%d)\",\n\t\t\talloc_len + reserve, caller, line);\n#else\n\t\tNET_ERR(\"Data buffer (%zu) allocation failed.\",\n\t\t\talloc_len + reserve);\n#endif\n\t\treturn -ENOMEM;\n\t}\n\n\tnet_pkt_append_buffer(pkt, buf);\n\n\t/* Hide the link layer header for now. The space is used when\n\t * link layer header needs to be written to the packet by L2 send.\n\t */\n\tif (reserve > 0U) {\n\t\tNET_DBG(\"Reserving %zu bytes for L2 header\", reserve);\n\n\t\tnet_buf_reserve(pkt->buffer, reserve);\n\n\t\tnet_pkt_cursor_init(pkt);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1263": "int net_pkt_alloc_buffer_with_reserve(struct net_pkt *pkt,",
                    "1264": "\t\t\t\t      size_t size,",
                    "1265": "\t\t\t\t      size_t reserve,",
                    "1266": "\t\t\t\t      enum net_ip_protocol proto,",
                    "1267": "\t\t\t\t      k_timeout_t timeout)",
                    "1268": "#endif",
                    "1269": "{",
                    "1270": "\tstruct net_buf_pool *pool = NULL;",
                    "1271": "\tsize_t alloc_len = 0;",
                    "1272": "\tsize_t hdr_len = 0;",
                    "1273": "\tstruct net_buf *buf;",
                    "1274": "",
                    "1275": "\tif (!size && proto == 0 && net_pkt_family(pkt) == NET_AF_UNSPEC) {",
                    "1276": "\t\treturn 0;",
                    "1277": "\t}",
                    "1278": "",
                    "1279": "\tif (k_is_in_isr()) {",
                    "1280": "\t\ttimeout = K_NO_WAIT;",
                    "1281": "\t}",
                    "1282": "",
                    "1283": "\t/* Verifying existing buffer and take into account free space there */",
                    "1284": "\talloc_len = net_pkt_available_buffer(pkt);",
                    "1285": "\tif (!alloc_len) {",
                    "1286": "\t\t/* In case of no free space, it will account for header",
                    "1287": "\t\t * space estimation",
                    "1288": "\t\t */",
                    "1289": "\t\thdr_len = pkt_estimate_headers_length(pkt,",
                    "1290": "\t\t\t\t\t\t      net_pkt_family(pkt),",
                    "1291": "\t\t\t\t\t\t      proto);",
                    "1292": "\t}",
                    "1293": "",
                    "1294": "\t/* Calculate the maximum that can be allocated depending on size */",
                    "1295": "\talloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);",
                    "1296": "",
                    "1297": "\tNET_DBG(\"Data allocation maximum size %zu (requested %zu, reserve %zu)\",",
                    "1298": "\t\talloc_len, size, reserve);",
                    "1299": "",
                    "1300": "\tif (pkt->context) {",
                    "1301": "\t\tpool = get_data_pool(pkt->context);",
                    "1302": "\t}",
                    "1303": "",
                    "1304": "\tif (!pool) {",
                    "1305": "\t\tpool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;",
                    "1306": "\t}",
                    "1307": "",
                    "1308": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "1309": "\tbuf = pkt_alloc_buffer(pkt, pool, alloc_len, reserve,",
                    "1310": "\t\t\t       timeout, caller, line);",
                    "1311": "#else",
                    "1312": "\tbuf = pkt_alloc_buffer(pkt, pool, alloc_len, reserve, timeout);",
                    "1313": "#endif",
                    "1314": "",
                    "1315": "\tif (!buf) {",
                    "1316": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "1317": "\t\tNET_ERR(\"Data buffer (%zu) allocation failed (%s:%d)\",",
                    "1318": "\t\t\talloc_len + reserve, caller, line);",
                    "1319": "#else",
                    "1320": "\t\tNET_ERR(\"Data buffer (%zu) allocation failed.\",",
                    "1321": "\t\t\talloc_len + reserve);",
                    "1322": "#endif",
                    "1323": "\t\treturn -ENOMEM;",
                    "1324": "\t}",
                    "1325": "",
                    "1326": "\tnet_pkt_append_buffer(pkt, buf);",
                    "1327": "",
                    "1328": "\t/* Hide the link layer header for now. The space is used when",
                    "1329": "\t * link layer header needs to be written to the packet by L2 send.",
                    "1330": "\t */",
                    "1331": "\tif (reserve > 0U) {",
                    "1332": "\t\tNET_DBG(\"Reserving %zu bytes for L2 header\", reserve);",
                    "1333": "",
                    "1334": "\t\tnet_buf_reserve(pkt->buffer, reserve);",
                    "1335": "",
                    "1336": "\t\tnet_pkt_cursor_init(pkt);",
                    "1337": "\t}",
                    "1338": "",
                    "1339": "\treturn 0;",
                    "1340": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_compact": {
            "name": "net_pkt_compact",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 780,
            "function_content": [
                "/* We do not use net_buf_frag_add() as this one will refcount\n* the frag once more if !pkt->frags\n*/\nvoid net_pkt_compact(struct net_pkt *pkt)\n{\n\tstruct net_buf *frag, *prev;\n\n\tNET_DBG(\"Compacting data in pkt %p\", pkt);\n\n\tfrag = pkt->frags;\n\tprev = NULL;\n\n\twhile (frag) {\n\t\tif (frag->frags) {\n\t\t\t/* Copy amount of data from next fragment to this\n\t\t\t * fragment.\n\t\t\t */\n\t\t\tsize_t copy_len;\n\n\t\t\tcopy_len = frag->frags->len;\n\t\t\tif (copy_len > net_buf_tailroom(frag)) {\n\t\t\t\tcopy_len = net_buf_tailroom(frag);\n\t\t\t}\n\n\t\t\tmemcpy(net_buf_tail(frag), frag->frags->data, copy_len);\n\t\t\tnet_buf_add(frag, copy_len);\n\n\t\t\tmemmove(frag->frags->data,\n\t\t\t\tfrag->frags->data + copy_len,\n\t\t\t\tfrag->frags->len - copy_len);\n\n\t\t\tfrag->frags->len -= copy_len;\n\n\t\t\t/* Is there any more space in this fragment */\n\t\t\tif (net_buf_tailroom(frag)) {\n\t\t\t\t/* There is. This also means that the next\n\t\t\t\t * fragment is empty as otherwise we could\n\t\t\t\t * not have copied all data. Remove next\n\t\t\t\t * fragment as there is no data in it any more.\n\t\t\t\t */\n\t\t\t\tnet_pkt_frag_del(pkt, frag, frag->frags);\n\n\t\t\t\t/* Then check next fragment */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!frag->len) {\n\t\t\t\t/* Remove the last fragment because there is no\n\t\t\t\t * data in it.\n\t\t\t\t */\n\t\t\t\tnet_pkt_frag_del(pkt, prev, frag);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprev = frag;\n\t\tfrag = frag->frags;\n\t}\n}\n",
                {
                    "780": "void net_pkt_compact(struct net_pkt *pkt)",
                    "781": "{",
                    "782": "\tstruct net_buf *frag, *prev;",
                    "783": "",
                    "784": "\tNET_DBG(\"Compacting data in pkt %p\", pkt);",
                    "785": "",
                    "786": "\tfrag = pkt->frags;",
                    "787": "\tprev = NULL;",
                    "788": "",
                    "789": "\twhile (frag) {",
                    "790": "\t\tif (frag->frags) {",
                    "791": "\t\t\t/* Copy amount of data from next fragment to this",
                    "792": "\t\t\t * fragment.",
                    "793": "\t\t\t */",
                    "794": "\t\t\tsize_t copy_len;",
                    "795": "",
                    "796": "\t\t\tcopy_len = frag->frags->len;",
                    "797": "\t\t\tif (copy_len > net_buf_tailroom(frag)) {",
                    "798": "\t\t\t\tcopy_len = net_buf_tailroom(frag);",
                    "799": "\t\t\t}",
                    "800": "",
                    "801": "\t\t\tmemcpy(net_buf_tail(frag), frag->frags->data, copy_len);",
                    "802": "\t\t\tnet_buf_add(frag, copy_len);",
                    "803": "",
                    "804": "\t\t\tmemmove(frag->frags->data,",
                    "805": "\t\t\t\tfrag->frags->data + copy_len,",
                    "806": "\t\t\t\tfrag->frags->len - copy_len);",
                    "807": "",
                    "808": "\t\t\tfrag->frags->len -= copy_len;",
                    "809": "",
                    "810": "\t\t\t/* Is there any more space in this fragment */",
                    "811": "\t\t\tif (net_buf_tailroom(frag)) {",
                    "812": "\t\t\t\t/* There is. This also means that the next",
                    "813": "\t\t\t\t * fragment is empty as otherwise we could",
                    "814": "\t\t\t\t * not have copied all data. Remove next",
                    "815": "\t\t\t\t * fragment as there is no data in it any more.",
                    "816": "\t\t\t\t */",
                    "817": "\t\t\t\tnet_pkt_frag_del(pkt, frag, frag->frags);",
                    "818": "",
                    "819": "\t\t\t\t/* Then check next fragment */",
                    "820": "\t\t\t\tcontinue;",
                    "821": "\t\t\t}",
                    "822": "\t\t} else {",
                    "823": "\t\t\tif (!frag->len) {",
                    "824": "\t\t\t\t/* Remove the last fragment because there is no",
                    "825": "\t\t\t\t * data in it.",
                    "826": "\t\t\t\t */",
                    "827": "\t\t\t\tnet_pkt_frag_del(pkt, prev, frag);",
                    "828": "",
                    "829": "\t\t\t\tbreak;",
                    "830": "\t\t\t}",
                    "831": "\t\t}",
                    "832": "",
                    "833": "\t\tprev = frag;",
                    "834": "\t\tfrag = frag->frags;",
                    "835": "\t}",
                    "836": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_frag_insert": {
            "name": "net_pkt_frag_insert",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 769,
            "function_content": [
                "/* We do not use net_buf_frag_add() as this one will refcount\n* the frag once more if !pkt->frags\n*/\nvoid net_pkt_frag_insert(struct net_pkt *pkt, struct net_buf *frag)\n#endif\n{\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"pkt %p frag %p (%s:%d)\", pkt, frag, caller, line);\n#endif\n\n\tnet_buf_frag_last(frag)->frags = pkt->frags;\n\tpkt->frags = frag;\n}\n",
                {
                    "769": "void net_pkt_frag_insert(struct net_pkt *pkt, struct net_buf *frag)",
                    "770": "#endif",
                    "771": "{",
                    "772": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "773": "\tNET_DBG(\"pkt %p frag %p (%s:%d)\", pkt, frag, caller, line);",
                    "774": "#endif",
                    "775": "",
                    "776": "\tnet_buf_frag_last(frag)->frags = pkt->frags;",
                    "777": "\tpkt->frags = frag;",
                    "778": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_frag_add": {
            "name": "net_pkt_frag_add",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 747,
            "function_content": [
                "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\nvoid net_pkt_frag_add(struct net_pkt *pkt, struct net_buf *frag)\n#endif\n{\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"pkt %p frag %p (%s:%d)\", pkt, frag, caller, line);\n#endif\n\n\t/* We do not use net_buf_frag_add() as this one will refcount\n\t * the frag once more if !pkt->frags\n\t */\n\tif (!pkt->frags) {\n\t\tpkt->frags = frag;\n\t\treturn;\n\t}\n\n\tnet_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);\n}\n",
                {
                    "747": "void net_pkt_frag_add(struct net_pkt *pkt, struct net_buf *frag)",
                    "748": "#endif",
                    "749": "{",
                    "750": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "751": "\tNET_DBG(\"pkt %p frag %p (%s:%d)\", pkt, frag, caller, line);",
                    "752": "#endif",
                    "753": "",
                    "754": "\t/* We do not use net_buf_frag_add() as this one will refcount",
                    "755": "\t * the frag once more if !pkt->frags",
                    "756": "\t */",
                    "757": "\tif (!pkt->frags) {",
                    "758": "\t\tpkt->frags = frag;",
                    "759": "\t\treturn;",
                    "760": "\t}",
                    "761": "",
                    "762": "\tnet_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);",
                    "763": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_frag_del": {
            "name": "net_pkt_frag_del",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 713,
            "function_content": [
                "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\nstruct net_buf *net_pkt_frag_del(struct net_pkt *pkt,\n\t\t\t\t struct net_buf *parent,\n\t\t\t\t struct net_buf *frag)\n#endif\n{\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"pkt %p parent %p frag %p ref %u (%s:%d)\",\n\t\tpkt, parent, frag, frag->ref, caller, line);\n#endif\n\n\tif (pkt->frags == frag && !parent) {\n\t\tstruct net_buf *tmp;\n\n\t\tif (frag->ref == 1U) {\n\t\t\tnet_pkt_alloc_del(frag, caller, line);\n\t\t}\n\n\t\ttmp = net_buf_frag_del(NULL, frag);\n\t\tpkt->frags = tmp;\n\n\t\treturn tmp;\n\t}\n\n\tif (frag->ref == 1U) {\n\t\tnet_pkt_alloc_del(frag, caller, line);\n\t}\n\n\treturn net_buf_frag_del(parent, frag);\n}\n",
                {
                    "713": "struct net_buf *net_pkt_frag_del(struct net_pkt *pkt,",
                    "714": "\t\t\t\t struct net_buf *parent,",
                    "715": "\t\t\t\t struct net_buf *frag)",
                    "716": "#endif",
                    "717": "{",
                    "718": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "719": "\tNET_DBG(\"pkt %p parent %p frag %p ref %u (%s:%d)\",",
                    "720": "\t\tpkt, parent, frag, frag->ref, caller, line);",
                    "721": "#endif",
                    "722": "",
                    "723": "\tif (pkt->frags == frag && !parent) {",
                    "724": "\t\tstruct net_buf *tmp;",
                    "725": "",
                    "726": "\t\tif (frag->ref == 1U) {",
                    "727": "\t\t\tnet_pkt_alloc_del(frag, caller, line);",
                    "728": "\t\t}",
                    "729": "",
                    "730": "\t\ttmp = net_buf_frag_del(NULL, frag);",
                    "731": "\t\tpkt->frags = tmp;",
                    "732": "",
                    "733": "\t\treturn tmp;",
                    "734": "\t}",
                    "735": "",
                    "736": "\tif (frag->ref == 1U) {",
                    "737": "\t\tnet_pkt_alloc_del(frag, caller, line);",
                    "738": "\t}",
                    "739": "",
                    "740": "\treturn net_buf_frag_del(parent, frag);",
                    "741": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_unref": {
            "name": "net_pkt_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 527,
            "function_content": [
                "#endif /* CONFIG_NET_CONTEXT_NET_PKT_POOL */\nvoid net_pkt_unref(struct net_pkt *pkt)\n{\n#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\n\tatomic_val_t ref;\n\n\tif (!pkt) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_ERR(\"*** ERROR *** pkt %p (%s():%d)\", pkt, caller, line);\n#endif\n\t\treturn;\n\t}\n\n\tdo {\n\t\tref = atomic_get(&pkt->atomic_ref);\n\t\tif (!ref) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\t\tconst char *func_freed;\n\t\t\tint line_freed;\n\n\t\t\tif (net_pkt_alloc_find(pkt, &func_freed, &line_freed)) {\n\t\t\t\tNET_ERR(\"*** ERROR *** pkt %p is freed already \"\n\t\t\t\t\t\"by %s():%d (%s():%d)\",\n\t\t\t\t\tpkt, func_freed, line_freed, caller,\n\t\t\t\t\tline);\n\t\t\t} else {\n\t\t\t\tNET_ERR(\"*** ERROR *** pkt %p is freed already \"\n\t\t\t\t\t\"(%s():%d)\", pkt, caller, line);\n\t\t\t}\n#endif\n\t\t\treturn;\n\t\t}\n\t} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"%s [%d] pkt %p ref %ld frags %p (%s():%d)\",\n\t\tslab2str(pkt->slab), k_mem_slab_num_free_get(pkt->slab),\n\t\tpkt, ref - 1, pkt->frags, caller, line);\n#endif\n\tif (ref > 1) {\n\t\tgoto done;\n\t}\n\n\tfrag = pkt->frags;\n\twhile (frag) {\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_DBG(\"%s (%s) [%d] frag %p ref %d frags %p (%s():%d)\",\n\t\t\tpool2str(net_buf_pool_get(frag->pool_id)),\n\t\t\tget_name(net_buf_pool_get(frag->pool_id)),\n\t\t\tget_frees(net_buf_pool_get(frag->pool_id)), frag,\n\t\t\tfrag->ref - 1U, frag->frags, caller, line);\n#endif\n\n\t\tif (!frag->ref) {\n\t\t\tconst char *func_freed;\n\t\t\tint line_freed;\n\n\t\t\tif (net_pkt_alloc_find(frag,\n\t\t\t\t\t       &func_freed, &line_freed)) {\n\t\t\t\tNET_ERR(\"*** ERROR *** frag %p is freed \"\n\t\t\t\t\t\"already by %s():%d (%s():%d)\",\n\t\t\t\t\tfrag, func_freed, line_freed,\n\t\t\t\t\tcaller, line);\n\t\t\t} else {\n\t\t\t\tNET_ERR(\"*** ERROR *** frag %p is freed \"\n\t\t\t\t\t\"already (%s():%d)\",\n\t\t\t\t\tfrag, caller, line);\n\t\t\t}\n\t\t}\n\n\t\tnet_pkt_alloc_del(frag, caller, line);\n\n\t\tfrag = frag->frags;\n\t}\n\n\tnet_pkt_alloc_del(pkt, caller, line);\ndone:\n#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\n\n\tif (ref > 1) {\n\t\treturn;\n\t}\n\n\tif (pkt->frags) {\n\t\tnet_pkt_frag_unref(pkt->frags);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_DEBUG_NET_PKT_NON_FRAGILE_ACCESS)) {\n\t\tpkt->buffer = NULL;\n\t\tnet_pkt_cursor_init(pkt);\n\t}\n\n\tk_mem_slab_free(pkt->slab, (void *)pkt);\n}\n",
                {
                    "527": "void net_pkt_unref(struct net_pkt *pkt)",
                    "528": "{",
                    "529": "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */",
                    "530": "\tatomic_val_t ref;",
                    "531": "",
                    "532": "\tif (!pkt) {",
                    "533": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "534": "\t\tNET_ERR(\"*** ERROR *** pkt %p (%s():%d)\", pkt, caller, line);",
                    "535": "#endif",
                    "536": "\t\treturn;",
                    "537": "\t}",
                    "538": "",
                    "539": "\tdo {",
                    "540": "\t\tref = atomic_get(&pkt->atomic_ref);",
                    "541": "\t\tif (!ref) {",
                    "542": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "543": "\t\t\tconst char *func_freed;",
                    "544": "\t\t\tint line_freed;",
                    "545": "",
                    "546": "\t\t\tif (net_pkt_alloc_find(pkt, &func_freed, &line_freed)) {",
                    "547": "\t\t\t\tNET_ERR(\"*** ERROR *** pkt %p is freed already \"",
                    "548": "\t\t\t\t\t\"by %s():%d (%s():%d)\",",
                    "549": "\t\t\t\t\tpkt, func_freed, line_freed, caller,",
                    "550": "\t\t\t\t\tline);",
                    "551": "\t\t\t} else {",
                    "552": "\t\t\t\tNET_ERR(\"*** ERROR *** pkt %p is freed already \"",
                    "553": "\t\t\t\t\t\"(%s():%d)\", pkt, caller, line);",
                    "554": "\t\t\t}",
                    "555": "#endif",
                    "556": "\t\t\treturn;",
                    "557": "\t\t}",
                    "558": "\t} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));",
                    "559": "",
                    "560": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "561": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "562": "\tNET_DBG(\"%s [%d] pkt %p ref %ld frags %p (%s():%d)\",",
                    "563": "\t\tslab2str(pkt->slab), k_mem_slab_num_free_get(pkt->slab),",
                    "564": "\t\tpkt, ref - 1, pkt->frags, caller, line);",
                    "565": "#endif",
                    "566": "\tif (ref > 1) {",
                    "567": "\t\tgoto done;",
                    "568": "\t}",
                    "569": "",
                    "570": "\tfrag = pkt->frags;",
                    "571": "\twhile (frag) {",
                    "572": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "573": "\t\tNET_DBG(\"%s (%s) [%d] frag %p ref %d frags %p (%s():%d)\",",
                    "574": "\t\t\tpool2str(net_buf_pool_get(frag->pool_id)),",
                    "575": "\t\t\tget_name(net_buf_pool_get(frag->pool_id)),",
                    "576": "\t\t\tget_frees(net_buf_pool_get(frag->pool_id)), frag,",
                    "577": "\t\t\tfrag->ref - 1U, frag->frags, caller, line);",
                    "578": "#endif",
                    "579": "",
                    "580": "\t\tif (!frag->ref) {",
                    "581": "\t\t\tconst char *func_freed;",
                    "582": "\t\t\tint line_freed;",
                    "583": "",
                    "584": "\t\t\tif (net_pkt_alloc_find(frag,",
                    "585": "\t\t\t\t\t       &func_freed, &line_freed)) {",
                    "586": "\t\t\t\tNET_ERR(\"*** ERROR *** frag %p is freed \"",
                    "587": "\t\t\t\t\t\"already by %s():%d (%s():%d)\",",
                    "588": "\t\t\t\t\tfrag, func_freed, line_freed,",
                    "589": "\t\t\t\t\tcaller, line);",
                    "590": "\t\t\t} else {",
                    "591": "\t\t\t\tNET_ERR(\"*** ERROR *** frag %p is freed \"",
                    "592": "\t\t\t\t\t\"already (%s():%d)\",",
                    "593": "\t\t\t\t\tfrag, caller, line);",
                    "594": "\t\t\t}",
                    "595": "\t\t}",
                    "596": "",
                    "597": "\t\tnet_pkt_alloc_del(frag, caller, line);",
                    "598": "",
                    "599": "\t\tfrag = frag->frags;",
                    "600": "\t}",
                    "601": "",
                    "602": "\tnet_pkt_alloc_del(pkt, caller, line);",
                    "603": "done:",
                    "604": "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */",
                    "605": "",
                    "606": "\tif (ref > 1) {",
                    "607": "\t\treturn;",
                    "608": "\t}",
                    "609": "",
                    "610": "\tif (pkt->frags) {",
                    "611": "\t\tnet_pkt_frag_unref(pkt->frags);",
                    "612": "\t}",
                    "613": "",
                    "614": "\tif (IS_ENABLED(CONFIG_NET_DEBUG_NET_PKT_NON_FRAGILE_ACCESS)) {",
                    "615": "\t\tpkt->buffer = NULL;",
                    "616": "\t\tnet_pkt_cursor_init(pkt);",
                    "617": "\t}",
                    "618": "",
                    "619": "\tk_mem_slab_free(pkt->slab, (void *)pkt);",
                    "620": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_eth_ipv6_mcast_to_mac_addr": {
            "name": "net_eth_ipv6_mcast_to_mac_addr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 72,
            "function_content": [
                "/* RFC 1112 6.4. Extensions to an Ethernet Local Network Module\n* \"An IP host group address is mapped to an Ethernet multicast\n* address by placing the low-order 23-bits of the IP address into\n* the low-order 23 bits of the Ethernet multicast address\n* 01-00-5E-00-00-00 (hex).\"\n*/\nvoid net_eth_ipv6_mcast_to_mac_addr(const struct net_in6_addr *ipv6_addr,\n\t\t\t\t    struct net_eth_addr *mac_addr)\n{\n\t/* RFC 2464 7. Address Mapping -- Multicast\n\t * \"An IPv6 packet with a multicast destination address DST,\n\t * consisting of the sixteen octets DST[1] through DST[16],\n\t * is transmitted to the Ethernet multicast address whose\n\t * first two octets are the value 3333 hexadecimal and whose\n\t * last four octets are the last four octets of DST.\"\n\t */\n\tmac_addr->addr[0] = mac_addr->addr[1] = 0x33;\n\tmemcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);\n}\n",
                {
                    "72": "void net_eth_ipv6_mcast_to_mac_addr(const struct net_in6_addr *ipv6_addr,",
                    "73": "\t\t\t\t    struct net_eth_addr *mac_addr)",
                    "74": "{",
                    "75": "\t/* RFC 2464 7. Address Mapping -- Multicast",
                    "76": "\t * \"An IPv6 packet with a multicast destination address DST,",
                    "77": "\t * consisting of the sixteen octets DST[1] through DST[16],",
                    "78": "\t * is transmitted to the Ethernet multicast address whose",
                    "79": "\t * first two octets are the value 3333 hexadecimal and whose",
                    "80": "\t * last four octets are the last four octets of DST.\"",
                    "81": "\t */",
                    "82": "\tmac_addr->addr[0] = mac_addr->addr[1] = 0x33;",
                    "83": "\tmemcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);",
                    "84": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_eth_ipv4_mcast_to_mac_addr": {
            "name": "net_eth_ipv4_mcast_to_mac_addr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 53,
            "function_content": [
                "/*\n* Copyright (c) 2016-2018 Intel Corporation.\n* SPDX-FileCopyrightText: Copyright 2025 NXP\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nvoid net_eth_ipv4_mcast_to_mac_addr(const struct net_in_addr *ipv4_addr,\n\t\t\t\t    struct net_eth_addr *mac_addr)\n{\n\t/* RFC 1112 6.4. Extensions to an Ethernet Local Network Module\n\t * \"An IP host group address is mapped to an Ethernet multicast\n\t * address by placing the low-order 23-bits of the IP address into\n\t * the low-order 23 bits of the Ethernet multicast address\n\t * 01-00-5E-00-00-00 (hex).\"\n\t */\n\tmac_addr->addr[0] = 0x01;\n\tmac_addr->addr[1] = 0x00;\n\tmac_addr->addr[2] = 0x5e;\n\tmac_addr->addr[3] = ipv4_addr->s4_addr[1];\n\tmac_addr->addr[4] = ipv4_addr->s4_addr[2];\n\tmac_addr->addr[5] = ipv4_addr->s4_addr[3];\n\n\tmac_addr->addr[3] &= 0x7f;\n}\n",
                {
                    "53": "void net_eth_ipv4_mcast_to_mac_addr(const struct net_in_addr *ipv4_addr,",
                    "54": "\t\t\t\t    struct net_eth_addr *mac_addr)",
                    "55": "{",
                    "56": "\t/* RFC 1112 6.4. Extensions to an Ethernet Local Network Module",
                    "57": "\t * \"An IP host group address is mapped to an Ethernet multicast",
                    "58": "\t * address by placing the low-order 23-bits of the IP address into",
                    "59": "\t * the low-order 23 bits of the Ethernet multicast address",
                    "60": "\t * 01-00-5E-00-00-00 (hex).\"",
                    "61": "\t */",
                    "62": "\tmac_addr->addr[0] = 0x01;",
                    "63": "\tmac_addr->addr[1] = 0x00;",
                    "64": "\tmac_addr->addr[2] = 0x5e;",
                    "65": "\tmac_addr->addr[3] = ipv4_addr->s4_addr[1];",
                    "66": "\tmac_addr->addr[4] = ipv4_addr->s4_addr[2];",
                    "67": "\tmac_addr->addr[5] = ipv4_addr->s4_addr[3];",
                    "68": "",
                    "69": "\tmac_addr->addr[3] &= 0x7f;",
                    "70": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_config": {
            "name": "set_config",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/drivers/ethernet/eth_native_tap.c",
            "location_line": 454,
            "function_content": [
                "/* Create a thread that will handle incoming data from host */\nstatic int set_config(const struct device *dev,\n\t\t      enum ethernet_config_type type,\n\t\t      const struct ethernet_config *config)\n{\n\tint ret = 0;\n\n\tif (IS_ENABLED(CONFIG_NET_PROMISCUOUS_MODE) &&\n\t    type == ETHERNET_CONFIG_TYPE_PROMISC_MODE) {\n\t\tstruct eth_context *context = dev->data;\n\n\t\tif (config->promisc_mode) {\n\t\t\tif (context->promisc_mode) {\n\t\t\t\treturn -EALREADY;\n\t\t\t}\n\n\t\t\tcontext->promisc_mode = true;\n\t\t} else {\n\t\t\tif (!context->promisc_mode) {\n\t\t\t\treturn -EALREADY;\n\t\t\t}\n\n\t\t\tcontext->promisc_mode = false;\n\t\t}\n\n\t\tret = eth_promisc_mode(context->if_name,\n\t\t\t\t       context->promisc_mode);\n\t} else if (type == ETHERNET_CONFIG_TYPE_MAC_ADDRESS) {\n\t\tstruct eth_context *context = dev->data;\n\n\t\tmemcpy(context->mac_addr, config->mac_address.addr,\n\t\t       sizeof(context->mac_addr));\n\t}\n\n\treturn ret;\n}\n",
                {
                    "454": "static int set_config(const struct device *dev,",
                    "455": "\t\t      enum ethernet_config_type type,",
                    "456": "\t\t      const struct ethernet_config *config)",
                    "457": "{",
                    "458": "\tint ret = 0;",
                    "459": "",
                    "460": "\tif (IS_ENABLED(CONFIG_NET_PROMISCUOUS_MODE) &&",
                    "461": "\t    type == ETHERNET_CONFIG_TYPE_PROMISC_MODE) {",
                    "462": "\t\tstruct eth_context *context = dev->data;",
                    "463": "",
                    "464": "\t\tif (config->promisc_mode) {",
                    "465": "\t\t\tif (context->promisc_mode) {",
                    "466": "\t\t\t\treturn -EALREADY;",
                    "467": "\t\t\t}",
                    "468": "",
                    "469": "\t\t\tcontext->promisc_mode = true;",
                    "470": "\t\t} else {",
                    "471": "\t\t\tif (!context->promisc_mode) {",
                    "472": "\t\t\t\treturn -EALREADY;",
                    "473": "\t\t\t}",
                    "474": "",
                    "475": "\t\t\tcontext->promisc_mode = false;",
                    "476": "\t\t}",
                    "477": "",
                    "478": "\t\tret = eth_promisc_mode(context->if_name,",
                    "479": "\t\t\t\t       context->promisc_mode);",
                    "480": "\t} else if (type == ETHERNET_CONFIG_TYPE_MAC_ADDRESS) {",
                    "481": "\t\tstruct eth_context *context = dev->data;",
                    "482": "",
                    "483": "\t\tmemcpy(context->mac_addr, config->mac_address.addr,",
                    "484": "\t\t       sizeof(context->mac_addr));",
                    "485": "\t}",
                    "486": "",
                    "487": "\treturn ret;",
                    "488": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "eth_send": {
            "name": "eth_send",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/drivers/ethernet/eth_native_tap.c",
            "location_line": 181,
            "function_content": [
                "#endif /* CONFIG_NET_GPTP */\nstatic int eth_send(const struct device *dev, struct net_pkt *pkt)\n{\n\tstruct eth_context *ctx = dev->data;\n\tint count = net_pkt_get_len(pkt);\n\tint ret;\n\n\tret = net_pkt_read(pkt, ctx->send, count);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tupdate_gptp(net_pkt_iface(pkt), pkt, true);\n\n\tLOG_DBG(\"Send pkt %p len %d\", pkt, count);\n\n\tret = nsi_host_write(ctx->dev_fd, ctx->send, count);\n\tif (ret < 0) {\n\t\tLOG_DBG(\"Cannot send pkt %p (%d)\", pkt, ret);\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}\n",
                {
                    "181": "static int eth_send(const struct device *dev, struct net_pkt *pkt)",
                    "182": "{",
                    "183": "\tstruct eth_context *ctx = dev->data;",
                    "184": "\tint count = net_pkt_get_len(pkt);",
                    "185": "\tint ret;",
                    "186": "",
                    "187": "\tret = net_pkt_read(pkt, ctx->send, count);",
                    "188": "\tif (ret) {",
                    "189": "\t\treturn ret;",
                    "190": "\t}",
                    "191": "",
                    "192": "\tupdate_gptp(net_pkt_iface(pkt), pkt, true);",
                    "193": "",
                    "194": "\tLOG_DBG(\"Send pkt %p len %d\", pkt, count);",
                    "195": "",
                    "196": "\tret = nsi_host_write(ctx->dev_fd, ctx->send, count);",
                    "197": "\tif (ret < 0) {",
                    "198": "\t\tLOG_DBG(\"Cannot send pkt %p (%d)\", pkt, ret);",
                    "199": "\t}",
                    "200": "",
                    "201": "\treturn ret < 0 ? ret : 0;",
                    "202": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_put": {
            "name": "mbox_message_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 210,
            "function_content": [
                "/**\n* @brief Send a mailbox message.\n*\n* Helper routine that handles both synchronous and asynchronous sends.\n*\n* @param mbox Pointer to the mailbox object.\n* @param tx_msg Pointer to transmit message descriptor.\n* @param timeout Maximum time (milliseconds) to wait for the message to be\n*        received (although not necessarily completely processed).\n*        Use K_NO_WAIT to return immediately, or K_FOREVER to wait as long\n*        as necessary.\n*\n* @return 0 if successful, -ENOMSG if failed immediately, -EAGAIN if timed out\n*/\nstatic int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_thread *receiving_thread;\n\tstruct k_mbox_msg *rx_msg;\n\tk_spinlock_key_t key;\n\n\t/* save sender id so it can be used during message matching */\n\ttx_msg->rx_source_thread = _current;\n\n\t/* finish readying sending thread (actual or dummy) for send */\n\tsending_thread = tx_msg->_syncing_thread;\n\tsending_thread->base.swap_data = tx_msg;\n\n\t/* search mailbox's rx queue for a compatible receiver */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {\n\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take receiver out of rx queue */\n\t\t\tz_unpend_thread(receiving_thread);\n\n\t\t\t/* ready receiver for execution */\n\t\t\tarch_thread_return_value_set(receiving_thread, 0);\n\t\t\tz_ready_thread(receiving_thread);\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t\t\t/*\n\t\t\t * asynchronous send: swap out current thread\n\t\t\t * if receiver has priority, otherwise let it continue\n\t\t\t *\n\t\t\t * note: dummy sending thread sits (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)\n\t\t\t    != 0U) {\n\t\t\t\tz_reschedule(&mbox->lock, key);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t\t\t/*\n\t\t\t * synchronous send: pend current thread (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* didn't find a matching receiver: don't wait for one */\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);\n\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/* asynchronous send: dummy thread waits on tx queue for receiver */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn 0;\n\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t/* synchronous send: sender waits on tx queue for receiver or timeout */\n\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\treturn ret;\n}\n",
                {
                    "210": "static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,",
                    "211": "\t\t\t     k_timeout_t timeout)",
                    "212": "{",
                    "213": "\tstruct k_thread *sending_thread;",
                    "214": "\tstruct k_thread *receiving_thread;",
                    "215": "\tstruct k_mbox_msg *rx_msg;",
                    "216": "\tk_spinlock_key_t key;",
                    "217": "",
                    "218": "\t/* save sender id so it can be used during message matching */",
                    "219": "\ttx_msg->rx_source_thread = _current;",
                    "220": "",
                    "221": "\t/* finish readying sending thread (actual or dummy) for send */",
                    "222": "\tsending_thread = tx_msg->_syncing_thread;",
                    "223": "\tsending_thread->base.swap_data = tx_msg;",
                    "224": "",
                    "225": "\t/* search mailbox's rx queue for a compatible receiver */",
                    "226": "\tkey = k_spin_lock(&mbox->lock);",
                    "227": "",
                    "228": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);",
                    "229": "",
                    "230": "\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {",
                    "231": "\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;",
                    "232": "",
                    "233": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "234": "\t\t\t/* take receiver out of rx queue */",
                    "235": "\t\t\tz_unpend_thread(receiving_thread);",
                    "236": "",
                    "237": "\t\t\t/* ready receiver for execution */",
                    "238": "\t\t\tarch_thread_return_value_set(receiving_thread, 0);",
                    "239": "\t\t\tz_ready_thread(receiving_thread);",
                    "240": "",
                    "241": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "242": "\t\t\t/*",
                    "243": "\t\t\t * asynchronous send: swap out current thread",
                    "244": "\t\t\t * if receiver has priority, otherwise let it continue",
                    "245": "\t\t\t *",
                    "246": "\t\t\t * note: dummy sending thread sits (unqueued)",
                    "247": "\t\t\t * until the receiver consumes the message",
                    "248": "\t\t\t */",
                    "249": "\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)",
                    "250": "\t\t\t    != 0U) {",
                    "251": "\t\t\t\tz_reschedule(&mbox->lock, key);",
                    "252": "\t\t\t\treturn 0;",
                    "253": "\t\t\t}",
                    "254": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "255": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "256": "",
                    "257": "\t\t\t/*",
                    "258": "\t\t\t * synchronous send: pend current thread (unqueued)",
                    "259": "\t\t\t * until the receiver consumes the message",
                    "260": "\t\t\t */",
                    "261": "\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);",
                    "262": "",
                    "263": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "264": "",
                    "265": "\t\t\treturn ret;",
                    "266": "\t\t}",
                    "267": "\t}",
                    "268": "",
                    "269": "\t/* didn't find a matching receiver: don't wait for one */",
                    "270": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "271": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);",
                    "272": "",
                    "273": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "274": "\t\treturn -ENOMSG;",
                    "275": "\t}",
                    "276": "",
                    "277": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "278": "\t/* asynchronous send: dummy thread waits on tx queue for receiver */",
                    "279": "\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {",
                    "280": "\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);",
                    "281": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "282": "\t\treturn 0;",
                    "283": "\t}",
                    "284": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "286": "",
                    "287": "\t/* synchronous send: sender waits on tx queue for receiver or timeout */",
                    "288": "\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);",
                    "289": "",
                    "290": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "291": "",
                    "292": "\treturn ret;",
                    "293": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "copy_to_pending_readers": {
            "name": "copy_to_pending_readers",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 93,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_PIPE */\nstatic size_t copy_to_pending_readers(struct k_pipe *pipe, bool *need_resched,\n\t\t\t\t      const uint8_t *data, size_t len)\n{\n\tstruct k_thread *reader = NULL;\n\tstruct pipe_buf_spec *reader_buf;\n\tsize_t copy_size, written = 0;\n\n\t/*\n\t * Attempt a direct data copy to waiting readers if any.\n\t * The copy has to be done under the scheduler lock to ensure all the\n\t * needed data is copied to the target thread whose buffer spec lives\n\t * on that thread's stack, and then the thread unpended only if it\n\t * received all the data it wanted, without racing with a potential\n\t * thread timeout/cancellation event.\n\t */\n\tdo {\n\t\tLOCK_SCHED_SPINLOCK {\n\t\t\treader = _priq_wait_best(&pipe->data.waitq);\n\t\t\tif (reader == NULL) {\n\t\t\t\tK_SPINLOCK_BREAK;\n\t\t\t}\n\n\t\t\treader_buf = reader->base.swap_data;\n\t\t\tcopy_size = min(len - written,\n\t\t\t\t\treader_buf->len - reader_buf->used);\n\t\t\tmemcpy(&reader_buf->data[reader_buf->used],\n\t\t\t       &data[written], copy_size);\n\t\t\twritten += copy_size;\n\t\t\treader_buf->used += copy_size;\n\n\t\t\tif (reader_buf->used < reader_buf->len) {\n\t\t\t\t/* This reader wants more: don't unpend. */\n\t\t\t\treader = NULL;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This reader has received all the data\n\t\t\t\t * it was waiting for: wake it up with\n\t\t\t\t * the scheduler lock still held.\n\t\t\t\t */\n\t\t\t\tunpend_thread_no_timeout(reader);\n\t\t\t\tz_abort_thread_timeout(reader);\n\t\t\t}\n\t\t}\n\t\tif (reader != NULL) {\n\t\t\t/* rest of thread wake-up outside the scheduler lock */\n\t\t\tz_thread_return_value_set_with_data(reader, 0, NULL);\n\t\t\tz_ready_thread(reader);\n\t\t\t*need_resched = true;\n\t\t}\n\t} while (reader != NULL && written < len);\n\n\treturn written;\n}\n",
                {
                    "93": "static size_t copy_to_pending_readers(struct k_pipe *pipe, bool *need_resched,",
                    "94": "\t\t\t\t      const uint8_t *data, size_t len)",
                    "95": "{",
                    "96": "\tstruct k_thread *reader = NULL;",
                    "97": "\tstruct pipe_buf_spec *reader_buf;",
                    "98": "\tsize_t copy_size, written = 0;",
                    "99": "",
                    "100": "\t/*",
                    "101": "\t * Attempt a direct data copy to waiting readers if any.",
                    "102": "\t * The copy has to be done under the scheduler lock to ensure all the",
                    "103": "\t * needed data is copied to the target thread whose buffer spec lives",
                    "104": "\t * on that thread's stack, and then the thread unpended only if it",
                    "105": "\t * received all the data it wanted, without racing with a potential",
                    "106": "\t * thread timeout/cancellation event.",
                    "107": "\t */",
                    "108": "\tdo {",
                    "109": "\t\tLOCK_SCHED_SPINLOCK {",
                    "110": "\t\t\treader = _priq_wait_best(&pipe->data.waitq);",
                    "111": "\t\t\tif (reader == NULL) {",
                    "112": "\t\t\t\tK_SPINLOCK_BREAK;",
                    "113": "\t\t\t}",
                    "114": "",
                    "115": "\t\t\treader_buf = reader->base.swap_data;",
                    "116": "\t\t\tcopy_size = min(len - written,",
                    "117": "\t\t\t\t\treader_buf->len - reader_buf->used);",
                    "118": "\t\t\tmemcpy(&reader_buf->data[reader_buf->used],",
                    "119": "\t\t\t       &data[written], copy_size);",
                    "120": "\t\t\twritten += copy_size;",
                    "121": "\t\t\treader_buf->used += copy_size;",
                    "122": "",
                    "123": "\t\t\tif (reader_buf->used < reader_buf->len) {",
                    "124": "\t\t\t\t/* This reader wants more: don't unpend. */",
                    "125": "\t\t\t\treader = NULL;",
                    "126": "\t\t\t} else {",
                    "127": "\t\t\t\t/*",
                    "128": "\t\t\t\t * This reader has received all the data",
                    "129": "\t\t\t\t * it was waiting for: wake it up with",
                    "130": "\t\t\t\t * the scheduler lock still held.",
                    "131": "\t\t\t\t */",
                    "132": "\t\t\t\tunpend_thread_no_timeout(reader);",
                    "133": "\t\t\t\tz_abort_thread_timeout(reader);",
                    "134": "\t\t\t}",
                    "135": "\t\t}",
                    "136": "\t\tif (reader != NULL) {",
                    "137": "\t\t\t/* rest of thread wake-up outside the scheduler lock */",
                    "138": "\t\t\tz_thread_return_value_set_with_data(reader, 0, NULL);",
                    "139": "\t\t\tz_ready_thread(reader);",
                    "140": "\t\t\t*need_resched = true;",
                    "141": "\t\t}",
                    "142": "\t} while (reader != NULL && written < len);",
                    "143": "",
                    "144": "\treturn written;",
                    "145": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "triggered_work_cancel": {
            "name": "triggered_work_cancel",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 618,
            "function_content": [
                "/* Drop work ownership and execute real handler. */\nstatic int triggered_work_cancel(struct k_work_poll *work,\n\t\t\t\t k_spinlock_key_t key)\n{\n\t/* Check if the work waits for event. */\n\tif (work->poller.is_polling && work->poller.mode != MODE_NONE) {\n\t\t/* Remove timeout associated with the work. */\n\t\tz_abort_timeout(&work->timeout);\n\n\t\t/*\n\t\t * Prevent work execution if event arrives while we will be\n\t\t * clearing registrations.\n\t\t */\n\t\twork->poller.mode = MODE_NONE;\n\n\t\t/* Clear registrations and work ownership. */\n\t\tclear_event_registrations(work->events, work->num_events, key);\n\t\twork->workq = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we reached here, the work is either being registered in\n\t * the k_work_poll_submit_to_queue(), executed or is pending.\n\t * Only in the last case we have a chance to cancel it, but\n\t * unfortunately there is no public API performing this task.\n\t */\n\n\treturn -EINVAL;\n}\n",
                {
                    "618": "static int triggered_work_cancel(struct k_work_poll *work,",
                    "619": "\t\t\t\t k_spinlock_key_t key)",
                    "620": "{",
                    "621": "\t/* Check if the work waits for event. */",
                    "622": "\tif (work->poller.is_polling && work->poller.mode != MODE_NONE) {",
                    "623": "\t\t/* Remove timeout associated with the work. */",
                    "624": "\t\tz_abort_timeout(&work->timeout);",
                    "625": "",
                    "626": "\t\t/*",
                    "627": "\t\t * Prevent work execution if event arrives while we will be",
                    "628": "\t\t * clearing registrations.",
                    "629": "\t\t */",
                    "630": "\t\twork->poller.mode = MODE_NONE;",
                    "631": "",
                    "632": "\t\t/* Clear registrations and work ownership. */",
                    "633": "\t\tclear_event_registrations(work->events, work->num_events, key);",
                    "634": "\t\twork->workq = NULL;",
                    "635": "\t\treturn 0;",
                    "636": "\t}",
                    "637": "",
                    "638": "\t/*",
                    "639": "\t * If we reached here, the work is either being registered in",
                    "640": "\t * the k_work_poll_submit_to_queue(), executed or is pending.",
                    "641": "\t * Only in the last case we have a chance to cancel it, but",
                    "642": "\t * unfortunately there is no public API performing this task.",
                    "643": "\t */",
                    "644": "",
                    "645": "\treturn -EINVAL;",
                    "646": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "triggered_work_handler": {
            "name": "triggered_work_handler",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 565,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic void triggered_work_handler(struct k_work *work)\n{\n\tstruct k_work_poll *twork =\n\t\t\tCONTAINER_OF(work, struct k_work_poll, work);\n\n\t/*\n\t * If callback is not set, the k_work_poll_submit_to_queue()\n\t * already cleared event registrations.\n\t */\n\tif (twork->poller.mode != MODE_NONE) {\n\t\tk_spinlock_key_t key;\n\n\t\tkey = k_spin_lock(&lock);\n\t\tclear_event_registrations(twork->events,\n\t\t\t\t\t  twork->num_events, key);\n\t\tk_spin_unlock(&lock, key);\n\t}\n\n\t/* Drop work ownership and execute real handler. */\n\ttwork->workq = NULL;\n\ttwork->real_handler(work);\n}\n",
                {
                    "565": "static void triggered_work_handler(struct k_work *work)",
                    "566": "{",
                    "567": "\tstruct k_work_poll *twork =",
                    "568": "\t\t\tCONTAINER_OF(work, struct k_work_poll, work);",
                    "569": "",
                    "570": "\t/*",
                    "571": "\t * If callback is not set, the k_work_poll_submit_to_queue()",
                    "572": "\t * already cleared event registrations.",
                    "573": "\t */",
                    "574": "\tif (twork->poller.mode != MODE_NONE) {",
                    "575": "\t\tk_spinlock_key_t key;",
                    "576": "",
                    "577": "\t\tkey = k_spin_lock(&lock);",
                    "578": "\t\tclear_event_registrations(twork->events,",
                    "579": "\t\t\t\t\t  twork->num_events, key);",
                    "580": "\t\tk_spin_unlock(&lock, key);",
                    "581": "\t}",
                    "582": "",
                    "583": "\t/* Drop work ownership and execute real handler. */",
                    "584": "\ttwork->workq = NULL;",
                    "585": "\ttwork->real_handler(work);",
                    "586": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "queue_insert": {
            "name": "queue_insert",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 132,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic int32_t queue_insert(struct k_queue *queue, void *prev, void *data,\n\t\t\t    bool alloc, bool is_append)\n{\n\tstruct k_thread *first_pending_thread;\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tint32_t result = 0;\n\tbool resched = false;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);\n\n\tif (is_append) {\n\t\tprev = sys_sflist_peek_tail(&queue->data_q);\n\t}\n\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);\n\n\tif (unlikely(first_pending_thread != NULL)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);\n\n\t\tprepare_thread_to_run(first_pending_thread, data);\n\t\tresched = true;\n\t\tgoto out;\n\t}\n\n\t/* Only need to actually allocate if no threads are pending */\n\tif (alloc) {\n\t\tstruct alloc_node *anode;\n\n\t\tanode = z_thread_malloc(sizeof(*anode));\n\t\tif (anode == NULL) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tanode->data = data;\n\t\tsys_sfnode_init(&anode->node, 0x1);\n\t\tdata = anode;\n\t} else {\n\t\tsys_sfnode_init(data, 0x0);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);\n\n\tsys_sflist_insert(&queue->data_q, prev, data);\n\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);\n\nout:\n\tif (resched) {\n\t\tz_reschedule(&queue->lock, key);\n\t} else {\n\t\tk_spin_unlock(&queue->lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, result);\n\n\treturn result;\n}\n",
                {
                    "132": "static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,",
                    "133": "\t\t\t    bool alloc, bool is_append)",
                    "134": "{",
                    "135": "\tstruct k_thread *first_pending_thread;",
                    "136": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "137": "\tint32_t result = 0;",
                    "138": "\tbool resched = false;",
                    "139": "",
                    "140": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);",
                    "141": "",
                    "142": "\tif (is_append) {",
                    "143": "\t\tprev = sys_sflist_peek_tail(&queue->data_q);",
                    "144": "\t}",
                    "145": "\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);",
                    "146": "",
                    "147": "\tif (unlikely(first_pending_thread != NULL)) {",
                    "148": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);",
                    "149": "",
                    "150": "\t\tprepare_thread_to_run(first_pending_thread, data);",
                    "151": "\t\tresched = true;",
                    "152": "\t\tgoto out;",
                    "153": "\t}",
                    "154": "",
                    "155": "\t/* Only need to actually allocate if no threads are pending */",
                    "156": "\tif (alloc) {",
                    "157": "\t\tstruct alloc_node *anode;",
                    "158": "",
                    "159": "\t\tanode = z_thread_malloc(sizeof(*anode));",
                    "160": "\t\tif (anode == NULL) {",
                    "161": "\t\t\tresult = -ENOMEM;",
                    "162": "\t\t\tgoto out;",
                    "163": "\t\t}",
                    "164": "\t\tanode->data = data;",
                    "165": "\t\tsys_sfnode_init(&anode->node, 0x1);",
                    "166": "\t\tdata = anode;",
                    "167": "\t} else {",
                    "168": "\t\tsys_sfnode_init(data, 0x0);",
                    "169": "\t}",
                    "170": "",
                    "171": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);",
                    "172": "",
                    "173": "\tsys_sflist_insert(&queue->data_q, prev, data);",
                    "174": "\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);",
                    "175": "",
                    "176": "out:",
                    "177": "\tif (resched) {",
                    "178": "\t\tz_reschedule(&queue->lock, key);",
                    "179": "\t} else {",
                    "180": "\t\tk_spin_unlock(&queue->lock, key);",
                    "181": "\t}",
                    "182": "",
                    "183": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, result);",
                    "184": "",
                    "185": "\treturn result;",
                    "186": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "init_ready_q": {
            "name": "init_ready_q",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1003,
            "function_content": [
                "#endif /* CONFIG_USE_SWITCH */\nvoid init_ready_q(struct _ready_q *ready_q)\n{\n\t_priq_run_init(&ready_q->runq);\n}\n",
                {
                    "1003": "void init_ready_q(struct _ready_q *ready_q)",
                    "1004": "{",
                    "1005": "\t_priq_run_init(&ready_q->runq);",
                    "1006": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "add_to_waitq_locked": {
            "name": "add_to_waitq_locked",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 574,
            "function_content": [
                "/* _sched_spinlock must be held */\nstatic void add_to_waitq_locked(struct k_thread *thread, _wait_q_t *wait_q)\n{\n\tunready_thread(thread);\n\tz_mark_thread_as_pending(thread);\n\n\tSYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);\n\n\tif (wait_q != NULL) {\n\t\tthread->base.pended_on = wait_q;\n\t\t_priq_wait_add(&wait_q->waitq, thread);\n\t}\n}\n",
                {
                    "574": "static void add_to_waitq_locked(struct k_thread *thread, _wait_q_t *wait_q)",
                    "575": "{",
                    "576": "\tunready_thread(thread);",
                    "577": "\tz_mark_thread_as_pending(thread);",
                    "578": "",
                    "579": "\tSYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);",
                    "580": "",
                    "581": "\tif (wait_q != NULL) {",
                    "582": "\t\tthread->base.pended_on = wait_q;",
                    "583": "\t\t_priq_wait_add(&wait_q->waitq, thread);",
                    "584": "\t}",
                    "585": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "unready_thread": {
            "name": "unready_thread",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 562,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic void unready_thread(struct k_thread *thread)\n{\n\tif (z_is_thread_queued(thread)) {\n\t\tdequeue_thread(thread);\n\t}\n\tupdate_cache(thread == _current);\n}\n",
                {
                    "562": "static void unready_thread(struct k_thread *thread)",
                    "563": "{",
                    "564": "\tif (z_is_thread_queued(thread)) {",
                    "565": "\t\tdequeue_thread(thread);",
                    "566": "\t}",
                    "567": "\tupdate_cache(thread == _current);",
                    "568": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "thread_halt_spin": {
            "name": "thread_halt_spin",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 390,
            "function_content": [
                "/* Spins in ISR context, waiting for a thread known to be running on\n* another CPU to catch the IPI we sent and halt.  Note that we check\n* for ourselves being asynchronously halted first to prevent simple\n* deadlocks (but not complex ones involving cycles of 3+ threads!).\n* Acts to release the provided lock before returning.\n*/\nstatic void thread_halt_spin(struct k_thread *thread, k_spinlock_key_t key)\n{\n\tif (z_is_thread_halting(_current)) {\n\t\thalt_thread(_current,\n\t\t\t    z_is_thread_aborting(_current) ? _THREAD_DEAD : _THREAD_SUSPENDED);\n\t}\n\tk_spin_unlock(&_sched_spinlock, key);\n\twhile (z_is_thread_halting(thread)) {\n\t\tunsigned int k = arch_irq_lock();\n\n\t\tarch_spin_relax(); /* Requires interrupts be masked */\n\t\tarch_irq_unlock(k);\n\t}\n}\n",
                {
                    "390": "static void thread_halt_spin(struct k_thread *thread, k_spinlock_key_t key)",
                    "391": "{",
                    "392": "\tif (z_is_thread_halting(_current)) {",
                    "393": "\t\thalt_thread(_current,",
                    "394": "\t\t\t    z_is_thread_aborting(_current) ? _THREAD_DEAD : _THREAD_SUSPENDED);",
                    "395": "\t}",
                    "396": "\tk_spin_unlock(&_sched_spinlock, key);",
                    "397": "\twhile (z_is_thread_halting(thread)) {",
                    "398": "\t\tunsigned int k = arch_irq_lock();",
                    "399": "",
                    "400": "\t\tarch_spin_relax(); /* Requires interrupts be masked */",
                    "401": "\t\tarch_irq_unlock(k);",
                    "402": "\t}",
                    "403": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ready_thread": {
            "name": "ready_thread",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 348,
            "function_content": [
                "#endif /* CONFIG_SMP */\nstatic void ready_thread(struct k_thread *thread)\n{\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(thread));\n#endif /* CONFIG_KERNEL_COHERENCE */\n\n\t/* If thread is queued already, do not try and added it to the\n\t * run queue again\n\t */\n\tif (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);\n\n\t\tqueue_thread(thread);\n\t\tupdate_cache(0);\n\n\t\tflag_ipi(ipi_mask_create(thread));\n\t}\n}\n",
                {
                    "348": "static void ready_thread(struct k_thread *thread)",
                    "349": "{",
                    "350": "#ifdef CONFIG_KERNEL_COHERENCE",
                    "351": "\t__ASSERT_NO_MSG(sys_cache_is_mem_coherent(thread));",
                    "352": "#endif /* CONFIG_KERNEL_COHERENCE */",
                    "353": "",
                    "354": "\t/* If thread is queued already, do not try and added it to the",
                    "355": "\t * run queue again",
                    "356": "\t */",
                    "357": "\tif (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {",
                    "358": "\t\tSYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);",
                    "359": "",
                    "360": "\t\tqueue_thread(thread);",
                    "361": "\t\tupdate_cache(0);",
                    "362": "",
                    "363": "\t\tflag_ipi(ipi_mask_create(thread));",
                    "364": "\t}",
                    "365": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "remove_timeout": {
            "name": "remove_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 55,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic void remove_timeout(struct _timeout *t)\n{\n\tif (next(t) != NULL) {\n\t\tnext(t)->dticks += t->dticks;\n\t}\n\n\tsys_dlist_remove(&t->node);\n}\n",
                {
                    "55": "static void remove_timeout(struct _timeout *t)",
                    "56": "{",
                    "57": "\tif (next(t) != NULL) {",
                    "58": "\t\tnext(t)->dticks += t->dticks;",
                    "59": "\t}",
                    "60": "",
                    "61": "\tsys_dlist_remove(&t->node);",
                    "62": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "first": {
            "name": "first",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 41,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *first(void)\n{\n\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);\n\n\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);\n}\n",
                {
                    "41": "static struct _timeout *first(void)",
                    "42": "{",
                    "43": "\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);",
                    "44": "",
                    "45": "\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);",
                    "46": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_cbvprintf_impl": {
            "name": "z_cbvprintf_impl",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_complete.c",
            "location_line": 1370,
            "function_content": [
                "/* Outline function to emit all characters in [sp, ep). */\nint z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,\n\t\t     va_list ap, uint32_t flags)\n{\n\tchar buf[CONVERTED_BUFLEN];\n\tsize_t count = 0;\n\tsint_value_type sint;\n\tcbprintf_cb_local out = __out;\n\n\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)\n\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;\n\n/* Output character, returning EOF if output failed, otherwise\n * updating count.\n *\n * NB: c is evaluated exactly once: side-effects are OK\n */\n#define OUTC(c) do { \\\n\tint rc = (*out)((int)(c), ctx); \\\n\t\\\n\tif (rc < 0) { \\\n\t\treturn rc; \\\n\t} \\\n\t++count; \\\n} while (false)\n\n/* Output sequence of characters, returning a negative error if output\n * failed.\n */\n\n#define OUTS(_sp, _ep) do { \\\n\tint rc = outs(out, ctx, (_sp), (_ep)); \\\n\t\\\n\tif (rc < 0) {\t    \\\n\t\treturn rc; \\\n\t} \\\n\tcount += rc; \\\n} while (false)\n\n\twhile (*fp != 0) {\n\t\tif (*fp != '%') {\n\t\t\tOUTC(*fp);\n\t\t\t++fp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Force union into RAM with conversion state to\n\t\t * mitigate LLVM code generation bug.\n\t\t */\n\t\tstruct {\n\t\t\tunion argument_value value;\n\t\t\tstruct conversion conv;\n\t\t} state = {\n\t\t\t.value = {\n\t\t\t\t.uint = 0,\n\t\t\t},\n\t\t};\n\t\tstruct conversion *const conv = &state.conv;\n\t\tunion argument_value *const value = &state.value;\n\t\tconst char *sp = fp;\n\t\tint width = -1;\n\t\tint precision = -1;\n\t\tconst char *bps = NULL;\n\t\tconst char *bpe = buf + sizeof(buf);\n\t\tchar sign = 0;\n\n\t\tfp = extract_conversion(conv, sp);\n\n\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\t\t\t    && tagged_ap) {\n\t\t\t\t/* Skip over the argument tag as it is not being\n\t\t\t\t * used here.\n\t\t\t\t */\n\t\t\t\t(void)va_arg(ap, int);\n\t\t\t}\n\t\t}\n\n\t\t/* If dynamic width is specified, process it,\n\t\t * otherwise set width if present.\n\t\t */\n\t\tif (conv->width_star) {\n\t\t\twidth = va_arg(ap, int);\n\n\t\t\tif (width < 0) {\n\t\t\t\tconv->flag_dash = true;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t} else if (conv->width_present) {\n\t\t\twidth = conv->width_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* If dynamic precision is specified, process it, otherwise\n\t\t * set precision if present.  For floating point where\n\t\t * precision is not present use 6.\n\t\t */\n\t\tif (conv->prec_star) {\n\t\t\tint arg = va_arg(ap, int);\n\n\t\t\tif (arg < 0) {\n\t\t\t\tconv->prec_present = false;\n\t\t\t} else {\n\t\t\t\tprecision = arg;\n\t\t\t}\n\t\t} else if (conv->prec_present) {\n\t\t\tprecision = conv->prec_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* Reuse width and precision memory in conv for value\n\t\t * padding counts.\n\t\t */\n\t\tconv->pad0_value = 0;\n\t\tconv->pad0_pre_exp = 0;\n\n\t\t/* FP conversion requires knowing the precision. */\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)\n\t\t    && (conv->specifier_cat == SPECIFIER_FP)\n\t\t    && !conv->prec_present) {\n\t\t\tif (conv->specifier_a) {\n\t\t\t\tprecision = FRACTION_HEX;\n\t\t\t} else {\n\t\t\t\tprecision = 6;\n\t\t\t}\n\t\t}\n\n\t\t/* Get the value to be converted from the args.\n\t\t *\n\t\t * This can't be extracted to a helper function because\n\t\t * passing a pointer to va_list doesn't work on x86_64.  See\n\t\t * https://stackoverflow.com/a/8048892.\n\t\t */\n\t\tenum specifier_cat_enum specifier_cat\n\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;\n\t\tenum length_mod_enum length_mod\n\t\t\t= (enum length_mod_enum)conv->length_mod;\n\n\t\t/* Extract the value based on the argument category and length.\n\t\t *\n\t\t * Note that the length modifier doesn't affect the value of a\n\t\t * pointer argument.\n\t\t */\n\t\tif (specifier_cat == SPECIFIER_SINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->sint = va_arg(ap, int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif (WCHAR_IS_SIGNED\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->sint = va_arg(ap, long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\t/* Though ssize_t is the signed equivalent of\n\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.\n\t\t\t\t * Assume that size_t and ptrdiff_t are the\n\t\t\t\t * unsigned and signed equivalents of each\n\t\t\t\t * other.  This can be checked in a platform\n\t\t\t\t * test.\n\t\t\t\t */\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->sint = (signed char)value->sint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->sint = (short)value->sint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_UINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->uint = va_arg(ap, unsigned int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif ((!WCHAR_IS_SIGNED)\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\tunsigned long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\t\t\tuintmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->uint = (unsigned char)value->uint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->uint = (unsigned short)value->uint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_FP) {\n\t\t\tif (length_mod == LENGTH_UPPER_L) {\n\t\t\t\tvalue->ldbl = va_arg(ap, long double);\n\t\t\t} else {\n\t\t\t\tvalue->dbl = va_arg(ap, double);\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_PTR) {\n\t\t\tvalue->ptr = va_arg(ap, void *);\n\t\t}\n\n\t\t/* We've now consumed all arguments related to this\n\t\t * specification.  If the conversion is invalid, or is\n\t\t * something we don't support, then output the original\n\t\t * specification and move on.\n\t\t */\n\t\tif (conv->invalid || conv->unsupported) {\n\t\t\tOUTS(sp, fp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do formatting, either into the buffer or\n\t\t * referencing external data.\n\t\t */\n\t\tswitch (conv->specifier) {\n\t\tcase '%':\n\t\t\tOUTC('%');\n\t\t\tbreak;\n\t\tcase 's': {\n\t\t\tbps = (const char *)value->ptr;\n\n\t\t\tsize_t len;\n\n\t\t\tif (precision >= 0) {\n\t\t\t\tlen = strnlen(bps, precision);\n\t\t\t} else {\n\t\t\t\tlen = strlen(bps);\n\t\t\t}\n\n\t\t\tbpe = bps + len;\n\t\t\tprecision = -1;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 'p':\n\t\t\t/* Implementation-defined: null is \"(nil)\", non-null\n\t\t\t * has 0x prefix followed by significant address hex\n\t\t\t * digits, no leading zeros.\n\t\t\t */\n\t\t\tif (value->ptr != NULL) {\n\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,\n\t\t\t\t\t\t  buf, bpe);\n\n\t\t\t\t/* Use 0x prefix */\n\t\t\t\tconv->altform_0c = true;\n\t\t\t\tconv->specifier = 'x';\n\n\t\t\t\tgoto prec_int_pad0;\n\t\t\t}\n\n\t\t\tbps = \"(nil)\";\n\t\t\tbpe = bps + 5;\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tbps = buf;\n\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;\n\t\t\tbpe = buf + 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tif (conv->flag_plus) {\n\t\t\t\tsign = '+';\n\t\t\t} else if (conv->flag_space) {\n\t\t\t\tsign = ' ';\n\t\t\t}\n\n\t\t\t/* sint/uint overlay in the union, and so\n\t\t\t * can't appear in read and write operations\n\t\t\t * in the same statement.\n\t\t\t */\n\t\t\tsint = value->sint;\n\t\t\tif (sint < 0) {\n\t\t\t\tsign = '-';\n\t\t\t\tvalue->uint = (uint_value_type)-sint;\n\t\t\t} else {\n\t\t\t\tvalue->uint = (uint_value_type)sint;\n\t\t\t}\n\n\t\t\t__fallthrough;\n\t\tcase 'o':\n\t\tcase 'u':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);\n\n\t\tprec_int_pad0:\n\t\t\t/* Update pad0 values based on precision and converted\n\t\t\t * length.  Note that a non-empty sign is not in the\n\t\t\t * converted sequence, but it does not affect the\n\t\t\t * padding size.\n\t\t\t */\n\t\t\tif (precision >= 0) {\n\t\t\t\tsize_t len = bpe - bps;\n\n\t\t\t\t/* Zero-padding flag is ignored for integer\n\t\t\t\t * conversions with precision.\n\t\t\t\t */\n\t\t\t\tconv->flag_zero = false;\n\n\t\t\t\t/* Set pad0_value to satisfy precision */\n\t\t\t\tif (len < (size_t)precision) {\n\t\t\t\t\tconv->pad0_value = precision - (int)len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {\n\t\t\t\tstore_count(conv, value->ptr, count);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FP_CONV_CASES:\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {\n\t\t\t\tbps = encode_float(value->dbl, conv, precision,\n\t\t\t\t\t\t   &sign, buf, &bpe);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Add an empty default with break, this is a defensive\n\t\t\t * programming. Static analysis tool won't raise a violation\n\t\t\t * if default is empty, but has that comment.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If we don't have a converted value to emit, move\n\t\t * on.\n\t\t */\n\t\tif (bps == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The converted value is now stored in [bps, bpe), excluding\n\t\t * any required zero padding.\n\t\t *\n\t\t * The unjustified output will be:\n\t\t *\n\t\t * * any sign character (sint-only)\n\t\t * * any altform prefix\n\t\t * * for FP:\n\t\t *   * any pre-decimal content from the converted value\n\t\t *   * any pad0_value padding (!postdp)\n\t\t *   * any decimal point in the converted value\n\t\t *   * any pad0_value padding (postdp)\n\t\t *   * any pre-exponent content from the converted value\n\t\t *   * any pad0_pre_exp padding\n\t\t *   * any exponent content from the converted value\n\t\t * * for non-FP:\n\t\t *   * any pad0_prefix\n\t\t *   * the converted value\n\t\t */\n\t\tsize_t nj_len = (bpe - bps);\n\t\tint pad_len = 0;\n\n\t\tif (sign != 0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tif (conv->altform_0c) {\n\t\t\tnj_len += 2U;\n\t\t} else if (conv->altform_0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tnj_len += conv->pad0_value;\n\t\tif (conv->pad_fp) {\n\t\t\tnj_len += conv->pad0_pre_exp;\n\t\t}\n\n\t\t/* If we have a width update width to hold the padding we need\n\t\t * for justification.  The result may be negative, which will\n\t\t * result in no padding.\n\t\t *\n\t\t * If a non-negative padding width is present and we're doing\n\t\t * right-justification, emit the padding now.\n\t\t */\n\t\tif (width > 0) {\n\t\t\twidth -= (int)nj_len;\n\n\t\t\tif (!conv->flag_dash) {\n\t\t\t\tchar pad = ' ';\n\n\t\t\t\t/* If we're zero-padding we have to emit the\n\t\t\t\t * sign first.\n\t\t\t\t */\n\t\t\t\tif (conv->flag_zero) {\n\t\t\t\t\tif (sign != 0) {\n\t\t\t\t\t\tOUTC(sign);\n\t\t\t\t\t\tsign = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpad = '0';\n\t\t\t\t}\n\n\t\t\t\twhile (width-- > 0) {\n\t\t\t\t\tOUTC(pad);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have a sign that hasn't been emitted, now's the\n\t\t * time....\n\t\t */\n\t\tif (sign != 0) {\n\t\t\tOUTC(sign);\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {\n\t\t\tconst char *cp = bps;\n\n\t\t\tif (conv->specifier_a) {\n\t\t\t\t/* Only padding is pre_exp */\n\t\t\t\twhile (*cp != 'p') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\n\t\t\t\tpad_len = conv->pad0_value;\n\t\t\t\tif (!conv->pad_postdp) {\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*cp == '.') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t\t/* Remaining padding is\n\t\t\t\t\t * post-dp.\n\t\t\t\t\t */\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_pre_exp;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(cp, bpe);\n\t\t} else {\n\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tif (conv->altform_0c) {\n\t\t\t\tOUTC(conv->specifier);\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_value;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(bps, bpe);\n\t\t}\n\n\t\t/* Finish left justification */\n\t\twhile (width > 0) {\n\t\t\tOUTC(' ');\n\t\t\t--width;\n\t\t}\n\t}\n\n\treturn count;\n#undef OUTS\n#undef OUTC\n}\n",
                {
                    "1370": "int z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,",
                    "1371": "\t\t     va_list ap, uint32_t flags)",
                    "1372": "{",
                    "1373": "\tchar buf[CONVERTED_BUFLEN];",
                    "1374": "\tsize_t count = 0;",
                    "1375": "\tsint_value_type sint;",
                    "1376": "\tcbprintf_cb_local out = __out;",
                    "1377": "",
                    "1378": "\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)",
                    "1379": "\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;",
                    "1380": "",
                    "1381": "/* Output character, returning EOF if output failed, otherwise",
                    "1382": " * updating count.",
                    "1383": " *",
                    "1384": " * NB: c is evaluated exactly once: side-effects are OK",
                    "1385": " */",
                    "1386": "#define OUTC(c) do { \\",
                    "1387": "\tint rc = (*out)((int)(c), ctx); \\",
                    "1388": "\t\\",
                    "1389": "\tif (rc < 0) { \\",
                    "1390": "\t\treturn rc; \\",
                    "1391": "\t} \\",
                    "1392": "\t++count; \\",
                    "1393": "} while (false)",
                    "1394": "",
                    "1395": "/* Output sequence of characters, returning a negative error if output",
                    "1396": " * failed.",
                    "1397": " */",
                    "1398": "",
                    "1399": "#define OUTS(_sp, _ep) do { \\",
                    "1400": "\tint rc = outs(out, ctx, (_sp), (_ep)); \\",
                    "1401": "\t\\",
                    "1402": "\tif (rc < 0) {\t    \\",
                    "1403": "\t\treturn rc; \\",
                    "1404": "\t} \\",
                    "1405": "\tcount += rc; \\",
                    "1406": "} while (false)",
                    "1407": "",
                    "1408": "\twhile (*fp != 0) {",
                    "1409": "\t\tif (*fp != '%') {",
                    "1410": "\t\t\tOUTC(*fp);",
                    "1411": "\t\t\t++fp;",
                    "1412": "\t\t\tcontinue;",
                    "1413": "\t\t}",
                    "1414": "",
                    "1415": "\t\t/* Force union into RAM with conversion state to",
                    "1416": "\t\t * mitigate LLVM code generation bug.",
                    "1417": "\t\t */",
                    "1418": "\t\tstruct {",
                    "1419": "\t\t\tunion argument_value value;",
                    "1420": "\t\t\tstruct conversion conv;",
                    "1421": "\t\t} state = {",
                    "1422": "\t\t\t.value = {",
                    "1423": "\t\t\t\t.uint = 0,",
                    "1424": "\t\t\t},",
                    "1425": "\t\t};",
                    "1426": "\t\tstruct conversion *const conv = &state.conv;",
                    "1427": "\t\tunion argument_value *const value = &state.value;",
                    "1428": "\t\tconst char *sp = fp;",
                    "1429": "\t\tint width = -1;",
                    "1430": "\t\tint precision = -1;",
                    "1431": "\t\tconst char *bps = NULL;",
                    "1432": "\t\tconst char *bpe = buf + sizeof(buf);",
                    "1433": "\t\tchar sign = 0;",
                    "1434": "",
                    "1435": "\t\tfp = extract_conversion(conv, sp);",
                    "1436": "",
                    "1437": "\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {",
                    "1438": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)",
                    "1439": "\t\t\t    && tagged_ap) {",
                    "1440": "\t\t\t\t/* Skip over the argument tag as it is not being",
                    "1441": "\t\t\t\t * used here.",
                    "1442": "\t\t\t\t */",
                    "1443": "\t\t\t\t(void)va_arg(ap, int);",
                    "1444": "\t\t\t}",
                    "1445": "\t\t}",
                    "1446": "",
                    "1447": "\t\t/* If dynamic width is specified, process it,",
                    "1448": "\t\t * otherwise set width if present.",
                    "1449": "\t\t */",
                    "1450": "\t\tif (conv->width_star) {",
                    "1451": "\t\t\twidth = va_arg(ap, int);",
                    "1452": "",
                    "1453": "\t\t\tif (width < 0) {",
                    "1454": "\t\t\t\tconv->flag_dash = true;",
                    "1455": "\t\t\t\twidth = -width;",
                    "1456": "\t\t\t}",
                    "1457": "\t\t} else if (conv->width_present) {",
                    "1458": "\t\t\twidth = conv->width_value;",
                    "1459": "\t\t} else {",
                    "1460": "\t\t\t;",
                    "1461": "\t\t}",
                    "1462": "",
                    "1463": "\t\t/* If dynamic precision is specified, process it, otherwise",
                    "1464": "\t\t * set precision if present.  For floating point where",
                    "1465": "\t\t * precision is not present use 6.",
                    "1466": "\t\t */",
                    "1467": "\t\tif (conv->prec_star) {",
                    "1468": "\t\t\tint arg = va_arg(ap, int);",
                    "1469": "",
                    "1470": "\t\t\tif (arg < 0) {",
                    "1471": "\t\t\t\tconv->prec_present = false;",
                    "1472": "\t\t\t} else {",
                    "1473": "\t\t\t\tprecision = arg;",
                    "1474": "\t\t\t}",
                    "1475": "\t\t} else if (conv->prec_present) {",
                    "1476": "\t\t\tprecision = conv->prec_value;",
                    "1477": "\t\t} else {",
                    "1478": "\t\t\t;",
                    "1479": "\t\t}",
                    "1480": "",
                    "1481": "\t\t/* Reuse width and precision memory in conv for value",
                    "1482": "\t\t * padding counts.",
                    "1483": "\t\t */",
                    "1484": "\t\tconv->pad0_value = 0;",
                    "1485": "\t\tconv->pad0_pre_exp = 0;",
                    "1486": "",
                    "1487": "\t\t/* FP conversion requires knowing the precision. */",
                    "1488": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)",
                    "1489": "\t\t    && (conv->specifier_cat == SPECIFIER_FP)",
                    "1490": "\t\t    && !conv->prec_present) {",
                    "1491": "\t\t\tif (conv->specifier_a) {",
                    "1492": "\t\t\t\tprecision = FRACTION_HEX;",
                    "1493": "\t\t\t} else {",
                    "1494": "\t\t\t\tprecision = 6;",
                    "1495": "\t\t\t}",
                    "1496": "\t\t}",
                    "1497": "",
                    "1498": "\t\t/* Get the value to be converted from the args.",
                    "1499": "\t\t *",
                    "1500": "\t\t * This can't be extracted to a helper function because",
                    "1501": "\t\t * passing a pointer to va_list doesn't work on x86_64.  See",
                    "1502": "\t\t * https://stackoverflow.com/a/8048892.",
                    "1503": "\t\t */",
                    "1504": "\t\tenum specifier_cat_enum specifier_cat",
                    "1505": "\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;",
                    "1506": "\t\tenum length_mod_enum length_mod",
                    "1507": "\t\t\t= (enum length_mod_enum)conv->length_mod;",
                    "1508": "",
                    "1509": "\t\t/* Extract the value based on the argument category and length.",
                    "1510": "\t\t *",
                    "1511": "\t\t * Note that the length modifier doesn't affect the value of a",
                    "1512": "\t\t * pointer argument.",
                    "1513": "\t\t */",
                    "1514": "\t\tif (specifier_cat == SPECIFIER_SINT) {",
                    "1515": "\t\t\tswitch (length_mod) {",
                    "1516": "\t\t\tdefault:",
                    "1517": "\t\t\tcase LENGTH_NONE:",
                    "1518": "\t\t\tcase LENGTH_HH:",
                    "1519": "\t\t\tcase LENGTH_H:",
                    "1520": "\t\t\t\tvalue->sint = va_arg(ap, int);",
                    "1521": "\t\t\t\tbreak;",
                    "1522": "\t\t\tcase LENGTH_L:",
                    "1523": "\t\t\t\tif (WCHAR_IS_SIGNED",
                    "1524": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1525": "\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,",
                    "1526": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1527": "\t\t\t\t} else {",
                    "1528": "\t\t\t\t\tvalue->sint = va_arg(ap, long);",
                    "1529": "\t\t\t\t}",
                    "1530": "\t\t\t\tbreak;",
                    "1531": "\t\t\tcase LENGTH_LL:",
                    "1532": "\t\t\t\tvalue->sint =",
                    "1533": "\t\t\t\t\t(sint_value_type)va_arg(ap, long long);",
                    "1534": "\t\t\t\tbreak;",
                    "1535": "\t\t\tcase LENGTH_J:",
                    "1536": "\t\t\t\tvalue->sint =",
                    "1537": "\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);",
                    "1538": "\t\t\t\tbreak;",
                    "1539": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1540": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1541": "\t\t\t\t/* Though ssize_t is the signed equivalent of",
                    "1542": "\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.",
                    "1543": "\t\t\t\t * Assume that size_t and ptrdiff_t are the",
                    "1544": "\t\t\t\t * unsigned and signed equivalents of each",
                    "1545": "\t\t\t\t * other.  This can be checked in a platform",
                    "1546": "\t\t\t\t * test.",
                    "1547": "\t\t\t\t */",
                    "1548": "\t\t\t\tvalue->sint =",
                    "1549": "\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);",
                    "1550": "\t\t\t\tbreak;",
                    "1551": "\t\t\t}",
                    "1552": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1553": "\t\t\t\tvalue->sint = (signed char)value->sint;",
                    "1554": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1555": "\t\t\t\tvalue->sint = (short)value->sint;",
                    "1556": "\t\t\t}",
                    "1557": "\t\t} else if (specifier_cat == SPECIFIER_UINT) {",
                    "1558": "\t\t\tswitch (length_mod) {",
                    "1559": "\t\t\tdefault:",
                    "1560": "\t\t\tcase LENGTH_NONE:",
                    "1561": "\t\t\tcase LENGTH_HH:",
                    "1562": "\t\t\tcase LENGTH_H:",
                    "1563": "\t\t\t\tvalue->uint = va_arg(ap, unsigned int);",
                    "1564": "\t\t\t\tbreak;",
                    "1565": "\t\t\tcase LENGTH_L:",
                    "1566": "\t\t\t\tif ((!WCHAR_IS_SIGNED)",
                    "1567": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1568": "\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,",
                    "1569": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1570": "\t\t\t\t} else {",
                    "1571": "\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);",
                    "1572": "\t\t\t\t}",
                    "1573": "\t\t\t\tbreak;",
                    "1574": "\t\t\tcase LENGTH_LL:",
                    "1575": "\t\t\t\tvalue->uint =",
                    "1576": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1577": "\t\t\t\t\t\tunsigned long long);",
                    "1578": "\t\t\t\tbreak;",
                    "1579": "\t\t\tcase LENGTH_J:",
                    "1580": "\t\t\t\tvalue->uint =",
                    "1581": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1582": "\t\t\t\t\t\t\t\tuintmax_t);",
                    "1583": "\t\t\t\tbreak;",
                    "1584": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1585": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1586": "\t\t\t\tvalue->uint =",
                    "1587": "\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);",
                    "1588": "\t\t\t\tbreak;",
                    "1589": "\t\t\t}",
                    "1590": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1591": "\t\t\t\tvalue->uint = (unsigned char)value->uint;",
                    "1592": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1593": "\t\t\t\tvalue->uint = (unsigned short)value->uint;",
                    "1594": "\t\t\t}",
                    "1595": "\t\t} else if (specifier_cat == SPECIFIER_FP) {",
                    "1596": "\t\t\tif (length_mod == LENGTH_UPPER_L) {",
                    "1597": "\t\t\t\tvalue->ldbl = va_arg(ap, long double);",
                    "1598": "\t\t\t} else {",
                    "1599": "\t\t\t\tvalue->dbl = va_arg(ap, double);",
                    "1600": "\t\t\t}",
                    "1601": "\t\t} else if (specifier_cat == SPECIFIER_PTR) {",
                    "1602": "\t\t\tvalue->ptr = va_arg(ap, void *);",
                    "1603": "\t\t}",
                    "1604": "",
                    "1605": "\t\t/* We've now consumed all arguments related to this",
                    "1606": "\t\t * specification.  If the conversion is invalid, or is",
                    "1607": "\t\t * something we don't support, then output the original",
                    "1608": "\t\t * specification and move on.",
                    "1609": "\t\t */",
                    "1610": "\t\tif (conv->invalid || conv->unsupported) {",
                    "1611": "\t\t\tOUTS(sp, fp);",
                    "1612": "\t\t\tcontinue;",
                    "1613": "\t\t}",
                    "1614": "",
                    "1615": "\t\t/* Do formatting, either into the buffer or",
                    "1616": "\t\t * referencing external data.",
                    "1617": "\t\t */",
                    "1618": "\t\tswitch (conv->specifier) {",
                    "1619": "\t\tcase '%':",
                    "1620": "\t\t\tOUTC('%');",
                    "1621": "\t\t\tbreak;",
                    "1622": "\t\tcase 's': {",
                    "1623": "\t\t\tbps = (const char *)value->ptr;",
                    "1624": "",
                    "1625": "\t\t\tsize_t len;",
                    "1626": "",
                    "1627": "\t\t\tif (precision >= 0) {",
                    "1628": "\t\t\t\tlen = strnlen(bps, precision);",
                    "1629": "\t\t\t} else {",
                    "1630": "\t\t\t\tlen = strlen(bps);",
                    "1631": "\t\t\t}",
                    "1632": "",
                    "1633": "\t\t\tbpe = bps + len;",
                    "1634": "\t\t\tprecision = -1;",
                    "1635": "",
                    "1636": "\t\t\tbreak;",
                    "1637": "\t\t}",
                    "1638": "\t\tcase 'p':",
                    "1639": "\t\t\t/* Implementation-defined: null is \"(nil)\", non-null",
                    "1640": "\t\t\t * has 0x prefix followed by significant address hex",
                    "1641": "\t\t\t * digits, no leading zeros.",
                    "1642": "\t\t\t */",
                    "1643": "\t\t\tif (value->ptr != NULL) {",
                    "1644": "\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,",
                    "1645": "\t\t\t\t\t\t  buf, bpe);",
                    "1646": "",
                    "1647": "\t\t\t\t/* Use 0x prefix */",
                    "1648": "\t\t\t\tconv->altform_0c = true;",
                    "1649": "\t\t\t\tconv->specifier = 'x';",
                    "1650": "",
                    "1651": "\t\t\t\tgoto prec_int_pad0;",
                    "1652": "\t\t\t}",
                    "1653": "",
                    "1654": "\t\t\tbps = \"(nil)\";",
                    "1655": "\t\t\tbpe = bps + 5;",
                    "1656": "",
                    "1657": "\t\t\tbreak;",
                    "1658": "\t\tcase 'c':",
                    "1659": "\t\t\tbps = buf;",
                    "1660": "\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;",
                    "1661": "\t\t\tbpe = buf + 1;",
                    "1662": "\t\t\tbreak;",
                    "1663": "\t\tcase 'd':",
                    "1664": "\t\tcase 'i':",
                    "1665": "\t\t\tif (conv->flag_plus) {",
                    "1666": "\t\t\t\tsign = '+';",
                    "1667": "\t\t\t} else if (conv->flag_space) {",
                    "1668": "\t\t\t\tsign = ' ';",
                    "1669": "\t\t\t}",
                    "1670": "",
                    "1671": "\t\t\t/* sint/uint overlay in the union, and so",
                    "1672": "\t\t\t * can't appear in read and write operations",
                    "1673": "\t\t\t * in the same statement.",
                    "1674": "\t\t\t */",
                    "1675": "\t\t\tsint = value->sint;",
                    "1676": "\t\t\tif (sint < 0) {",
                    "1677": "\t\t\t\tsign = '-';",
                    "1678": "\t\t\t\tvalue->uint = (uint_value_type)-sint;",
                    "1679": "\t\t\t} else {",
                    "1680": "\t\t\t\tvalue->uint = (uint_value_type)sint;",
                    "1681": "\t\t\t}",
                    "1682": "",
                    "1683": "\t\t\t__fallthrough;",
                    "1684": "\t\tcase 'o':",
                    "1685": "\t\tcase 'u':",
                    "1686": "\t\tcase 'x':",
                    "1687": "\t\tcase 'X':",
                    "1688": "\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);",
                    "1689": "",
                    "1690": "\t\tprec_int_pad0:",
                    "1691": "\t\t\t/* Update pad0 values based on precision and converted",
                    "1692": "\t\t\t * length.  Note that a non-empty sign is not in the",
                    "1693": "\t\t\t * converted sequence, but it does not affect the",
                    "1694": "\t\t\t * padding size.",
                    "1695": "\t\t\t */",
                    "1696": "\t\t\tif (precision >= 0) {",
                    "1697": "\t\t\t\tsize_t len = bpe - bps;",
                    "1698": "",
                    "1699": "\t\t\t\t/* Zero-padding flag is ignored for integer",
                    "1700": "\t\t\t\t * conversions with precision.",
                    "1701": "\t\t\t\t */",
                    "1702": "\t\t\t\tconv->flag_zero = false;",
                    "1703": "",
                    "1704": "\t\t\t\t/* Set pad0_value to satisfy precision */",
                    "1705": "\t\t\t\tif (len < (size_t)precision) {",
                    "1706": "\t\t\t\t\tconv->pad0_value = precision - (int)len;",
                    "1707": "\t\t\t\t}",
                    "1708": "\t\t\t}",
                    "1709": "",
                    "1710": "\t\t\tbreak;",
                    "1711": "\t\tcase 'n':",
                    "1712": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {",
                    "1713": "\t\t\t\tstore_count(conv, value->ptr, count);",
                    "1714": "\t\t\t}",
                    "1715": "",
                    "1716": "\t\t\tbreak;",
                    "1717": "",
                    "1718": "\t\tcase FP_CONV_CASES:",
                    "1719": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {",
                    "1720": "\t\t\t\tbps = encode_float(value->dbl, conv, precision,",
                    "1721": "\t\t\t\t\t\t   &sign, buf, &bpe);",
                    "1722": "\t\t\t}",
                    "1723": "\t\t\tbreak;",
                    "1724": "\t\tdefault:",
                    "1725": "\t\t\t/* Add an empty default with break, this is a defensive",
                    "1726": "\t\t\t * programming. Static analysis tool won't raise a violation",
                    "1727": "\t\t\t * if default is empty, but has that comment.",
                    "1728": "\t\t\t */",
                    "1729": "\t\t\tbreak;",
                    "1730": "\t\t}",
                    "1731": "",
                    "1732": "\t\t/* If we don't have a converted value to emit, move",
                    "1733": "\t\t * on.",
                    "1734": "\t\t */",
                    "1735": "\t\tif (bps == NULL) {",
                    "1736": "\t\t\tcontinue;",
                    "1737": "\t\t}",
                    "1738": "",
                    "1739": "\t\t/* The converted value is now stored in [bps, bpe), excluding",
                    "1740": "\t\t * any required zero padding.",
                    "1741": "\t\t *",
                    "1742": "\t\t * The unjustified output will be:",
                    "1743": "\t\t *",
                    "1744": "\t\t * * any sign character (sint-only)",
                    "1745": "\t\t * * any altform prefix",
                    "1746": "\t\t * * for FP:",
                    "1747": "\t\t *   * any pre-decimal content from the converted value",
                    "1748": "\t\t *   * any pad0_value padding (!postdp)",
                    "1749": "\t\t *   * any decimal point in the converted value",
                    "1750": "\t\t *   * any pad0_value padding (postdp)",
                    "1751": "\t\t *   * any pre-exponent content from the converted value",
                    "1752": "\t\t *   * any pad0_pre_exp padding",
                    "1753": "\t\t *   * any exponent content from the converted value",
                    "1754": "\t\t * * for non-FP:",
                    "1755": "\t\t *   * any pad0_prefix",
                    "1756": "\t\t *   * the converted value",
                    "1757": "\t\t */",
                    "1758": "\t\tsize_t nj_len = (bpe - bps);",
                    "1759": "\t\tint pad_len = 0;",
                    "1760": "",
                    "1761": "\t\tif (sign != 0) {",
                    "1762": "\t\t\tnj_len += 1U;",
                    "1763": "\t\t}",
                    "1764": "",
                    "1765": "\t\tif (conv->altform_0c) {",
                    "1766": "\t\t\tnj_len += 2U;",
                    "1767": "\t\t} else if (conv->altform_0) {",
                    "1768": "\t\t\tnj_len += 1U;",
                    "1769": "\t\t}",
                    "1770": "",
                    "1771": "\t\tnj_len += conv->pad0_value;",
                    "1772": "\t\tif (conv->pad_fp) {",
                    "1773": "\t\t\tnj_len += conv->pad0_pre_exp;",
                    "1774": "\t\t}",
                    "1775": "",
                    "1776": "\t\t/* If we have a width update width to hold the padding we need",
                    "1777": "\t\t * for justification.  The result may be negative, which will",
                    "1778": "\t\t * result in no padding.",
                    "1779": "\t\t *",
                    "1780": "\t\t * If a non-negative padding width is present and we're doing",
                    "1781": "\t\t * right-justification, emit the padding now.",
                    "1782": "\t\t */",
                    "1783": "\t\tif (width > 0) {",
                    "1784": "\t\t\twidth -= (int)nj_len;",
                    "1785": "",
                    "1786": "\t\t\tif (!conv->flag_dash) {",
                    "1787": "\t\t\t\tchar pad = ' ';",
                    "1788": "",
                    "1789": "\t\t\t\t/* If we're zero-padding we have to emit the",
                    "1790": "\t\t\t\t * sign first.",
                    "1791": "\t\t\t\t */",
                    "1792": "\t\t\t\tif (conv->flag_zero) {",
                    "1793": "\t\t\t\t\tif (sign != 0) {",
                    "1794": "\t\t\t\t\t\tOUTC(sign);",
                    "1795": "\t\t\t\t\t\tsign = 0;",
                    "1796": "\t\t\t\t\t}",
                    "1797": "\t\t\t\t\tpad = '0';",
                    "1798": "\t\t\t\t}",
                    "1799": "",
                    "1800": "\t\t\t\twhile (width-- > 0) {",
                    "1801": "\t\t\t\t\tOUTC(pad);",
                    "1802": "\t\t\t\t}",
                    "1803": "\t\t\t}",
                    "1804": "\t\t}",
                    "1805": "",
                    "1806": "\t\t/* If we have a sign that hasn't been emitted, now's the",
                    "1807": "\t\t * time....",
                    "1808": "\t\t */",
                    "1809": "\t\tif (sign != 0) {",
                    "1810": "\t\t\tOUTC(sign);",
                    "1811": "\t\t}",
                    "1812": "",
                    "1813": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {",
                    "1814": "\t\t\tconst char *cp = bps;",
                    "1815": "",
                    "1816": "\t\t\tif (conv->specifier_a) {",
                    "1817": "\t\t\t\t/* Only padding is pre_exp */",
                    "1818": "\t\t\t\twhile (*cp != 'p') {",
                    "1819": "\t\t\t\t\tOUTC(*cp);",
                    "1820": "\t\t\t\t\t++cp;",
                    "1821": "\t\t\t\t}",
                    "1822": "\t\t\t} else {",
                    "1823": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1824": "\t\t\t\t\tOUTC(*cp);",
                    "1825": "\t\t\t\t\t++cp;",
                    "1826": "\t\t\t\t}",
                    "1827": "",
                    "1828": "\t\t\t\tpad_len = conv->pad0_value;",
                    "1829": "\t\t\t\tif (!conv->pad_postdp) {",
                    "1830": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1831": "\t\t\t\t\t\tOUTC('0');",
                    "1832": "\t\t\t\t\t}",
                    "1833": "\t\t\t\t}",
                    "1834": "",
                    "1835": "\t\t\t\tif (*cp == '.') {",
                    "1836": "\t\t\t\t\tOUTC(*cp);",
                    "1837": "\t\t\t\t\t++cp;",
                    "1838": "\t\t\t\t\t/* Remaining padding is",
                    "1839": "\t\t\t\t\t * post-dp.",
                    "1840": "\t\t\t\t\t */",
                    "1841": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1842": "\t\t\t\t\t\tOUTC('0');",
                    "1843": "\t\t\t\t\t}",
                    "1844": "\t\t\t\t}",
                    "1845": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1846": "\t\t\t\t\tOUTC(*cp);",
                    "1847": "\t\t\t\t\t++cp;",
                    "1848": "\t\t\t\t}",
                    "1849": "\t\t\t}",
                    "1850": "",
                    "1851": "\t\t\tpad_len = conv->pad0_pre_exp;",
                    "1852": "\t\t\twhile (pad_len-- > 0) {",
                    "1853": "\t\t\t\tOUTC('0');",
                    "1854": "\t\t\t}",
                    "1855": "",
                    "1856": "\t\t\tOUTS(cp, bpe);",
                    "1857": "\t\t} else {",
                    "1858": "\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {",
                    "1859": "\t\t\t\tOUTC('0');",
                    "1860": "\t\t\t}",
                    "1861": "",
                    "1862": "\t\t\tif (conv->altform_0c) {",
                    "1863": "\t\t\t\tOUTC(conv->specifier);",
                    "1864": "\t\t\t}",
                    "1865": "",
                    "1866": "\t\t\tpad_len = conv->pad0_value;",
                    "1867": "\t\t\twhile (pad_len-- > 0) {",
                    "1868": "\t\t\t\tOUTC('0');",
                    "1869": "\t\t\t}",
                    "1870": "",
                    "1871": "\t\t\tOUTS(bps, bpe);",
                    "1872": "\t\t}",
                    "1873": "",
                    "1874": "\t\t/* Finish left justification */",
                    "1875": "\t\twhile (width > 0) {",
                    "1876": "\t\t\tOUTC(' ');",
                    "1877": "\t\t\t--width;",
                    "1878": "\t\t}",
                    "1879": "\t}",
                    "1880": "",
                    "1881": "\treturn count;",
                    "1882": "#undef OUTS",
                    "1883": "#undef OUTC",
                    "1884": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "encode_float": {
            "name": "encode_float",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_complete.c",
            "location_line": 870,
            "function_content": [
                "/* Convert the IEEE 754-2008 double to text format.\n*\n* @param value the 64-bit floating point value.\n*\n* @param conv details about how the conversion is to proceed.  Some fields\n* are adjusted based on the value being converted.\n*\n* @param precision the precision for the conversion (generally digits past\n* the decimal point).\n*\n* @param bps pointer to the first character in a buffer that will hold the\n* converted value.\n*\n* @param bpe On entry this points to the end of the buffer reserved to hold\n* the converted value.  On exit it is updated to point just past the\n* converted value.\n*\n* return a pointer to the start of the converted value.  This may not be @p\n* bps but will be consistent with the exit value of *bpe.\n*/\nstatic char *encode_float(double value,\n\t\t\t  struct conversion *conv,\n\t\t\t  int precision,\n\t\t\t  char *sign,\n\t\t\t  char *bps,\n\t\t\t  const char **bpe)\n{\n\tunion {\n\t\tuint64_t u64;\n\t\tdouble dbl;\n\t} u = {\n\t\t.dbl = value,\n\t};\n\tbool prune_zero = false;\n\tchar *buf = bps;\n\n\t/* Prepend the sign: '-' if negative, flags control\n\t * non-negative behavior.\n\t */\n\tif ((u.u64 & SIGN_MASK) != 0U) {\n\t\t*sign = '-';\n\t} else if (conv->flag_plus) {\n\t\t*sign = '+';\n\t} else if (conv->flag_space) {\n\t\t*sign = ' ';\n\t} else {\n\t\t;\n\t}\n\n\t/* Extract the non-negative offset exponent and fraction.  Record\n\t * whether the value is subnormal.\n\t */\n\tchar c = conv->specifier;\n\tint expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);\n\tuint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);\n\tbool is_subnormal = (expo == 0) && (fract != 0);\n\n\t/* Exponent of all-ones signals infinity or NaN, which are\n\t * text constants regardless of specifier.\n\t */\n\tif (expo == BIT_MASK(EXPONENT_BITS)) {\n\t\tif (fract == 0) {\n\t\t\tif (isupper((unsigned char)c) != 0) {\n\t\t\t\tbuf[0] = 'I';\n\t\t\t\tbuf[1] = 'N';\n\t\t\t\tbuf[2] = 'F';\n\t\t\t\tbuf += 3;\n\t\t\t} else {\n\t\t\t\tbuf[0] = 'i';\n\t\t\t\tbuf[1] = 'n';\n\t\t\t\tbuf[2] = 'f';\n\t\t\t\tbuf += 3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (isupper((unsigned char)c) != 0) {\n\t\t\t\tbuf[0] = 'N';\n\t\t\t\tbuf[1] = 'A';\n\t\t\t\tbuf[2] = 'N';\n\t\t\t\tbuf += 3;\n\t\t\t} else {\n\t\t\t\tbuf[0] = 'n';\n\t\t\t\tbuf[1] = 'a';\n\t\t\t\tbuf[2] = 'n';\n\t\t\t\tbuf += 3;\n\t\t\t}\n\t\t}\n\n\t\t/* No zero-padding with text values */\n\t\tconv->flag_zero = false;\n\n\t\t*bpe = buf;\n\t\treturn bps;\n\t}\n\n\t/* The case of an F specifier is no longer relevant. */\n\tif (c == 'F') {\n\t\tc = 'f';\n\t}\n\n\t/* Handle converting to the hex representation. */\n\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_A_SUPPORT)\n\t    && (IS_ENABLED(CONFIG_CBPRINTF_FP_ALWAYS_A)\n\t\t|| conv->specifier_a)) {\n\t\tbuf[0] = '0';\n\t\tbuf[1] = 'x';\n\t\tbuf += 2;\n\n\t\t/* Remove the offset from the exponent, and store the\n\t\t * non-fractional value.  Subnormals require increasing the\n\t\t * exponent as first bit isn't the implicit bit.\n\t\t */\n\t\texpo -= 1023;\n\t\tif (is_subnormal) {\n\t\t\t*buf = '0';\n\t\t\t++buf;\n\t\t\t++expo;\n\t\t} else {\n\t\t\t*buf = '1';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* If we didn't get precision from a %a specification then we\n\t\t * treat it as from a %a specification with no precision: full\n\t\t * range, zero-pruning enabled.\n\t\t *\n\t\t * Otherwise we have to cap the precision of the generated\n\t\t * fraction, or possibly round it.\n\t\t */\n\t\tif (!(conv->specifier_a && conv->prec_present)) {\n\t\t\tprecision = FRACTION_HEX;\n\t\t\tprune_zero = true;\n\t\t} else if (precision > FRACTION_HEX) {\n\t\t\tconv->pad0_pre_exp = precision - FRACTION_HEX;\n\t\t\tconv->pad_fp = true;\n\t\t\tprecision = FRACTION_HEX;\n\t\t} else if ((fract != 0)\n\t\t\t   && (precision < FRACTION_HEX)) {\n\t\t\tsize_t pos = 4 * (FRACTION_HEX - precision) - 1;\n\t\t\tuint64_t mask = BIT64(pos);\n\n\t\t\t/* Round only if the bit that would round is\n\t\t\t * set.\n\t\t\t */\n\t\t\tif ((fract & mask) != 0ULL) {\n\t\t\t\tfract += mask;\n\t\t\t}\n\t\t}\n\n\t\t/* Record whether we must retain the decimal point even if we\n\t\t * can prune zeros.\n\t\t */\n\t\tbool require_dp = ((fract != 0) || conv->flag_hash);\n\n\t\tif (require_dp || (precision != 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* Get the fractional value as a hexadecimal string, using x\n\t\t * for a and X for A.\n\t\t */\n\t\tstruct conversion aconv = {\n\t\t\t.specifier = isupper((unsigned char)c) != 0 ? 'X' : 'x',\n\t\t};\n\t\tconst char *spe = *bpe;\n\t\tchar *sp = bps + (spe - bps);\n\n\t\tif (fract != 0) {\n\t\t\tsp = encode_uint(fract, &aconv, buf, spe);\n\t\t}\n\n\t\t/* Pad out to full range since this is below the decimal\n\t\t * point.\n\t\t */\n\t\twhile ((spe - sp) < FRACTION_HEX) {\n\t\t\t--sp;\n\t\t\t*sp = '0';\n\t\t}\n\n\t\t/* Append the leading significant \"digits\". */\n\t\twhile ((sp < spe) && (precision > 0)) {\n\t\t\t*buf = *sp;\n\t\t\t++buf;\n\t\t\t++sp;\n\t\t\t--precision;\n\t\t}\n\n\t\tif (prune_zero) {\n\t\t\twhile (*--buf == '0') {\n\t\t\t\t;\n\t\t\t}\n\t\t\tif ((*buf != '.') || require_dp) {\n\t\t\t\t++buf;\n\t\t\t}\n\t\t}\n\n\t\t*buf = 'p';\n\t\t++buf;\n\t\tif (expo >= 0) {\n\t\t\t*buf = '+';\n\t\t\t++buf;\n\t\t} else {\n\t\t\t*buf = '-';\n\t\t\t++buf;\n\t\t\texpo = -expo;\n\t\t}\n\n\t\taconv.specifier = 'i';\n\t\tsp = encode_uint(expo, &aconv, buf, spe);\n\n\t\twhile (sp < spe) {\n\t\t\t*buf = *sp;\n\t\t\t++buf;\n\t\t\t++sp;\n\t\t}\n\n\t\t*bpe = buf;\n\t\treturn bps;\n\t}\n\n\t/* Remainder of code operates on a 64-bit fraction, so shift up (and\n\t * discard garbage from the exponent where the implicit 1 would be\n\t * stored).\n\t */\n\tfract <<= EXPONENT_BITS;\n\tfract &= ~SIGN_MASK;\n\n\t/* Non-zero values need normalization. */\n\tif ((expo | fract) != 0) {\n\t\tif (is_subnormal) {\n\t\t\t/* Fraction is subnormal.  Normalize it and correct\n\t\t\t * the exponent.\n\t\t\t */\n\t\t\tfor (fract <<= 1; (fract & BIT_63) == 0; fract <<= 1) {\n\t\t\t\texpo--;\n\t\t\t}\n\t\t}\n\t\t/* Adjust the offset exponent to be signed rather than offset,\n\t\t * and set the implicit 1 bit in the (shifted) 53-bit\n\t\t * fraction.\n\t\t */\n\t\texpo -= (1023 - 1);\t/* +1 since .1 vs 1. */\n\t\tfract |= BIT_63;\n\t}\n\n\t/*\n\t * Let's consider:\n\t *\n\t *\tvalue = fract * 2^expo * 10^decexp\n\t *\n\t * Initially decexp = 0. The goal is to bring exp between\n\t * 0 and -2 as the magnitude of a fractional decimal digit is 3 bits.\n\t */\n\tint decexp = 0;\n\n\twhile (expo < -2) {\n\t\t/*\n\t\t * Make room to allow a multiplication by 5 without overflow.\n\t\t * We test only the top part for faster code.\n\t\t */\n\t\tdo {\n\t\t\tfract >>= 1;\n\t\t\texpo++;\n\t\t} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));\n\n\t\t/* Perform fract * 5 * 2 / 10 */\n\t\tfract *= 5U;\n\t\texpo++;\n\t\tdecexp--;\n\t}\n\n\twhile (expo > 0) {\n\t\t/*\n\t\t * Perform fract / 5 / 2 * 10.\n\t\t * The +2 is there to do round the result of the division\n\t\t * by 5 not to lose too much precision in extreme cases.\n\t\t */\n\t\tfract += 2;\n\t\t_ldiv5(&fract);\n\t\texpo--;\n\t\tdecexp++;\n\n\t\t/* Bring back our fractional number to full scale */\n\t\tdo {\n\t\t\tfract <<= 1;\n\t\t\texpo--;\n\t\t} while (!(fract & BIT_63));\n\t}\n\n\t/*\n\t * The binary fractional point is located somewhere above bit 63.\n\t * Move it between bits 59 and 60 to give 4 bits of room to the\n\t * integer part.\n\t */\n\tfract >>= (4 - expo);\n\n\tif ((c == 'g') || (c == 'G')) {\n\t\t/* Use the specified precision and exponent to select the\n\t\t * representation and correct the precision and zero-pruning\n\t\t * in accordance with the ISO C rule.\n\t\t */\n\t\tif ((decexp < (-4 + 1)) || (decexp > precision)) {\n\t\t\tc += 'e' - 'g';  /* e or E */\n\t\t\tif (precision > 0) {\n\t\t\t\tprecision--;\n\t\t\t}\n\t\t} else {\n\t\t\tc = 'f';\n\t\t\tprecision -= decexp;\n\t\t}\n\t\tif (!conv->flag_hash && (precision > 0)) {\n\t\t\tprune_zero = true;\n\t\t}\n\t}\n\n\tint decimals;\n\tif (c == 'f') {\n\t\tdecimals = precision + decexp;\n\t\tif (decimals < 0) {\n\t\t\tdecimals = 0;\n\t\t}\n\t} else {\n\t\tdecimals = precision + 1;\n\t}\n\n\tint digit_count = 16;\n\n\tif (decimals > 16) {\n\t\tdecimals = 16;\n\t}\n\n\t/* Round the value to the last digit being printed. */\n\tuint64_t round = BIT64(59); /* 0.5 */\n\twhile (decimals-- != 0) {\n\t\t_ldiv10(&round);\n\t}\n\tfract += round;\n\t/* Make sure rounding didn't make fract >= 1.0 */\n\tif (fract >= BIT64(60)) {\n\t\t_ldiv10(&fract);\n\t\tdecexp++;\n\t}\n\n\tif (c == 'f') {\n\t\tif (decexp > 0) {\n\t\t\t/* Emit the digits above the decimal point. */\n\t\t\twhile ((decexp > 0) && (digit_count > 0)) {\n\t\t\t\t*buf = _get_digit(&fract, &digit_count);\n\t\t\t\t++buf;\n\t\t\t\tdecexp--;\n\t\t\t}\n\n\t\t\tconv->pad0_value = decexp;\n\n\t\t\tdecexp = 0;\n\t\t} else {\n\t\t\t*buf = '0';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* Emit the decimal point only if required by the alternative\n\t\t * format, or if more digits are to follow.\n\t\t */\n\t\tif (conv->flag_hash || (precision > 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\n\t\tif ((decexp < 0) && (precision > 0)) {\n\t\t\tconv->pad0_value = -decexp;\n\t\t\tif (conv->pad0_value > precision) {\n\t\t\t\tconv->pad0_value = precision;\n\t\t\t}\n\n\t\t\tprecision -= conv->pad0_value;\n\t\t\tconv->pad_postdp = (conv->pad0_value > 0);\n\t\t}\n\t} else { /* e or E */\n\t\t/* Emit the one digit before the decimal.  If it's not zero,\n\t\t * this is significant so reduce the base-10 exponent.\n\t\t */\n\t\t*buf = _get_digit(&fract, &digit_count);\n\t\tif (*buf++ != '0') {\n\t\t\tdecexp--;\n\t\t}\n\n\t\t/* Emit the decimal point only if required by the alternative\n\t\t * format, or if more digits are to follow.\n\t\t */\n\t\tif (conv->flag_hash || (precision > 0)) {\n\t\t\t*buf = '.';\n\t\t\t++buf;\n\t\t}\n\t}\n\n\twhile ((precision > 0) && (digit_count > 0)) {\n\t\t*buf = _get_digit(&fract, &digit_count);\n\t\t++buf;\n\t\tprecision--;\n\t}\n\n\tconv->pad0_pre_exp = precision;\n\n\tif (prune_zero) {\n\t\tconv->pad0_pre_exp = 0;\n\t\tdo {\n\t\t\t--buf;\n\t\t} while (*buf == '0');\n\t\tif (*buf != '.') {\n\t\t\t++buf;\n\t\t}\n\t}\n\n\t/* Emit the explicit exponent, if format requires it. */\n\tif ((c == 'e') || (c == 'E')) {\n\t\t*buf = c;\n\t\t++buf;\n\t\tif (decexp < 0) {\n\t\t\tdecexp = -decexp;\n\t\t\t*buf = '-';\n\t\t\t++buf;\n\t\t} else {\n\t\t\t*buf = '+';\n\t\t\t++buf;\n\t\t}\n\n\t\t/* At most 3 digits to the decimal.  Spit them out. */\n\t\tif (decexp >= 100) {\n\t\t\t*buf = (decexp / 100) + '0';\n\t\t\t++buf;\n\t\t\tdecexp %= 100;\n\t\t}\n\n\t\tbuf[0] = (decexp / 10) + '0';\n\t\tbuf[1] = (decexp % 10) + '0';\n\t\tbuf += 2;\n\t}\n\n\t/* Cache whether there's padding required */\n\tconv->pad_fp = (conv->pad0_value > 0)\n\t\t|| (conv->pad0_pre_exp > 0);\n\n\t/* Set the end of the encoded sequence, and return its start.  Also\n\t * store EOS as a non-digit/non-decimal value so we don't have to\n\t * check against bpe when iterating in multiple places.\n\t */\n\t*bpe = buf;\n\t*buf = 0;\n\treturn bps;\n}\n",
                {
                    "870": "static char *encode_float(double value,",
                    "871": "\t\t\t  struct conversion *conv,",
                    "872": "\t\t\t  int precision,",
                    "873": "\t\t\t  char *sign,",
                    "874": "\t\t\t  char *bps,",
                    "875": "\t\t\t  const char **bpe)",
                    "876": "{",
                    "877": "\tunion {",
                    "878": "\t\tuint64_t u64;",
                    "879": "\t\tdouble dbl;",
                    "880": "\t} u = {",
                    "881": "\t\t.dbl = value,",
                    "882": "\t};",
                    "883": "\tbool prune_zero = false;",
                    "884": "\tchar *buf = bps;",
                    "885": "",
                    "886": "\t/* Prepend the sign: '-' if negative, flags control",
                    "887": "\t * non-negative behavior.",
                    "888": "\t */",
                    "889": "\tif ((u.u64 & SIGN_MASK) != 0U) {",
                    "890": "\t\t*sign = '-';",
                    "891": "\t} else if (conv->flag_plus) {",
                    "892": "\t\t*sign = '+';",
                    "893": "\t} else if (conv->flag_space) {",
                    "894": "\t\t*sign = ' ';",
                    "895": "\t} else {",
                    "896": "\t\t;",
                    "897": "\t}",
                    "898": "",
                    "899": "\t/* Extract the non-negative offset exponent and fraction.  Record",
                    "900": "\t * whether the value is subnormal.",
                    "901": "\t */",
                    "902": "\tchar c = conv->specifier;",
                    "903": "\tint expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);",
                    "904": "\tuint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);",
                    "905": "\tbool is_subnormal = (expo == 0) && (fract != 0);",
                    "906": "",
                    "907": "\t/* Exponent of all-ones signals infinity or NaN, which are",
                    "908": "\t * text constants regardless of specifier.",
                    "909": "\t */",
                    "910": "\tif (expo == BIT_MASK(EXPONENT_BITS)) {",
                    "911": "\t\tif (fract == 0) {",
                    "912": "\t\t\tif (isupper((unsigned char)c) != 0) {",
                    "913": "\t\t\t\tbuf[0] = 'I';",
                    "914": "\t\t\t\tbuf[1] = 'N';",
                    "915": "\t\t\t\tbuf[2] = 'F';",
                    "916": "\t\t\t\tbuf += 3;",
                    "917": "\t\t\t} else {",
                    "918": "\t\t\t\tbuf[0] = 'i';",
                    "919": "\t\t\t\tbuf[1] = 'n';",
                    "920": "\t\t\t\tbuf[2] = 'f';",
                    "921": "\t\t\t\tbuf += 3;",
                    "922": "\t\t\t}",
                    "923": "\t\t} else {",
                    "924": "\t\t\tif (isupper((unsigned char)c) != 0) {",
                    "925": "\t\t\t\tbuf[0] = 'N';",
                    "926": "\t\t\t\tbuf[1] = 'A';",
                    "927": "\t\t\t\tbuf[2] = 'N';",
                    "928": "\t\t\t\tbuf += 3;",
                    "929": "\t\t\t} else {",
                    "930": "\t\t\t\tbuf[0] = 'n';",
                    "931": "\t\t\t\tbuf[1] = 'a';",
                    "932": "\t\t\t\tbuf[2] = 'n';",
                    "933": "\t\t\t\tbuf += 3;",
                    "934": "\t\t\t}",
                    "935": "\t\t}",
                    "936": "",
                    "937": "\t\t/* No zero-padding with text values */",
                    "938": "\t\tconv->flag_zero = false;",
                    "939": "",
                    "940": "\t\t*bpe = buf;",
                    "941": "\t\treturn bps;",
                    "942": "\t}",
                    "943": "",
                    "944": "\t/* The case of an F specifier is no longer relevant. */",
                    "945": "\tif (c == 'F') {",
                    "946": "\t\tc = 'f';",
                    "947": "\t}",
                    "948": "",
                    "949": "\t/* Handle converting to the hex representation. */",
                    "950": "\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_A_SUPPORT)",
                    "951": "\t    && (IS_ENABLED(CONFIG_CBPRINTF_FP_ALWAYS_A)",
                    "952": "\t\t|| conv->specifier_a)) {",
                    "953": "\t\tbuf[0] = '0';",
                    "954": "\t\tbuf[1] = 'x';",
                    "955": "\t\tbuf += 2;",
                    "956": "",
                    "957": "\t\t/* Remove the offset from the exponent, and store the",
                    "958": "\t\t * non-fractional value.  Subnormals require increasing the",
                    "959": "\t\t * exponent as first bit isn't the implicit bit.",
                    "960": "\t\t */",
                    "961": "\t\texpo -= 1023;",
                    "962": "\t\tif (is_subnormal) {",
                    "963": "\t\t\t*buf = '0';",
                    "964": "\t\t\t++buf;",
                    "965": "\t\t\t++expo;",
                    "966": "\t\t} else {",
                    "967": "\t\t\t*buf = '1';",
                    "968": "\t\t\t++buf;",
                    "969": "\t\t}",
                    "970": "",
                    "971": "\t\t/* If we didn't get precision from a %a specification then we",
                    "972": "\t\t * treat it as from a %a specification with no precision: full",
                    "973": "\t\t * range, zero-pruning enabled.",
                    "974": "\t\t *",
                    "975": "\t\t * Otherwise we have to cap the precision of the generated",
                    "976": "\t\t * fraction, or possibly round it.",
                    "977": "\t\t */",
                    "978": "\t\tif (!(conv->specifier_a && conv->prec_present)) {",
                    "979": "\t\t\tprecision = FRACTION_HEX;",
                    "980": "\t\t\tprune_zero = true;",
                    "981": "\t\t} else if (precision > FRACTION_HEX) {",
                    "982": "\t\t\tconv->pad0_pre_exp = precision - FRACTION_HEX;",
                    "983": "\t\t\tconv->pad_fp = true;",
                    "984": "\t\t\tprecision = FRACTION_HEX;",
                    "985": "\t\t} else if ((fract != 0)",
                    "986": "\t\t\t   && (precision < FRACTION_HEX)) {",
                    "987": "\t\t\tsize_t pos = 4 * (FRACTION_HEX - precision) - 1;",
                    "988": "\t\t\tuint64_t mask = BIT64(pos);",
                    "989": "",
                    "990": "\t\t\t/* Round only if the bit that would round is",
                    "991": "\t\t\t * set.",
                    "992": "\t\t\t */",
                    "993": "\t\t\tif ((fract & mask) != 0ULL) {",
                    "994": "\t\t\t\tfract += mask;",
                    "995": "\t\t\t}",
                    "996": "\t\t}",
                    "997": "",
                    "998": "\t\t/* Record whether we must retain the decimal point even if we",
                    "999": "\t\t * can prune zeros.",
                    "1000": "\t\t */",
                    "1001": "\t\tbool require_dp = ((fract != 0) || conv->flag_hash);",
                    "1002": "",
                    "1003": "\t\tif (require_dp || (precision != 0)) {",
                    "1004": "\t\t\t*buf = '.';",
                    "1005": "\t\t\t++buf;",
                    "1006": "\t\t}",
                    "1007": "",
                    "1008": "\t\t/* Get the fractional value as a hexadecimal string, using x",
                    "1009": "\t\t * for a and X for A.",
                    "1010": "\t\t */",
                    "1011": "\t\tstruct conversion aconv = {",
                    "1012": "\t\t\t.specifier = isupper((unsigned char)c) != 0 ? 'X' : 'x',",
                    "1013": "\t\t};",
                    "1014": "\t\tconst char *spe = *bpe;",
                    "1015": "\t\tchar *sp = bps + (spe - bps);",
                    "1016": "",
                    "1017": "\t\tif (fract != 0) {",
                    "1018": "\t\t\tsp = encode_uint(fract, &aconv, buf, spe);",
                    "1019": "\t\t}",
                    "1020": "",
                    "1021": "\t\t/* Pad out to full range since this is below the decimal",
                    "1022": "\t\t * point.",
                    "1023": "\t\t */",
                    "1024": "\t\twhile ((spe - sp) < FRACTION_HEX) {",
                    "1025": "\t\t\t--sp;",
                    "1026": "\t\t\t*sp = '0';",
                    "1027": "\t\t}",
                    "1028": "",
                    "1029": "\t\t/* Append the leading significant \"digits\". */",
                    "1030": "\t\twhile ((sp < spe) && (precision > 0)) {",
                    "1031": "\t\t\t*buf = *sp;",
                    "1032": "\t\t\t++buf;",
                    "1033": "\t\t\t++sp;",
                    "1034": "\t\t\t--precision;",
                    "1035": "\t\t}",
                    "1036": "",
                    "1037": "\t\tif (prune_zero) {",
                    "1038": "\t\t\twhile (*--buf == '0') {",
                    "1039": "\t\t\t\t;",
                    "1040": "\t\t\t}",
                    "1041": "\t\t\tif ((*buf != '.') || require_dp) {",
                    "1042": "\t\t\t\t++buf;",
                    "1043": "\t\t\t}",
                    "1044": "\t\t}",
                    "1045": "",
                    "1046": "\t\t*buf = 'p';",
                    "1047": "\t\t++buf;",
                    "1048": "\t\tif (expo >= 0) {",
                    "1049": "\t\t\t*buf = '+';",
                    "1050": "\t\t\t++buf;",
                    "1051": "\t\t} else {",
                    "1052": "\t\t\t*buf = '-';",
                    "1053": "\t\t\t++buf;",
                    "1054": "\t\t\texpo = -expo;",
                    "1055": "\t\t}",
                    "1056": "",
                    "1057": "\t\taconv.specifier = 'i';",
                    "1058": "\t\tsp = encode_uint(expo, &aconv, buf, spe);",
                    "1059": "",
                    "1060": "\t\twhile (sp < spe) {",
                    "1061": "\t\t\t*buf = *sp;",
                    "1062": "\t\t\t++buf;",
                    "1063": "\t\t\t++sp;",
                    "1064": "\t\t}",
                    "1065": "",
                    "1066": "\t\t*bpe = buf;",
                    "1067": "\t\treturn bps;",
                    "1068": "\t}",
                    "1069": "",
                    "1070": "\t/* Remainder of code operates on a 64-bit fraction, so shift up (and",
                    "1071": "\t * discard garbage from the exponent where the implicit 1 would be",
                    "1072": "\t * stored).",
                    "1073": "\t */",
                    "1074": "\tfract <<= EXPONENT_BITS;",
                    "1075": "\tfract &= ~SIGN_MASK;",
                    "1076": "",
                    "1077": "\t/* Non-zero values need normalization. */",
                    "1078": "\tif ((expo | fract) != 0) {",
                    "1079": "\t\tif (is_subnormal) {",
                    "1080": "\t\t\t/* Fraction is subnormal.  Normalize it and correct",
                    "1081": "\t\t\t * the exponent.",
                    "1082": "\t\t\t */",
                    "1083": "\t\t\tfor (fract <<= 1; (fract & BIT_63) == 0; fract <<= 1) {",
                    "1084": "\t\t\t\texpo--;",
                    "1085": "\t\t\t}",
                    "1086": "\t\t}",
                    "1087": "\t\t/* Adjust the offset exponent to be signed rather than offset,",
                    "1088": "\t\t * and set the implicit 1 bit in the (shifted) 53-bit",
                    "1089": "\t\t * fraction.",
                    "1090": "\t\t */",
                    "1091": "\t\texpo -= (1023 - 1);\t/* +1 since .1 vs 1. */",
                    "1092": "\t\tfract |= BIT_63;",
                    "1093": "\t}",
                    "1094": "",
                    "1095": "\t/*",
                    "1096": "\t * Let's consider:",
                    "1097": "\t *",
                    "1098": "\t *\tvalue = fract * 2^expo * 10^decexp",
                    "1099": "\t *",
                    "1100": "\t * Initially decexp = 0. The goal is to bring exp between",
                    "1101": "\t * 0 and -2 as the magnitude of a fractional decimal digit is 3 bits.",
                    "1102": "\t */",
                    "1103": "\tint decexp = 0;",
                    "1104": "",
                    "1105": "\twhile (expo < -2) {",
                    "1106": "\t\t/*",
                    "1107": "\t\t * Make room to allow a multiplication by 5 without overflow.",
                    "1108": "\t\t * We test only the top part for faster code.",
                    "1109": "\t\t */",
                    "1110": "\t\tdo {",
                    "1111": "\t\t\tfract >>= 1;",
                    "1112": "\t\t\texpo++;",
                    "1113": "\t\t} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));",
                    "1114": "",
                    "1115": "\t\t/* Perform fract * 5 * 2 / 10 */",
                    "1116": "\t\tfract *= 5U;",
                    "1117": "\t\texpo++;",
                    "1118": "\t\tdecexp--;",
                    "1119": "\t}",
                    "1120": "",
                    "1121": "\twhile (expo > 0) {",
                    "1122": "\t\t/*",
                    "1123": "\t\t * Perform fract / 5 / 2 * 10.",
                    "1124": "\t\t * The +2 is there to do round the result of the division",
                    "1125": "\t\t * by 5 not to lose too much precision in extreme cases.",
                    "1126": "\t\t */",
                    "1127": "\t\tfract += 2;",
                    "1128": "\t\t_ldiv5(&fract);",
                    "1129": "\t\texpo--;",
                    "1130": "\t\tdecexp++;",
                    "1131": "",
                    "1132": "\t\t/* Bring back our fractional number to full scale */",
                    "1133": "\t\tdo {",
                    "1134": "\t\t\tfract <<= 1;",
                    "1135": "\t\t\texpo--;",
                    "1136": "\t\t} while (!(fract & BIT_63));",
                    "1137": "\t}",
                    "1138": "",
                    "1139": "\t/*",
                    "1140": "\t * The binary fractional point is located somewhere above bit 63.",
                    "1141": "\t * Move it between bits 59 and 60 to give 4 bits of room to the",
                    "1142": "\t * integer part.",
                    "1143": "\t */",
                    "1144": "\tfract >>= (4 - expo);",
                    "1145": "",
                    "1146": "\tif ((c == 'g') || (c == 'G')) {",
                    "1147": "\t\t/* Use the specified precision and exponent to select the",
                    "1148": "\t\t * representation and correct the precision and zero-pruning",
                    "1149": "\t\t * in accordance with the ISO C rule.",
                    "1150": "\t\t */",
                    "1151": "\t\tif ((decexp < (-4 + 1)) || (decexp > precision)) {",
                    "1152": "\t\t\tc += 'e' - 'g';  /* e or E */",
                    "1153": "\t\t\tif (precision > 0) {",
                    "1154": "\t\t\t\tprecision--;",
                    "1155": "\t\t\t}",
                    "1156": "\t\t} else {",
                    "1157": "\t\t\tc = 'f';",
                    "1158": "\t\t\tprecision -= decexp;",
                    "1159": "\t\t}",
                    "1160": "\t\tif (!conv->flag_hash && (precision > 0)) {",
                    "1161": "\t\t\tprune_zero = true;",
                    "1162": "\t\t}",
                    "1163": "\t}",
                    "1164": "",
                    "1165": "\tint decimals;",
                    "1166": "\tif (c == 'f') {",
                    "1167": "\t\tdecimals = precision + decexp;",
                    "1168": "\t\tif (decimals < 0) {",
                    "1169": "\t\t\tdecimals = 0;",
                    "1170": "\t\t}",
                    "1171": "\t} else {",
                    "1172": "\t\tdecimals = precision + 1;",
                    "1173": "\t}",
                    "1174": "",
                    "1175": "\tint digit_count = 16;",
                    "1176": "",
                    "1177": "\tif (decimals > 16) {",
                    "1178": "\t\tdecimals = 16;",
                    "1179": "\t}",
                    "1180": "",
                    "1181": "\t/* Round the value to the last digit being printed. */",
                    "1182": "\tuint64_t round = BIT64(59); /* 0.5 */",
                    "1183": "\twhile (decimals-- != 0) {",
                    "1184": "\t\t_ldiv10(&round);",
                    "1185": "\t}",
                    "1186": "\tfract += round;",
                    "1187": "\t/* Make sure rounding didn't make fract >= 1.0 */",
                    "1188": "\tif (fract >= BIT64(60)) {",
                    "1189": "\t\t_ldiv10(&fract);",
                    "1190": "\t\tdecexp++;",
                    "1191": "\t}",
                    "1192": "",
                    "1193": "\tif (c == 'f') {",
                    "1194": "\t\tif (decexp > 0) {",
                    "1195": "\t\t\t/* Emit the digits above the decimal point. */",
                    "1196": "\t\t\twhile ((decexp > 0) && (digit_count > 0)) {",
                    "1197": "\t\t\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1198": "\t\t\t\t++buf;",
                    "1199": "\t\t\t\tdecexp--;",
                    "1200": "\t\t\t}",
                    "1201": "",
                    "1202": "\t\t\tconv->pad0_value = decexp;",
                    "1203": "",
                    "1204": "\t\t\tdecexp = 0;",
                    "1205": "\t\t} else {",
                    "1206": "\t\t\t*buf = '0';",
                    "1207": "\t\t\t++buf;",
                    "1208": "\t\t}",
                    "1209": "",
                    "1210": "\t\t/* Emit the decimal point only if required by the alternative",
                    "1211": "\t\t * format, or if more digits are to follow.",
                    "1212": "\t\t */",
                    "1213": "\t\tif (conv->flag_hash || (precision > 0)) {",
                    "1214": "\t\t\t*buf = '.';",
                    "1215": "\t\t\t++buf;",
                    "1216": "\t\t}",
                    "1217": "",
                    "1218": "\t\tif ((decexp < 0) && (precision > 0)) {",
                    "1219": "\t\t\tconv->pad0_value = -decexp;",
                    "1220": "\t\t\tif (conv->pad0_value > precision) {",
                    "1221": "\t\t\t\tconv->pad0_value = precision;",
                    "1222": "\t\t\t}",
                    "1223": "",
                    "1224": "\t\t\tprecision -= conv->pad0_value;",
                    "1225": "\t\t\tconv->pad_postdp = (conv->pad0_value > 0);",
                    "1226": "\t\t}",
                    "1227": "\t} else { /* e or E */",
                    "1228": "\t\t/* Emit the one digit before the decimal.  If it's not zero,",
                    "1229": "\t\t * this is significant so reduce the base-10 exponent.",
                    "1230": "\t\t */",
                    "1231": "\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1232": "\t\tif (*buf++ != '0') {",
                    "1233": "\t\t\tdecexp--;",
                    "1234": "\t\t}",
                    "1235": "",
                    "1236": "\t\t/* Emit the decimal point only if required by the alternative",
                    "1237": "\t\t * format, or if more digits are to follow.",
                    "1238": "\t\t */",
                    "1239": "\t\tif (conv->flag_hash || (precision > 0)) {",
                    "1240": "\t\t\t*buf = '.';",
                    "1241": "\t\t\t++buf;",
                    "1242": "\t\t}",
                    "1243": "\t}",
                    "1244": "",
                    "1245": "\twhile ((precision > 0) && (digit_count > 0)) {",
                    "1246": "\t\t*buf = _get_digit(&fract, &digit_count);",
                    "1247": "\t\t++buf;",
                    "1248": "\t\tprecision--;",
                    "1249": "\t}",
                    "1250": "",
                    "1251": "\tconv->pad0_pre_exp = precision;",
                    "1252": "",
                    "1253": "\tif (prune_zero) {",
                    "1254": "\t\tconv->pad0_pre_exp = 0;",
                    "1255": "\t\tdo {",
                    "1256": "\t\t\t--buf;",
                    "1257": "\t\t} while (*buf == '0');",
                    "1258": "\t\tif (*buf != '.') {",
                    "1259": "\t\t\t++buf;",
                    "1260": "\t\t}",
                    "1261": "\t}",
                    "1262": "",
                    "1263": "\t/* Emit the explicit exponent, if format requires it. */",
                    "1264": "\tif ((c == 'e') || (c == 'E')) {",
                    "1265": "\t\t*buf = c;",
                    "1266": "\t\t++buf;",
                    "1267": "\t\tif (decexp < 0) {",
                    "1268": "\t\t\tdecexp = -decexp;",
                    "1269": "\t\t\t*buf = '-';",
                    "1270": "\t\t\t++buf;",
                    "1271": "\t\t} else {",
                    "1272": "\t\t\t*buf = '+';",
                    "1273": "\t\t\t++buf;",
                    "1274": "\t\t}",
                    "1275": "",
                    "1276": "\t\t/* At most 3 digits to the decimal.  Spit them out. */",
                    "1277": "\t\tif (decexp >= 100) {",
                    "1278": "\t\t\t*buf = (decexp / 100) + '0';",
                    "1279": "\t\t\t++buf;",
                    "1280": "\t\t\tdecexp %= 100;",
                    "1281": "\t\t}",
                    "1282": "",
                    "1283": "\t\tbuf[0] = (decexp / 10) + '0';",
                    "1284": "\t\tbuf[1] = (decexp % 10) + '0';",
                    "1285": "\t\tbuf += 2;",
                    "1286": "\t}",
                    "1287": "",
                    "1288": "\t/* Cache whether there's padding required */",
                    "1289": "\tconv->pad_fp = (conv->pad0_value > 0)",
                    "1290": "\t\t|| (conv->pad0_pre_exp > 0);",
                    "1291": "",
                    "1292": "\t/* Set the end of the encoded sequence, and return its start.  Also",
                    "1293": "\t * store EOS as a non-digit/non-decimal value so we don't have to",
                    "1294": "\t * check against bpe when iterating in multiple places.",
                    "1295": "\t */",
                    "1296": "\t*bpe = buf;",
                    "1297": "\t*buf = 0;",
                    "1298": "\treturn bps;",
                    "1299": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_conn_input": {
            "name": "net_conn_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 847,
            "function_content": [
                "#endif /* defined(CONFIG_NET_SOCKETS_CAN) */\nenum net_verdict net_conn_input(struct net_pkt *pkt,\n\t\t\t\tunion net_ip_header *ip_hdr,\n\t\t\t\tuint8_t proto,\n\t\t\t\tunion net_proto_header *proto_hdr)\n{\n\tstruct net_if *pkt_iface = net_pkt_iface(pkt);\n\tuint8_t pkt_family = net_pkt_family(pkt);\n\tuint16_t src_port = 0U, dst_port = 0U;\n\n\tif (!net_pkt_filter_local_in_recv_ok(pkt)) {\n\t\t/* drop the packet */\n\t\tnet_stats_update_filter_rx_local_drop(net_pkt_iface(pkt));\n\t\treturn NET_DROP;\n\t}\n\n\tif (pkt_family == NET_AF_INET || pkt_family == NET_AF_INET6) {\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) && proto == NET_IPPROTO_UDP) {\n\t\t\tsrc_port = proto_hdr->udp->src_port;\n\t\t\tdst_port = proto_hdr->udp->dst_port;\n\t\t} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == NET_IPPROTO_TCP) {\n\t\t\tif (proto_hdr->tcp == NULL) {\n\t\t\t\treturn NET_DROP;\n\t\t\t}\n\t\t\tsrc_port = proto_hdr->tcp->src_port;\n\t\t\tdst_port = proto_hdr->tcp->dst_port;\n\t\t}\n\t\tif (!conn_are_endpoints_valid(pkt, pkt_family, ip_hdr,\n\t\t\t\t\t      src_port, dst_port)) {\n\t\t\tNET_DBG(\"Dropping invalid src/dst end-points packet\");\n\t\t\treturn NET_DROP;\n\t\t}\n\t} else {\n\t\tNET_DBG(\"No suitable protocol handler configured\");\n\t\treturn NET_DROP;\n\t}\n\n\tNET_DBG(\"Check %s listener for pkt %p src port %u dst port %u\"\n\t\t\" family %d\", net_proto2str(net_pkt_family(pkt), proto), pkt,\n\t\tnet_ntohs(src_port), net_ntohs(dst_port), net_pkt_family(pkt));\n\n\tstruct net_conn *best_match = NULL;\n\tint16_t best_rank = -1;\n\tbool is_mcast_pkt = false;\n\tbool mcast_pkt_delivered = false;\n\tbool is_bcast_pkt = false;\n\tstruct net_conn *conn;\n\tnet_conn_cb_t cb = NULL;\n\tvoid *user_data = NULL;\n\n\t/* If we receive a packet with multicast destination address, we might\n\t * need to deliver the packet to multiple recipients.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == NET_AF_INET) {\n\t\tif (net_ipv4_is_addr_mcast_raw(ip_hdr->ipv4->dst)) {\n\t\t\tis_mcast_pkt = true;\n\t\t} else if (net_if_ipv4_is_addr_bcast_raw(pkt_iface,\n\t\t\t\t\t\t\t ip_hdr->ipv4->dst)) {\n\t\t\tis_bcast_pkt = true;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV6) && pkt_family == NET_AF_INET6) {\n\t\tis_mcast_pkt = net_ipv6_is_addr_mcast_raw(ip_hdr->ipv6->dst);\n\t}\n\n\tk_mutex_lock(&conn_lock, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {\n\t\t/* Is the candidate connection matching the packet's interface? */\n\t\tif (!is_iface_matching(conn, pkt)) {\n\t\t\tcontinue; /* wrong interface */\n\t\t}\n\n\t\t/* Is the candidate connection matching the packet's protocol family? */\n\t\tif (conn->family != NET_AF_UNSPEC && conn->family != pkt_family) {\n\t\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6)) {\n\t\t\t\tif (!(conn->family == NET_AF_INET6 && pkt_family == NET_AF_INET &&\n\t\t\t\t      !conn->v6only && conn->type != NET_SOCK_RAW)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue; /* wrong protocol family */\n\t\t\t}\n\n\t\t\t/* We might have a match for v4-to-v6 mapping, check more */\n\t\t}\n\n\t\t/* Is the candidate connection matching the packet's protocol within the family? */\n\t\tif (conn->proto != proto) {\n\t\t\tcontinue; /* wrong protocol */\n\t\t}\n\n\t\t/* Apply protocol-specific matching criteria... */\n\t\tuint8_t conn_family = conn->family;\n\n\t\tif ((IS_ENABLED(CONFIG_NET_UDP) || IS_ENABLED(CONFIG_NET_TCP)) &&\n\t\t    (conn_family == NET_AF_INET || conn_family == NET_AF_INET6 ||\n\t\t     conn_family == NET_AF_UNSPEC)) {\n\t\t\t/* Is the candidate connection matching the packet's TCP/UDP\n\t\t\t * address and port?\n\t\t\t */\n\t\t\tif ((conn->flags & NET_CONN_REMOTE_PORT_SPEC) != 0 &&\n\t\t\t    net_sin(&conn->remote_addr)->sin_port != src_port) {\n\t\t\t\tcontinue; /* wrong remote port */\n\t\t\t}\n\n\t\t\tif ((conn->flags & NET_CONN_LOCAL_PORT_SPEC) != 0 &&\n\t\t\t    net_sin(&conn->local_addr)->sin_port != dst_port) {\n\t\t\t\tcontinue; /* wrong local port */\n\t\t\t}\n\n\t\t\tif ((conn->flags & NET_CONN_REMOTE_ADDR_SET) != 0 &&\n\t\t\t    !conn_addr_cmp(pkt, ip_hdr, &conn->remote_addr, true)) {\n\t\t\t\tcontinue; /* wrong remote address */\n\t\t\t}\n\n\t\t\tif ((conn->flags & NET_CONN_LOCAL_ADDR_SET) != 0 &&\n\t\t\t    !conn_addr_cmp(pkt, ip_hdr, &conn->local_addr, false)) {\n\n\t\t\t\t/* Check if we could do a v4-mapping-to-v6 and the IPv6 socket\n\t\t\t\t * has no IPV6_V6ONLY option set and if the local IPV6 address\n\t\t\t\t * is unspecified, then we could accept a connection from IPv4\n\t\t\t\t * address by mapping it to IPv6 address.\n\t\t\t\t */\n\t\t\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6)) {\n\t\t\t\t\tif (!(conn->family == NET_AF_INET6 &&\n\t\t\t\t\t      pkt_family == NET_AF_INET &&\n\t\t\t\t\t      !conn->v6only &&\n\t\t\t\t\t      net_ipv6_is_addr_unspecified(\n\t\t\t\t\t\t      &net_sin6(&conn->local_addr)->sin6_addr))) {\n\t\t\t\t\t\tcontinue; /* wrong local address */\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue; /* wrong local address */\n\t\t\t\t}\n\n\t\t\t\t/* We might have a match for v4-to-v6 mapping,\n\t\t\t\t * continue with rank checking.\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif (best_rank < NET_CONN_RANK(conn->flags)) {\n\t\t\t\tstruct net_pkt *mcast_pkt;\n\n\t\t\t\tif (!is_mcast_pkt) {\n\t\t\t\t\tbest_rank = NET_CONN_RANK(conn->flags);\n\t\t\t\t\tbest_match = conn;\n\n\t\t\t\t\tcontinue; /* found a match - but maybe not yet the best */\n\t\t\t\t}\n\n\t\t\t\t/* If we have a multicast packet, and we found\n\t\t\t\t * a match, then deliver the packet immediately\n\t\t\t\t * to the handler. As there might be several\n\t\t\t\t * sockets interested about these, we need to\n\t\t\t\t * clone the received pkt.\n\t\t\t\t */\n\n\t\t\t\tNET_DBG(\"[%p] mcast match found cb %p ud %p\", conn, conn->cb,\n\t\t\t\t\tconn->user_data);\n\n\t\t\t\tmcast_pkt = net_pkt_clone(\n\t\t\t\t\tpkt, K_MSEC(CONFIG_NET_CONN_PACKET_CLONE_TIMEOUT));\n\t\t\t\tif (!mcast_pkt) {\n\t\t\t\t\tk_mutex_unlock(&conn_lock);\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\n\t\t\t\tif (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==\n\t\t\t\t    NET_DROP) {\n\t\t\t\t\tnet_stats_update_per_proto_drop(pkt_iface, proto);\n\t\t\t\t\tnet_pkt_unref(mcast_pkt);\n\t\t\t\t} else {\n\t\t\t\t\tnet_stats_update_per_proto_recv(pkt_iface, proto);\n\t\t\t\t}\n\n\t\t\t\tmcast_pkt_delivered = true;\n\t\t\t}\n\t\t}\n\t} /* loop end */\n\n\tif (best_match != NULL) {\n\t\tcb = best_match->cb;\n\t\tuser_data = best_match->user_data;\n\t}\n\n\tk_mutex_unlock(&conn_lock);\n\n\tif (is_mcast_pkt && mcast_pkt_delivered) {\n\t\t/* As one or more multicast packets\n\t\t * have already been delivered in the loop above,\n\t\t * we shall not call the callback again here.\n\t\t */\n\t\tnet_pkt_unref(pkt);\n\t\treturn NET_OK;\n\t}\n\n\tif (cb != NULL) {\n\t\tNET_DBG(\"[%p] match found cb %p ud %p rank 0x%02x\", best_match, cb,\n\t\t\tuser_data, NET_CONN_RANK(best_match->flags));\n\n\t\tif (cb(best_match, pkt, ip_hdr, proto_hdr, user_data)\n\t\t\t\t== NET_DROP) {\n\t\t\tgoto drop;\n\t\t}\n\n\t\tnet_stats_update_per_proto_recv(pkt_iface, proto);\n\n\t\treturn NET_OK;\n\t}\n\n\tNET_DBG(\"No match found.\");\n\n\tif ((pkt_family == NET_AF_INET || pkt_family == NET_AF_INET6) &&\n\t    !(is_mcast_pkt || is_bcast_pkt)) {\n\t\tif (IS_ENABLED(CONFIG_NET_TCP) && proto == NET_IPPROTO_TCP &&\n\t\t    IS_ENABLED(CONFIG_NET_TCP_REJECT_CONN_WITH_RST)) {\n\t\t\tnet_tcp_reply_rst(pkt);\n\t\t\tnet_stats_update_tcp_seg_connrst(pkt_iface);\n\t\t} else {\n\t\t\tconn_send_icmp_error(pkt);\n\t\t}\n\t}\n\ndrop:\n\tnet_stats_update_per_proto_drop(pkt_iface, proto);\n\n\treturn NET_DROP;\n}\n",
                {
                    "847": "enum net_verdict net_conn_input(struct net_pkt *pkt,",
                    "848": "\t\t\t\tunion net_ip_header *ip_hdr,",
                    "849": "\t\t\t\tuint8_t proto,",
                    "850": "\t\t\t\tunion net_proto_header *proto_hdr)",
                    "851": "{",
                    "852": "\tstruct net_if *pkt_iface = net_pkt_iface(pkt);",
                    "853": "\tuint8_t pkt_family = net_pkt_family(pkt);",
                    "854": "\tuint16_t src_port = 0U, dst_port = 0U;",
                    "855": "",
                    "856": "\tif (!net_pkt_filter_local_in_recv_ok(pkt)) {",
                    "857": "\t\t/* drop the packet */",
                    "858": "\t\tnet_stats_update_filter_rx_local_drop(net_pkt_iface(pkt));",
                    "859": "\t\treturn NET_DROP;",
                    "860": "\t}",
                    "861": "",
                    "862": "\tif (pkt_family == NET_AF_INET || pkt_family == NET_AF_INET6) {",
                    "863": "\t\tif (IS_ENABLED(CONFIG_NET_UDP) && proto == NET_IPPROTO_UDP) {",
                    "864": "\t\t\tsrc_port = proto_hdr->udp->src_port;",
                    "865": "\t\t\tdst_port = proto_hdr->udp->dst_port;",
                    "866": "\t\t} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == NET_IPPROTO_TCP) {",
                    "867": "\t\t\tif (proto_hdr->tcp == NULL) {",
                    "868": "\t\t\t\treturn NET_DROP;",
                    "869": "\t\t\t}",
                    "870": "\t\t\tsrc_port = proto_hdr->tcp->src_port;",
                    "871": "\t\t\tdst_port = proto_hdr->tcp->dst_port;",
                    "872": "\t\t}",
                    "873": "\t\tif (!conn_are_endpoints_valid(pkt, pkt_family, ip_hdr,",
                    "874": "\t\t\t\t\t      src_port, dst_port)) {",
                    "875": "\t\t\tNET_DBG(\"Dropping invalid src/dst end-points packet\");",
                    "876": "\t\t\treturn NET_DROP;",
                    "877": "\t\t}",
                    "878": "\t} else {",
                    "879": "\t\tNET_DBG(\"No suitable protocol handler configured\");",
                    "880": "\t\treturn NET_DROP;",
                    "881": "\t}",
                    "882": "",
                    "883": "\tNET_DBG(\"Check %s listener for pkt %p src port %u dst port %u\"",
                    "884": "\t\t\" family %d\", net_proto2str(net_pkt_family(pkt), proto), pkt,",
                    "885": "\t\tnet_ntohs(src_port), net_ntohs(dst_port), net_pkt_family(pkt));",
                    "886": "",
                    "887": "\tstruct net_conn *best_match = NULL;",
                    "888": "\tint16_t best_rank = -1;",
                    "889": "\tbool is_mcast_pkt = false;",
                    "890": "\tbool mcast_pkt_delivered = false;",
                    "891": "\tbool is_bcast_pkt = false;",
                    "892": "\tstruct net_conn *conn;",
                    "893": "\tnet_conn_cb_t cb = NULL;",
                    "894": "\tvoid *user_data = NULL;",
                    "895": "",
                    "896": "\t/* If we receive a packet with multicast destination address, we might",
                    "897": "\t * need to deliver the packet to multiple recipients.",
                    "898": "\t */",
                    "899": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == NET_AF_INET) {",
                    "900": "\t\tif (net_ipv4_is_addr_mcast_raw(ip_hdr->ipv4->dst)) {",
                    "901": "\t\t\tis_mcast_pkt = true;",
                    "902": "\t\t} else if (net_if_ipv4_is_addr_bcast_raw(pkt_iface,",
                    "903": "\t\t\t\t\t\t\t ip_hdr->ipv4->dst)) {",
                    "904": "\t\t\tis_bcast_pkt = true;",
                    "905": "\t\t}",
                    "906": "\t} else if (IS_ENABLED(CONFIG_NET_IPV6) && pkt_family == NET_AF_INET6) {",
                    "907": "\t\tis_mcast_pkt = net_ipv6_is_addr_mcast_raw(ip_hdr->ipv6->dst);",
                    "908": "\t}",
                    "909": "",
                    "910": "\tk_mutex_lock(&conn_lock, K_FOREVER);",
                    "911": "",
                    "912": "\tSYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {",
                    "913": "\t\t/* Is the candidate connection matching the packet's interface? */",
                    "914": "\t\tif (!is_iface_matching(conn, pkt)) {",
                    "915": "\t\t\tcontinue; /* wrong interface */",
                    "916": "\t\t}",
                    "917": "",
                    "918": "\t\t/* Is the candidate connection matching the packet's protocol family? */",
                    "919": "\t\tif (conn->family != NET_AF_UNSPEC && conn->family != pkt_family) {",
                    "920": "\t\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6)) {",
                    "921": "\t\t\t\tif (!(conn->family == NET_AF_INET6 && pkt_family == NET_AF_INET &&",
                    "922": "\t\t\t\t      !conn->v6only && conn->type != NET_SOCK_RAW)) {",
                    "923": "\t\t\t\t\tcontinue;",
                    "924": "\t\t\t\t}",
                    "925": "\t\t\t} else {",
                    "926": "\t\t\t\tcontinue; /* wrong protocol family */",
                    "927": "\t\t\t}",
                    "928": "",
                    "929": "\t\t\t/* We might have a match for v4-to-v6 mapping, check more */",
                    "930": "\t\t}",
                    "931": "",
                    "932": "\t\t/* Is the candidate connection matching the packet's protocol within the family? */",
                    "933": "\t\tif (conn->proto != proto) {",
                    "934": "\t\t\tcontinue; /* wrong protocol */",
                    "935": "\t\t}",
                    "936": "",
                    "937": "\t\t/* Apply protocol-specific matching criteria... */",
                    "938": "\t\tuint8_t conn_family = conn->family;",
                    "939": "",
                    "940": "\t\tif ((IS_ENABLED(CONFIG_NET_UDP) || IS_ENABLED(CONFIG_NET_TCP)) &&",
                    "941": "\t\t    (conn_family == NET_AF_INET || conn_family == NET_AF_INET6 ||",
                    "942": "\t\t     conn_family == NET_AF_UNSPEC)) {",
                    "943": "\t\t\t/* Is the candidate connection matching the packet's TCP/UDP",
                    "944": "\t\t\t * address and port?",
                    "945": "\t\t\t */",
                    "946": "\t\t\tif ((conn->flags & NET_CONN_REMOTE_PORT_SPEC) != 0 &&",
                    "947": "\t\t\t    net_sin(&conn->remote_addr)->sin_port != src_port) {",
                    "948": "\t\t\t\tcontinue; /* wrong remote port */",
                    "949": "\t\t\t}",
                    "950": "",
                    "951": "\t\t\tif ((conn->flags & NET_CONN_LOCAL_PORT_SPEC) != 0 &&",
                    "952": "\t\t\t    net_sin(&conn->local_addr)->sin_port != dst_port) {",
                    "953": "\t\t\t\tcontinue; /* wrong local port */",
                    "954": "\t\t\t}",
                    "955": "",
                    "956": "\t\t\tif ((conn->flags & NET_CONN_REMOTE_ADDR_SET) != 0 &&",
                    "957": "\t\t\t    !conn_addr_cmp(pkt, ip_hdr, &conn->remote_addr, true)) {",
                    "958": "\t\t\t\tcontinue; /* wrong remote address */",
                    "959": "\t\t\t}",
                    "960": "",
                    "961": "\t\t\tif ((conn->flags & NET_CONN_LOCAL_ADDR_SET) != 0 &&",
                    "962": "\t\t\t    !conn_addr_cmp(pkt, ip_hdr, &conn->local_addr, false)) {",
                    "963": "",
                    "964": "\t\t\t\t/* Check if we could do a v4-mapping-to-v6 and the IPv6 socket",
                    "965": "\t\t\t\t * has no IPV6_V6ONLY option set and if the local IPV6 address",
                    "966": "\t\t\t\t * is unspecified, then we could accept a connection from IPv4",
                    "967": "\t\t\t\t * address by mapping it to IPv6 address.",
                    "968": "\t\t\t\t */",
                    "969": "\t\t\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6)) {",
                    "970": "\t\t\t\t\tif (!(conn->family == NET_AF_INET6 &&",
                    "971": "\t\t\t\t\t      pkt_family == NET_AF_INET &&",
                    "972": "\t\t\t\t\t      !conn->v6only &&",
                    "973": "\t\t\t\t\t      net_ipv6_is_addr_unspecified(",
                    "974": "\t\t\t\t\t\t      &net_sin6(&conn->local_addr)->sin6_addr))) {",
                    "975": "\t\t\t\t\t\tcontinue; /* wrong local address */",
                    "976": "\t\t\t\t\t}",
                    "977": "\t\t\t\t} else {",
                    "978": "\t\t\t\t\tcontinue; /* wrong local address */",
                    "979": "\t\t\t\t}",
                    "980": "",
                    "981": "\t\t\t\t/* We might have a match for v4-to-v6 mapping,",
                    "982": "\t\t\t\t * continue with rank checking.",
                    "983": "\t\t\t\t */",
                    "984": "\t\t\t}",
                    "985": "",
                    "986": "\t\t\tif (best_rank < NET_CONN_RANK(conn->flags)) {",
                    "987": "\t\t\t\tstruct net_pkt *mcast_pkt;",
                    "988": "",
                    "989": "\t\t\t\tif (!is_mcast_pkt) {",
                    "990": "\t\t\t\t\tbest_rank = NET_CONN_RANK(conn->flags);",
                    "991": "\t\t\t\t\tbest_match = conn;",
                    "992": "",
                    "993": "\t\t\t\t\tcontinue; /* found a match - but maybe not yet the best */",
                    "994": "\t\t\t\t}",
                    "995": "",
                    "996": "\t\t\t\t/* If we have a multicast packet, and we found",
                    "997": "\t\t\t\t * a match, then deliver the packet immediately",
                    "998": "\t\t\t\t * to the handler. As there might be several",
                    "999": "\t\t\t\t * sockets interested about these, we need to",
                    "1000": "\t\t\t\t * clone the received pkt.",
                    "1001": "\t\t\t\t */",
                    "1002": "",
                    "1003": "\t\t\t\tNET_DBG(\"[%p] mcast match found cb %p ud %p\", conn, conn->cb,",
                    "1004": "\t\t\t\t\tconn->user_data);",
                    "1005": "",
                    "1006": "\t\t\t\tmcast_pkt = net_pkt_clone(",
                    "1007": "\t\t\t\t\tpkt, K_MSEC(CONFIG_NET_CONN_PACKET_CLONE_TIMEOUT));",
                    "1008": "\t\t\t\tif (!mcast_pkt) {",
                    "1009": "\t\t\t\t\tk_mutex_unlock(&conn_lock);",
                    "1010": "\t\t\t\t\tgoto drop;",
                    "1011": "\t\t\t\t}",
                    "1012": "",
                    "1013": "\t\t\t\tif (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==",
                    "1014": "\t\t\t\t    NET_DROP) {",
                    "1015": "\t\t\t\t\tnet_stats_update_per_proto_drop(pkt_iface, proto);",
                    "1016": "\t\t\t\t\tnet_pkt_unref(mcast_pkt);",
                    "1017": "\t\t\t\t} else {",
                    "1018": "\t\t\t\t\tnet_stats_update_per_proto_recv(pkt_iface, proto);",
                    "1019": "\t\t\t\t}",
                    "1020": "",
                    "1021": "\t\t\t\tmcast_pkt_delivered = true;",
                    "1022": "\t\t\t}",
                    "1023": "\t\t}",
                    "1024": "\t} /* loop end */",
                    "1025": "",
                    "1026": "\tif (best_match != NULL) {",
                    "1027": "\t\tcb = best_match->cb;",
                    "1028": "\t\tuser_data = best_match->user_data;",
                    "1029": "\t}",
                    "1030": "",
                    "1031": "\tk_mutex_unlock(&conn_lock);",
                    "1032": "",
                    "1033": "\tif (is_mcast_pkt && mcast_pkt_delivered) {",
                    "1034": "\t\t/* As one or more multicast packets",
                    "1035": "\t\t * have already been delivered in the loop above,",
                    "1036": "\t\t * we shall not call the callback again here.",
                    "1037": "\t\t */",
                    "1038": "\t\tnet_pkt_unref(pkt);",
                    "1039": "\t\treturn NET_OK;",
                    "1040": "\t}",
                    "1041": "",
                    "1042": "\tif (cb != NULL) {",
                    "1043": "\t\tNET_DBG(\"[%p] match found cb %p ud %p rank 0x%02x\", best_match, cb,",
                    "1044": "\t\t\tuser_data, NET_CONN_RANK(best_match->flags));",
                    "1045": "",
                    "1046": "\t\tif (cb(best_match, pkt, ip_hdr, proto_hdr, user_data)",
                    "1047": "\t\t\t\t== NET_DROP) {",
                    "1048": "\t\t\tgoto drop;",
                    "1049": "\t\t}",
                    "1050": "",
                    "1051": "\t\tnet_stats_update_per_proto_recv(pkt_iface, proto);",
                    "1052": "",
                    "1053": "\t\treturn NET_OK;",
                    "1054": "\t}",
                    "1055": "",
                    "1056": "\tNET_DBG(\"No match found.\");",
                    "1057": "",
                    "1058": "\tif ((pkt_family == NET_AF_INET || pkt_family == NET_AF_INET6) &&",
                    "1059": "\t    !(is_mcast_pkt || is_bcast_pkt)) {",
                    "1060": "\t\tif (IS_ENABLED(CONFIG_NET_TCP) && proto == NET_IPPROTO_TCP &&",
                    "1061": "\t\t    IS_ENABLED(CONFIG_NET_TCP_REJECT_CONN_WITH_RST)) {",
                    "1062": "\t\t\tnet_tcp_reply_rst(pkt);",
                    "1063": "\t\t\tnet_stats_update_tcp_seg_connrst(pkt_iface);",
                    "1064": "\t\t} else {",
                    "1065": "\t\t\tconn_send_icmp_error(pkt);",
                    "1066": "\t\t}",
                    "1067": "\t}",
                    "1068": "",
                    "1069": "drop:",
                    "1070": "\tnet_stats_update_per_proto_drop(pkt_iface, proto);",
                    "1071": "",
                    "1072": "\treturn NET_DROP;",
                    "1073": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "conn_addr_cmp": {
            "name": "conn_addr_cmp",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 504,
            "function_content": [
                "/* Check if we already have identical connection handler installed. */\nstatic bool conn_addr_cmp(struct net_pkt *pkt,\n\t\t\t  union net_ip_header *ip_hdr,\n\t\t\t  struct net_sockaddr *addr,\n\t\t\t  bool is_remote)\n{\n\tif (addr->sa_family != net_pkt_family(pkt)) {\n\t\treturn false;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_pkt_family(pkt) == NET_AF_INET6 &&\n\t    addr->sa_family == NET_AF_INET6) {\n\t\tuint8_t *addr6;\n\n\t\tif (is_remote) {\n\t\t\taddr6 = ip_hdr->ipv6->src;\n\t\t} else {\n\t\t\taddr6 = ip_hdr->ipv6->dst;\n\t\t}\n\n\t\tif (!net_ipv6_is_addr_unspecified(\n\t\t\t    &net_sin6(addr)->sin6_addr)) {\n\t\t\tif (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,\n\t\t\t\t\t\t   addr6)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t   net_pkt_family(pkt) == NET_AF_INET &&\n\t\t   addr->sa_family == NET_AF_INET) {\n\t\tuint8_t *addr4;\n\n\t\tif (is_remote) {\n\t\t\taddr4 = ip_hdr->ipv4->src;\n\t\t} else {\n\t\t\taddr4 = ip_hdr->ipv4->dst;\n\t\t}\n\n\t\tif (net_sin(addr)->sin_addr.s_addr) {\n\t\t\tif (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,\n\t\t\t\t\t\t   addr4)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n",
                {
                    "504": "static bool conn_addr_cmp(struct net_pkt *pkt,",
                    "505": "\t\t\t  union net_ip_header *ip_hdr,",
                    "506": "\t\t\t  struct net_sockaddr *addr,",
                    "507": "\t\t\t  bool is_remote)",
                    "508": "{",
                    "509": "\tif (addr->sa_family != net_pkt_family(pkt)) {",
                    "510": "\t\treturn false;",
                    "511": "\t}",
                    "512": "",
                    "513": "\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "514": "\t    net_pkt_family(pkt) == NET_AF_INET6 &&",
                    "515": "\t    addr->sa_family == NET_AF_INET6) {",
                    "516": "\t\tuint8_t *addr6;",
                    "517": "",
                    "518": "\t\tif (is_remote) {",
                    "519": "\t\t\taddr6 = ip_hdr->ipv6->src;",
                    "520": "\t\t} else {",
                    "521": "\t\t\taddr6 = ip_hdr->ipv6->dst;",
                    "522": "\t\t}",
                    "523": "",
                    "524": "\t\tif (!net_ipv6_is_addr_unspecified(",
                    "525": "\t\t\t    &net_sin6(addr)->sin6_addr)) {",
                    "526": "\t\t\tif (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,",
                    "527": "\t\t\t\t\t\t   addr6)) {",
                    "528": "\t\t\t\treturn false;",
                    "529": "\t\t\t}",
                    "530": "\t\t}",
                    "531": "",
                    "532": "\t\treturn true;",
                    "533": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "534": "\t\t   net_pkt_family(pkt) == NET_AF_INET &&",
                    "535": "\t\t   addr->sa_family == NET_AF_INET) {",
                    "536": "\t\tuint8_t *addr4;",
                    "537": "",
                    "538": "\t\tif (is_remote) {",
                    "539": "\t\t\taddr4 = ip_hdr->ipv4->src;",
                    "540": "\t\t} else {",
                    "541": "\t\t\taddr4 = ip_hdr->ipv4->dst;",
                    "542": "\t\t}",
                    "543": "",
                    "544": "\t\tif (net_sin(addr)->sin_addr.s_addr) {",
                    "545": "\t\t\tif (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,",
                    "546": "\t\t\t\t\t\t   addr4)) {",
                    "547": "\t\t\t\treturn false;",
                    "548": "\t\t\t}",
                    "549": "\t\t}",
                    "550": "\t}",
                    "551": "",
                    "552": "\treturn true;",
                    "553": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_conn_change_local": {
            "name": "net_conn_change_local",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 325,
            "function_content": [
                "/* Check if we already have identical connection handler installed. */\nstatic int net_conn_change_local(struct net_conn *conn,\n\t\t\t\t const struct net_sockaddr *local_addr,\n\t\t\t\t uint16_t local_port)\n{\n\tNET_DBG(\"[%zu] connection handler %p changed local\",\n\t\tconn - conns, conn);\n\n\tif (local_addr != NULL) {\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t    local_addr->sa_family == NET_AF_INET6) {\n\t\t\tmemcpy(&conn->local_addr, local_addr,\n\t\t\t       sizeof(struct net_sockaddr_in6));\n\n\t\t\tif (!net_ipv6_is_addr_unspecified(\n\t\t\t\t\t&net_sin6(local_addr)->sin6_addr)) {\n\t\t\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SPEC;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t\t   local_addr->sa_family == NET_AF_INET) {\n\t\t\tmemcpy(&conn->local_addr, local_addr,\n\t\t\t       sizeof(struct net_sockaddr_in));\n\n\t\t\tif (net_sin(local_addr)->sin_addr.s_addr) {\n\t\t\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SPEC;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&\n\t\t\t   local_addr->sa_family == NET_AF_CAN) {\n\t\t\tmemcpy(&conn->local_addr, local_addr,\n\t\t\t       sizeof(struct net_sockaddr_can));\n\t\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&\n\t\t\t   local_addr->sa_family == NET_AF_PACKET) {\n\t\t\tmemcpy(&conn->local_addr, local_addr,\n\t\t\t       sizeof(struct net_sockaddr_ll));\n\t\t} else {\n\t\t\tNET_ERR(\"Local address family not set\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SET;\n\t} else {\n\t\tconn->flags &= ~NET_CONN_LOCAL_ADDR_SPEC;\n\t\tconn->flags &= ~NET_CONN_LOCAL_ADDR_SET;\n\t}\n\n\tif (local_port > 0U) {\n\t\tconn->flags |= NET_CONN_LOCAL_PORT_SPEC;\n\t\tnet_sin(&conn->local_addr)->sin_port = net_htons(local_port);\n\t} else {\n\t\tconn->flags &= ~NET_CONN_LOCAL_PORT_SPEC;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "325": "static int net_conn_change_local(struct net_conn *conn,",
                    "326": "\t\t\t\t const struct net_sockaddr *local_addr,",
                    "327": "\t\t\t\t uint16_t local_port)",
                    "328": "{",
                    "329": "\tNET_DBG(\"[%zu] connection handler %p changed local\",",
                    "330": "\t\tconn - conns, conn);",
                    "331": "",
                    "332": "\tif (local_addr != NULL) {",
                    "333": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "334": "\t\t    local_addr->sa_family == NET_AF_INET6) {",
                    "335": "\t\t\tmemcpy(&conn->local_addr, local_addr,",
                    "336": "\t\t\t       sizeof(struct net_sockaddr_in6));",
                    "337": "",
                    "338": "\t\t\tif (!net_ipv6_is_addr_unspecified(",
                    "339": "\t\t\t\t\t&net_sin6(local_addr)->sin6_addr)) {",
                    "340": "\t\t\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SPEC;",
                    "341": "\t\t\t}",
                    "342": "\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "343": "\t\t\t   local_addr->sa_family == NET_AF_INET) {",
                    "344": "\t\t\tmemcpy(&conn->local_addr, local_addr,",
                    "345": "\t\t\t       sizeof(struct net_sockaddr_in));",
                    "346": "",
                    "347": "\t\t\tif (net_sin(local_addr)->sin_addr.s_addr) {",
                    "348": "\t\t\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SPEC;",
                    "349": "\t\t\t}",
                    "350": "\t\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&",
                    "351": "\t\t\t   local_addr->sa_family == NET_AF_CAN) {",
                    "352": "\t\t\tmemcpy(&conn->local_addr, local_addr,",
                    "353": "\t\t\t       sizeof(struct net_sockaddr_can));",
                    "354": "\t\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&",
                    "355": "\t\t\t   local_addr->sa_family == NET_AF_PACKET) {",
                    "356": "\t\t\tmemcpy(&conn->local_addr, local_addr,",
                    "357": "\t\t\t       sizeof(struct net_sockaddr_ll));",
                    "358": "\t\t} else {",
                    "359": "\t\t\tNET_ERR(\"Local address family not set\");",
                    "360": "\t\t\treturn -EINVAL;",
                    "361": "\t\t}",
                    "362": "",
                    "363": "\t\tconn->flags |= NET_CONN_LOCAL_ADDR_SET;",
                    "364": "\t} else {",
                    "365": "\t\tconn->flags &= ~NET_CONN_LOCAL_ADDR_SPEC;",
                    "366": "\t\tconn->flags &= ~NET_CONN_LOCAL_ADDR_SET;",
                    "367": "\t}",
                    "368": "",
                    "369": "\tif (local_port > 0U) {",
                    "370": "\t\tconn->flags |= NET_CONN_LOCAL_PORT_SPEC;",
                    "371": "\t\tnet_sin(&conn->local_addr)->sin_port = net_htons(local_port);",
                    "372": "\t} else {",
                    "373": "\t\tconn->flags &= ~NET_CONN_LOCAL_PORT_SPEC;",
                    "374": "\t}",
                    "375": "",
                    "376": "\treturn 0;",
                    "377": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_conn_change_remote": {
            "name": "net_conn_change_remote",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 278,
            "function_content": [
                "/* Check if we already have identical connection handler installed. */\nstatic int net_conn_change_remote(struct net_conn *conn,\n\t\t\t\t  const struct net_sockaddr *remote_addr,\n\t\t\t\t  uint16_t remote_port)\n{\n\tNET_DBG(\"[%zu] connection handler %p changed remote\",\n\t\tconn - conns, conn);\n\n\tif (remote_addr) {\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t    remote_addr->sa_family == NET_AF_INET6) {\n\t\t\tmemcpy(&conn->remote_addr, remote_addr,\n\t\t\t       sizeof(struct net_sockaddr_in6));\n\n\t\t\tif (!net_ipv6_is_addr_unspecified(\n\t\t\t\t    &net_sin6(remote_addr)->\n\t\t\t\t    sin6_addr)) {\n\t\t\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SPEC;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t\t   remote_addr->sa_family == NET_AF_INET) {\n\t\t\tmemcpy(&conn->remote_addr, remote_addr,\n\t\t\t       sizeof(struct net_sockaddr_in));\n\n\t\t\tif (net_sin(remote_addr)->sin_addr.s_addr) {\n\t\t\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SPEC;\n\t\t\t}\n\t\t} else {\n\t\t\tNET_ERR(\"Remote address family not set\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SET;\n\t} else {\n\t\tconn->flags &= ~NET_CONN_REMOTE_ADDR_SPEC;\n\t\tconn->flags &= ~NET_CONN_REMOTE_ADDR_SET;\n\t}\n\n\tif (remote_port) {\n\t\tconn->flags |= NET_CONN_REMOTE_PORT_SPEC;\n\t\tnet_sin(&conn->remote_addr)->sin_port = net_htons(remote_port);\n\t} else {\n\t\tconn->flags &= ~NET_CONN_REMOTE_PORT_SPEC;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "278": "static int net_conn_change_remote(struct net_conn *conn,",
                    "279": "\t\t\t\t  const struct net_sockaddr *remote_addr,",
                    "280": "\t\t\t\t  uint16_t remote_port)",
                    "281": "{",
                    "282": "\tNET_DBG(\"[%zu] connection handler %p changed remote\",",
                    "283": "\t\tconn - conns, conn);",
                    "284": "",
                    "285": "\tif (remote_addr) {",
                    "286": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "287": "\t\t    remote_addr->sa_family == NET_AF_INET6) {",
                    "288": "\t\t\tmemcpy(&conn->remote_addr, remote_addr,",
                    "289": "\t\t\t       sizeof(struct net_sockaddr_in6));",
                    "290": "",
                    "291": "\t\t\tif (!net_ipv6_is_addr_unspecified(",
                    "292": "\t\t\t\t    &net_sin6(remote_addr)->",
                    "293": "\t\t\t\t    sin6_addr)) {",
                    "294": "\t\t\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SPEC;",
                    "295": "\t\t\t}",
                    "296": "\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "297": "\t\t\t   remote_addr->sa_family == NET_AF_INET) {",
                    "298": "\t\t\tmemcpy(&conn->remote_addr, remote_addr,",
                    "299": "\t\t\t       sizeof(struct net_sockaddr_in));",
                    "300": "",
                    "301": "\t\t\tif (net_sin(remote_addr)->sin_addr.s_addr) {",
                    "302": "\t\t\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SPEC;",
                    "303": "\t\t\t}",
                    "304": "\t\t} else {",
                    "305": "\t\t\tNET_ERR(\"Remote address family not set\");",
                    "306": "\t\t\treturn -EINVAL;",
                    "307": "\t\t}",
                    "308": "",
                    "309": "\t\tconn->flags |= NET_CONN_REMOTE_ADDR_SET;",
                    "310": "\t} else {",
                    "311": "\t\tconn->flags &= ~NET_CONN_REMOTE_ADDR_SPEC;",
                    "312": "\t\tconn->flags &= ~NET_CONN_REMOTE_ADDR_SET;",
                    "313": "\t}",
                    "314": "",
                    "315": "\tif (remote_port) {",
                    "316": "\t\tconn->flags |= NET_CONN_REMOTE_PORT_SPEC;",
                    "317": "\t\tnet_sin(&conn->remote_addr)->sin_port = net_htons(remote_port);",
                    "318": "\t} else {",
                    "319": "\t\tconn->flags &= ~NET_CONN_REMOTE_PORT_SPEC;",
                    "320": "\t}",
                    "321": "",
                    "322": "\treturn 0;",
                    "323": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "conn_find_handler": {
            "name": "conn_find_handler",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 154,
            "function_content": [
                "/* Check if we already have identical connection handler installed. */\nstatic struct net_conn *conn_find_handler(struct net_if *iface,\n\t\t\t\t\t  uint16_t proto, uint8_t family,\n\t\t\t\t\t  const struct net_sockaddr *remote_addr,\n\t\t\t\t\t  const struct net_sockaddr *local_addr,\n\t\t\t\t\t  uint16_t remote_port,\n\t\t\t\t\t  uint16_t local_port,\n\t\t\t\t\t  bool reuseport_set)\n{\n\tstruct net_conn *conn;\n\tstruct net_conn *tmp;\n\n\tk_mutex_lock(&conn_lock, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {\n\t\tif (conn->proto != proto) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (conn->family != family) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (local_addr) {\n\t\t\tif (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t\t    local_addr->sa_family == NET_AF_INET6 &&\n\t\t\t    local_addr->sa_family ==\n\t\t\t    conn->local_addr.sa_family) {\n\t\t\t\tif (!net_ipv6_addr_cmp(\n\t\t\t\t\t    &net_sin6(local_addr)->sin6_addr,\n\t\t\t\t\t    &net_sin6(&conn->local_addr)->\n\t\t\t\t\t\t\t\tsin6_addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t\t\t   local_addr->sa_family == NET_AF_INET &&\n\t\t\t\t   local_addr->sa_family ==\n\t\t\t\t   conn->local_addr.sa_family) {\n\t\t\t\tif (!net_ipv4_addr_cmp(\n\t\t\t\t\t    &net_sin(local_addr)->sin_addr,\n\t\t\t\t\t    &net_sin(&conn->local_addr)->\n\t\t\t\t\t\t\t\tsin_addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_sin(&conn->local_addr)->sin_port !=\n\t\t    net_htons(local_port)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (remote_addr) {\n\t\t\tif (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t\t    remote_addr->sa_family == NET_AF_INET6 &&\n\t\t\t    remote_addr->sa_family ==\n\t\t\t    conn->remote_addr.sa_family) {\n\t\t\t\tif (!net_ipv6_addr_cmp(\n\t\t\t\t\t    &net_sin6(remote_addr)->sin6_addr,\n\t\t\t\t\t    &net_sin6(&conn->remote_addr)->\n\t\t\t\t\t\t\t\tsin6_addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t\t\t   remote_addr->sa_family == NET_AF_INET &&\n\t\t\t\t   remote_addr->sa_family ==\n\t\t\t\t   conn->remote_addr.sa_family) {\n\t\t\t\tif (!net_ipv4_addr_cmp(\n\t\t\t\t\t    &net_sin(remote_addr)->sin_addr,\n\t\t\t\t\t    &net_sin(&conn->remote_addr)->\n\t\t\t\t\t\t\t\tsin_addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {\n\t\t\tcontinue;\n\t\t} else if (reuseport_set && conn->context != NULL &&\n\t\t\t   net_context_is_reuseport_set(conn->context)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_sin(&conn->remote_addr)->sin_port !=\n\t\t    net_htons(remote_port)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (conn->context != NULL && iface != NULL &&\n\t\t    net_context_is_bound_to_iface(conn->context)) {\n\t\t\tif (iface != net_context_get_iface(conn->context)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tk_mutex_unlock(&conn_lock);\n\t\treturn conn;\n\t}\n\n\tk_mutex_unlock(&conn_lock);\n\treturn NULL;\n}\n",
                {
                    "154": "static struct net_conn *conn_find_handler(struct net_if *iface,",
                    "155": "\t\t\t\t\t  uint16_t proto, uint8_t family,",
                    "156": "\t\t\t\t\t  const struct net_sockaddr *remote_addr,",
                    "157": "\t\t\t\t\t  const struct net_sockaddr *local_addr,",
                    "158": "\t\t\t\t\t  uint16_t remote_port,",
                    "159": "\t\t\t\t\t  uint16_t local_port,",
                    "160": "\t\t\t\t\t  bool reuseport_set)",
                    "161": "{",
                    "162": "\tstruct net_conn *conn;",
                    "163": "\tstruct net_conn *tmp;",
                    "164": "",
                    "165": "\tk_mutex_lock(&conn_lock, K_FOREVER);",
                    "166": "",
                    "167": "\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {",
                    "168": "\t\tif (conn->proto != proto) {",
                    "169": "\t\t\tcontinue;",
                    "170": "\t\t}",
                    "171": "",
                    "172": "\t\tif (conn->family != family) {",
                    "173": "\t\t\tcontinue;",
                    "174": "\t\t}",
                    "175": "",
                    "176": "\t\tif (local_addr) {",
                    "177": "\t\t\tif (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {",
                    "178": "\t\t\t\tcontinue;",
                    "179": "\t\t\t}",
                    "180": "",
                    "181": "\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "182": "\t\t\t    local_addr->sa_family == NET_AF_INET6 &&",
                    "183": "\t\t\t    local_addr->sa_family ==",
                    "184": "\t\t\t    conn->local_addr.sa_family) {",
                    "185": "\t\t\t\tif (!net_ipv6_addr_cmp(",
                    "186": "\t\t\t\t\t    &net_sin6(local_addr)->sin6_addr,",
                    "187": "\t\t\t\t\t    &net_sin6(&conn->local_addr)->",
                    "188": "\t\t\t\t\t\t\t\tsin6_addr)) {",
                    "189": "\t\t\t\t\tcontinue;",
                    "190": "\t\t\t\t}",
                    "191": "\t\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "192": "\t\t\t\t   local_addr->sa_family == NET_AF_INET &&",
                    "193": "\t\t\t\t   local_addr->sa_family ==",
                    "194": "\t\t\t\t   conn->local_addr.sa_family) {",
                    "195": "\t\t\t\tif (!net_ipv4_addr_cmp(",
                    "196": "\t\t\t\t\t    &net_sin(local_addr)->sin_addr,",
                    "197": "\t\t\t\t\t    &net_sin(&conn->local_addr)->",
                    "198": "\t\t\t\t\t\t\t\tsin_addr)) {",
                    "199": "\t\t\t\t\tcontinue;",
                    "200": "\t\t\t\t}",
                    "201": "\t\t\t} else {",
                    "202": "\t\t\t\tcontinue;",
                    "203": "\t\t\t}",
                    "204": "\t\t} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {",
                    "205": "\t\t\tcontinue;",
                    "206": "\t\t}",
                    "207": "",
                    "208": "\t\tif (net_sin(&conn->local_addr)->sin_port !=",
                    "209": "\t\t    net_htons(local_port)) {",
                    "210": "\t\t\tcontinue;",
                    "211": "\t\t}",
                    "212": "",
                    "213": "\t\tif (remote_addr) {",
                    "214": "\t\t\tif (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {",
                    "215": "\t\t\t\tcontinue;",
                    "216": "\t\t\t}",
                    "217": "",
                    "218": "\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "219": "\t\t\t    remote_addr->sa_family == NET_AF_INET6 &&",
                    "220": "\t\t\t    remote_addr->sa_family ==",
                    "221": "\t\t\t    conn->remote_addr.sa_family) {",
                    "222": "\t\t\t\tif (!net_ipv6_addr_cmp(",
                    "223": "\t\t\t\t\t    &net_sin6(remote_addr)->sin6_addr,",
                    "224": "\t\t\t\t\t    &net_sin6(&conn->remote_addr)->",
                    "225": "\t\t\t\t\t\t\t\tsin6_addr)) {",
                    "226": "\t\t\t\t\tcontinue;",
                    "227": "\t\t\t\t}",
                    "228": "\t\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "229": "\t\t\t\t   remote_addr->sa_family == NET_AF_INET &&",
                    "230": "\t\t\t\t   remote_addr->sa_family ==",
                    "231": "\t\t\t\t   conn->remote_addr.sa_family) {",
                    "232": "\t\t\t\tif (!net_ipv4_addr_cmp(",
                    "233": "\t\t\t\t\t    &net_sin(remote_addr)->sin_addr,",
                    "234": "\t\t\t\t\t    &net_sin(&conn->remote_addr)->",
                    "235": "\t\t\t\t\t\t\t\tsin_addr)) {",
                    "236": "\t\t\t\t\tcontinue;",
                    "237": "\t\t\t\t}",
                    "238": "\t\t\t} else {",
                    "239": "\t\t\t\tcontinue;",
                    "240": "\t\t\t}",
                    "241": "\t\t} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {",
                    "242": "\t\t\tcontinue;",
                    "243": "\t\t} else if (reuseport_set && conn->context != NULL &&",
                    "244": "\t\t\t   net_context_is_reuseport_set(conn->context)) {",
                    "245": "\t\t\tcontinue;",
                    "246": "\t\t}",
                    "247": "",
                    "248": "\t\tif (net_sin(&conn->remote_addr)->sin_port !=",
                    "249": "\t\t    net_htons(remote_port)) {",
                    "250": "\t\t\tcontinue;",
                    "251": "\t\t}",
                    "252": "",
                    "253": "\t\tif (conn->context != NULL && iface != NULL &&",
                    "254": "\t\t    net_context_is_bound_to_iface(conn->context)) {",
                    "255": "\t\t\tif (iface != net_context_get_iface(conn->context)) {",
                    "256": "\t\t\t\tcontinue;",
                    "257": "\t\t\t}",
                    "258": "\t\t}",
                    "259": "",
                    "260": "\t\tk_mutex_unlock(&conn_lock);",
                    "261": "\t\treturn conn;",
                    "262": "\t}",
                    "263": "",
                    "264": "\tk_mutex_unlock(&conn_lock);",
                    "265": "\treturn NULL;",
                    "266": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_icmpv6_send_error": {
            "name": "net_icmpv6_send_error",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/icmpv6.c",
            "location_line": 194,
            "function_content": [
                "/* We must not set the destination ll address here but trust\n* that it is set properly using a value from neighbor cache.\n* Same for source as it points to original pkt ll src address.\n*/\nint net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,\n\t\t\t  uint32_t param)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tint err = -EIO;\n\tstruct net_in6_addr orig_src, orig_dst;\n\tstruct net_ipv6_hdr *ip_hdr;\n\tconst struct net_in6_addr *src;\n\tstruct net_pkt *pkt;\n\tsize_t copy_len;\n\tint ret;\n\n\tnet_pkt_cursor_init(orig);\n\n\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);\n\tif (!ip_hdr) {\n\t\tgoto drop_no_pkt;\n\t}\n\n\tif (ip_hdr->nexthdr == NET_IPPROTO_ICMPV6) {\n\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,\n\t\t\t\t\t\t      struct net_icmp_hdr);\n\t\tstruct net_icmp_hdr *icmp_hdr;\n\n\t\tnet_pkt_acknowledge_data(orig, &ipv6_access);\n\n\t\ticmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(\n\t\t\t\t\t\t\torig, &icmpv6_access);\n\t\tif (!icmp_hdr || icmp_hdr->type < 128) {\n\t\t\t/* We must not send ICMP errors back */\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop_no_pkt;\n\t\t}\n\n\t\tnet_pkt_cursor_init(orig);\n\t}\n\n\tnet_ipv6_addr_copy_raw(orig_src.s6_addr, ip_hdr->src);\n\tnet_ipv6_addr_copy_raw(orig_dst.s6_addr, ip_hdr->dst);\n\n\tif (ip_hdr->nexthdr == NET_IPPROTO_UDP) {\n\t\tcopy_len = sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_udp_hdr);\n\t} else if (ip_hdr->nexthdr == NET_IPPROTO_TCP) {\n\t\tcopy_len = sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_tcp_hdr);\n\t} else {\n\t\tcopy_len = net_pkt_get_len(orig);\n\t}\n\n\tpkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),\n\t\t\t\t\tnet_pkt_lladdr_src(orig)->len * 2 +\n\t\t\t\t\tcopy_len + NET_ICMPV6_UNUSED_LEN,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tPKT_WAIT_TIME);\n\tif (!pkt) {\n\t\terr = -ENOMEM;\n\t\tgoto drop_no_pkt;\n\t}\n\n\t/* We created above a new packet that contains some extra space that we\n\t * will use to store the destination and source link addresses. This is\n\t * needed because we cannot use the original pkt, which contains the\n\t * link address where the new packet will be sent, as that pkt might\n\t * get re-used before we have managed to set the link addresses in L2\n\t * as that (link address setting) happens in a different thread (TX)\n\t * than this one.\n\t * So we copy the destination and source link addresses here, then set\n\t * the link address pointers correctly, and skip the needed space\n\t * as the link address will be set in the pkt when the packet is\n\t * constructed in L2. So basically all this for just to create some\n\t * extra space for link addresses so that we can set the lladdr\n\t * pointers in net_pkt.\n\t */\n\tret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,\n\t\t\t    net_pkt_lladdr_src(orig)->len);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto drop;\n\t}\n\n\tmemcpy(net_pkt_lladdr_dst(pkt)->addr, pkt->buffer->data,\n\t       net_pkt_lladdr_dst(orig)->len);\n\n\tret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,\n\t\t\t    net_pkt_lladdr_dst(orig)->len);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto drop;\n\t}\n\n\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);\n\n\tmemcpy(net_pkt_lladdr_src(pkt)->addr, pkt->buffer->data,\n\t       net_pkt_lladdr_src(orig)->len);\n\n\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);\n\n\tnet_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;\n\tnet_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;\n\n\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {\n\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),\n\t\t\t\t\t\t  &orig_dst);\n\t} else {\n\t\tsrc = &orig_dst;\n\t}\n\n\tif (net_ipv6_create(pkt, src, &orig_src) ||\n\t    net_icmpv6_create(pkt, type, code)) {\n\t\tgoto drop;\n\t}\n\n\t/* Depending on error option, we store the param into the ICMP message.\n\t */\n\tif (type == NET_ICMPV6_PARAM_PROBLEM) {\n\t\terr = net_pkt_write_be32(pkt, param);\n\t} else {\n\t\terr = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);\n\t}\n\n\t/* Allocator might not have been able to allocate all requested space,\n\t * so let's copy as much as we can.\n\t */\n\tcopy_len = net_pkt_available_buffer(pkt);\n\n\tif (err || net_pkt_copy(pkt, orig, copy_len)) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tNET_DBG(\"Sending ICMPv6 Error Message type %d code %d param %d\"\n\t\t\" from %s to %s\", type, code, param,\n\t\tnet_sprint_ipv6_addr(src),\n\t\tnet_sprint_ipv6_addr(&orig_src));\n\n\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {\n\t\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\t\treturn 0;\n\t}\n\ndrop:\n\tnet_pkt_unref(pkt);\n\ndrop_no_pkt:\n\tnet_stats_update_icmp_drop(net_pkt_iface(orig));\n\n\treturn err;\n}\n",
                {
                    "194": "int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,",
                    "195": "\t\t\t  uint32_t param)",
                    "196": "{",
                    "197": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "198": "\tint err = -EIO;",
                    "199": "\tstruct net_in6_addr orig_src, orig_dst;",
                    "200": "\tstruct net_ipv6_hdr *ip_hdr;",
                    "201": "\tconst struct net_in6_addr *src;",
                    "202": "\tstruct net_pkt *pkt;",
                    "203": "\tsize_t copy_len;",
                    "204": "\tint ret;",
                    "205": "",
                    "206": "\tnet_pkt_cursor_init(orig);",
                    "207": "",
                    "208": "\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);",
                    "209": "\tif (!ip_hdr) {",
                    "210": "\t\tgoto drop_no_pkt;",
                    "211": "\t}",
                    "212": "",
                    "213": "\tif (ip_hdr->nexthdr == NET_IPPROTO_ICMPV6) {",
                    "214": "\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,",
                    "215": "\t\t\t\t\t\t      struct net_icmp_hdr);",
                    "216": "\t\tstruct net_icmp_hdr *icmp_hdr;",
                    "217": "",
                    "218": "\t\tnet_pkt_acknowledge_data(orig, &ipv6_access);",
                    "219": "",
                    "220": "\t\ticmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(",
                    "221": "\t\t\t\t\t\t\torig, &icmpv6_access);",
                    "222": "\t\tif (!icmp_hdr || icmp_hdr->type < 128) {",
                    "223": "\t\t\t/* We must not send ICMP errors back */",
                    "224": "\t\t\terr = -EINVAL;",
                    "225": "\t\t\tgoto drop_no_pkt;",
                    "226": "\t\t}",
                    "227": "",
                    "228": "\t\tnet_pkt_cursor_init(orig);",
                    "229": "\t}",
                    "230": "",
                    "231": "\tnet_ipv6_addr_copy_raw(orig_src.s6_addr, ip_hdr->src);",
                    "232": "\tnet_ipv6_addr_copy_raw(orig_dst.s6_addr, ip_hdr->dst);",
                    "233": "",
                    "234": "\tif (ip_hdr->nexthdr == NET_IPPROTO_UDP) {",
                    "235": "\t\tcopy_len = sizeof(struct net_ipv6_hdr) +",
                    "236": "\t\t\tsizeof(struct net_udp_hdr);",
                    "237": "\t} else if (ip_hdr->nexthdr == NET_IPPROTO_TCP) {",
                    "238": "\t\tcopy_len = sizeof(struct net_ipv6_hdr) +",
                    "239": "\t\t\tsizeof(struct net_tcp_hdr);",
                    "240": "\t} else {",
                    "241": "\t\tcopy_len = net_pkt_get_len(orig);",
                    "242": "\t}",
                    "243": "",
                    "244": "\tpkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),",
                    "245": "\t\t\t\t\tnet_pkt_lladdr_src(orig)->len * 2 +",
                    "246": "\t\t\t\t\tcopy_len + NET_ICMPV6_UNUSED_LEN,",
                    "247": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "248": "\t\t\t\t\tPKT_WAIT_TIME);",
                    "249": "\tif (!pkt) {",
                    "250": "\t\terr = -ENOMEM;",
                    "251": "\t\tgoto drop_no_pkt;",
                    "252": "\t}",
                    "253": "",
                    "254": "\t/* We created above a new packet that contains some extra space that we",
                    "255": "\t * will use to store the destination and source link addresses. This is",
                    "256": "\t * needed because we cannot use the original pkt, which contains the",
                    "257": "\t * link address where the new packet will be sent, as that pkt might",
                    "258": "\t * get re-used before we have managed to set the link addresses in L2",
                    "259": "\t * as that (link address setting) happens in a different thread (TX)",
                    "260": "\t * than this one.",
                    "261": "\t * So we copy the destination and source link addresses here, then set",
                    "262": "\t * the link address pointers correctly, and skip the needed space",
                    "263": "\t * as the link address will be set in the pkt when the packet is",
                    "264": "\t * constructed in L2. So basically all this for just to create some",
                    "265": "\t * extra space for link addresses so that we can set the lladdr",
                    "266": "\t * pointers in net_pkt.",
                    "267": "\t */",
                    "268": "\tret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,",
                    "269": "\t\t\t    net_pkt_lladdr_src(orig)->len);",
                    "270": "\tif (ret < 0) {",
                    "271": "\t\terr = ret;",
                    "272": "\t\tgoto drop;",
                    "273": "\t}",
                    "274": "",
                    "275": "\tmemcpy(net_pkt_lladdr_dst(pkt)->addr, pkt->buffer->data,",
                    "276": "\t       net_pkt_lladdr_dst(orig)->len);",
                    "277": "",
                    "278": "\tret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,",
                    "279": "\t\t\t    net_pkt_lladdr_dst(orig)->len);",
                    "280": "\tif (ret < 0) {",
                    "281": "\t\terr = ret;",
                    "282": "\t\tgoto drop;",
                    "283": "\t}",
                    "284": "",
                    "285": "\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);",
                    "286": "",
                    "287": "\tmemcpy(net_pkt_lladdr_src(pkt)->addr, pkt->buffer->data,",
                    "288": "\t       net_pkt_lladdr_src(orig)->len);",
                    "289": "",
                    "290": "\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);",
                    "291": "",
                    "292": "\tnet_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;",
                    "293": "\tnet_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;",
                    "294": "",
                    "295": "\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {",
                    "296": "\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),",
                    "297": "\t\t\t\t\t\t  &orig_dst);",
                    "298": "\t} else {",
                    "299": "\t\tsrc = &orig_dst;",
                    "300": "\t}",
                    "301": "",
                    "302": "\tif (net_ipv6_create(pkt, src, &orig_src) ||",
                    "303": "\t    net_icmpv6_create(pkt, type, code)) {",
                    "304": "\t\tgoto drop;",
                    "305": "\t}",
                    "306": "",
                    "307": "\t/* Depending on error option, we store the param into the ICMP message.",
                    "308": "\t */",
                    "309": "\tif (type == NET_ICMPV6_PARAM_PROBLEM) {",
                    "310": "\t\terr = net_pkt_write_be32(pkt, param);",
                    "311": "\t} else {",
                    "312": "\t\terr = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);",
                    "313": "\t}",
                    "314": "",
                    "315": "\t/* Allocator might not have been able to allocate all requested space,",
                    "316": "\t * so let's copy as much as we can.",
                    "317": "\t */",
                    "318": "\tcopy_len = net_pkt_available_buffer(pkt);",
                    "319": "",
                    "320": "\tif (err || net_pkt_copy(pkt, orig, copy_len)) {",
                    "321": "\t\tgoto drop;",
                    "322": "\t}",
                    "323": "",
                    "324": "\tnet_pkt_cursor_init(pkt);",
                    "325": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "326": "",
                    "327": "\tNET_DBG(\"Sending ICMPv6 Error Message type %d code %d param %d\"",
                    "328": "\t\t\" from %s to %s\", type, code, param,",
                    "329": "\t\tnet_sprint_ipv6_addr(src),",
                    "330": "\t\tnet_sprint_ipv6_addr(&orig_src));",
                    "331": "",
                    "332": "\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {",
                    "333": "\t\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "334": "\t\treturn 0;",
                    "335": "\t}",
                    "336": "",
                    "337": "drop:",
                    "338": "\tnet_pkt_unref(pkt);",
                    "339": "",
                    "340": "drop_no_pkt:",
                    "341": "\tnet_stats_update_icmp_drop(net_pkt_iface(orig));",
                    "342": "",
                    "343": "\treturn err;",
                    "344": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "icmpv6_handle_echo_request": {
            "name": "icmpv6_handle_echo_request",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/icmpv6.c",
            "location_line": 99,
            "function_content": [
                "/*\n* Copyright (c) 2016 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstatic int icmpv6_handle_echo_request(struct net_icmp_ctx *ctx,\n\t\t\t\t      struct net_pkt *pkt,\n\t\t\t\t      struct net_icmp_ip_hdr *hdr,\n\t\t\t\t      struct net_icmp_hdr *icmp_hdr,\n\t\t\t\t      void *user_data)\n{\n\tstruct net_pkt *reply = NULL;\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tstruct net_in6_addr req_src, req_dst;\n\tconst struct net_in6_addr *src;\n\tint16_t payload_len;\n\n\tARG_UNUSED(user_data);\n\tARG_UNUSED(icmp_hdr);\n\n\tnet_ipv6_addr_copy_raw(req_src.s6_addr, ip_hdr->src);\n\tnet_ipv6_addr_copy_raw(req_dst.s6_addr, ip_hdr->dst);\n\n\tNET_DBG(\"Received Echo Request from %s to %s\",\n\t\tnet_sprint_ipv6_addr(&req_src),\n\t\tnet_sprint_ipv6_addr(&req_dst));\n\n\tpayload_len = net_ntohs(ip_hdr->len) -\n\t\tnet_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;\n\tif (payload_len < NET_ICMPV6_UNUSED_LEN) {\n\t\t/* No identifier or sequence number present */\n\t\tgoto drop;\n\t}\n\n\treply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,\n\t\t\t\t\t  NET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\t  PKT_WAIT_TIME);\n\tif (!reply) {\n\t\tNET_DBG(\"DROP: No buffer\");\n\t\tgoto drop;\n\t}\n\n\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {\n\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),\n\t\t\t\t\t\t  &req_src);\n\n\t\tif (net_ipv6_is_addr_unspecified(src)) {\n\t\t\tNET_DBG(\"DROP: No src address match\");\n\t\t\tgoto drop;\n\t\t}\n\t} else {\n\t\tsrc = &req_dst;\n\t}\n\n\t/* We must not set the destination ll address here but trust\n\t * that it is set properly using a value from neighbor cache.\n\t * Same for source as it points to original pkt ll src address.\n\t */\n\t(void)net_linkaddr_clear(net_pkt_lladdr_dst(reply));\n\t(void)net_linkaddr_clear(net_pkt_lladdr_src(reply));\n\n\tnet_pkt_set_ip_dscp(reply, net_pkt_ip_dscp(pkt));\n\tnet_pkt_set_ip_ecn(reply, net_pkt_ip_ecn(pkt));\n\n\tif (net_ipv6_create(reply, src, &req_src)) {\n\t\tNET_DBG(\"DROP: wrong buffer\");\n\t\tgoto drop;\n\t}\n\n\tif (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||\n\t    net_pkt_copy(reply, pkt, payload_len)) {\n\t\tNET_DBG(\"DROP: wrong buffer\");\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_cursor_init(reply);\n\tnet_ipv6_finalize(reply, NET_IPPROTO_ICMPV6);\n\n\tNET_DBG(\"Sending Echo Reply from %s to %s\",\n\t\tnet_sprint_ipv6_addr(src),\n\t\tnet_sprint_ipv6_addr(&req_src));\n\n\tif (net_try_send_data(reply, K_NO_WAIT) < 0) {\n\t\tgoto drop;\n\t}\n\n\tnet_stats_update_icmp_sent(net_pkt_iface(reply));\n\n\treturn 0;\n\ndrop:\n\tif (reply) {\n\t\tnet_pkt_unref(reply);\n\t}\n\n\tnet_stats_update_icmp_drop(net_pkt_iface(pkt));\n\n\treturn -EIO;\n}\n",
                {
                    "99": "static int icmpv6_handle_echo_request(struct net_icmp_ctx *ctx,",
                    "100": "\t\t\t\t      struct net_pkt *pkt,",
                    "101": "\t\t\t\t      struct net_icmp_ip_hdr *hdr,",
                    "102": "\t\t\t\t      struct net_icmp_hdr *icmp_hdr,",
                    "103": "\t\t\t\t      void *user_data)",
                    "104": "{",
                    "105": "\tstruct net_pkt *reply = NULL;",
                    "106": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "107": "\tstruct net_in6_addr req_src, req_dst;",
                    "108": "\tconst struct net_in6_addr *src;",
                    "109": "\tint16_t payload_len;",
                    "110": "",
                    "111": "\tARG_UNUSED(user_data);",
                    "112": "\tARG_UNUSED(icmp_hdr);",
                    "113": "",
                    "114": "\tnet_ipv6_addr_copy_raw(req_src.s6_addr, ip_hdr->src);",
                    "115": "\tnet_ipv6_addr_copy_raw(req_dst.s6_addr, ip_hdr->dst);",
                    "116": "",
                    "117": "\tNET_DBG(\"Received Echo Request from %s to %s\",",
                    "118": "\t\tnet_sprint_ipv6_addr(&req_src),",
                    "119": "\t\tnet_sprint_ipv6_addr(&req_dst));",
                    "120": "",
                    "121": "\tpayload_len = net_ntohs(ip_hdr->len) -",
                    "122": "\t\tnet_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;",
                    "123": "\tif (payload_len < NET_ICMPV6_UNUSED_LEN) {",
                    "124": "\t\t/* No identifier or sequence number present */",
                    "125": "\t\tgoto drop;",
                    "126": "\t}",
                    "127": "",
                    "128": "\treply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,",
                    "129": "\t\t\t\t\t  NET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "130": "\t\t\t\t\t  PKT_WAIT_TIME);",
                    "131": "\tif (!reply) {",
                    "132": "\t\tNET_DBG(\"DROP: No buffer\");",
                    "133": "\t\tgoto drop;",
                    "134": "\t}",
                    "135": "",
                    "136": "\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {",
                    "137": "\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),",
                    "138": "\t\t\t\t\t\t  &req_src);",
                    "139": "",
                    "140": "\t\tif (net_ipv6_is_addr_unspecified(src)) {",
                    "141": "\t\t\tNET_DBG(\"DROP: No src address match\");",
                    "142": "\t\t\tgoto drop;",
                    "143": "\t\t}",
                    "144": "\t} else {",
                    "145": "\t\tsrc = &req_dst;",
                    "146": "\t}",
                    "147": "",
                    "148": "\t/* We must not set the destination ll address here but trust",
                    "149": "\t * that it is set properly using a value from neighbor cache.",
                    "150": "\t * Same for source as it points to original pkt ll src address.",
                    "151": "\t */",
                    "152": "\t(void)net_linkaddr_clear(net_pkt_lladdr_dst(reply));",
                    "153": "\t(void)net_linkaddr_clear(net_pkt_lladdr_src(reply));",
                    "154": "",
                    "155": "\tnet_pkt_set_ip_dscp(reply, net_pkt_ip_dscp(pkt));",
                    "156": "\tnet_pkt_set_ip_ecn(reply, net_pkt_ip_ecn(pkt));",
                    "157": "",
                    "158": "\tif (net_ipv6_create(reply, src, &req_src)) {",
                    "159": "\t\tNET_DBG(\"DROP: wrong buffer\");",
                    "160": "\t\tgoto drop;",
                    "161": "\t}",
                    "162": "",
                    "163": "\tif (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||",
                    "164": "\t    net_pkt_copy(reply, pkt, payload_len)) {",
                    "165": "\t\tNET_DBG(\"DROP: wrong buffer\");",
                    "166": "\t\tgoto drop;",
                    "167": "\t}",
                    "168": "",
                    "169": "\tnet_pkt_cursor_init(reply);",
                    "170": "\tnet_ipv6_finalize(reply, NET_IPPROTO_ICMPV6);",
                    "171": "",
                    "172": "\tNET_DBG(\"Sending Echo Reply from %s to %s\",",
                    "173": "\t\tnet_sprint_ipv6_addr(src),",
                    "174": "\t\tnet_sprint_ipv6_addr(&req_src));",
                    "175": "",
                    "176": "\tif (net_try_send_data(reply, K_NO_WAIT) < 0) {",
                    "177": "\t\tgoto drop;",
                    "178": "\t}",
                    "179": "",
                    "180": "\tnet_stats_update_icmp_sent(net_pkt_iface(reply));",
                    "181": "",
                    "182": "\treturn 0;",
                    "183": "",
                    "184": "drop:",
                    "185": "\tif (reply) {",
                    "186": "\t\tnet_pkt_unref(reply);",
                    "187": "\t}",
                    "188": "",
                    "189": "\tnet_stats_update_icmp_drop(net_pkt_iface(pkt));",
                    "190": "",
                    "191": "\treturn -EIO;",
                    "192": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_input": {
            "name": "net_udp_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 150,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstruct net_udp_hdr *net_udp_input(struct net_pkt *pkt,\n\t\t\t\t  struct net_pkt_data_access *udp_access)\n{\n\tstruct net_udp_hdr *udp_hdr;\n\tenum net_if_checksum_type type = net_pkt_family(pkt) == NET_AF_INET6 ?\n\t\tNET_IF_CHECKSUM_IPV6_UDP : NET_IF_CHECKSUM_IPV4_UDP;\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);\n\tif (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {\n\t\tNET_DBG(\"DROP: corrupted header\");\n\t\tgoto drop;\n\t}\n\n\tif (net_ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -\n\t\t\t\t    net_pkt_ip_hdr_len(pkt) -\n\t\t\t\t    net_pkt_ip_opts_len(pkt))) {\n\t\tNET_DBG(\"DROP: Invalid hdr length\");\n\t\tgoto drop;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&\n\t    (net_if_need_calc_rx_checksum(net_pkt_iface(pkt), type) ||\n\t     net_pkt_is_ip_reassembled(pkt))) {\n\t\tif (!udp_hdr->chksum) {\n\t\t\tif (IS_ENABLED(CONFIG_NET_UDP_MISSING_CHECKSUM) &&\n\t\t\t    net_pkt_family(pkt) == NET_AF_INET) {\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (net_calc_verify_chksum_udp(pkt) != 0U) {\n\t\t\tNET_DBG(\"DROP: checksum mismatch\");\n\t\t\tgoto drop;\n\t\t}\n\t}\nout:\n\treturn udp_hdr;\ndrop:\n\tnet_stats_update_udp_chkerr(net_pkt_iface(pkt));\n\treturn NULL;\n}\n",
                {
                    "150": "struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,",
                    "151": "\t\t\t\t  struct net_pkt_data_access *udp_access)",
                    "152": "{",
                    "153": "\tstruct net_udp_hdr *udp_hdr;",
                    "154": "\tenum net_if_checksum_type type = net_pkt_family(pkt) == NET_AF_INET6 ?",
                    "155": "\t\tNET_IF_CHECKSUM_IPV6_UDP : NET_IF_CHECKSUM_IPV4_UDP;",
                    "156": "",
                    "157": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);",
                    "158": "\tif (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {",
                    "159": "\t\tNET_DBG(\"DROP: corrupted header\");",
                    "160": "\t\tgoto drop;",
                    "161": "\t}",
                    "162": "",
                    "163": "\tif (net_ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -",
                    "164": "\t\t\t\t    net_pkt_ip_hdr_len(pkt) -",
                    "165": "\t\t\t\t    net_pkt_ip_opts_len(pkt))) {",
                    "166": "\t\tNET_DBG(\"DROP: Invalid hdr length\");",
                    "167": "\t\tgoto drop;",
                    "168": "\t}",
                    "169": "",
                    "170": "\tif (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&",
                    "171": "\t    (net_if_need_calc_rx_checksum(net_pkt_iface(pkt), type) ||",
                    "172": "\t     net_pkt_is_ip_reassembled(pkt))) {",
                    "173": "\t\tif (!udp_hdr->chksum) {",
                    "174": "\t\t\tif (IS_ENABLED(CONFIG_NET_UDP_MISSING_CHECKSUM) &&",
                    "175": "\t\t\t    net_pkt_family(pkt) == NET_AF_INET) {",
                    "176": "\t\t\t\tgoto out;",
                    "177": "\t\t\t}",
                    "178": "",
                    "179": "\t\t\tgoto drop;",
                    "180": "\t\t}",
                    "181": "",
                    "182": "\t\tif (net_calc_verify_chksum_udp(pkt) != 0U) {",
                    "183": "\t\t\tNET_DBG(\"DROP: checksum mismatch\");",
                    "184": "\t\t\tgoto drop;",
                    "185": "\t\t}",
                    "186": "\t}",
                    "187": "out:",
                    "188": "\treturn udp_hdr;",
                    "189": "drop:",
                    "190": "\tnet_stats_update_udp_chkerr(net_pkt_iface(pkt));",
                    "191": "\treturn NULL;",
                    "192": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_finalize": {
            "name": "net_udp_finalize",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 38,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nint net_udp_finalize(struct net_pkt *pkt, bool force_chksum)\n{\n\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);\n\tstruct net_udp_hdr *udp_hdr;\n\tuint16_t length = 0;\n\tenum net_if_checksum_type type = net_pkt_family(pkt) == NET_AF_INET6 ?\n\t\tNET_IF_CHECKSUM_IPV6_UDP : NET_IF_CHECKSUM_IPV4_UDP;\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);\n\tif (!udp_hdr) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tlength = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -\n\t\t net_pkt_ip_opts_len(pkt);\n\n\tudp_hdr->len = net_htons(length);\n\n\tif (net_if_need_calc_tx_checksum(net_pkt_iface(pkt), type) || force_chksum) {\n\t\tudp_hdr->chksum = net_calc_chksum_udp(pkt);\n\t\tnet_pkt_set_chksum_done(pkt, true);\n\t}\n\n\treturn net_pkt_set_data(pkt, &udp_access);\n}\n",
                {
                    "38": "int net_udp_finalize(struct net_pkt *pkt, bool force_chksum)",
                    "39": "{",
                    "40": "\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);",
                    "41": "\tstruct net_udp_hdr *udp_hdr;",
                    "42": "\tuint16_t length = 0;",
                    "43": "\tenum net_if_checksum_type type = net_pkt_family(pkt) == NET_AF_INET6 ?",
                    "44": "\t\tNET_IF_CHECKSUM_IPV6_UDP : NET_IF_CHECKSUM_IPV4_UDP;",
                    "45": "",
                    "46": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);",
                    "47": "\tif (!udp_hdr) {",
                    "48": "\t\treturn -ENOBUFS;",
                    "49": "\t}",
                    "50": "",
                    "51": "\tlength = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -",
                    "52": "\t\t net_pkt_ip_opts_len(pkt);",
                    "53": "",
                    "54": "\tudp_hdr->len = net_htons(length);",
                    "55": "",
                    "56": "\tif (net_if_need_calc_tx_checksum(net_pkt_iface(pkt), type) || force_chksum) {",
                    "57": "\t\tudp_hdr->chksum = net_calc_chksum_udp(pkt);",
                    "58": "\t\tnet_pkt_set_chksum_done(pkt, true);",
                    "59": "\t}",
                    "60": "",
                    "61": "\treturn net_pkt_set_data(pkt, &udp_access);",
                    "62": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_input": {
            "name": "net_ipv6_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 478,
            "function_content": [
                "/* Destination header can appears twice */\nenum net_verdict net_ipv6_input(struct net_pkt *pkt)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);\n\tstruct net_if *pkt_iface = net_pkt_iface(pkt);\n\tenum net_verdict verdict = NET_DROP;\n\tint real_len = net_pkt_get_len(pkt);\n\tuint8_t ext_bitmap = 0U;\n\tuint16_t ext_len = 0U;\n\tuint8_t current_hdr, nexthdr, prev_hdr_offset;\n\tunion net_proto_header proto_hdr;\n\tstruct net_ipv6_hdr *hdr;\n\tstruct net_if_mcast_addr *if_mcast_addr;\n\tunion net_ip_header ip;\n\tint pkt_len;\n\n#if defined(CONFIG_NET_L2_IPIP)\n\tstruct net_pkt_cursor hdr_start;\n\n\tnet_pkt_cursor_backup(pkt, &hdr_start);\n#endif\n\n\tnet_stats_update_ipv6_recv(pkt_iface);\n\n\thdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);\n\tif (!hdr) {\n\t\tNET_DBG(\"DROP: no buffer\");\n\t\tgoto drop;\n\t}\n\n\tpkt_len = net_ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);\n\tif (real_len < pkt_len) {\n\t\tNET_DBG(\"DROP: pkt len per hdr %d != pkt real len %d\",\n\t\t\tpkt_len, real_len);\n\t\tgoto drop;\n\t} else if (real_len > pkt_len) {\n\t\tnet_pkt_update_length(pkt, pkt_len);\n\t}\n\n\tNET_DBG(\"IPv6 packet len %d received from %s to %s\", pkt_len,\n\t\tnet_sprint_ipv6_addr(&hdr->src),\n\t\tnet_sprint_ipv6_addr(&hdr->dst));\n\n\tif (net_ipv6_is_addr_unspecified_raw(hdr->src)) {\n\t\t/* If this is a possible DAD message, let it pass. Extra checks\n\t\t * are done in duplicate address detection code to verify that\n\t\t * the packet is ok.\n\t\t */\n\t\tif (!(IS_ENABLED(CONFIG_NET_IPV6_DAD) &&\n\t\t      net_ipv6_is_addr_solicited_node_raw(hdr->dst))) {\n\t\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (net_ipv6_is_addr_mcast_raw(hdr->src) ||\n\t    net_ipv6_is_addr_mcast_scope_raw(hdr->dst, 0)) {\n\t\tNET_DBG(\"DROP: multicast packet\");\n\t\tgoto drop;\n\t}\n\n\tif (!net_pkt_is_loopback(pkt)) {\n\t\tif (net_ipv6_is_addr_loopback_raw(hdr->dst) ||\n\t\t    net_ipv6_is_addr_loopback_raw(hdr->src)) {\n\t\t\tNET_DBG(\"DROP: ::1 packet\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||\n\t\t    (net_ipv6_is_addr_mcast_group_raw(\n\t\t\t    hdr->dst,\n\t\t\t    (const uint8_t *)net_ipv6_unspecified_address()) &&\n\t\t     (net_ipv6_is_addr_mcast_site_raw(hdr->dst) ||\n\t\t      net_ipv6_is_addr_mcast_org_raw(hdr->dst)))) {\n\t\t\tNET_DBG(\"DROP: invalid scope multicast packet\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* We need to pass the packet through in case our address is\n\t\t * tentative, as receiving a packet with a tentative address as\n\t\t * source means that duplicate address has been detected.\n\t\t * This check is done later on if routing features are enabled.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_NET_ROUTING) && !IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&\n\t\t    is_src_non_tentative_itself(hdr->src)) {\n\t\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Reconstruct TC field. */\n\n\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {\n\t\tuint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);\n\n\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));\n\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));\n\t}\n\n\t/* Check extension headers */\n\tnet_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);\n\tnet_pkt_set_ipv6_ext_len(pkt, 0);\n\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);\n\tnet_pkt_set_family(pkt, NET_PF_INET6);\n\n\tif (!net_pkt_filter_ip_recv_ok(pkt)) {\n\t\t/* drop the packet */\n\t\tNET_DBG(\"DROP: pkt filter\");\n\t\tnet_stats_update_filter_rx_ipv6_drop(net_pkt_iface(pkt));\n\t\treturn NET_DROP;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&\n\t\tnet_ipv6_is_addr_mcast_raw(hdr->dst) && !net_pkt_forwarding(pkt)) {\n\t\t/* If the packet is a multicast packet and multicast routing\n\t\t * is activated, we give the packet to the routing engine.\n\t\t *\n\t\t * But we only drop the packet if an error occurs, otherwise\n\t\t * it might be eminent to respond on the packet on application\n\t\t * layer.\n\t\t */\n\t\tif (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {\n\t\t\tNET_DBG(\"DROP: forward mcast\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!net_ipv6_is_addr_mcast_raw(hdr->dst)) {\n\t\tif (!net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {\n\t\t\tif (ipv6_route_packet(pkt, hdr) == NET_OK) {\n\t\t\t\treturn NET_OK;\n\t\t\t}\n\n\t\t\tNET_DBG(\"DROP: no such address %s in iface %d\",\n\t\t\t\tnet_sprint_ipv6_addr(hdr->dst),\n\t\t\t\tnet_if_get_by_iface(pkt_iface));\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* If we receive a packet with ll source address fe80: and\n\t\t * destination address is one of ours, and if the packet would\n\t\t * cross interface boundary, then drop the packet.\n\t\t * RFC 4291 ch 2.5.6\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&\n\t\t    net_ipv6_is_ll_addr_raw(hdr->src) &&\n\t\t    !net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {\n\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);\n\t\t\tNET_DBG(\"DROP: cross interface boundary\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif ((IS_ENABLED(CONFIG_NET_ROUTING) || IS_ENABLED(CONFIG_NET_ROUTE_MCAST)) &&\n\t    !net_pkt_is_loopback(pkt) && is_src_non_tentative_itself(hdr->src)) {\n\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");\n\t\tgoto drop;\n\t}\n\n\tif (net_ipv6_is_addr_mcast_raw(hdr->dst) &&\n\t    !(net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||\n\t      net_ipv6_is_addr_mcast_link_all_nodes_raw(hdr->dst))) {\n\t\t/* If we receive a packet with a interface-local or\n\t\t * link-local all-nodes multicast destination address we\n\t\t * always have to pass it to the upper layer.\n\t\t *\n\t\t * For all other destination multicast addresses we have to\n\t\t * check if one of the joined multicast groups on the\n\t\t * originating interface of the packet matches. Otherwise the\n\t\t * packet will be dropped.\n\t\t * RFC4291 ch 2.7.1, ch 2.8\n\t\t */\n\t\tif_mcast_addr = net_if_ipv6_maddr_lookup_raw(hdr->dst, &pkt_iface);\n\t\tif (!if_mcast_addr ||\n\t\t    !net_if_ipv6_maddr_is_joined(if_mcast_addr)) {\n\t\t\tNET_DBG(\"DROP: packet for unjoined multicast address\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &ipv6_access);\n\n\tcurrent_hdr = hdr->nexthdr;\n\text_bitmap = extension_to_bitmap(current_hdr, ext_bitmap);\n\t/* Offset of \"nexthdr\" in the IPv6 header */\n\tprev_hdr_offset = (uint8_t *)&hdr->nexthdr - (uint8_t *)hdr;\n\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);\n\n\twhile (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {\n\t\tint exthdr_len;\n\t\tuint8_t ext_bit;\n\n\t\tNET_DBG(\"IPv6 next header %d\", current_hdr);\n\n\t\tif (current_hdr == NET_IPV6_NEXTHDR_NONE) {\n\t\t\t/* There is nothing after this header (see RFC 2460,\n\t\t\t * ch 4.7), so we can drop the packet now.\n\t\t\t * This is not an error case so do not update drop\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tNET_DBG(\"DROP: none nexthdr\");\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\t/* Offset of \"nexthdr\" in the Extension Header */\n\t\tprev_hdr_offset = net_pkt_get_current_offset(pkt);\n\n\t\tif (net_pkt_read_u8(pkt, &nexthdr)) {\n\t\t\tNET_DBG(\"DROP: pkt invalid read\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Detect duplicated Extension headers */\n\t\text_bit = extension_to_bitmap(nexthdr, ext_bitmap);\n\t\tif (ext_bit & ext_bitmap) {\n\t\t\tgoto bad_hdr;\n\t\t}\n\t\text_bitmap |= ext_bit;\n\n\t\t/* Make sure that nexthdr is valid, reject the Extension Header early otherwise.\n\t\t * This is also important so that the \"pointer\" field in the ICMPv6 error\n\t\t * message points to the \"nexthdr\" field.\n\t\t */\n\t\tswitch (nexthdr) {\n\t\tcase NET_IPV6_NEXTHDR_HBHO:\n\t\t\t/* Hop-by-hop header can appear only once and must appear right after\n\t\t\t * the IPv6 header. Consequently the \"nexthdr\" field of an Extension\n\t\t\t * Header can never be an HBH option.\n\t\t\t */\n\t\t\tgoto bad_hdr;\n\n\t\tcase NET_IPV6_NEXTHDR_DESTO:\n\t\tcase NET_IPV6_NEXTHDR_FRAG:\n\t\tcase NET_IPV6_NEXTHDR_NONE:\n\t\t\t/* Valid values */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto bad_hdr;\n\t\t}\n\n\t\t/* Process the current Extension Header */\n\t\tswitch (current_hdr) {\n\t\tcase NET_IPV6_NEXTHDR_HBHO:\n\t\tcase NET_IPV6_NEXTHDR_DESTO:\n\t\t\t/* Process options below */\n\t\t\tbreak;\n\n\t\tcase NET_IPV6_NEXTHDR_FRAG:\n\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6_FRAGMENT)) {\n\t\t\t\tnet_pkt_set_ipv6_fragment_start(\n\t\t\t\t\tpkt,\n\t\t\t\t\tnet_pkt_get_current_offset(pkt) - 1);\n\t\t\t\treturn net_ipv6_handle_fragment_hdr(pkt, hdr,\n\t\t\t\t\t\t\t\t    current_hdr);\n\t\t\t}\n\n\t\t\tgoto bad_hdr;\n\n\t\tdefault:\n\t\t\t/* Unsupported */\n\t\t\tgoto bad_hdr;\n\t\t}\n\n\t\texthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);\n\t\tif (exthdr_len < 0) {\n\t\t\tNET_DBG(\"DROP: extension hdr len (%d)\", exthdr_len);\n\t\t\tgoto drop;\n\t\t}\n\n\t\text_len += exthdr_len;\n\t\tcurrent_hdr = nexthdr;\n\t\t/* Save the offset to \"nexthdr\" in case we need to overwrite it\n\t\t * when processing a fragment header\n\t\t */\n\t\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);\n\t}\n\n\tnet_pkt_set_ipv6_ext_len(pkt, ext_len);\n\n\tip.ipv6 = hdr;\n\n\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW)) {\n\t\tif (net_conn_raw_ip_input(pkt, &ip, current_hdr) == NET_DROP) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tswitch (current_hdr) {\n\tcase NET_IPPROTO_ICMPV6:\n\t\tverdict = net_icmpv6_input(pkt, hdr);\n\t\tbreak;\n\tcase NET_IPPROTO_TCP:\n\t\tproto_hdr.tcp = net_tcp_input(pkt, &tcp_access);\n\t\tif (proto_hdr.tcp) {\n\t\t\tverdict = NET_OK;\n\t\t}\n\n\t\tNET_DBG(\"%s verdict %s\", \"TCP\", net_verdict2str(verdict));\n\t\tbreak;\n\tcase NET_IPPROTO_UDP:\n\t\tproto_hdr.udp = net_udp_input(pkt, &udp_access);\n\t\tif (proto_hdr.udp) {\n\t\t\tverdict = NET_OK;\n\t\t}\n\n\t\tNET_DBG(\"%s verdict %s\", \"UDP\", net_verdict2str(verdict));\n\t\tbreak;\n\n#if defined(CONFIG_NET_L2_IPIP)\n\tcase NET_IPPROTO_IPV6:\n\tcase NET_IPPROTO_IPIP: {\n\t\tstruct net_sockaddr_in6 remote_addr = { 0 };\n\t\tstruct net_if *tunnel_iface;\n\n\t\tremote_addr.sin6_family = NET_AF_INET6;\n\t\tnet_ipv6_addr_copy_raw((uint8_t *)&remote_addr.sin6_addr, hdr->src);\n\n\t\tnet_pkt_set_remote_address(pkt, (struct net_sockaddr *)&remote_addr,\n\t\t\t\t\t   sizeof(struct net_sockaddr_in6));\n\n\t\t/* Get rid of the old IP header */\n\t\tnet_pkt_cursor_restore(pkt, &hdr_start);\n\t\tnet_pkt_pull(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t     net_pkt_ipv6_ext_len(pkt));\n\n\t\ttunnel_iface = net_ipip_get_virtual_interface(net_pkt_iface(pkt));\n\t\tif (tunnel_iface != NULL && net_if_l2(tunnel_iface)->recv != NULL) {\n\t\t\treturn net_if_l2(tunnel_iface)->recv(net_pkt_iface(pkt), pkt);\n\t\t}\n\t}\n#endif\n\t}\n\n\tif (verdict == NET_DROP) {\n\t\tNET_DBG(\"DROP: because verdict\");\n\t\tgoto drop;\n\t} else if (current_hdr == NET_IPPROTO_ICMPV6) {\n\t\tNET_DBG(\"%s verdict %s\", \"ICMPv6\", net_verdict2str(verdict));\n\t\treturn verdict;\n\t}\n\n\tverdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);\n\n\tNET_DBG(\"%s verdict %s\", \"Connection\", net_verdict2str(verdict));\n\n\tif (verdict != NET_DROP) {\n\t\treturn verdict;\n\t}\n\ndrop:\n\tnet_stats_update_ipv6_drop(pkt_iface);\n\treturn NET_DROP;\n\nbad_hdr:\n\t/* Send error message about parameter problem (RFC 2460) */\n\tnet_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,\n\t\t\t      NET_ICMPV6_PARAM_PROB_NEXTHEADER,\n\t\t\t      net_pkt_get_current_offset(pkt) - 1);\n\n\tNET_DBG(\"DROP: Unknown/wrong nexthdr type\");\n\tnet_stats_update_ip_errors_protoerr(pkt_iface);\n\n\treturn NET_DROP;\n}\n",
                {
                    "478": "enum net_verdict net_ipv6_input(struct net_pkt *pkt)",
                    "479": "{",
                    "480": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "481": "\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);",
                    "482": "\tNET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);",
                    "483": "\tstruct net_if *pkt_iface = net_pkt_iface(pkt);",
                    "484": "\tenum net_verdict verdict = NET_DROP;",
                    "485": "\tint real_len = net_pkt_get_len(pkt);",
                    "486": "\tuint8_t ext_bitmap = 0U;",
                    "487": "\tuint16_t ext_len = 0U;",
                    "488": "\tuint8_t current_hdr, nexthdr, prev_hdr_offset;",
                    "489": "\tunion net_proto_header proto_hdr;",
                    "490": "\tstruct net_ipv6_hdr *hdr;",
                    "491": "\tstruct net_if_mcast_addr *if_mcast_addr;",
                    "492": "\tunion net_ip_header ip;",
                    "493": "\tint pkt_len;",
                    "494": "",
                    "495": "#if defined(CONFIG_NET_L2_IPIP)",
                    "496": "\tstruct net_pkt_cursor hdr_start;",
                    "497": "",
                    "498": "\tnet_pkt_cursor_backup(pkt, &hdr_start);",
                    "499": "#endif",
                    "500": "",
                    "501": "\tnet_stats_update_ipv6_recv(pkt_iface);",
                    "502": "",
                    "503": "\thdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);",
                    "504": "\tif (!hdr) {",
                    "505": "\t\tNET_DBG(\"DROP: no buffer\");",
                    "506": "\t\tgoto drop;",
                    "507": "\t}",
                    "508": "",
                    "509": "\tpkt_len = net_ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);",
                    "510": "\tif (real_len < pkt_len) {",
                    "511": "\t\tNET_DBG(\"DROP: pkt len per hdr %d != pkt real len %d\",",
                    "512": "\t\t\tpkt_len, real_len);",
                    "513": "\t\tgoto drop;",
                    "514": "\t} else if (real_len > pkt_len) {",
                    "515": "\t\tnet_pkt_update_length(pkt, pkt_len);",
                    "516": "\t}",
                    "517": "",
                    "518": "\tNET_DBG(\"IPv6 packet len %d received from %s to %s\", pkt_len,",
                    "519": "\t\tnet_sprint_ipv6_addr(&hdr->src),",
                    "520": "\t\tnet_sprint_ipv6_addr(&hdr->dst));",
                    "521": "",
                    "522": "\tif (net_ipv6_is_addr_unspecified_raw(hdr->src)) {",
                    "523": "\t\t/* If this is a possible DAD message, let it pass. Extra checks",
                    "524": "\t\t * are done in duplicate address detection code to verify that",
                    "525": "\t\t * the packet is ok.",
                    "526": "\t\t */",
                    "527": "\t\tif (!(IS_ENABLED(CONFIG_NET_IPV6_DAD) &&",
                    "528": "\t\t      net_ipv6_is_addr_solicited_node_raw(hdr->dst))) {",
                    "529": "\t\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");",
                    "530": "\t\t\tgoto drop;",
                    "531": "\t\t}",
                    "532": "\t}",
                    "533": "",
                    "534": "\tif (net_ipv6_is_addr_mcast_raw(hdr->src) ||",
                    "535": "\t    net_ipv6_is_addr_mcast_scope_raw(hdr->dst, 0)) {",
                    "536": "\t\tNET_DBG(\"DROP: multicast packet\");",
                    "537": "\t\tgoto drop;",
                    "538": "\t}",
                    "539": "",
                    "540": "\tif (!net_pkt_is_loopback(pkt)) {",
                    "541": "\t\tif (net_ipv6_is_addr_loopback_raw(hdr->dst) ||",
                    "542": "\t\t    net_ipv6_is_addr_loopback_raw(hdr->src)) {",
                    "543": "\t\t\tNET_DBG(\"DROP: ::1 packet\");",
                    "544": "\t\t\tgoto drop;",
                    "545": "\t\t}",
                    "546": "",
                    "547": "\t\tif (net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||",
                    "548": "\t\t    (net_ipv6_is_addr_mcast_group_raw(",
                    "549": "\t\t\t    hdr->dst,",
                    "550": "\t\t\t    (const uint8_t *)net_ipv6_unspecified_address()) &&",
                    "551": "\t\t     (net_ipv6_is_addr_mcast_site_raw(hdr->dst) ||",
                    "552": "\t\t      net_ipv6_is_addr_mcast_org_raw(hdr->dst)))) {",
                    "553": "\t\t\tNET_DBG(\"DROP: invalid scope multicast packet\");",
                    "554": "\t\t\tgoto drop;",
                    "555": "\t\t}",
                    "556": "",
                    "557": "\t\t/* We need to pass the packet through in case our address is",
                    "558": "\t\t * tentative, as receiving a packet with a tentative address as",
                    "559": "\t\t * source means that duplicate address has been detected.",
                    "560": "\t\t * This check is done later on if routing features are enabled.",
                    "561": "\t\t */",
                    "562": "\t\tif (!IS_ENABLED(CONFIG_NET_ROUTING) && !IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&",
                    "563": "\t\t    is_src_non_tentative_itself(hdr->src)) {",
                    "564": "\t\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");",
                    "565": "\t\t\tgoto drop;",
                    "566": "\t\t}",
                    "567": "\t}",
                    "568": "",
                    "569": "\t/* Reconstruct TC field. */",
                    "570": "",
                    "571": "\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {",
                    "572": "\t\tuint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);",
                    "573": "",
                    "574": "\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));",
                    "575": "\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));",
                    "576": "\t}",
                    "577": "",
                    "578": "\t/* Check extension headers */",
                    "579": "\tnet_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);",
                    "580": "\tnet_pkt_set_ipv6_ext_len(pkt, 0);",
                    "581": "\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));",
                    "582": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);",
                    "583": "\tnet_pkt_set_family(pkt, NET_PF_INET6);",
                    "584": "",
                    "585": "\tif (!net_pkt_filter_ip_recv_ok(pkt)) {",
                    "586": "\t\t/* drop the packet */",
                    "587": "\t\tNET_DBG(\"DROP: pkt filter\");",
                    "588": "\t\tnet_stats_update_filter_rx_ipv6_drop(net_pkt_iface(pkt));",
                    "589": "\t\treturn NET_DROP;",
                    "590": "\t}",
                    "591": "",
                    "592": "\tif (IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&",
                    "593": "\t\tnet_ipv6_is_addr_mcast_raw(hdr->dst) && !net_pkt_forwarding(pkt)) {",
                    "594": "\t\t/* If the packet is a multicast packet and multicast routing",
                    "595": "\t\t * is activated, we give the packet to the routing engine.",
                    "596": "\t\t *",
                    "597": "\t\t * But we only drop the packet if an error occurs, otherwise",
                    "598": "\t\t * it might be eminent to respond on the packet on application",
                    "599": "\t\t * layer.",
                    "600": "\t\t */",
                    "601": "\t\tif (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {",
                    "602": "\t\t\tNET_DBG(\"DROP: forward mcast\");",
                    "603": "\t\t\tgoto drop;",
                    "604": "\t\t}",
                    "605": "\t}",
                    "606": "",
                    "607": "\tif (!net_ipv6_is_addr_mcast_raw(hdr->dst)) {",
                    "608": "\t\tif (!net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {",
                    "609": "\t\t\tif (ipv6_route_packet(pkt, hdr) == NET_OK) {",
                    "610": "\t\t\t\treturn NET_OK;",
                    "611": "\t\t\t}",
                    "612": "",
                    "613": "\t\t\tNET_DBG(\"DROP: no such address %s in iface %d\",",
                    "614": "\t\t\t\tnet_sprint_ipv6_addr(hdr->dst),",
                    "615": "\t\t\t\tnet_if_get_by_iface(pkt_iface));",
                    "616": "\t\t\tgoto drop;",
                    "617": "\t\t}",
                    "618": "",
                    "619": "\t\t/* If we receive a packet with ll source address fe80: and",
                    "620": "\t\t * destination address is one of ours, and if the packet would",
                    "621": "\t\t * cross interface boundary, then drop the packet.",
                    "622": "\t\t * RFC 4291 ch 2.5.6",
                    "623": "\t\t */",
                    "624": "\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&",
                    "625": "\t\t    net_ipv6_is_ll_addr_raw(hdr->src) &&",
                    "626": "\t\t    !net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {",
                    "627": "\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);",
                    "628": "\t\t\tNET_DBG(\"DROP: cross interface boundary\");",
                    "629": "\t\t\tgoto drop;",
                    "630": "\t\t}",
                    "631": "\t}",
                    "632": "",
                    "633": "\tif ((IS_ENABLED(CONFIG_NET_ROUTING) || IS_ENABLED(CONFIG_NET_ROUTE_MCAST)) &&",
                    "634": "\t    !net_pkt_is_loopback(pkt) && is_src_non_tentative_itself(hdr->src)) {",
                    "635": "\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");",
                    "636": "\t\tgoto drop;",
                    "637": "\t}",
                    "638": "",
                    "639": "\tif (net_ipv6_is_addr_mcast_raw(hdr->dst) &&",
                    "640": "\t    !(net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||",
                    "641": "\t      net_ipv6_is_addr_mcast_link_all_nodes_raw(hdr->dst))) {",
                    "642": "\t\t/* If we receive a packet with a interface-local or",
                    "643": "\t\t * link-local all-nodes multicast destination address we",
                    "644": "\t\t * always have to pass it to the upper layer.",
                    "645": "\t\t *",
                    "646": "\t\t * For all other destination multicast addresses we have to",
                    "647": "\t\t * check if one of the joined multicast groups on the",
                    "648": "\t\t * originating interface of the packet matches. Otherwise the",
                    "649": "\t\t * packet will be dropped.",
                    "650": "\t\t * RFC4291 ch 2.7.1, ch 2.8",
                    "651": "\t\t */",
                    "652": "\t\tif_mcast_addr = net_if_ipv6_maddr_lookup_raw(hdr->dst, &pkt_iface);",
                    "653": "\t\tif (!if_mcast_addr ||",
                    "654": "\t\t    !net_if_ipv6_maddr_is_joined(if_mcast_addr)) {",
                    "655": "\t\t\tNET_DBG(\"DROP: packet for unjoined multicast address\");",
                    "656": "\t\t\tgoto drop;",
                    "657": "\t\t}",
                    "658": "\t}",
                    "659": "",
                    "660": "\tnet_pkt_acknowledge_data(pkt, &ipv6_access);",
                    "661": "",
                    "662": "\tcurrent_hdr = hdr->nexthdr;",
                    "663": "\text_bitmap = extension_to_bitmap(current_hdr, ext_bitmap);",
                    "664": "\t/* Offset of \"nexthdr\" in the IPv6 header */",
                    "665": "\tprev_hdr_offset = (uint8_t *)&hdr->nexthdr - (uint8_t *)hdr;",
                    "666": "\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);",
                    "667": "",
                    "668": "\twhile (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {",
                    "669": "\t\tint exthdr_len;",
                    "670": "\t\tuint8_t ext_bit;",
                    "671": "",
                    "672": "\t\tNET_DBG(\"IPv6 next header %d\", current_hdr);",
                    "673": "",
                    "674": "\t\tif (current_hdr == NET_IPV6_NEXTHDR_NONE) {",
                    "675": "\t\t\t/* There is nothing after this header (see RFC 2460,",
                    "676": "\t\t\t * ch 4.7), so we can drop the packet now.",
                    "677": "\t\t\t * This is not an error case so do not update drop",
                    "678": "\t\t\t * statistics.",
                    "679": "\t\t\t */",
                    "680": "\t\t\tNET_DBG(\"DROP: none nexthdr\");",
                    "681": "\t\t\treturn NET_DROP;",
                    "682": "\t\t}",
                    "683": "",
                    "684": "\t\t/* Offset of \"nexthdr\" in the Extension Header */",
                    "685": "\t\tprev_hdr_offset = net_pkt_get_current_offset(pkt);",
                    "686": "",
                    "687": "\t\tif (net_pkt_read_u8(pkt, &nexthdr)) {",
                    "688": "\t\t\tNET_DBG(\"DROP: pkt invalid read\");",
                    "689": "\t\t\tgoto drop;",
                    "690": "\t\t}",
                    "691": "",
                    "692": "\t\t/* Detect duplicated Extension headers */",
                    "693": "\t\text_bit = extension_to_bitmap(nexthdr, ext_bitmap);",
                    "694": "\t\tif (ext_bit & ext_bitmap) {",
                    "695": "\t\t\tgoto bad_hdr;",
                    "696": "\t\t}",
                    "697": "\t\text_bitmap |= ext_bit;",
                    "698": "",
                    "699": "\t\t/* Make sure that nexthdr is valid, reject the Extension Header early otherwise.",
                    "700": "\t\t * This is also important so that the \"pointer\" field in the ICMPv6 error",
                    "701": "\t\t * message points to the \"nexthdr\" field.",
                    "702": "\t\t */",
                    "703": "\t\tswitch (nexthdr) {",
                    "704": "\t\tcase NET_IPV6_NEXTHDR_HBHO:",
                    "705": "\t\t\t/* Hop-by-hop header can appear only once and must appear right after",
                    "706": "\t\t\t * the IPv6 header. Consequently the \"nexthdr\" field of an Extension",
                    "707": "\t\t\t * Header can never be an HBH option.",
                    "708": "\t\t\t */",
                    "709": "\t\t\tgoto bad_hdr;",
                    "710": "",
                    "711": "\t\tcase NET_IPV6_NEXTHDR_DESTO:",
                    "712": "\t\tcase NET_IPV6_NEXTHDR_FRAG:",
                    "713": "\t\tcase NET_IPV6_NEXTHDR_NONE:",
                    "714": "\t\t\t/* Valid values */",
                    "715": "\t\t\tbreak;",
                    "716": "",
                    "717": "\t\tdefault:",
                    "718": "\t\t\tif (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {",
                    "719": "\t\t\t\tbreak;",
                    "720": "\t\t\t}",
                    "721": "\t\t\tgoto bad_hdr;",
                    "722": "\t\t}",
                    "723": "",
                    "724": "\t\t/* Process the current Extension Header */",
                    "725": "\t\tswitch (current_hdr) {",
                    "726": "\t\tcase NET_IPV6_NEXTHDR_HBHO:",
                    "727": "\t\tcase NET_IPV6_NEXTHDR_DESTO:",
                    "728": "\t\t\t/* Process options below */",
                    "729": "\t\t\tbreak;",
                    "730": "",
                    "731": "\t\tcase NET_IPV6_NEXTHDR_FRAG:",
                    "732": "\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6_FRAGMENT)) {",
                    "733": "\t\t\t\tnet_pkt_set_ipv6_fragment_start(",
                    "734": "\t\t\t\t\tpkt,",
                    "735": "\t\t\t\t\tnet_pkt_get_current_offset(pkt) - 1);",
                    "736": "\t\t\t\treturn net_ipv6_handle_fragment_hdr(pkt, hdr,",
                    "737": "\t\t\t\t\t\t\t\t    current_hdr);",
                    "738": "\t\t\t}",
                    "739": "",
                    "740": "\t\t\tgoto bad_hdr;",
                    "741": "",
                    "742": "\t\tdefault:",
                    "743": "\t\t\t/* Unsupported */",
                    "744": "\t\t\tgoto bad_hdr;",
                    "745": "\t\t}",
                    "746": "",
                    "747": "\t\texthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);",
                    "748": "\t\tif (exthdr_len < 0) {",
                    "749": "\t\t\tNET_DBG(\"DROP: extension hdr len (%d)\", exthdr_len);",
                    "750": "\t\t\tgoto drop;",
                    "751": "\t\t}",
                    "752": "",
                    "753": "\t\text_len += exthdr_len;",
                    "754": "\t\tcurrent_hdr = nexthdr;",
                    "755": "\t\t/* Save the offset to \"nexthdr\" in case we need to overwrite it",
                    "756": "\t\t * when processing a fragment header",
                    "757": "\t\t */",
                    "758": "\t\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);",
                    "759": "\t}",
                    "760": "",
                    "761": "\tnet_pkt_set_ipv6_ext_len(pkt, ext_len);",
                    "762": "",
                    "763": "\tip.ipv6 = hdr;",
                    "764": "",
                    "765": "\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW)) {",
                    "766": "\t\tif (net_conn_raw_ip_input(pkt, &ip, current_hdr) == NET_DROP) {",
                    "767": "\t\t\tgoto drop;",
                    "768": "\t\t}",
                    "769": "\t}",
                    "770": "",
                    "771": "\tswitch (current_hdr) {",
                    "772": "\tcase NET_IPPROTO_ICMPV6:",
                    "773": "\t\tverdict = net_icmpv6_input(pkt, hdr);",
                    "774": "\t\tbreak;",
                    "775": "\tcase NET_IPPROTO_TCP:",
                    "776": "\t\tproto_hdr.tcp = net_tcp_input(pkt, &tcp_access);",
                    "777": "\t\tif (proto_hdr.tcp) {",
                    "778": "\t\t\tverdict = NET_OK;",
                    "779": "\t\t}",
                    "780": "",
                    "781": "\t\tNET_DBG(\"%s verdict %s\", \"TCP\", net_verdict2str(verdict));",
                    "782": "\t\tbreak;",
                    "783": "\tcase NET_IPPROTO_UDP:",
                    "784": "\t\tproto_hdr.udp = net_udp_input(pkt, &udp_access);",
                    "785": "\t\tif (proto_hdr.udp) {",
                    "786": "\t\t\tverdict = NET_OK;",
                    "787": "\t\t}",
                    "788": "",
                    "789": "\t\tNET_DBG(\"%s verdict %s\", \"UDP\", net_verdict2str(verdict));",
                    "790": "\t\tbreak;",
                    "791": "",
                    "792": "#if defined(CONFIG_NET_L2_IPIP)",
                    "793": "\tcase NET_IPPROTO_IPV6:",
                    "794": "\tcase NET_IPPROTO_IPIP: {",
                    "795": "\t\tstruct net_sockaddr_in6 remote_addr = { 0 };",
                    "796": "\t\tstruct net_if *tunnel_iface;",
                    "797": "",
                    "798": "\t\tremote_addr.sin6_family = NET_AF_INET6;",
                    "799": "\t\tnet_ipv6_addr_copy_raw((uint8_t *)&remote_addr.sin6_addr, hdr->src);",
                    "800": "",
                    "801": "\t\tnet_pkt_set_remote_address(pkt, (struct net_sockaddr *)&remote_addr,",
                    "802": "\t\t\t\t\t   sizeof(struct net_sockaddr_in6));",
                    "803": "",
                    "804": "\t\t/* Get rid of the old IP header */",
                    "805": "\t\tnet_pkt_cursor_restore(pkt, &hdr_start);",
                    "806": "\t\tnet_pkt_pull(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "807": "\t\t\t     net_pkt_ipv6_ext_len(pkt));",
                    "808": "",
                    "809": "\t\ttunnel_iface = net_ipip_get_virtual_interface(net_pkt_iface(pkt));",
                    "810": "\t\tif (tunnel_iface != NULL && net_if_l2(tunnel_iface)->recv != NULL) {",
                    "811": "\t\t\treturn net_if_l2(tunnel_iface)->recv(net_pkt_iface(pkt), pkt);",
                    "812": "\t\t}",
                    "813": "\t}",
                    "814": "#endif",
                    "815": "\t}",
                    "816": "",
                    "817": "\tif (verdict == NET_DROP) {",
                    "818": "\t\tNET_DBG(\"DROP: because verdict\");",
                    "819": "\t\tgoto drop;",
                    "820": "\t} else if (current_hdr == NET_IPPROTO_ICMPV6) {",
                    "821": "\t\tNET_DBG(\"%s verdict %s\", \"ICMPv6\", net_verdict2str(verdict));",
                    "822": "\t\treturn verdict;",
                    "823": "\t}",
                    "824": "",
                    "825": "\tverdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);",
                    "826": "",
                    "827": "\tNET_DBG(\"%s verdict %s\", \"Connection\", net_verdict2str(verdict));",
                    "828": "",
                    "829": "\tif (verdict != NET_DROP) {",
                    "830": "\t\treturn verdict;",
                    "831": "\t}",
                    "832": "",
                    "833": "drop:",
                    "834": "\tnet_stats_update_ipv6_drop(pkt_iface);",
                    "835": "\treturn NET_DROP;",
                    "836": "",
                    "837": "bad_hdr:",
                    "838": "\t/* Send error message about parameter problem (RFC 2460) */",
                    "839": "\tnet_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,",
                    "840": "\t\t\t      NET_ICMPV6_PARAM_PROB_NEXTHEADER,",
                    "841": "\t\t\t      net_pkt_get_current_offset(pkt) - 1);",
                    "842": "",
                    "843": "\tNET_DBG(\"DROP: Unknown/wrong nexthdr type\");",
                    "844": "\tnet_stats_update_ip_errors_protoerr(pkt_iface);",
                    "845": "",
                    "846": "\treturn NET_DROP;",
                    "847": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ipv6_route_packet": {
            "name": "ipv6_route_packet",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 319,
            "function_content": [
                "#endif /* CONFIG_NET_ROUTE */\nstatic enum net_verdict ipv6_route_packet(struct net_pkt *pkt,\n\t\t\t\t\t  struct net_ipv6_hdr *hdr)\n{\n\tstruct net_route_entry *route;\n\tstruct net_in6_addr *nexthop;\n\tstruct net_in6_addr src_ip, dst_ip;\n\tbool found;\n\n\tnet_ipv6_addr_copy_raw(src_ip.s6_addr, hdr->src);\n\tnet_ipv6_addr_copy_raw(dst_ip.s6_addr, hdr->dst);\n\n\t/* Check if the packet can be routed */\n\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {\n\t\tfound = net_route_get_info(NULL, &dst_ip, &route, &nexthop);\n\t} else {\n\t\tfound = net_route_get_info(net_pkt_iface(pkt), &dst_ip,\n\t\t\t\t\t   &route, &nexthop);\n\t}\n\n\tif (found) {\n\t\tint ret;\n\n\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&\n\t\t    (net_ipv6_is_ll_addr(&src_ip) ||\n\t\t     net_ipv6_is_ll_addr(&dst_ip))) {\n\t\t\t/* RFC 4291 ch 2.5.6 */\n\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);\n\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Used when detecting if the original link\n\t\t * layer address length is changed or not.\n\t\t */\n\t\tnet_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));\n\n\t\tif (route) {\n\t\t\tnet_pkt_set_iface(pkt, route->iface);\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&\n\t\t    net_pkt_orig_iface(pkt) != net_pkt_iface(pkt) &&\n\t\t    !net_if_flag_is_set(net_pkt_orig_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\t\t/* If the route interface to destination is\n\t\t\t * different than the original route, then add\n\t\t\t * route to original source.\n\t\t\t */\n\t\t\tNET_DBG(\"Route pkt %p from %p to %p\",\n\t\t\t\tpkt, net_pkt_orig_iface(pkt),\n\t\t\t\tnet_pkt_iface(pkt));\n\n\t\t\tadd_route(net_pkt_orig_iface(pkt), &src_ip, 128);\n\t\t}\n\n\t\tret = net_route_packet(pkt, nexthop);\n\t\tif (ret < 0) {\n\t\t\tNET_DBG(\"Cannot re-route pkt %p via %s \"\n\t\t\t\t\"at iface %p (%d)\",\n\t\t\t\tpkt, net_sprint_ipv6_addr(nexthop),\n\t\t\t\tnet_pkt_iface(pkt), ret);\n\t\t} else {\n\t\t\treturn NET_OK;\n\t\t}\n\t} else {\n\t\tstruct net_if *iface = NULL;\n\t\tint ret;\n\n\t\tif (net_if_ipv6_addr_onlink(&iface, &dst_ip)) {\n\t\t\tret = net_route_packet_if(pkt, iface);\n\t\t\tif (ret < 0) {\n\t\t\t\tNET_DBG(\"Cannot re-route pkt %p \"\n\t\t\t\t\t\"at iface %p (%d)\",\n\t\t\t\t\tpkt, net_pkt_iface(pkt), ret);\n\t\t\t} else {\n\t\t\t\treturn NET_OK;\n\t\t\t}\n\t\t}\n\n\t\tNET_DBG(\"No route to %s pkt %p dropped\",\n\t\t\tnet_sprint_ipv6_addr(&dst_ip), pkt);\n\t}\n\ndrop:\n\treturn NET_DROP;\n}\n",
                {
                    "319": "static enum net_verdict ipv6_route_packet(struct net_pkt *pkt,",
                    "320": "\t\t\t\t\t  struct net_ipv6_hdr *hdr)",
                    "321": "{",
                    "322": "\tstruct net_route_entry *route;",
                    "323": "\tstruct net_in6_addr *nexthop;",
                    "324": "\tstruct net_in6_addr src_ip, dst_ip;",
                    "325": "\tbool found;",
                    "326": "",
                    "327": "\tnet_ipv6_addr_copy_raw(src_ip.s6_addr, hdr->src);",
                    "328": "\tnet_ipv6_addr_copy_raw(dst_ip.s6_addr, hdr->dst);",
                    "329": "",
                    "330": "\t/* Check if the packet can be routed */",
                    "331": "\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {",
                    "332": "\t\tfound = net_route_get_info(NULL, &dst_ip, &route, &nexthop);",
                    "333": "\t} else {",
                    "334": "\t\tfound = net_route_get_info(net_pkt_iface(pkt), &dst_ip,",
                    "335": "\t\t\t\t\t   &route, &nexthop);",
                    "336": "\t}",
                    "337": "",
                    "338": "\tif (found) {",
                    "339": "\t\tint ret;",
                    "340": "",
                    "341": "\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&",
                    "342": "\t\t    (net_ipv6_is_ll_addr(&src_ip) ||",
                    "343": "\t\t     net_ipv6_is_ll_addr(&dst_ip))) {",
                    "344": "\t\t\t/* RFC 4291 ch 2.5.6 */",
                    "345": "\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);",
                    "346": "",
                    "347": "\t\t\tgoto drop;",
                    "348": "\t\t}",
                    "349": "",
                    "350": "\t\t/* Used when detecting if the original link",
                    "351": "\t\t * layer address length is changed or not.",
                    "352": "\t\t */",
                    "353": "\t\tnet_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));",
                    "354": "",
                    "355": "\t\tif (route) {",
                    "356": "\t\t\tnet_pkt_set_iface(pkt, route->iface);",
                    "357": "\t\t}",
                    "358": "",
                    "359": "\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&",
                    "360": "\t\t    net_pkt_orig_iface(pkt) != net_pkt_iface(pkt) &&",
                    "361": "\t\t    !net_if_flag_is_set(net_pkt_orig_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "362": "\t\t\t/* If the route interface to destination is",
                    "363": "\t\t\t * different than the original route, then add",
                    "364": "\t\t\t * route to original source.",
                    "365": "\t\t\t */",
                    "366": "\t\t\tNET_DBG(\"Route pkt %p from %p to %p\",",
                    "367": "\t\t\t\tpkt, net_pkt_orig_iface(pkt),",
                    "368": "\t\t\t\tnet_pkt_iface(pkt));",
                    "369": "",
                    "370": "\t\t\tadd_route(net_pkt_orig_iface(pkt), &src_ip, 128);",
                    "371": "\t\t}",
                    "372": "",
                    "373": "\t\tret = net_route_packet(pkt, nexthop);",
                    "374": "\t\tif (ret < 0) {",
                    "375": "\t\t\tNET_DBG(\"Cannot re-route pkt %p via %s \"",
                    "376": "\t\t\t\t\"at iface %p (%d)\",",
                    "377": "\t\t\t\tpkt, net_sprint_ipv6_addr(nexthop),",
                    "378": "\t\t\t\tnet_pkt_iface(pkt), ret);",
                    "379": "\t\t} else {",
                    "380": "\t\t\treturn NET_OK;",
                    "381": "\t\t}",
                    "382": "\t} else {",
                    "383": "\t\tstruct net_if *iface = NULL;",
                    "384": "\t\tint ret;",
                    "385": "",
                    "386": "\t\tif (net_if_ipv6_addr_onlink(&iface, &dst_ip)) {",
                    "387": "\t\t\tret = net_route_packet_if(pkt, iface);",
                    "388": "\t\t\tif (ret < 0) {",
                    "389": "\t\t\t\tNET_DBG(\"Cannot re-route pkt %p \"",
                    "390": "\t\t\t\t\t\"at iface %p (%d)\",",
                    "391": "\t\t\t\t\tpkt, net_pkt_iface(pkt), ret);",
                    "392": "\t\t\t} else {",
                    "393": "\t\t\t\treturn NET_OK;",
                    "394": "\t\t\t}",
                    "395": "\t\t}",
                    "396": "",
                    "397": "\t\tNET_DBG(\"No route to %s pkt %p dropped\",",
                    "398": "\t\t\tnet_sprint_ipv6_addr(&dst_ip), pkt);",
                    "399": "\t}",
                    "400": "",
                    "401": "drop:",
                    "402": "\treturn NET_DROP;",
                    "403": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_finalize": {
            "name": "net_ipv6_finalize",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 118,
            "function_content": [
                "/* Set the hop limit by default from net_pkt as that could\n* be set for example when sending NS. If the limit is 0,\n* then take the value from socket.\n*/\nint net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tstruct net_ipv6_hdr *ipv6_hdr;\n\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);\n\tif (!ipv6_hdr) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tipv6_hdr->len = net_htons(net_pkt_get_len(pkt) -\n\t\t\t      sizeof(struct net_ipv6_hdr));\n\n\tif (net_pkt_ipv6_next_hdr(pkt) != 255U) {\n\t\tipv6_hdr->nexthdr = net_pkt_ipv6_next_hdr(pkt);\n\t} else {\n\t\tipv6_hdr->nexthdr = next_header_proto;\n\t}\n\n\tnet_pkt_set_data(pkt, &ipv6_access);\n\n\tif (net_pkt_ipv6_next_hdr(pkt) != 255U &&\n\t    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IPV6);\n\n\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t    next_header_proto == NET_IPPROTO_UDP) {\n\t\treturn net_udp_finalize(pkt, false);\n\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&\n\t\t   next_header_proto == NET_IPPROTO_TCP) {\n\t\treturn net_tcp_finalize(pkt, false);\n\t} else if (next_header_proto == NET_IPPROTO_ICMPV6) {\n\t\treturn net_icmpv6_finalize(pkt, false);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "118": "int net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)",
                    "119": "{",
                    "120": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "121": "\tstruct net_ipv6_hdr *ipv6_hdr;",
                    "122": "",
                    "123": "\tnet_pkt_set_overwrite(pkt, true);",
                    "124": "",
                    "125": "\tipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);",
                    "126": "\tif (!ipv6_hdr) {",
                    "127": "\t\treturn -ENOBUFS;",
                    "128": "\t}",
                    "129": "",
                    "130": "\tipv6_hdr->len = net_htons(net_pkt_get_len(pkt) -",
                    "131": "\t\t\t      sizeof(struct net_ipv6_hdr));",
                    "132": "",
                    "133": "\tif (net_pkt_ipv6_next_hdr(pkt) != 255U) {",
                    "134": "\t\tipv6_hdr->nexthdr = net_pkt_ipv6_next_hdr(pkt);",
                    "135": "\t} else {",
                    "136": "\t\tipv6_hdr->nexthdr = next_header_proto;",
                    "137": "\t}",
                    "138": "",
                    "139": "\tnet_pkt_set_data(pkt, &ipv6_access);",
                    "140": "",
                    "141": "\tif (net_pkt_ipv6_next_hdr(pkt) != 255U &&",
                    "142": "\t    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {",
                    "143": "\t\treturn -ENOBUFS;",
                    "144": "\t}",
                    "145": "",
                    "146": "\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IPV6);",
                    "147": "",
                    "148": "\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "149": "\t    next_header_proto == NET_IPPROTO_UDP) {",
                    "150": "\t\treturn net_udp_finalize(pkt, false);",
                    "151": "\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "152": "\t\t   next_header_proto == NET_IPPROTO_TCP) {",
                    "153": "\t\treturn net_tcp_finalize(pkt, false);",
                    "154": "\t} else if (next_header_proto == NET_IPPROTO_ICMPV6) {",
                    "155": "\t\treturn net_icmpv6_finalize(pkt, false);",
                    "156": "\t}",
                    "157": "",
                    "158": "\treturn 0;",
                    "159": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_create": {
            "name": "net_ipv6_create",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 60,
            "function_content": [
                "/* Maximum reachable time value specified in RFC 4861 section\n* 6.2.1. Router Configuration Variables, AdvReachableTime\n*/\nint net_ipv6_create(struct net_pkt *pkt,\n\t\t    const struct net_in6_addr *src,\n\t\t    const struct net_in6_addr *dst)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tstruct net_ipv6_hdr *ipv6_hdr;\n\tuint8_t tc = 0;\n\n\tipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);\n\tif (!ipv6_hdr) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {\n\t\tnet_ipv6_set_dscp(&tc, net_pkt_ip_dscp(pkt));\n\t\tnet_ipv6_set_ecn(&tc, net_pkt_ip_ecn(pkt));\n\t}\n\n\tipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);\n\tipv6_hdr->tcflow  = (tc << 4) & 0xF0;\n\tipv6_hdr->flow    = 0U;\n\tipv6_hdr->len     = 0U;\n\tipv6_hdr->nexthdr = 0U;\n\n\t/* Set the hop limit by default from net_pkt as that could\n\t * be set for example when sending NS. If the limit is 0,\n\t * then take the value from socket.\n\t */\n\tipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);\n\tif (ipv6_hdr->hop_limit == 0U) {\n\t\tif (net_ipv6_is_addr_mcast(dst)) {\n\t\t\tif (net_pkt_context(pkt) != NULL) {\n\t\t\t\tipv6_hdr->hop_limit =\n\t\t\t\t\tnet_context_get_ipv6_mcast_hop_limit(net_pkt_context(pkt));\n\t\t\t} else {\n\t\t\t\tipv6_hdr->hop_limit =\n\t\t\t\t\tnet_if_ipv6_get_mcast_hop_limit(net_pkt_iface(pkt));\n\t\t\t}\n\t\t} else {\n\t\t\tif (net_pkt_context(pkt) != NULL) {\n\t\t\t\tipv6_hdr->hop_limit =\n\t\t\t\t\tnet_context_get_ipv6_hop_limit(net_pkt_context(pkt));\n\t\t\t} else {\n\t\t\t\tipv6_hdr->hop_limit =\n\t\t\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt));\n\t\t\t}\n\t\t}\n\t}\n\n\tnet_ipv6_addr_copy_raw(ipv6_hdr->dst, (uint8_t *)dst);\n\tnet_ipv6_addr_copy_raw(ipv6_hdr->src, (uint8_t *)src);\n\n\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));\n\tnet_pkt_set_ipv6_ext_len(pkt, 0);\n\n\treturn net_pkt_set_data(pkt, &ipv6_access);\n}\n",
                {
                    "60": "int net_ipv6_create(struct net_pkt *pkt,",
                    "61": "\t\t    const struct net_in6_addr *src,",
                    "62": "\t\t    const struct net_in6_addr *dst)",
                    "63": "{",
                    "64": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "65": "\tstruct net_ipv6_hdr *ipv6_hdr;",
                    "66": "\tuint8_t tc = 0;",
                    "67": "",
                    "68": "\tipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);",
                    "69": "\tif (!ipv6_hdr) {",
                    "70": "\t\treturn -ENOBUFS;",
                    "71": "\t}",
                    "72": "",
                    "73": "\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {",
                    "74": "\t\tnet_ipv6_set_dscp(&tc, net_pkt_ip_dscp(pkt));",
                    "75": "\t\tnet_ipv6_set_ecn(&tc, net_pkt_ip_ecn(pkt));",
                    "76": "\t}",
                    "77": "",
                    "78": "\tipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);",
                    "79": "\tipv6_hdr->tcflow  = (tc << 4) & 0xF0;",
                    "80": "\tipv6_hdr->flow    = 0U;",
                    "81": "\tipv6_hdr->len     = 0U;",
                    "82": "\tipv6_hdr->nexthdr = 0U;",
                    "83": "",
                    "84": "\t/* Set the hop limit by default from net_pkt as that could",
                    "85": "\t * be set for example when sending NS. If the limit is 0,",
                    "86": "\t * then take the value from socket.",
                    "87": "\t */",
                    "88": "\tipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);",
                    "89": "\tif (ipv6_hdr->hop_limit == 0U) {",
                    "90": "\t\tif (net_ipv6_is_addr_mcast(dst)) {",
                    "91": "\t\t\tif (net_pkt_context(pkt) != NULL) {",
                    "92": "\t\t\t\tipv6_hdr->hop_limit =",
                    "93": "\t\t\t\t\tnet_context_get_ipv6_mcast_hop_limit(net_pkt_context(pkt));",
                    "94": "\t\t\t} else {",
                    "95": "\t\t\t\tipv6_hdr->hop_limit =",
                    "96": "\t\t\t\t\tnet_if_ipv6_get_mcast_hop_limit(net_pkt_iface(pkt));",
                    "97": "\t\t\t}",
                    "98": "\t\t} else {",
                    "99": "\t\t\tif (net_pkt_context(pkt) != NULL) {",
                    "100": "\t\t\t\tipv6_hdr->hop_limit =",
                    "101": "\t\t\t\t\tnet_context_get_ipv6_hop_limit(net_pkt_context(pkt));",
                    "102": "\t\t\t} else {",
                    "103": "\t\t\t\tipv6_hdr->hop_limit =",
                    "104": "\t\t\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt));",
                    "105": "\t\t\t}",
                    "106": "\t\t}",
                    "107": "\t}",
                    "108": "",
                    "109": "\tnet_ipv6_addr_copy_raw(ipv6_hdr->dst, (uint8_t *)dst);",
                    "110": "\tnet_ipv6_addr_copy_raw(ipv6_hdr->src, (uint8_t *)src);",
                    "111": "",
                    "112": "\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));",
                    "113": "\tnet_pkt_set_ipv6_ext_len(pkt, 0);",
                    "114": "",
                    "115": "\treturn net_pkt_set_data(pkt, &ipv6_access);",
                    "116": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "handle_mld_query": {
            "name": "handle_mld_query",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_mld.c",
            "location_line": 409,
            "function_content": [
                "/* We may have skipped duplicated addresses that we reserved space for,\n* modify number of records.\n*/\nstatic int handle_mld_query(struct net_icmp_ctx *ctx,\n\t\t\t    struct net_pkt *pkt,\n\t\t\t    struct net_icmp_ip_hdr *hdr,\n\t\t\t    struct net_icmp_hdr *icmp_hdr,\n\t\t\t    void *user_data)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,\n\t\t\t\t\t      struct net_icmpv6_mld_query);\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tuint16_t length = net_pkt_get_len(pkt);\n\tstruct net_icmpv6_mld_query *mld_query;\n\tuint16_t pkt_len;\n\tint ret = -EIO;\n\n\tif (net_pkt_remaining_data(pkt) < sizeof(struct net_icmpv6_mld_query)) {\n\t\t/* MLDv1 query, drop. */\n\t\tret = 0;\n\t\tgoto drop;\n\t}\n\n\tmld_query = (struct net_icmpv6_mld_query *)\n\t\t\t\tnet_pkt_get_data(pkt, &mld_access);\n\tif (!mld_query) {\n\t\tNET_DBG(\"DROP: NULL MLD query\");\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &mld_access);\n\n\tdbg_addr_recv(\"Multicast Listener Query\", &ip_hdr->src, &ip_hdr->dst);\n\n\tnet_stats_update_ipv6_mld_recv(net_pkt_iface(pkt));\n\n\tmld_query->num_sources = net_ntohs(mld_query->num_sources);\n\n\tpkt_len = sizeof(struct net_ipv6_hdr) +\tnet_pkt_ipv6_ext_len(pkt) +\n\t\tsizeof(struct net_icmp_hdr) +\n\t\tsizeof(struct net_icmpv6_mld_query) +\n\t\tsizeof(struct net_in6_addr) * mld_query->num_sources;\n\n\tif (length < pkt_len || pkt_len > NET_IPV6_MTU ||\n\t    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {\n\t\tgoto drop;\n\t}\n\n\t/* Currently we only support an unspecified address query. */\n\tif (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,\n\t\t\t\t   (uint8_t *)net_ipv6_unspecified_address())) {\n\t\tNET_DBG(\"DROP: only supporting unspecified address query\");\n\t\tgoto drop;\n\t}\n\n\treturn send_mld_report(net_pkt_iface(pkt));\n\ndrop:\n\tnet_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));\n\n\treturn ret;\n}\n",
                {
                    "409": "static int handle_mld_query(struct net_icmp_ctx *ctx,",
                    "410": "\t\t\t    struct net_pkt *pkt,",
                    "411": "\t\t\t    struct net_icmp_ip_hdr *hdr,",
                    "412": "\t\t\t    struct net_icmp_hdr *icmp_hdr,",
                    "413": "\t\t\t    void *user_data)",
                    "414": "{",
                    "415": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,",
                    "416": "\t\t\t\t\t      struct net_icmpv6_mld_query);",
                    "417": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "418": "\tuint16_t length = net_pkt_get_len(pkt);",
                    "419": "\tstruct net_icmpv6_mld_query *mld_query;",
                    "420": "\tuint16_t pkt_len;",
                    "421": "\tint ret = -EIO;",
                    "422": "",
                    "423": "\tif (net_pkt_remaining_data(pkt) < sizeof(struct net_icmpv6_mld_query)) {",
                    "424": "\t\t/* MLDv1 query, drop. */",
                    "425": "\t\tret = 0;",
                    "426": "\t\tgoto drop;",
                    "427": "\t}",
                    "428": "",
                    "429": "\tmld_query = (struct net_icmpv6_mld_query *)",
                    "430": "\t\t\t\tnet_pkt_get_data(pkt, &mld_access);",
                    "431": "\tif (!mld_query) {",
                    "432": "\t\tNET_DBG(\"DROP: NULL MLD query\");",
                    "433": "\t\tgoto drop;",
                    "434": "\t}",
                    "435": "",
                    "436": "\tnet_pkt_acknowledge_data(pkt, &mld_access);",
                    "437": "",
                    "438": "\tdbg_addr_recv(\"Multicast Listener Query\", &ip_hdr->src, &ip_hdr->dst);",
                    "439": "",
                    "440": "\tnet_stats_update_ipv6_mld_recv(net_pkt_iface(pkt));",
                    "441": "",
                    "442": "\tmld_query->num_sources = net_ntohs(mld_query->num_sources);",
                    "443": "",
                    "444": "\tpkt_len = sizeof(struct net_ipv6_hdr) +\tnet_pkt_ipv6_ext_len(pkt) +",
                    "445": "\t\tsizeof(struct net_icmp_hdr) +",
                    "446": "\t\tsizeof(struct net_icmpv6_mld_query) +",
                    "447": "\t\tsizeof(struct net_in6_addr) * mld_query->num_sources;",
                    "448": "",
                    "449": "\tif (length < pkt_len || pkt_len > NET_IPV6_MTU ||",
                    "450": "\t    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {",
                    "451": "\t\tgoto drop;",
                    "452": "\t}",
                    "453": "",
                    "454": "\t/* Currently we only support an unspecified address query. */",
                    "455": "\tif (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,",
                    "456": "\t\t\t\t   (uint8_t *)net_ipv6_unspecified_address())) {",
                    "457": "\t\tNET_DBG(\"DROP: only supporting unspecified address query\");",
                    "458": "\t\tgoto drop;",
                    "459": "\t}",
                    "460": "",
                    "461": "\treturn send_mld_report(net_pkt_iface(pkt));",
                    "462": "",
                    "463": "drop:",
                    "464": "\tnet_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));",
                    "465": "",
                    "466": "\treturn ret;",
                    "467": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mld_create_packet": {
            "name": "mld_create_packet",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_mld.c",
            "location_line": 77,
            "function_content": [
                "/* Internal structure used for appending multicast routes to MLDv2 reports */\nstatic int mld_create_packet(struct net_pkt *pkt, uint16_t count)\n{\n\tstruct net_in6_addr dst;\n\n\t/* Sent to all MLDv2-capable routers */\n\tnet_ipv6_addr_create(&dst, 0xff02, 0, 0, 0, 0, 0, 0, 0x0016);\n\n\tnet_pkt_set_ipv6_hop_limit(pkt, 1); /* RFC 3810 ch 7.4 */\n\n\tif (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(\n\t\t\t\t    net_pkt_iface(pkt), &dst),\n\t\t\t    &dst)) {\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* Add hop-by-hop option and router alert option, RFC 3810 ch 5. */\n\tif (net_pkt_write_u8(pkt, NET_IPPROTO_ICMPV6) ||\n\t    net_pkt_write_u8(pkt, 0)) {\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* IPv6 router alert option is described in RFC 2711.\n\t * - 0x0502 RFC 2711 ch 2.1\n\t * - MLD (value 0)\n\t * - 2 bytes of padding\n\t */\n\tif (net_pkt_write_be16(pkt, 0x0502) ||\n\t    net_pkt_write_be16(pkt, 0) ||\n\t    net_pkt_write_be16(pkt, 0)) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tnet_pkt_set_ipv6_ext_len(pkt, IPV6_OPT_HDR_ROUTER_ALERT_LEN);\n\n\t/* ICMPv6 header + reserved space + count.\n\t * MLDv6 stuff will come right after\n\t */\n\tif (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||\n\t    net_pkt_write_be16(pkt, 0) ||\n\t    net_pkt_write_be16(pkt, count)) {\n\t\treturn -ENOBUFS;\n\t}\n\n\tnet_pkt_set_ipv6_next_hdr(pkt, NET_IPV6_NEXTHDR_HBHO);\n\n\treturn 0;\n}\n",
                {
                    "77": "static int mld_create_packet(struct net_pkt *pkt, uint16_t count)",
                    "78": "{",
                    "79": "\tstruct net_in6_addr dst;",
                    "80": "",
                    "81": "\t/* Sent to all MLDv2-capable routers */",
                    "82": "\tnet_ipv6_addr_create(&dst, 0xff02, 0, 0, 0, 0, 0, 0, 0x0016);",
                    "83": "",
                    "84": "\tnet_pkt_set_ipv6_hop_limit(pkt, 1); /* RFC 3810 ch 7.4 */",
                    "85": "",
                    "86": "\tif (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(",
                    "87": "\t\t\t\t    net_pkt_iface(pkt), &dst),",
                    "88": "\t\t\t    &dst)) {",
                    "89": "\t\treturn -ENOBUFS;",
                    "90": "\t}",
                    "91": "",
                    "92": "\t/* Add hop-by-hop option and router alert option, RFC 3810 ch 5. */",
                    "93": "\tif (net_pkt_write_u8(pkt, NET_IPPROTO_ICMPV6) ||",
                    "94": "\t    net_pkt_write_u8(pkt, 0)) {",
                    "95": "\t\treturn -ENOBUFS;",
                    "96": "\t}",
                    "97": "",
                    "98": "\t/* IPv6 router alert option is described in RFC 2711.",
                    "99": "\t * - 0x0502 RFC 2711 ch 2.1",
                    "100": "\t * - MLD (value 0)",
                    "101": "\t * - 2 bytes of padding",
                    "102": "\t */",
                    "103": "\tif (net_pkt_write_be16(pkt, 0x0502) ||",
                    "104": "\t    net_pkt_write_be16(pkt, 0) ||",
                    "105": "\t    net_pkt_write_be16(pkt, 0)) {",
                    "106": "\t\treturn -ENOBUFS;",
                    "107": "\t}",
                    "108": "",
                    "109": "\tnet_pkt_set_ipv6_ext_len(pkt, IPV6_OPT_HDR_ROUTER_ALERT_LEN);",
                    "110": "",
                    "111": "\t/* ICMPv6 header + reserved space + count.",
                    "112": "\t * MLDv6 stuff will come right after",
                    "113": "\t */",
                    "114": "\tif (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||",
                    "115": "\t    net_pkt_write_be16(pkt, 0) ||",
                    "116": "\t    net_pkt_write_be16(pkt, count)) {",
                    "117": "\t\treturn -ENOBUFS;",
                    "118": "\t}",
                    "119": "",
                    "120": "\tnet_pkt_set_ipv6_next_hdr(pkt, NET_IPV6_NEXTHDR_HBHO);",
                    "121": "",
                    "122": "\treturn 0;",
                    "123": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "handle_ra_input": {
            "name": "handle_ra_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 2616,
            "function_content": [
                "/* Skip the rest of the DNS servers. */\nstatic int handle_ra_input(struct net_icmp_ctx *ctx,\n\t\t\t   struct net_pkt *pkt,\n\t\t\t   struct net_icmp_ip_hdr *hdr,\n\t\t\t   struct net_icmp_hdr *icmp_hdr,\n\t\t\t   void *user_data)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,\n\t\t\t\t\t      struct net_icmpv6_ra_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tuint16_t length = net_pkt_get_len(pkt);\n\tstruct net_nbr *nbr = NULL;\n\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;\n\tstruct net_icmpv6_ra_hdr *ra_hdr;\n\tstruct net_if_router *router;\n\tuint32_t mtu, reachable_time, retrans_timer;\n\tuint16_t router_lifetime;\n\tstruct net_in6_addr ra_src;\n\n\tARG_UNUSED(user_data);\n\n\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\tgoto drop;\n\t}\n\n\tra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);\n\tif (!ra_hdr) {\n\t\tNET_ERR(\"DROP: NULL RA header\");\n\t\tgoto drop;\n\t}\n\n\tdbg_addr_recv(\"Router Advertisement\", &ip_hdr->src, &ip_hdr->dst, pkt);\n\n\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));\n\n\tnet_ipv6_addr_copy_raw(ra_src.s6_addr, ip_hdr->src);\n\n\tif (((length < (sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_icmp_hdr) +\n\t\t\tsizeof(struct net_icmpv6_ra_hdr) +\n\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||\n\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||\n\t     !net_ipv6_is_ll_addr(&ra_src)) &&\n\t\ticmp_hdr->code != 0U) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &ra_access);\n\n\trouter_lifetime = net_ntohs(ra_hdr->router_lifetime);\n\treachable_time = net_ntohl(ra_hdr->reachable_time);\n\tretrans_timer = net_ntohl(ra_hdr->retrans_timer);\n\n\tif (ra_hdr->cur_hop_limit) {\n\t\tnet_if_ipv6_set_hop_limit(net_pkt_iface(pkt),\n\t\t\t\t\t  ra_hdr->cur_hop_limit);\n\t\tNET_DBG(\"New hop limit %d\",\n\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));\n\t}\n\n\tif (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&\n\t    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=\n\t     reachable_time)) {\n\t\tnet_if_ipv6_set_base_reachable_time(net_pkt_iface(pkt),\n\t\t\t\t\t\t    reachable_time);\n\t\tnet_if_ipv6_set_reachable_time(\n\t\t\tnet_pkt_iface(pkt)->config.ip.ipv6);\n\t}\n\n\tif (retrans_timer) {\n\t\tnet_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),\n\t\t\t\t\t      ra_hdr->retrans_timer);\n\t}\n\n\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));\n\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));\n\n\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\n\twhile (nd_opt_hdr) {\n\t\tnet_pkt_acknowledge_data(pkt, &nd_access);\n\n\t\tswitch (nd_opt_hdr->type) {\n\t\tcase NET_ICMPV6_ND_OPT_SLLAO:\n\t\t\t/* Update existing neighbor cache entry with link layer address. */\n\t\t\tnbr = handle_ra_neighbor(pkt, nd_opt_hdr->len, &ra_src);\n\t\t\tif (!nbr) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase NET_ICMPV6_ND_OPT_MTU:\n\t\t\t/* MTU has reserved 2 bytes, so skip it. */\n\t\t\tif (net_pkt_skip(pkt, 2) ||\n\t\t\t    net_pkt_read_be32(pkt, &mtu)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {\n\t\t\t\tNET_ERR(\"DROP: Unsupported MTU %u, min is %u, \"\n\t\t\t\t\t\"max is %u\",\n\t\t\t\t\tmtu, MIN_IPV6_MTU, MAX_IPV6_MTU);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tnet_if_set_mtu(net_pkt_iface(pkt), mtu);\n\n\t\t\tbreak;\n\t\tcase NET_ICMPV6_ND_OPT_PREFIX_INFO:\n\t\t\tif (nd_opt_hdr->len != 4) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",\n\t\t\t\t\t\"prefix opt\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_prefix(pkt)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#if defined(CONFIG_NET_6LO_CONTEXT)\n\t\tcase NET_ICMPV6_ND_OPT_6CO:\n\t\t\t/* RFC 6775, 4.2 (Length)*/\n\t\t\tif (!(nd_opt_hdr->len == 2U || nd_opt_hdr->len == 3U)) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length %d\",\n\t\t\t\t\t\"6CO\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_6co(pkt, nd_opt_hdr->len)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#endif\n\t\tcase NET_ICMPV6_ND_OPT_ROUTE:\n\t\t\tif (!IS_ENABLED(CONFIG_NET_ROUTE)) {\n\t\t\t\tNET_DBG(\"Route option skipped\");\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\t/* RFC 4191, ch. 2.3 */\n\t\t\tif (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",\n\t\t\t\t\t\"route info opt\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_route_info(pkt, nd_opt_hdr->len, &ra_src)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#if defined(CONFIG_NET_IPV6_RA_RDNSS)\n\t\tcase NET_ICMPV6_ND_OPT_RDNSS:\n\t\t\tif (!handle_ra_rdnss(pkt, nd_opt_hdr->len)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tcase NET_ICMPV6_ND_OPT_DNSSL:\n\t\t\tNET_DBG(\"DNSSL option skipped\");\n\t\t\tgoto skip;\n\n\t\tdefault:\n\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);\n\t\tskip:\n\t\t\tif (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\t}\n\n\tif (nbr == NULL) {\n\t\t/* Add neighbor cache entry using link local address, regardless\n\t\t * of link layer address presence in Router Advertisement.\n\t\t */\n\t\tnbr = net_ipv6_nbr_add(net_pkt_iface(pkt), &ra_src,\n\t\t\t\t       NULL, true, NET_IPV6_NBR_STATE_INCOMPLETE);\n\t}\n\n\trouter = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ra_src);\n\tif (router) {\n\t\tif (!router_lifetime) {\n\t\t\t/* TODO: Start rs_timer on iface if no routers\n\t\t\t * at all available on iface.\n\t\t\t */\n\t\t\tnet_if_ipv6_router_rm(router);\n\t\t} else {\n\t\t\tif (nbr) {\n\t\t\t\tnet_ipv6_nbr_data(nbr)->is_router = true;\n\t\t\t}\n\n\t\t\tnet_if_ipv6_router_update_lifetime(\n\t\t\t\t\trouter, router_lifetime);\n\t\t}\n\t} else {\n\t\tnet_if_ipv6_router_add(net_pkt_iface(pkt), &ra_src,\n\t\t\t\t       router_lifetime);\n\t}\n\n\tnet_ipv6_nbr_lock();\n\n\tif (nbr != NULL) {\n\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tstruct net_pkt *pending;\n\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tNET_DBG(\"Sending pending pkt %p to %s\",\n\t\t\t\tpending,\n\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));\n\n\t\t\tif (net_send_data(pending) < 0) {\n\t\t\t\tnet_pkt_unref(pending);\n\t\t\t}\n\t\t}\n\n\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\n\t/* Cancel the RS timer on iface */\n\tnet_if_stop_rs(net_pkt_iface(pkt));\n\n\treturn 0;\n\ndrop:\n\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\n\treturn -EIO;\n}\n",
                {
                    "2616": "static int handle_ra_input(struct net_icmp_ctx *ctx,",
                    "2617": "\t\t\t   struct net_pkt *pkt,",
                    "2618": "\t\t\t   struct net_icmp_ip_hdr *hdr,",
                    "2619": "\t\t\t   struct net_icmp_hdr *icmp_hdr,",
                    "2620": "\t\t\t   void *user_data)",
                    "2621": "{",
                    "2622": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,",
                    "2623": "\t\t\t\t\t      struct net_icmpv6_ra_hdr);",
                    "2624": "\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);",
                    "2625": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "2626": "\tuint16_t length = net_pkt_get_len(pkt);",
                    "2627": "\tstruct net_nbr *nbr = NULL;",
                    "2628": "\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;",
                    "2629": "\tstruct net_icmpv6_ra_hdr *ra_hdr;",
                    "2630": "\tstruct net_if_router *router;",
                    "2631": "\tuint32_t mtu, reachable_time, retrans_timer;",
                    "2632": "\tuint16_t router_lifetime;",
                    "2633": "\tstruct net_in6_addr ra_src;",
                    "2634": "",
                    "2635": "\tARG_UNUSED(user_data);",
                    "2636": "",
                    "2637": "\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "2638": "\t\tgoto drop;",
                    "2639": "\t}",
                    "2640": "",
                    "2641": "\tra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);",
                    "2642": "\tif (!ra_hdr) {",
                    "2643": "\t\tNET_ERR(\"DROP: NULL RA header\");",
                    "2644": "\t\tgoto drop;",
                    "2645": "\t}",
                    "2646": "",
                    "2647": "\tdbg_addr_recv(\"Router Advertisement\", &ip_hdr->src, &ip_hdr->dst, pkt);",
                    "2648": "",
                    "2649": "\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));",
                    "2650": "",
                    "2651": "\tnet_ipv6_addr_copy_raw(ra_src.s6_addr, ip_hdr->src);",
                    "2652": "",
                    "2653": "\tif (((length < (sizeof(struct net_ipv6_hdr) +",
                    "2654": "\t\t\tsizeof(struct net_icmp_hdr) +",
                    "2655": "\t\t\tsizeof(struct net_icmpv6_ra_hdr) +",
                    "2656": "\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||",
                    "2657": "\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||",
                    "2658": "\t     !net_ipv6_is_ll_addr(&ra_src)) &&",
                    "2659": "\t\ticmp_hdr->code != 0U) {",
                    "2660": "\t\tgoto drop;",
                    "2661": "\t}",
                    "2662": "",
                    "2663": "\tnet_pkt_acknowledge_data(pkt, &ra_access);",
                    "2664": "",
                    "2665": "\trouter_lifetime = net_ntohs(ra_hdr->router_lifetime);",
                    "2666": "\treachable_time = net_ntohl(ra_hdr->reachable_time);",
                    "2667": "\tretrans_timer = net_ntohl(ra_hdr->retrans_timer);",
                    "2668": "",
                    "2669": "\tif (ra_hdr->cur_hop_limit) {",
                    "2670": "\t\tnet_if_ipv6_set_hop_limit(net_pkt_iface(pkt),",
                    "2671": "\t\t\t\t\t  ra_hdr->cur_hop_limit);",
                    "2672": "\t\tNET_DBG(\"New hop limit %d\",",
                    "2673": "\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));",
                    "2674": "\t}",
                    "2675": "",
                    "2676": "\tif (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&",
                    "2677": "\t    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=",
                    "2678": "\t     reachable_time)) {",
                    "2679": "\t\tnet_if_ipv6_set_base_reachable_time(net_pkt_iface(pkt),",
                    "2680": "\t\t\t\t\t\t    reachable_time);",
                    "2681": "\t\tnet_if_ipv6_set_reachable_time(",
                    "2682": "\t\t\tnet_pkt_iface(pkt)->config.ip.ipv6);",
                    "2683": "\t}",
                    "2684": "",
                    "2685": "\tif (retrans_timer) {",
                    "2686": "\t\tnet_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),",
                    "2687": "\t\t\t\t\t      ra_hdr->retrans_timer);",
                    "2688": "\t}",
                    "2689": "",
                    "2690": "\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));",
                    "2691": "\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));",
                    "2692": "",
                    "2693": "\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "2694": "\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "2695": "",
                    "2696": "\twhile (nd_opt_hdr) {",
                    "2697": "\t\tnet_pkt_acknowledge_data(pkt, &nd_access);",
                    "2698": "",
                    "2699": "\t\tswitch (nd_opt_hdr->type) {",
                    "2700": "\t\tcase NET_ICMPV6_ND_OPT_SLLAO:",
                    "2701": "\t\t\t/* Update existing neighbor cache entry with link layer address. */",
                    "2702": "\t\t\tnbr = handle_ra_neighbor(pkt, nd_opt_hdr->len, &ra_src);",
                    "2703": "\t\t\tif (!nbr) {",
                    "2704": "\t\t\t\tgoto drop;",
                    "2705": "\t\t\t}",
                    "2706": "",
                    "2707": "\t\t\tbreak;",
                    "2708": "\t\tcase NET_ICMPV6_ND_OPT_MTU:",
                    "2709": "\t\t\t/* MTU has reserved 2 bytes, so skip it. */",
                    "2710": "\t\t\tif (net_pkt_skip(pkt, 2) ||",
                    "2711": "\t\t\t    net_pkt_read_be32(pkt, &mtu)) {",
                    "2712": "\t\t\t\tgoto drop;",
                    "2713": "\t\t\t}",
                    "2714": "",
                    "2715": "\t\t\tif (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {",
                    "2716": "\t\t\t\tNET_ERR(\"DROP: Unsupported MTU %u, min is %u, \"",
                    "2717": "\t\t\t\t\t\"max is %u\",",
                    "2718": "\t\t\t\t\tmtu, MIN_IPV6_MTU, MAX_IPV6_MTU);",
                    "2719": "\t\t\t\tgoto drop;",
                    "2720": "\t\t\t}",
                    "2721": "",
                    "2722": "\t\t\tnet_if_set_mtu(net_pkt_iface(pkt), mtu);",
                    "2723": "",
                    "2724": "\t\t\tbreak;",
                    "2725": "\t\tcase NET_ICMPV6_ND_OPT_PREFIX_INFO:",
                    "2726": "\t\t\tif (nd_opt_hdr->len != 4) {",
                    "2727": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",",
                    "2728": "\t\t\t\t\t\"prefix opt\", nd_opt_hdr->len);",
                    "2729": "\t\t\t\tgoto drop;",
                    "2730": "\t\t\t}",
                    "2731": "",
                    "2732": "\t\t\tif (!handle_ra_prefix(pkt)) {",
                    "2733": "\t\t\t\tgoto drop;",
                    "2734": "\t\t\t}",
                    "2735": "",
                    "2736": "\t\t\tbreak;",
                    "2737": "#if defined(CONFIG_NET_6LO_CONTEXT)",
                    "2738": "\t\tcase NET_ICMPV6_ND_OPT_6CO:",
                    "2739": "\t\t\t/* RFC 6775, 4.2 (Length)*/",
                    "2740": "\t\t\tif (!(nd_opt_hdr->len == 2U || nd_opt_hdr->len == 3U)) {",
                    "2741": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length %d\",",
                    "2742": "\t\t\t\t\t\"6CO\", nd_opt_hdr->len);",
                    "2743": "\t\t\t\tgoto drop;",
                    "2744": "\t\t\t}",
                    "2745": "",
                    "2746": "\t\t\tif (!handle_ra_6co(pkt, nd_opt_hdr->len)) {",
                    "2747": "\t\t\t\tgoto drop;",
                    "2748": "\t\t\t}",
                    "2749": "",
                    "2750": "\t\t\tbreak;",
                    "2751": "#endif",
                    "2752": "\t\tcase NET_ICMPV6_ND_OPT_ROUTE:",
                    "2753": "\t\t\tif (!IS_ENABLED(CONFIG_NET_ROUTE)) {",
                    "2754": "\t\t\t\tNET_DBG(\"Route option skipped\");",
                    "2755": "\t\t\t\tgoto skip;",
                    "2756": "\t\t\t}",
                    "2757": "",
                    "2758": "\t\t\t/* RFC 4191, ch. 2.3 */",
                    "2759": "\t\t\tif (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {",
                    "2760": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",",
                    "2761": "\t\t\t\t\t\"route info opt\", nd_opt_hdr->len);",
                    "2762": "\t\t\t\tgoto drop;",
                    "2763": "\t\t\t}",
                    "2764": "",
                    "2765": "\t\t\tif (!handle_ra_route_info(pkt, nd_opt_hdr->len, &ra_src)) {",
                    "2766": "\t\t\t\tgoto drop;",
                    "2767": "\t\t\t}",
                    "2768": "",
                    "2769": "\t\t\tbreak;",
                    "2770": "#if defined(CONFIG_NET_IPV6_RA_RDNSS)",
                    "2771": "\t\tcase NET_ICMPV6_ND_OPT_RDNSS:",
                    "2772": "\t\t\tif (!handle_ra_rdnss(pkt, nd_opt_hdr->len)) {",
                    "2773": "\t\t\t\tgoto drop;",
                    "2774": "\t\t\t}",
                    "2775": "\t\t\tbreak;",
                    "2776": "#endif",
                    "2777": "",
                    "2778": "\t\tcase NET_ICMPV6_ND_OPT_DNSSL:",
                    "2779": "\t\t\tNET_DBG(\"DNSSL option skipped\");",
                    "2780": "\t\t\tgoto skip;",
                    "2781": "",
                    "2782": "\t\tdefault:",
                    "2783": "\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);",
                    "2784": "\t\tskip:",
                    "2785": "\t\t\tif (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {",
                    "2786": "\t\t\t\tgoto drop;",
                    "2787": "\t\t\t}",
                    "2788": "",
                    "2789": "\t\t\tbreak;",
                    "2790": "\t\t}",
                    "2791": "",
                    "2792": "\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "2793": "\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "2794": "\t}",
                    "2795": "",
                    "2796": "\tif (nbr == NULL) {",
                    "2797": "\t\t/* Add neighbor cache entry using link local address, regardless",
                    "2798": "\t\t * of link layer address presence in Router Advertisement.",
                    "2799": "\t\t */",
                    "2800": "\t\tnbr = net_ipv6_nbr_add(net_pkt_iface(pkt), &ra_src,",
                    "2801": "\t\t\t\t       NULL, true, NET_IPV6_NBR_STATE_INCOMPLETE);",
                    "2802": "\t}",
                    "2803": "",
                    "2804": "\trouter = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ra_src);",
                    "2805": "\tif (router) {",
                    "2806": "\t\tif (!router_lifetime) {",
                    "2807": "\t\t\t/* TODO: Start rs_timer on iface if no routers",
                    "2808": "\t\t\t * at all available on iface.",
                    "2809": "\t\t\t */",
                    "2810": "\t\t\tnet_if_ipv6_router_rm(router);",
                    "2811": "\t\t} else {",
                    "2812": "\t\t\tif (nbr) {",
                    "2813": "\t\t\t\tnet_ipv6_nbr_data(nbr)->is_router = true;",
                    "2814": "\t\t\t}",
                    "2815": "",
                    "2816": "\t\t\tnet_if_ipv6_router_update_lifetime(",
                    "2817": "\t\t\t\t\trouter, router_lifetime);",
                    "2818": "\t\t}",
                    "2819": "\t} else {",
                    "2820": "\t\tnet_if_ipv6_router_add(net_pkt_iface(pkt), &ra_src,",
                    "2821": "\t\t\t\t       router_lifetime);",
                    "2822": "\t}",
                    "2823": "",
                    "2824": "\tnet_ipv6_nbr_lock();",
                    "2825": "",
                    "2826": "\tif (nbr != NULL) {",
                    "2827": "\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "2828": "\t\t\tstruct net_pkt *pending;",
                    "2829": "",
                    "2830": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "2831": "\t\t\t\t\t     K_FOREVER);",
                    "2832": "",
                    "2833": "\t\t\tNET_DBG(\"Sending pending pkt %p to %s\",",
                    "2834": "\t\t\t\tpending,",
                    "2835": "\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));",
                    "2836": "",
                    "2837": "\t\t\tif (net_send_data(pending) < 0) {",
                    "2838": "\t\t\t\tnet_pkt_unref(pending);",
                    "2839": "\t\t\t}",
                    "2840": "\t\t}",
                    "2841": "",
                    "2842": "\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));",
                    "2843": "\t}",
                    "2844": "",
                    "2845": "\tnet_ipv6_nbr_unlock();",
                    "2846": "",
                    "2847": "\t/* Cancel the RS timer on iface */",
                    "2848": "\tnet_if_stop_rs(net_pkt_iface(pkt));",
                    "2849": "",
                    "2850": "\treturn 0;",
                    "2851": "",
                    "2852": "drop:",
                    "2853": "\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "2854": "",
                    "2855": "\treturn -EIO;",
                    "2856": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_send_rs": {
            "name": "net_ipv6_send_rs",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 2172,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6_NBR_CACHE */\nint net_ipv6_send_rs(struct net_if *iface)\n{\n\tuint8_t llao_len = 0U;\n\tint ret = -ENOBUFS;\n\tconst struct net_in6_addr *src;\n\tstruct net_in6_addr dst;\n\tstruct net_pkt *pkt;\n\n\tnet_ipv6_addr_create_ll_allrouters_mcast(&dst);\n\tsrc = net_if_ipv6_select_src_addr(iface, &dst);\n\n\tif (!net_ipv6_is_addr_unspecified(src)) {\n\t\tllao_len = get_llao_len(iface);\n\t}\n\n\tpkt = net_pkt_alloc_with_buffer(iface,\n\t\t\t\t\tsizeof(struct net_icmpv6_rs_hdr) +\n\t\t\t\t\tllao_len,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tND_NET_BUF_TIMEOUT);\n\tif (!pkt) {\n\t\treturn -ENOMEM;\n\t}\n\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);\n\n\tif (net_ipv6_create(pkt, src, &dst) ||\n\t    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||\n\t    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {\n\t\tgoto drop;\n\t}\n\n\tif (llao_len > 0) {\n\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),\n\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tdbg_addr_sent(\"Router Solicitation\", src, &dst, pkt);\n\n\tif (net_send_data(pkt) < 0) {\n\t\tnet_stats_update_ipv6_nd_drop(iface);\n\t\tret = -EINVAL;\n\n\t\tgoto drop;\n\t}\n\n\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\tnet_stats_update_ipv6_nd_sent(iface);\n\n\treturn 0;\n\ndrop:\n\tnet_pkt_unref(pkt);\n\n\treturn ret;\n}\n",
                {
                    "2172": "int net_ipv6_send_rs(struct net_if *iface)",
                    "2173": "{",
                    "2174": "\tuint8_t llao_len = 0U;",
                    "2175": "\tint ret = -ENOBUFS;",
                    "2176": "\tconst struct net_in6_addr *src;",
                    "2177": "\tstruct net_in6_addr dst;",
                    "2178": "\tstruct net_pkt *pkt;",
                    "2179": "",
                    "2180": "\tnet_ipv6_addr_create_ll_allrouters_mcast(&dst);",
                    "2181": "\tsrc = net_if_ipv6_select_src_addr(iface, &dst);",
                    "2182": "",
                    "2183": "\tif (!net_ipv6_is_addr_unspecified(src)) {",
                    "2184": "\t\tllao_len = get_llao_len(iface);",
                    "2185": "\t}",
                    "2186": "",
                    "2187": "\tpkt = net_pkt_alloc_with_buffer(iface,",
                    "2188": "\t\t\t\t\tsizeof(struct net_icmpv6_rs_hdr) +",
                    "2189": "\t\t\t\t\tllao_len,",
                    "2190": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "2191": "\t\t\t\t\tND_NET_BUF_TIMEOUT);",
                    "2192": "\tif (!pkt) {",
                    "2193": "\t\treturn -ENOMEM;",
                    "2194": "\t}",
                    "2195": "",
                    "2196": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);",
                    "2197": "",
                    "2198": "\tif (net_ipv6_create(pkt, src, &dst) ||",
                    "2199": "\t    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||",
                    "2200": "\t    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {",
                    "2201": "\t\tgoto drop;",
                    "2202": "\t}",
                    "2203": "",
                    "2204": "\tif (llao_len > 0) {",
                    "2205": "\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),",
                    "2206": "\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {",
                    "2207": "\t\t\tgoto drop;",
                    "2208": "\t\t}",
                    "2209": "\t}",
                    "2210": "",
                    "2211": "\tnet_pkt_cursor_init(pkt);",
                    "2212": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "2213": "",
                    "2214": "\tdbg_addr_sent(\"Router Solicitation\", src, &dst, pkt);",
                    "2215": "",
                    "2216": "\tif (net_send_data(pkt) < 0) {",
                    "2217": "\t\tnet_stats_update_ipv6_nd_drop(iface);",
                    "2218": "\t\tret = -EINVAL;",
                    "2219": "",
                    "2220": "\t\tgoto drop;",
                    "2221": "\t}",
                    "2222": "",
                    "2223": "\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "2224": "\tnet_stats_update_ipv6_nd_sent(iface);",
                    "2225": "",
                    "2226": "\treturn 0;",
                    "2227": "",
                    "2228": "drop:",
                    "2229": "\tnet_pkt_unref(pkt);",
                    "2230": "",
                    "2231": "\treturn ret;",
                    "2232": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_send_ns": {
            "name": "net_ipv6_send_ns",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 2004,
            "function_content": [
                "/* Update the statistics but silently drop NA msg if the sender\n* is not known or if there was an error in the message.\n* Returning <0 will cause error message to be printed which\n* is too much for this non error.\n*/\nint net_ipv6_send_ns(struct net_if *iface,\n\t\t     struct net_pkt *pending,\n\t\t     const struct net_in6_addr *src,\n\t\t     const struct net_in6_addr *dst,\n\t\t     const struct net_in6_addr *tgt,\n\t\t     bool is_my_address)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,\n\t\t\t\t\t      struct net_icmpv6_ns_hdr);\n\tstruct net_pkt *pkt = NULL;\n\tint ret = -ENOBUFS;\n\tstruct net_icmpv6_ns_hdr *ns_hdr;\n\tstruct net_in6_addr node_dst;\n\tstruct net_nbr *nbr;\n\tuint8_t llao_len;\n\n\tif (!dst) {\n\t\tnet_ipv6_addr_create_solicited_node(tgt, &node_dst);\n\t\tdst = &node_dst;\n\t}\n\n\tllao_len = get_llao_len(iface);\n\n\tif (is_my_address) {\n\t\tsrc = net_ipv6_unspecified_address();\n\t\tllao_len = 0U;\n\t} else {\n\t\tif (!src) {\n\t\t\tsrc = net_if_ipv6_select_src_addr(iface, tgt);\n\t\t}\n\n\t\tif (net_ipv6_is_addr_unspecified(src)) {\n\t\t\tNET_DBG(\"No source address for NS (tgt %s)\",\n\t\t\t\tnet_sprint_ipv6_addr(tgt));\n\t\t\tret = -EINVAL;\n\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tpkt = net_pkt_alloc_with_buffer(iface,\n\t\t\t\t\tsizeof(struct net_icmpv6_ns_hdr) +\n\t\t\t\t\tllao_len,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tND_NET_BUF_TIMEOUT);\n\tif (!pkt) {\n\t\tret = -ENOMEM;\n\t\tgoto drop;\n\t}\n\n\t/* Avoid recursive loop with network packet capturing */\n\tif (IS_ENABLED(CONFIG_NET_CAPTURE) && pending) {\n\t\tnet_pkt_set_captured(pkt, net_pkt_is_captured(pending));\n\t}\n\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);\n\n\tif (net_ipv6_create(pkt, src, dst) ||\n\t    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {\n\t\tgoto drop;\n\t}\n\n\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);\n\tif (!ns_hdr) {\n\t\tgoto drop;\n\t}\n\n\tns_hdr->reserved = 0U;\n\tnet_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);\n\n\tif (net_pkt_set_data(pkt, &ns_access)) {\n\t\tgoto drop;\n\t}\n\n\tif (!is_my_address) {\n\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),\n\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tnet_ipv6_nbr_lock();\n\tnbr = add_nbr(iface, tgt, false,\n\t\t      NET_IPV6_NBR_STATE_INCOMPLETE);\n\tif (!nbr) {\n\t\tNET_DBG(\"Could not create new neighbor %s\",\n\t\t\tnet_sprint_ipv6_addr(&ns_hdr->tgt));\n\t\tnet_ipv6_nbr_unlock();\n\t\tgoto drop;\n\t}\n\n\tif (pending != NULL) {\n\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tk_fifo_put(&net_ipv6_nbr_data(nbr)->pending_queue, pending);\n\t\t\tpending = net_pkt_ref(pending);\n\n\t\t\tNET_DBG(\"Setting timeout %d for NS\", NS_REPLY_TIMEOUT);\n\n\t\t\tnet_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();\n\n\t\t\t/* Let's start the timer if necessary */\n\t\t\tif (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {\n\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,\n\t\t\t\t\t\t  K_MSEC(NS_REPLY_TIMEOUT));\n\t\t\t}\n\t\t} else {\n\t\t\t/* If there is already a pending packet\n\t\t\t * for this neighbor, we do not send the NS but just\n\t\t\t * add the packet to the pending queue.\n\t\t\t */\n\t\t\tif (k_queue_unique_append(&net_ipv6_nbr_data(nbr)->pending_queue._queue,\n\t\t\t\t\t\t  pending)) {\n\t\t\t\tNET_DBG(\"Adding pending packet %p for NS to nbr %p\",\n\t\t\t\t\tpending, nbr);\n\n\t\t\t\tpending = net_pkt_ref(pending);\n\t\t\t} else {\n\t\t\t\tNET_DBG(\"Packet %p already pending for \"\n\t\t\t\t\t\"operation for nbr %p.\",\n\t\t\t\t\tpending, nbr);\n\t\t\t}\n\n\t\t\t/* Let the system timeout and then send the NS again */\n\t\t\tnet_ipv6_nbr_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdbg_addr_sent_tgt(\"Neighbor Solicitation\", src, dst, &ns_hdr->tgt, pkt);\n\n\tif (net_send_data(pkt) < 0) {\n\t\tNET_DBG(\"Cannot send NS %p (pending %p)\", pkt, pending);\n\n\t\tif (pending != NULL) {\n\t\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));\n\t\t\tpending = NULL;\n\t\t}\n\n\t\tnet_ipv6_nbr_unlock();\n\t\tgoto drop;\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\n\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\tnet_stats_update_ipv6_nd_sent(iface);\n\n\treturn 0;\n\ndrop:\n\tif (pending != NULL) {\n\t\tnet_pkt_unref(pending);\n\t}\n\n\tif (pkt) {\n\t\tnet_pkt_unref(pkt);\n\t}\n\n\tnet_stats_update_ipv6_nd_drop(iface);\n\n\treturn ret;\n}\n",
                {
                    "2004": "int net_ipv6_send_ns(struct net_if *iface,",
                    "2005": "\t\t     struct net_pkt *pending,",
                    "2006": "\t\t     const struct net_in6_addr *src,",
                    "2007": "\t\t     const struct net_in6_addr *dst,",
                    "2008": "\t\t     const struct net_in6_addr *tgt,",
                    "2009": "\t\t     bool is_my_address)",
                    "2010": "{",
                    "2011": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,",
                    "2012": "\t\t\t\t\t      struct net_icmpv6_ns_hdr);",
                    "2013": "\tstruct net_pkt *pkt = NULL;",
                    "2014": "\tint ret = -ENOBUFS;",
                    "2015": "\tstruct net_icmpv6_ns_hdr *ns_hdr;",
                    "2016": "\tstruct net_in6_addr node_dst;",
                    "2017": "\tstruct net_nbr *nbr;",
                    "2018": "\tuint8_t llao_len;",
                    "2019": "",
                    "2020": "\tif (!dst) {",
                    "2021": "\t\tnet_ipv6_addr_create_solicited_node(tgt, &node_dst);",
                    "2022": "\t\tdst = &node_dst;",
                    "2023": "\t}",
                    "2024": "",
                    "2025": "\tllao_len = get_llao_len(iface);",
                    "2026": "",
                    "2027": "\tif (is_my_address) {",
                    "2028": "\t\tsrc = net_ipv6_unspecified_address();",
                    "2029": "\t\tllao_len = 0U;",
                    "2030": "\t} else {",
                    "2031": "\t\tif (!src) {",
                    "2032": "\t\t\tsrc = net_if_ipv6_select_src_addr(iface, tgt);",
                    "2033": "\t\t}",
                    "2034": "",
                    "2035": "\t\tif (net_ipv6_is_addr_unspecified(src)) {",
                    "2036": "\t\t\tNET_DBG(\"No source address for NS (tgt %s)\",",
                    "2037": "\t\t\t\tnet_sprint_ipv6_addr(tgt));",
                    "2038": "\t\t\tret = -EINVAL;",
                    "2039": "",
                    "2040": "\t\t\tgoto drop;",
                    "2041": "\t\t}",
                    "2042": "\t}",
                    "2043": "",
                    "2044": "\tpkt = net_pkt_alloc_with_buffer(iface,",
                    "2045": "\t\t\t\t\tsizeof(struct net_icmpv6_ns_hdr) +",
                    "2046": "\t\t\t\t\tllao_len,",
                    "2047": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "2048": "\t\t\t\t\tND_NET_BUF_TIMEOUT);",
                    "2049": "\tif (!pkt) {",
                    "2050": "\t\tret = -ENOMEM;",
                    "2051": "\t\tgoto drop;",
                    "2052": "\t}",
                    "2053": "",
                    "2054": "\t/* Avoid recursive loop with network packet capturing */",
                    "2055": "\tif (IS_ENABLED(CONFIG_NET_CAPTURE) && pending) {",
                    "2056": "\t\tnet_pkt_set_captured(pkt, net_pkt_is_captured(pending));",
                    "2057": "\t}",
                    "2058": "",
                    "2059": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);",
                    "2060": "",
                    "2061": "\tif (net_ipv6_create(pkt, src, dst) ||",
                    "2062": "\t    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {",
                    "2063": "\t\tgoto drop;",
                    "2064": "\t}",
                    "2065": "",
                    "2066": "\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);",
                    "2067": "\tif (!ns_hdr) {",
                    "2068": "\t\tgoto drop;",
                    "2069": "\t}",
                    "2070": "",
                    "2071": "\tns_hdr->reserved = 0U;",
                    "2072": "\tnet_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);",
                    "2073": "",
                    "2074": "\tif (net_pkt_set_data(pkt, &ns_access)) {",
                    "2075": "\t\tgoto drop;",
                    "2076": "\t}",
                    "2077": "",
                    "2078": "\tif (!is_my_address) {",
                    "2079": "\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),",
                    "2080": "\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {",
                    "2081": "\t\t\tgoto drop;",
                    "2082": "\t\t}",
                    "2083": "\t}",
                    "2084": "",
                    "2085": "\tnet_pkt_cursor_init(pkt);",
                    "2086": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "2087": "",
                    "2088": "\tnet_ipv6_nbr_lock();",
                    "2089": "\tnbr = add_nbr(iface, tgt, false,",
                    "2090": "\t\t      NET_IPV6_NBR_STATE_INCOMPLETE);",
                    "2091": "\tif (!nbr) {",
                    "2092": "\t\tNET_DBG(\"Could not create new neighbor %s\",",
                    "2093": "\t\t\tnet_sprint_ipv6_addr(&ns_hdr->tgt));",
                    "2094": "\t\tnet_ipv6_nbr_unlock();",
                    "2095": "\t\tgoto drop;",
                    "2096": "\t}",
                    "2097": "",
                    "2098": "\tif (pending != NULL) {",
                    "2099": "\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "2100": "\t\t\tk_fifo_put(&net_ipv6_nbr_data(nbr)->pending_queue, pending);",
                    "2101": "\t\t\tpending = net_pkt_ref(pending);",
                    "2102": "",
                    "2103": "\t\t\tNET_DBG(\"Setting timeout %d for NS\", NS_REPLY_TIMEOUT);",
                    "2104": "",
                    "2105": "\t\t\tnet_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();",
                    "2106": "",
                    "2107": "\t\t\t/* Let's start the timer if necessary */",
                    "2108": "\t\t\tif (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {",
                    "2109": "\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,",
                    "2110": "\t\t\t\t\t\t  K_MSEC(NS_REPLY_TIMEOUT));",
                    "2111": "\t\t\t}",
                    "2112": "\t\t} else {",
                    "2113": "\t\t\t/* If there is already a pending packet",
                    "2114": "\t\t\t * for this neighbor, we do not send the NS but just",
                    "2115": "\t\t\t * add the packet to the pending queue.",
                    "2116": "\t\t\t */",
                    "2117": "\t\t\tif (k_queue_unique_append(&net_ipv6_nbr_data(nbr)->pending_queue._queue,",
                    "2118": "\t\t\t\t\t\t  pending)) {",
                    "2119": "\t\t\t\tNET_DBG(\"Adding pending packet %p for NS to nbr %p\",",
                    "2120": "\t\t\t\t\tpending, nbr);",
                    "2121": "",
                    "2122": "\t\t\t\tpending = net_pkt_ref(pending);",
                    "2123": "\t\t\t} else {",
                    "2124": "\t\t\t\tNET_DBG(\"Packet %p already pending for \"",
                    "2125": "\t\t\t\t\t\"operation for nbr %p.\",",
                    "2126": "\t\t\t\t\tpending, nbr);",
                    "2127": "\t\t\t}",
                    "2128": "",
                    "2129": "\t\t\t/* Let the system timeout and then send the NS again */",
                    "2130": "\t\t\tnet_ipv6_nbr_unlock();",
                    "2131": "\t\t\treturn 0;",
                    "2132": "\t\t}",
                    "2133": "\t}",
                    "2134": "",
                    "2135": "\tdbg_addr_sent_tgt(\"Neighbor Solicitation\", src, dst, &ns_hdr->tgt, pkt);",
                    "2136": "",
                    "2137": "\tif (net_send_data(pkt) < 0) {",
                    "2138": "\t\tNET_DBG(\"Cannot send NS %p (pending %p)\", pkt, pending);",
                    "2139": "",
                    "2140": "\t\tif (pending != NULL) {",
                    "2141": "\t\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));",
                    "2142": "\t\t\tpending = NULL;",
                    "2143": "\t\t}",
                    "2144": "",
                    "2145": "\t\tnet_ipv6_nbr_unlock();",
                    "2146": "\t\tgoto drop;",
                    "2147": "\t}",
                    "2148": "",
                    "2149": "\tnet_ipv6_nbr_unlock();",
                    "2150": "",
                    "2151": "\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "2152": "\tnet_stats_update_ipv6_nd_sent(iface);",
                    "2153": "",
                    "2154": "\treturn 0;",
                    "2155": "",
                    "2156": "drop:",
                    "2157": "\tif (pending != NULL) {",
                    "2158": "\t\tnet_pkt_unref(pending);",
                    "2159": "\t}",
                    "2160": "",
                    "2161": "\tif (pkt) {",
                    "2162": "\t\tnet_pkt_unref(pkt);",
                    "2163": "\t}",
                    "2164": "",
                    "2165": "\tnet_stats_update_ipv6_nd_drop(iface);",
                    "2166": "",
                    "2167": "\treturn ret;",
                    "2168": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "handle_na_input": {
            "name": "handle_na_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 1883,
            "function_content": [
                "/* Next send any pending messages to the peer. */\nstatic int handle_na_input(struct net_icmp_ctx *ctx,\n\t\t\t   struct net_pkt *pkt,\n\t\t\t   struct net_icmp_ip_hdr *hdr,\n\t\t\t   struct net_icmp_hdr *icmp_hdr,\n\t\t\t   void *user_data)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,\n\t\t\t\t\t      struct net_icmpv6_na_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tuint16_t length = net_pkt_get_len(pkt);\n\tuint16_t tllao_offset = 0U;\n\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;\n\tstruct net_icmpv6_na_hdr *na_hdr;\n\tstruct net_in6_addr na_tgt, na_dst;\n\tstruct net_if_addr *ifaddr;\n\n\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\tgoto drop;\n\t}\n\n\tna_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);\n\tif (!na_hdr) {\n\t\tNET_ERR(\"DROP: NULL NA header\");\n\t\tgoto drop;\n\t}\n\n\tdbg_addr_recv_tgt(\"Neighbor Advertisement\",\n\t\t\t  &ip_hdr->src, &ip_hdr->dst, &na_hdr->tgt, pkt);\n\n\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));\n\n\tnet_ipv6_addr_copy_raw(na_tgt.s6_addr, na_hdr->tgt);\n\tnet_ipv6_addr_copy_raw(na_dst.s6_addr, ip_hdr->dst);\n\n\tif (((length < (sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_icmp_hdr) +\n\t\t\tsizeof(struct net_icmpv6_na_hdr) +\n\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||\n\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||\n\t     net_ipv6_is_addr_mcast(&na_tgt) ||\n\t     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&\n\t      net_ipv6_is_addr_mcast(&na_dst))) &&\n\t    (icmp_hdr->code != 0U)) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &na_access);\n\n\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_na_hdr));\n\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));\n\n\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\n\twhile (nd_opt_hdr && nd_opt_hdr->len &&\n\t       net_pkt_ipv6_ext_opt_len(pkt) < length) {\n\t\tuint8_t prev_opt_len;\n\n\t\tswitch (nd_opt_hdr->type) {\n\t\tcase NET_ICMPV6_ND_OPT_TLLAO:\n\t\t\ttllao_offset = net_pkt_ip_hdr_len(pkt) +\n\t\t\t\tnet_pkt_ipv6_ext_len(pkt) +\n\t\t\t\tsizeof(struct net_icmp_hdr) +\n\t\t\t\tnet_pkt_ipv6_ext_opt_len(pkt) + 1 + 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);\n\n\t\tnet_pkt_set_ipv6_ext_opt_len(pkt,\n\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt) +\n\t\t\t\t\t     (nd_opt_hdr->len << 3));\n\n\t\tif (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {\n\t\t\tNET_ERR(\"DROP: Corrupted NA message\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tnet_pkt_acknowledge_data(pkt, &nd_access);\n\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\t}\n\n\tifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt), &na_tgt);\n\tif (ifaddr) {\n\t\tNET_DBG(\"Interface %p/%d already has address %s\",\n\t\t\tnet_pkt_iface(pkt),\n\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)),\n\t\t\tnet_sprint_ipv6_addr(&na_tgt));\n\n#if defined(CONFIG_NET_IPV6_DAD)\n\t\tif (ifaddr->addr_state == NET_ADDR_TENTATIVE) {\n\t\t\tdad_failed(net_pkt_iface(pkt), &na_tgt);\n\t\t}\n#endif /* CONFIG_NET_IPV6_DAD */\n\n\t\tgoto drop;\n\t}\n\n\tif (!handle_na_neighbor(pkt, na_hdr, &na_tgt, tllao_offset)) {\n\t\t/* Update the statistics but silently drop NA msg if the sender\n\t\t * is not known or if there was an error in the message.\n\t\t * Returning <0 will cause error message to be printed which\n\t\t * is too much for this non error.\n\t\t */\n\t\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\t}\n\n\treturn 0;\n\ndrop:\n\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\n\treturn -EIO;\n}\n",
                {
                    "1883": "static int handle_na_input(struct net_icmp_ctx *ctx,",
                    "1884": "\t\t\t   struct net_pkt *pkt,",
                    "1885": "\t\t\t   struct net_icmp_ip_hdr *hdr,",
                    "1886": "\t\t\t   struct net_icmp_hdr *icmp_hdr,",
                    "1887": "\t\t\t   void *user_data)",
                    "1888": "{",
                    "1889": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,",
                    "1890": "\t\t\t\t\t      struct net_icmpv6_na_hdr);",
                    "1891": "\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);",
                    "1892": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "1893": "\tuint16_t length = net_pkt_get_len(pkt);",
                    "1894": "\tuint16_t tllao_offset = 0U;",
                    "1895": "\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;",
                    "1896": "\tstruct net_icmpv6_na_hdr *na_hdr;",
                    "1897": "\tstruct net_in6_addr na_tgt, na_dst;",
                    "1898": "\tstruct net_if_addr *ifaddr;",
                    "1899": "",
                    "1900": "\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "1901": "\t\tgoto drop;",
                    "1902": "\t}",
                    "1903": "",
                    "1904": "\tna_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);",
                    "1905": "\tif (!na_hdr) {",
                    "1906": "\t\tNET_ERR(\"DROP: NULL NA header\");",
                    "1907": "\t\tgoto drop;",
                    "1908": "\t}",
                    "1909": "",
                    "1910": "\tdbg_addr_recv_tgt(\"Neighbor Advertisement\",",
                    "1911": "\t\t\t  &ip_hdr->src, &ip_hdr->dst, &na_hdr->tgt, pkt);",
                    "1912": "",
                    "1913": "\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));",
                    "1914": "",
                    "1915": "\tnet_ipv6_addr_copy_raw(na_tgt.s6_addr, na_hdr->tgt);",
                    "1916": "\tnet_ipv6_addr_copy_raw(na_dst.s6_addr, ip_hdr->dst);",
                    "1917": "",
                    "1918": "\tif (((length < (sizeof(struct net_ipv6_hdr) +",
                    "1919": "\t\t\tsizeof(struct net_icmp_hdr) +",
                    "1920": "\t\t\tsizeof(struct net_icmpv6_na_hdr) +",
                    "1921": "\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||",
                    "1922": "\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||",
                    "1923": "\t     net_ipv6_is_addr_mcast(&na_tgt) ||",
                    "1924": "\t     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&",
                    "1925": "\t      net_ipv6_is_addr_mcast(&na_dst))) &&",
                    "1926": "\t    (icmp_hdr->code != 0U)) {",
                    "1927": "\t\tgoto drop;",
                    "1928": "\t}",
                    "1929": "",
                    "1930": "\tnet_pkt_acknowledge_data(pkt, &na_access);",
                    "1931": "",
                    "1932": "\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_na_hdr));",
                    "1933": "\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));",
                    "1934": "",
                    "1935": "\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "1936": "\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "1937": "",
                    "1938": "\twhile (nd_opt_hdr && nd_opt_hdr->len &&",
                    "1939": "\t       net_pkt_ipv6_ext_opt_len(pkt) < length) {",
                    "1940": "\t\tuint8_t prev_opt_len;",
                    "1941": "",
                    "1942": "\t\tswitch (nd_opt_hdr->type) {",
                    "1943": "\t\tcase NET_ICMPV6_ND_OPT_TLLAO:",
                    "1944": "\t\t\ttllao_offset = net_pkt_ip_hdr_len(pkt) +",
                    "1945": "\t\t\t\tnet_pkt_ipv6_ext_len(pkt) +",
                    "1946": "\t\t\t\tsizeof(struct net_icmp_hdr) +",
                    "1947": "\t\t\t\tnet_pkt_ipv6_ext_opt_len(pkt) + 1 + 1;",
                    "1948": "\t\t\tbreak;",
                    "1949": "",
                    "1950": "\t\tdefault:",
                    "1951": "\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);",
                    "1952": "\t\t\tbreak;",
                    "1953": "\t\t}",
                    "1954": "",
                    "1955": "\t\tprev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);",
                    "1956": "",
                    "1957": "\t\tnet_pkt_set_ipv6_ext_opt_len(pkt,",
                    "1958": "\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt) +",
                    "1959": "\t\t\t\t\t     (nd_opt_hdr->len << 3));",
                    "1960": "",
                    "1961": "\t\tif (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {",
                    "1962": "\t\t\tNET_ERR(\"DROP: Corrupted NA message\");",
                    "1963": "\t\t\tgoto drop;",
                    "1964": "\t\t}",
                    "1965": "",
                    "1966": "\t\tnet_pkt_acknowledge_data(pkt, &nd_access);",
                    "1967": "\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "1968": "\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "1969": "\t}",
                    "1970": "",
                    "1971": "\tifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt), &na_tgt);",
                    "1972": "\tif (ifaddr) {",
                    "1973": "\t\tNET_DBG(\"Interface %p/%d already has address %s\",",
                    "1974": "\t\t\tnet_pkt_iface(pkt),",
                    "1975": "\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)),",
                    "1976": "\t\t\tnet_sprint_ipv6_addr(&na_tgt));",
                    "1977": "",
                    "1978": "#if defined(CONFIG_NET_IPV6_DAD)",
                    "1979": "\t\tif (ifaddr->addr_state == NET_ADDR_TENTATIVE) {",
                    "1980": "\t\t\tdad_failed(net_pkt_iface(pkt), &na_tgt);",
                    "1981": "\t\t}",
                    "1982": "#endif /* CONFIG_NET_IPV6_DAD */",
                    "1983": "",
                    "1984": "\t\tgoto drop;",
                    "1985": "\t}",
                    "1986": "",
                    "1987": "\tif (!handle_na_neighbor(pkt, na_hdr, &na_tgt, tllao_offset)) {",
                    "1988": "\t\t/* Update the statistics but silently drop NA msg if the sender",
                    "1989": "\t\t * is not known or if there was an error in the message.",
                    "1990": "\t\t * Returning <0 will cause error message to be printed which",
                    "1991": "\t\t * is too much for this non error.",
                    "1992": "\t\t */",
                    "1993": "\t\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "1994": "\t}",
                    "1995": "",
                    "1996": "\treturn 0;",
                    "1997": "",
                    "1998": "drop:",
                    "1999": "\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "2000": "",
                    "2001": "\treturn -EIO;",
                    "2002": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "handle_ns_input": {
            "name": "handle_ns_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 1260,
            "function_content": [
                "/* Let's make sure reserved part is full of 0 */\nstatic int handle_ns_input(struct net_icmp_ctx *ctx,\n\t\t\t   struct net_pkt *pkt,\n\t\t\t   struct net_icmp_ip_hdr *hdr,\n\t\t\t   struct net_icmp_hdr *icmp_hdr,\n\t\t\t   void *user_data)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,\n\t\t\t\t\t      struct net_icmpv6_ns_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tuint16_t length = net_pkt_get_len(pkt);\n\tuint8_t flags = 0U;\n\tbool routing = false;\n\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;\n\tstruct net_icmpv6_ns_hdr *ns_hdr;\n\tstruct net_if_addr *ifaddr;\n\tconst struct net_in6_addr *na_src;\n\tconst struct net_in6_addr *na_dst;\n\tstruct net_in6_addr *tgt;\n\tstruct net_in6_addr ns_tgt, ns_src, ns_dst;\n\tstruct net_linkaddr src_lladdr;\n\n\tsrc_lladdr.len = 0;\n\n\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\tgoto drop;\n\t}\n\n\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);\n\tif (!ns_hdr) {\n\t\tNET_ERR(\"DROP: NULL NS header\");\n\t\tgoto drop;\n\t}\n\n\tdbg_addr_recv_tgt(\"Neighbor Solicitation\",\n\t\t\t  &ip_hdr->src, &ip_hdr->dst, &ns_hdr->tgt, pkt);\n\n\tnet_ipv6_addr_copy_raw(ns_tgt.s6_addr, ns_hdr->tgt);\n\tnet_ipv6_addr_copy_raw(ns_src.s6_addr, ip_hdr->src);\n\tnet_ipv6_addr_copy_raw(ns_dst.s6_addr, ip_hdr->dst);\n\n\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));\n\n\tif (((length < (sizeof(struct net_ipv6_hdr) +\n\t\t\t  sizeof(struct net_icmp_hdr) +\n\t\t\t  sizeof(struct net_icmpv6_ns_hdr))) ||\n\t    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&\n\t    (net_ipv6_is_addr_mcast(&ns_tgt) &&\n\t     icmp_hdr->code != 0U)) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &ns_access);\n\n\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ns_hdr));\n\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));\n\n\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\n\twhile (nd_opt_hdr && nd_opt_hdr->len > 0 &&\n\t       net_pkt_ipv6_ext_opt_len(pkt) < length) {\n\t\tuint8_t prev_opt_len;\n\n\t\tnet_pkt_acknowledge_data(pkt, &nd_access);\n\n\t\tswitch (nd_opt_hdr->type) {\n\t\tcase NET_ICMPV6_ND_OPT_SLLAO:\n\t\t\tif (net_ipv6_is_addr_unspecified(&ns_src)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr)) {\n\t\t\t\tNET_ERR(\"DROP: failed to read LLAO\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);\n\n\t\tnet_pkt_set_ipv6_ext_opt_len(pkt,\n\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt) +\n\t\t\t\t\t     (nd_opt_hdr->len << 3));\n\n\t\tif (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {\n\t\t\tNET_ERR(\"DROP: Corrupted NS message\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {\n\t\tifaddr = net_if_ipv6_addr_lookup(&ns_tgt, NULL);\n\t} else {\n\t\tifaddr = net_if_ipv6_addr_lookup_by_iface(\n\t\t\t    net_pkt_iface(pkt), &ns_tgt);\n\t}\n\n\tif (!ifaddr) {\n\t\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {\n\t\t\tstruct net_in6_addr *nexthop;\n\n\t\t\tnexthop = check_route(NULL, &ns_tgt, NULL);\n\t\t\tif (nexthop) {\n\t\t\t\tns_routing_info(pkt, nexthop, &ns_tgt);\n\t\t\t\tna_dst = &ns_dst;\n\t\t\t\t/* Note that the target is not the address of\n\t\t\t\t * the \"nethop\" as that is a link-local address\n\t\t\t\t * which is not routable.\n\t\t\t\t */\n\t\t\t\ttgt = &ns_tgt;\n\n\t\t\t\t/* Source address must be one of our real\n\t\t\t\t * interface address where the packet was\n\t\t\t\t * received.\n\t\t\t\t */\n\t\t\t\tna_src = net_if_ipv6_select_src_addr(\n\t\t\t\t\t\tnet_pkt_iface(pkt),\n\t\t\t\t\t\t&ns_src);\n\t\t\t\tif (!na_src) {\n\t\t\t\t\tNET_DBG(\"DROP: No interface address \"\n\t\t\t\t\t\t\"for dst %s iface %p/%d\",\n\t\t\t\t\t\tnet_sprint_ipv6_addr(&ns_src),\n\t\t\t\t\t\tnet_pkt_iface(pkt),\n\t\t\t\t\t\tnet_if_get_by_iface(\n\t\t\t\t\t\t\tnet_pkt_iface(pkt)));\n\t\t\t\t\tgoto silent_drop;\n\t\t\t\t}\n\n\t\t\t\trouting = true;\n\t\t\t\tgoto nexthop_found;\n\t\t\t}\n\t\t}\n\n\t\tNET_DBG(\"DROP: No such interface address %s\",\n\t\t\tnet_sprint_ipv6_addr(&ns_tgt));\n\t\tgoto silent_drop;\n\t} else {\n\t\ttgt = &ifaddr->address.in6_addr;\n\t\tna_src = &ns_dst;\n\t}\n\nnexthop_found:\n\n#if !defined(CONFIG_NET_IPV6_DAD)\n\tif (net_ipv6_is_addr_unspecified(&ns_src)) {\n\t\tgoto drop;\n\t}\n\n#else /* CONFIG_NET_IPV6_DAD */\n\n\t/* Do DAD */\n\tif (net_ipv6_is_addr_unspecified(&ns_src)) {\n\n\t\tif (!net_ipv6_is_addr_solicited_node(&ns_dst)) {\n\t\t\tNET_DBG(\"DROP: Not solicited node addr %s\",\n\t\t\t\tnet_sprint_ipv6_addr(&ns_dst));\n\t\t\tgoto silent_drop;\n\t\t}\n\n\t\tif (ifaddr->addr_state == NET_ADDR_TENTATIVE) {\n\t\t\tNET_DBG(\"DROP: DAD failed for %s iface %p/%d\",\n\t\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr),\n\t\t\t\tnet_pkt_iface(pkt),\n\t\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));\n\n\t\t\tdad_failed(net_pkt_iface(pkt),\n\t\t\t\t   &ifaddr->address.in6_addr);\n\t\t\tgoto silent_drop;\n\t\t}\n\n\t\t/* We reuse the received packet for the NA addresses*/\n\t\tnet_ipv6_addr_create_ll_allnodes_mcast(&ns_dst);\n\t\tnet_ipaddr_copy((struct net_in6_addr *)ip_hdr->src,\n\t\t\t\tnet_if_ipv6_select_src_addr(\n\t\t\t\t\tnet_pkt_iface(pkt), &ns_dst));\n\n\t\tna_src = &ns_src;\n\t\tna_dst = &ns_dst;\n\t\tflags = NET_ICMPV6_NA_FLAG_OVERRIDE;\n\t\tgoto send_na;\n\t}\n#endif /* CONFIG_NET_IPV6_DAD */\n\n\tif (net_ipv6_is_my_addr(&ns_src)) {\n\t\tNET_DBG(\"DROP: Duplicate IPv6 %s address\",\n\t\t\tnet_sprint_ipv6_addr(&ns_src));\n\t\tgoto silent_drop;\n\t}\n\n\t/* Address resolution */\n\tif (net_ipv6_is_addr_solicited_node(&ns_dst)) {\n\t\tna_src = &ns_tgt;\n\t\tna_dst = &ns_src;\n\t\tflags = NET_ICMPV6_NA_FLAG_SOLICITED |\n\t\t\tNET_ICMPV6_NA_FLAG_OVERRIDE;\n\t\tgoto send_na;\n\t}\n\n\tif (routing) {\n\t\t/* No need to do NUD here when the target is being routed. */\n\t\tgoto send_na;\n\t}\n\n\t/* Neighbor Unreachability Detection (NUD) */\n\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {\n\t\tifaddr = net_if_ipv6_addr_lookup(&ns_dst, NULL);\n\t} else {\n\t\tifaddr = net_if_ipv6_addr_lookup_by_iface(\n\t\t\t\t\t\tnet_pkt_iface(pkt),\n\t\t\t\t\t\t&ns_dst);\n\t}\n\n\tif (ifaddr) {\n\t\tna_src = &ns_tgt;\n\t\tna_dst = &ns_src;\n\t\ttgt = &ifaddr->address.in6_addr;\n\t\tflags = NET_ICMPV6_NA_FLAG_SOLICITED |\n\t\t\tNET_ICMPV6_NA_FLAG_OVERRIDE;\n\t\tgoto send_na;\n\t} else {\n\t\tNET_DBG(\"DROP: NUD failed\");\n\t\tgoto silent_drop;\n\t}\n\nsend_na:\n\tif (src_lladdr.len > 0) {\n\t\tif (!net_ipv6_nbr_add(net_pkt_iface(pkt),\n\t\t\t\t      &ns_src, &src_lladdr, false,\n\t\t\t\t      NET_IPV6_NBR_STATE_INCOMPLETE)) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,\n\t\t\t      na_dst, tgt, flags)) {\n\t\treturn 0;\n\t}\n\n\tNET_DBG(\"DROP: Cannot send NA\");\n\n\treturn -EIO;\n\ndrop:\n\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\n\treturn -EIO;\n\nsilent_drop:\n\t/* If the event is not really an error then just ignore it and\n\t * return 0 so that icmpv6 module will not complain about it.\n\t */\n\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\n\treturn 0;\n}\n",
                {
                    "1260": "static int handle_ns_input(struct net_icmp_ctx *ctx,",
                    "1261": "\t\t\t   struct net_pkt *pkt,",
                    "1262": "\t\t\t   struct net_icmp_ip_hdr *hdr,",
                    "1263": "\t\t\t   struct net_icmp_hdr *icmp_hdr,",
                    "1264": "\t\t\t   void *user_data)",
                    "1265": "{",
                    "1266": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,",
                    "1267": "\t\t\t\t\t      struct net_icmpv6_ns_hdr);",
                    "1268": "\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);",
                    "1269": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "1270": "\tuint16_t length = net_pkt_get_len(pkt);",
                    "1271": "\tuint8_t flags = 0U;",
                    "1272": "\tbool routing = false;",
                    "1273": "\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;",
                    "1274": "\tstruct net_icmpv6_ns_hdr *ns_hdr;",
                    "1275": "\tstruct net_if_addr *ifaddr;",
                    "1276": "\tconst struct net_in6_addr *na_src;",
                    "1277": "\tconst struct net_in6_addr *na_dst;",
                    "1278": "\tstruct net_in6_addr *tgt;",
                    "1279": "\tstruct net_in6_addr ns_tgt, ns_src, ns_dst;",
                    "1280": "\tstruct net_linkaddr src_lladdr;",
                    "1281": "",
                    "1282": "\tsrc_lladdr.len = 0;",
                    "1283": "",
                    "1284": "\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "1285": "\t\tgoto drop;",
                    "1286": "\t}",
                    "1287": "",
                    "1288": "\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);",
                    "1289": "\tif (!ns_hdr) {",
                    "1290": "\t\tNET_ERR(\"DROP: NULL NS header\");",
                    "1291": "\t\tgoto drop;",
                    "1292": "\t}",
                    "1293": "",
                    "1294": "\tdbg_addr_recv_tgt(\"Neighbor Solicitation\",",
                    "1295": "\t\t\t  &ip_hdr->src, &ip_hdr->dst, &ns_hdr->tgt, pkt);",
                    "1296": "",
                    "1297": "\tnet_ipv6_addr_copy_raw(ns_tgt.s6_addr, ns_hdr->tgt);",
                    "1298": "\tnet_ipv6_addr_copy_raw(ns_src.s6_addr, ip_hdr->src);",
                    "1299": "\tnet_ipv6_addr_copy_raw(ns_dst.s6_addr, ip_hdr->dst);",
                    "1300": "",
                    "1301": "\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));",
                    "1302": "",
                    "1303": "\tif (((length < (sizeof(struct net_ipv6_hdr) +",
                    "1304": "\t\t\t  sizeof(struct net_icmp_hdr) +",
                    "1305": "\t\t\t  sizeof(struct net_icmpv6_ns_hdr))) ||",
                    "1306": "\t    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&",
                    "1307": "\t    (net_ipv6_is_addr_mcast(&ns_tgt) &&",
                    "1308": "\t     icmp_hdr->code != 0U)) {",
                    "1309": "\t\tgoto drop;",
                    "1310": "\t}",
                    "1311": "",
                    "1312": "\tnet_pkt_acknowledge_data(pkt, &ns_access);",
                    "1313": "",
                    "1314": "\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ns_hdr));",
                    "1315": "\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));",
                    "1316": "",
                    "1317": "\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "1318": "\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "1319": "",
                    "1320": "\twhile (nd_opt_hdr && nd_opt_hdr->len > 0 &&",
                    "1321": "\t       net_pkt_ipv6_ext_opt_len(pkt) < length) {",
                    "1322": "\t\tuint8_t prev_opt_len;",
                    "1323": "",
                    "1324": "\t\tnet_pkt_acknowledge_data(pkt, &nd_access);",
                    "1325": "",
                    "1326": "\t\tswitch (nd_opt_hdr->type) {",
                    "1327": "\t\tcase NET_ICMPV6_ND_OPT_SLLAO:",
                    "1328": "\t\t\tif (net_ipv6_is_addr_unspecified(&ns_src)) {",
                    "1329": "\t\t\t\tgoto drop;",
                    "1330": "\t\t\t}",
                    "1331": "",
                    "1332": "\t\t\tif (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr)) {",
                    "1333": "\t\t\t\tNET_ERR(\"DROP: failed to read LLAO\");",
                    "1334": "\t\t\t\tgoto drop;",
                    "1335": "\t\t\t}",
                    "1336": "",
                    "1337": "\t\t\tbreak;",
                    "1338": "\t\tdefault:",
                    "1339": "\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);",
                    "1340": "\t\t\tbreak;",
                    "1341": "\t\t}",
                    "1342": "",
                    "1343": "\t\tprev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);",
                    "1344": "",
                    "1345": "\t\tnet_pkt_set_ipv6_ext_opt_len(pkt,",
                    "1346": "\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt) +",
                    "1347": "\t\t\t\t\t     (nd_opt_hdr->len << 3));",
                    "1348": "",
                    "1349": "\t\tif (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {",
                    "1350": "\t\t\tNET_ERR(\"DROP: Corrupted NS message\");",
                    "1351": "\t\t\tgoto drop;",
                    "1352": "\t\t}",
                    "1353": "",
                    "1354": "\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "1355": "\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "1356": "\t}",
                    "1357": "",
                    "1358": "\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {",
                    "1359": "\t\tifaddr = net_if_ipv6_addr_lookup(&ns_tgt, NULL);",
                    "1360": "\t} else {",
                    "1361": "\t\tifaddr = net_if_ipv6_addr_lookup_by_iface(",
                    "1362": "\t\t\t    net_pkt_iface(pkt), &ns_tgt);",
                    "1363": "\t}",
                    "1364": "",
                    "1365": "\tif (!ifaddr) {",
                    "1366": "\t\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {",
                    "1367": "\t\t\tstruct net_in6_addr *nexthop;",
                    "1368": "",
                    "1369": "\t\t\tnexthop = check_route(NULL, &ns_tgt, NULL);",
                    "1370": "\t\t\tif (nexthop) {",
                    "1371": "\t\t\t\tns_routing_info(pkt, nexthop, &ns_tgt);",
                    "1372": "\t\t\t\tna_dst = &ns_dst;",
                    "1373": "\t\t\t\t/* Note that the target is not the address of",
                    "1374": "\t\t\t\t * the \"nethop\" as that is a link-local address",
                    "1375": "\t\t\t\t * which is not routable.",
                    "1376": "\t\t\t\t */",
                    "1377": "\t\t\t\ttgt = &ns_tgt;",
                    "1378": "",
                    "1379": "\t\t\t\t/* Source address must be one of our real",
                    "1380": "\t\t\t\t * interface address where the packet was",
                    "1381": "\t\t\t\t * received.",
                    "1382": "\t\t\t\t */",
                    "1383": "\t\t\t\tna_src = net_if_ipv6_select_src_addr(",
                    "1384": "\t\t\t\t\t\tnet_pkt_iface(pkt),",
                    "1385": "\t\t\t\t\t\t&ns_src);",
                    "1386": "\t\t\t\tif (!na_src) {",
                    "1387": "\t\t\t\t\tNET_DBG(\"DROP: No interface address \"",
                    "1388": "\t\t\t\t\t\t\"for dst %s iface %p/%d\",",
                    "1389": "\t\t\t\t\t\tnet_sprint_ipv6_addr(&ns_src),",
                    "1390": "\t\t\t\t\t\tnet_pkt_iface(pkt),",
                    "1391": "\t\t\t\t\t\tnet_if_get_by_iface(",
                    "1392": "\t\t\t\t\t\t\tnet_pkt_iface(pkt)));",
                    "1393": "\t\t\t\t\tgoto silent_drop;",
                    "1394": "\t\t\t\t}",
                    "1395": "",
                    "1396": "\t\t\t\trouting = true;",
                    "1397": "\t\t\t\tgoto nexthop_found;",
                    "1398": "\t\t\t}",
                    "1399": "\t\t}",
                    "1400": "",
                    "1401": "\t\tNET_DBG(\"DROP: No such interface address %s\",",
                    "1402": "\t\t\tnet_sprint_ipv6_addr(&ns_tgt));",
                    "1403": "\t\tgoto silent_drop;",
                    "1404": "\t} else {",
                    "1405": "\t\ttgt = &ifaddr->address.in6_addr;",
                    "1406": "\t\tna_src = &ns_dst;",
                    "1407": "\t}",
                    "1408": "",
                    "1409": "nexthop_found:",
                    "1410": "",
                    "1411": "#if !defined(CONFIG_NET_IPV6_DAD)",
                    "1412": "\tif (net_ipv6_is_addr_unspecified(&ns_src)) {",
                    "1413": "\t\tgoto drop;",
                    "1414": "\t}",
                    "1415": "",
                    "1416": "#else /* CONFIG_NET_IPV6_DAD */",
                    "1417": "",
                    "1418": "\t/* Do DAD */",
                    "1419": "\tif (net_ipv6_is_addr_unspecified(&ns_src)) {",
                    "1420": "",
                    "1421": "\t\tif (!net_ipv6_is_addr_solicited_node(&ns_dst)) {",
                    "1422": "\t\t\tNET_DBG(\"DROP: Not solicited node addr %s\",",
                    "1423": "\t\t\t\tnet_sprint_ipv6_addr(&ns_dst));",
                    "1424": "\t\t\tgoto silent_drop;",
                    "1425": "\t\t}",
                    "1426": "",
                    "1427": "\t\tif (ifaddr->addr_state == NET_ADDR_TENTATIVE) {",
                    "1428": "\t\t\tNET_DBG(\"DROP: DAD failed for %s iface %p/%d\",",
                    "1429": "\t\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr),",
                    "1430": "\t\t\t\tnet_pkt_iface(pkt),",
                    "1431": "\t\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));",
                    "1432": "",
                    "1433": "\t\t\tdad_failed(net_pkt_iface(pkt),",
                    "1434": "\t\t\t\t   &ifaddr->address.in6_addr);",
                    "1435": "\t\t\tgoto silent_drop;",
                    "1436": "\t\t}",
                    "1437": "",
                    "1438": "\t\t/* We reuse the received packet for the NA addresses*/",
                    "1439": "\t\tnet_ipv6_addr_create_ll_allnodes_mcast(&ns_dst);",
                    "1440": "\t\tnet_ipaddr_copy((struct net_in6_addr *)ip_hdr->src,",
                    "1441": "\t\t\t\tnet_if_ipv6_select_src_addr(",
                    "1442": "\t\t\t\t\tnet_pkt_iface(pkt), &ns_dst));",
                    "1443": "",
                    "1444": "\t\tna_src = &ns_src;",
                    "1445": "\t\tna_dst = &ns_dst;",
                    "1446": "\t\tflags = NET_ICMPV6_NA_FLAG_OVERRIDE;",
                    "1447": "\t\tgoto send_na;",
                    "1448": "\t}",
                    "1449": "#endif /* CONFIG_NET_IPV6_DAD */",
                    "1450": "",
                    "1451": "\tif (net_ipv6_is_my_addr(&ns_src)) {",
                    "1452": "\t\tNET_DBG(\"DROP: Duplicate IPv6 %s address\",",
                    "1453": "\t\t\tnet_sprint_ipv6_addr(&ns_src));",
                    "1454": "\t\tgoto silent_drop;",
                    "1455": "\t}",
                    "1456": "",
                    "1457": "\t/* Address resolution */",
                    "1458": "\tif (net_ipv6_is_addr_solicited_node(&ns_dst)) {",
                    "1459": "\t\tna_src = &ns_tgt;",
                    "1460": "\t\tna_dst = &ns_src;",
                    "1461": "\t\tflags = NET_ICMPV6_NA_FLAG_SOLICITED |",
                    "1462": "\t\t\tNET_ICMPV6_NA_FLAG_OVERRIDE;",
                    "1463": "\t\tgoto send_na;",
                    "1464": "\t}",
                    "1465": "",
                    "1466": "\tif (routing) {",
                    "1467": "\t\t/* No need to do NUD here when the target is being routed. */",
                    "1468": "\t\tgoto send_na;",
                    "1469": "\t}",
                    "1470": "",
                    "1471": "\t/* Neighbor Unreachability Detection (NUD) */",
                    "1472": "\tif (IS_ENABLED(CONFIG_NET_ROUTING)) {",
                    "1473": "\t\tifaddr = net_if_ipv6_addr_lookup(&ns_dst, NULL);",
                    "1474": "\t} else {",
                    "1475": "\t\tifaddr = net_if_ipv6_addr_lookup_by_iface(",
                    "1476": "\t\t\t\t\t\tnet_pkt_iface(pkt),",
                    "1477": "\t\t\t\t\t\t&ns_dst);",
                    "1478": "\t}",
                    "1479": "",
                    "1480": "\tif (ifaddr) {",
                    "1481": "\t\tna_src = &ns_tgt;",
                    "1482": "\t\tna_dst = &ns_src;",
                    "1483": "\t\ttgt = &ifaddr->address.in6_addr;",
                    "1484": "\t\tflags = NET_ICMPV6_NA_FLAG_SOLICITED |",
                    "1485": "\t\t\tNET_ICMPV6_NA_FLAG_OVERRIDE;",
                    "1486": "\t\tgoto send_na;",
                    "1487": "\t} else {",
                    "1488": "\t\tNET_DBG(\"DROP: NUD failed\");",
                    "1489": "\t\tgoto silent_drop;",
                    "1490": "\t}",
                    "1491": "",
                    "1492": "send_na:",
                    "1493": "\tif (src_lladdr.len > 0) {",
                    "1494": "\t\tif (!net_ipv6_nbr_add(net_pkt_iface(pkt),",
                    "1495": "\t\t\t\t      &ns_src, &src_lladdr, false,",
                    "1496": "\t\t\t\t      NET_IPV6_NBR_STATE_INCOMPLETE)) {",
                    "1497": "\t\t\tgoto drop;",
                    "1498": "\t\t}",
                    "1499": "\t}",
                    "1500": "",
                    "1501": "\tif (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,",
                    "1502": "\t\t\t      na_dst, tgt, flags)) {",
                    "1503": "\t\treturn 0;",
                    "1504": "\t}",
                    "1505": "",
                    "1506": "\tNET_DBG(\"DROP: Cannot send NA\");",
                    "1507": "",
                    "1508": "\treturn -EIO;",
                    "1509": "",
                    "1510": "drop:",
                    "1511": "\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "1512": "",
                    "1513": "\treturn -EIO;",
                    "1514": "",
                    "1515": "silent_drop:",
                    "1516": "\t/* If the event is not really an error then just ignore it and",
                    "1517": "\t * return 0 so that icmpv6 module will not complain about it.",
                    "1518": "\t */",
                    "1519": "\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "1520": "",
                    "1521": "\treturn 0;",
                    "1522": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_send_na": {
            "name": "net_ipv6_send_na",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 1162,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6_ND */\nint net_ipv6_send_na(struct net_if *iface, const struct net_in6_addr *src,\n\t\t     const struct net_in6_addr *dst, const struct net_in6_addr *tgt,\n\t\t     uint8_t flags)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,\n\t\t\t\t\t      struct net_icmpv6_na_hdr);\n\tint ret = -ENOBUFS;\n\tstruct net_icmpv6_na_hdr *na_hdr;\n\tstruct net_pkt *pkt;\n\tuint8_t llao_len;\n\n\tllao_len = get_llao_len(iface);\n\n\tpkt = net_pkt_alloc_with_buffer(iface,\n\t\t\t\t\tsizeof(struct net_icmpv6_na_hdr) +\n\t\t\t\t\tllao_len,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tND_NET_BUF_TIMEOUT);\n\tif (!pkt) {\n\t\treturn -ENOMEM;\n\t}\n\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);\n\n\tif (net_ipv6_create(pkt, src, dst) ||\n\t    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {\n\t\tgoto drop;\n\t}\n\n\tna_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);\n\tif (!na_hdr) {\n\t\tgoto drop;\n\t}\n\n\t/* Let's make sure reserved part is full of 0 */\n\tmemset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));\n\n\tna_hdr->flags = flags;\n\tnet_ipv6_addr_copy_raw(na_hdr->tgt, (uint8_t *)tgt);\n\n\tif (net_pkt_set_data(pkt, &na_access)) {\n\t\tgoto drop;\n\t}\n\n\tif (!set_llao(pkt, net_if_get_link_addr(iface),\n\t\t      llao_len, NET_ICMPV6_ND_OPT_TLLAO)) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tdbg_addr_sent_tgt(\"Neighbor Advertisement\", src, dst, &na_hdr->tgt,\n\t\t\t  pkt);\n\n\tif (net_send_data(pkt) < 0) {\n\t\tnet_stats_update_ipv6_nd_drop(iface);\n\t\tret = -EINVAL;\n\n\t\tgoto drop;\n\t}\n\n\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\tnet_stats_update_ipv6_nd_sent(iface);\n\n\treturn 0;\n\ndrop:\n\tnet_pkt_unref(pkt);\n\n\treturn ret;\n}\n",
                {
                    "1162": "int net_ipv6_send_na(struct net_if *iface, const struct net_in6_addr *src,",
                    "1163": "\t\t     const struct net_in6_addr *dst, const struct net_in6_addr *tgt,",
                    "1164": "\t\t     uint8_t flags)",
                    "1165": "{",
                    "1166": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,",
                    "1167": "\t\t\t\t\t      struct net_icmpv6_na_hdr);",
                    "1168": "\tint ret = -ENOBUFS;",
                    "1169": "\tstruct net_icmpv6_na_hdr *na_hdr;",
                    "1170": "\tstruct net_pkt *pkt;",
                    "1171": "\tuint8_t llao_len;",
                    "1172": "",
                    "1173": "\tllao_len = get_llao_len(iface);",
                    "1174": "",
                    "1175": "\tpkt = net_pkt_alloc_with_buffer(iface,",
                    "1176": "\t\t\t\t\tsizeof(struct net_icmpv6_na_hdr) +",
                    "1177": "\t\t\t\t\tllao_len,",
                    "1178": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "1179": "\t\t\t\t\tND_NET_BUF_TIMEOUT);",
                    "1180": "\tif (!pkt) {",
                    "1181": "\t\treturn -ENOMEM;",
                    "1182": "\t}",
                    "1183": "",
                    "1184": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);",
                    "1185": "",
                    "1186": "\tif (net_ipv6_create(pkt, src, dst) ||",
                    "1187": "\t    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {",
                    "1188": "\t\tgoto drop;",
                    "1189": "\t}",
                    "1190": "",
                    "1191": "\tna_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);",
                    "1192": "\tif (!na_hdr) {",
                    "1193": "\t\tgoto drop;",
                    "1194": "\t}",
                    "1195": "",
                    "1196": "\t/* Let's make sure reserved part is full of 0 */",
                    "1197": "\tmemset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));",
                    "1198": "",
                    "1199": "\tna_hdr->flags = flags;",
                    "1200": "\tnet_ipv6_addr_copy_raw(na_hdr->tgt, (uint8_t *)tgt);",
                    "1201": "",
                    "1202": "\tif (net_pkt_set_data(pkt, &na_access)) {",
                    "1203": "\t\tgoto drop;",
                    "1204": "\t}",
                    "1205": "",
                    "1206": "\tif (!set_llao(pkt, net_if_get_link_addr(iface),",
                    "1207": "\t\t      llao_len, NET_ICMPV6_ND_OPT_TLLAO)) {",
                    "1208": "\t\tgoto drop;",
                    "1209": "\t}",
                    "1210": "",
                    "1211": "\tnet_pkt_cursor_init(pkt);",
                    "1212": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "1213": "",
                    "1214": "\tdbg_addr_sent_tgt(\"Neighbor Advertisement\", src, dst, &na_hdr->tgt,",
                    "1215": "\t\t\t  pkt);",
                    "1216": "",
                    "1217": "\tif (net_send_data(pkt) < 0) {",
                    "1218": "\t\tnet_stats_update_ipv6_nd_drop(iface);",
                    "1219": "\t\tret = -EINVAL;",
                    "1220": "",
                    "1221": "\t\tgoto drop;",
                    "1222": "\t}",
                    "1223": "",
                    "1224": "\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "1225": "\tnet_stats_update_ipv6_nd_sent(iface);",
                    "1226": "",
                    "1227": "\treturn 0;",
                    "1228": "",
                    "1229": "drop:",
                    "1230": "\tnet_pkt_unref(pkt);",
                    "1231": "",
                    "1232": "\treturn ret;",
                    "1233": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_prepare_for_send": {
            "name": "net_ipv6_prepare_for_send",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 837,
            "function_content": [
                "/* Try to send the packet anyway */\nenum net_verdict net_ipv6_prepare_for_send(struct net_pkt *pkt)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tstruct net_in6_addr *nexthop = NULL;\n\tstruct net_if *iface = NULL;\n\tstruct net_ipv6_hdr *ip_hdr;\n\tstruct net_in6_addr dst_ip;\n\tstruct net_nbr *nbr;\n\tint ret;\n\n\tNET_ASSERT(pkt && pkt->buffer);\n\n\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);\n\tif (!ip_hdr) {\n\t\treturn NET_DROP;\n\t}\n\n\tnet_ipv6_addr_copy_raw(dst_ip.s6_addr, ip_hdr->dst);\n\n#if defined(CONFIG_NET_IPV6_FRAGMENT)\n\t/* If we have already fragmented the packet, the fragment id will\n\t * contain a proper value and we can skip other checks.\n\t */\n\tif (net_pkt_ipv6_fragment_id(pkt) == 0U) {\n\t\tsize_t pkt_len = net_pkt_get_len(pkt);\n\t\tuint16_t mtu;\n\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {\n\t\t\tstruct net_sockaddr_in6 dst = {\n\t\t\t\t.sin6_family = NET_AF_INET6,\n\t\t\t};\n\n\t\t\tnet_ipv6_addr_copy_raw((uint8_t *)&dst.sin6_addr, ip_hdr->dst);\n\n\t\t\tret = net_pmtu_get_mtu((struct net_sockaddr *)&dst);\n\t\t\tif (ret <= 0) {\n\t\t\t\tgoto use_interface_mtu;\n\t\t\t}\n\n\t\t\tmtu = ret;\n\t\t} else {\nuse_interface_mtu:\n\t\t\tmtu = net_if_get_mtu(net_pkt_iface(pkt));\n\t\t\tmtu = MAX(NET_IPV6_MTU, mtu);\n\t\t}\n\n\t\tif (mtu < pkt_len) {\n\t\t\tret = net_ipv6_send_fragmented_pkt(net_pkt_iface(pkt),\n\t\t\t\t\t\t\t   pkt, pkt_len, mtu);\n\t\t\tif (ret < 0) {\n\t\t\t\tNET_DBG(\"Cannot fragment IPv6 pkt (%d)\", ret);\n\t\t\t\treturn NET_DROP;\n\t\t\t}\n\n\t\t\t/* We need to unref here because we simulate the packet\n\t\t\t * sending.\n\t\t\t */\n\t\t\tnet_pkt_unref(pkt);\n\n\t\t\t/* No need to continue with the sending as the packet\n\t\t\t * is now split and its fragments will be sent\n\t\t\t * separately to network.\n\t\t\t */\n\t\t\treturn NET_CONTINUE;\n\t\t}\n\t}\n#endif /* CONFIG_NET_IPV6_FRAGMENT */\n\n\t/* If the IPv6 destination address is not link local, then try to get\n\t * the next hop from routing table if we have multi interface routing\n\t * enabled. The reason for this is that the neighbor cache will not\n\t * contain public IPv6 address information so in that case we should\n\t * not enter this branch.\n\t */\n\tif ((net_pkt_lladdr_dst(pkt)->len > 0 &&\n\t     ((IS_ENABLED(CONFIG_NET_ROUTING) &&\n\t      (net_ipv6_is_ll_addr(&dst_ip) ||\n\t       net_if_ipv6_addr_onlink(NULL, &dst_ip) ||\n\t       net_pkt_forwarding(pkt))) ||\n\t      !IS_ENABLED(CONFIG_NET_ROUTING))) ||\n\t    net_ipv6_is_addr_mcast(&dst_ip) ||\n\t    /* Workaround Linux bug, see:\n\t     * https://github.com/zephyrproject-rtos/zephyr/issues/3111\n\t     */\n\t    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||\n\t    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\treturn NET_OK;\n\t}\n\n\tif (net_if_ipv6_addr_onlink(&iface, &dst_ip)) {\n\t\tnexthop = &dst_ip;\n\t\tnet_pkt_set_iface(pkt, iface);\n\t} else if (net_ipv6_is_ll_addr(&dst_ip)) {\n\t\tnexthop = &dst_ip;\n\t} else {\n\t\t/* We need to figure out where the destination\n\t\t * host is located.\n\t\t */\n\t\tbool try_route = false;\n\n\t\tnexthop = check_route(NULL, &dst_ip, &try_route);\n\t\tif (!nexthop) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tif (try_route) {\n\t\t\tgoto try_send;\n\t\t}\n\t}\n\n\tif (!iface) {\n\t\t/* This means that the dst was not onlink, so try to\n\t\t * figure out the interface using nexthop instead.\n\t\t */\n\t\tif (net_if_ipv6_addr_onlink(&iface, nexthop)) {\n\t\t\tnet_pkt_set_iface(pkt, iface);\n\t\t} else {\n\t\t\t/* nexthop might be the nbr list, e.g. a link-local\n\t\t\t * address of a connected peer.\n\t\t\t */\n\t\t\tnbr = net_ipv6_nbr_lookup(NULL, nexthop);\n\t\t\tif (nbr) {\n\t\t\t\tiface = nbr->iface;\n\t\t\t\tnet_pkt_set_iface(pkt, iface);\n\t\t\t} else {\n\t\t\t\tiface = net_pkt_iface(pkt);\n\t\t\t}\n\t\t}\n\n\t\t/* If the above check returns null, we try to send\n\t\t * the packet and hope for the best.\n\t\t */\n\t}\n\ntry_send:\n\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {\n\t\tstruct net_pmtu_entry *entry;\n\t\tstruct net_sockaddr_in6 dst = {\n\t\t\t.sin6_family = NET_AF_INET6,\n\t\t};\n\n\t\tnet_ipaddr_copy(&dst.sin6_addr, (struct net_in6_addr *)ip_hdr->dst);\n\n\t\tentry = net_pmtu_get_entry((struct net_sockaddr *)&dst);\n\t\tif (entry == NULL) {\n\t\t\tret = net_pmtu_update_mtu((struct net_sockaddr *)&dst,\n\t\t\t\t\t\t  net_if_get_mtu(iface));\n\t\t\tif (ret < 0) {\n\t\t\t\tNET_DBG(\"Cannot update PMTU for %s (%d)\",\n\t\t\t\t\tnet_sprint_ipv6_addr(&dst.sin6_addr),\n\t\t\t\t\tret);\n\t\t\t}\n\t\t}\n\t}\n\n\tnet_ipv6_nbr_lock();\n\n\tnbr = nbr_lookup(&net_neighbor.table, iface, nexthop);\n\n\tNET_DBG(\"Neighbor lookup %p (%d) iface %p/%d addr %s state %s\", nbr,\n\t\tnbr ? nbr->idx : NET_NBR_LLADDR_UNKNOWN,\n\t\tiface, net_if_get_by_iface(iface),\n\t\tnet_sprint_ipv6_addr(nexthop),\n\t\tnbr ? net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state) :\n\t\t\"-\");\n\n\tif (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {\n\t\tstruct net_linkaddr *lladdr;\n\n\t\tlladdr = net_nbr_get_lladdr(nbr->idx);\n\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt), lladdr->addr,\n\t\t\t\t       lladdr->len);\n\n\t\tNET_DBG(\"Neighbor %p addr %s\", nbr,\n\t\t\tnet_sprint_ll_addr(lladdr->addr, lladdr->len));\n\n\t\t/* Start the NUD if we are in STALE state.\n\t\t * See RFC 4861 ch 7.3.3 for details.\n\t\t */\n#if defined(CONFIG_NET_IPV6_ND)\n\t\tif (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {\n\t\t\tipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);\n\n\t\t\tipv6_nd_restart_reachable_timer(nbr,\n\t\t\t\t\t\t\tDELAY_FIRST_PROBE_TIME);\n\t\t}\n#endif\n\t\tnet_ipv6_nbr_unlock();\n\t\treturn NET_OK;\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\n#if defined(CONFIG_NET_IPV6_ND)\n\tstruct net_in6_addr src_ip;\n\n\tnet_ipv6_addr_copy_raw(src_ip.s6_addr, ip_hdr->src);\n\n\t/* We need to send NS and wait for NA before sending the packet. If the packet was\n\t * forwarded from another interface do not use the original source address.\n\t */\n\tret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,\n\t\t\t       net_pkt_forwarding(pkt) ? NULL : &src_ip,\n\t\t\t       NULL, nexthop, false);\n\tif (ret < 0) {\n\t\t/* In case of an error, the NS send function will unref\n\t\t * the pkt.\n\t\t */\n\t\tNET_DBG(\"Cannot send NS (%d) iface %p/%d\",\n\t\t\tret, net_pkt_iface(pkt),\n\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));\n\t}\n\n\tNET_DBG(\"pkt %p (buffer %p) will be sent later to iface %p/%d\",\n\t\tpkt, pkt->buffer, net_pkt_iface(pkt),\n\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));\n\n\treturn NET_CONTINUE;\n#else\n\tARG_UNUSED(ret);\n\n\tNET_DBG(\"pkt %p (buffer %p) cannot be sent to iface %p/%d, \"\n\t\t\"dropping it.\", pkt, pkt->buffer,\n\t\tnet_pkt_iface(pkt), net_if_get_by_iface(net_pkt_iface(pkt)));\n\n\treturn NET_DROP;\n#endif /* CONFIG_NET_IPV6_ND */\n}\n",
                {
                    "837": "enum net_verdict net_ipv6_prepare_for_send(struct net_pkt *pkt)",
                    "838": "{",
                    "839": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "840": "\tstruct net_in6_addr *nexthop = NULL;",
                    "841": "\tstruct net_if *iface = NULL;",
                    "842": "\tstruct net_ipv6_hdr *ip_hdr;",
                    "843": "\tstruct net_in6_addr dst_ip;",
                    "844": "\tstruct net_nbr *nbr;",
                    "845": "\tint ret;",
                    "846": "",
                    "847": "\tNET_ASSERT(pkt && pkt->buffer);",
                    "848": "",
                    "849": "\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);",
                    "850": "\tif (!ip_hdr) {",
                    "851": "\t\treturn NET_DROP;",
                    "852": "\t}",
                    "853": "",
                    "854": "\tnet_ipv6_addr_copy_raw(dst_ip.s6_addr, ip_hdr->dst);",
                    "855": "",
                    "856": "#if defined(CONFIG_NET_IPV6_FRAGMENT)",
                    "857": "\t/* If we have already fragmented the packet, the fragment id will",
                    "858": "\t * contain a proper value and we can skip other checks.",
                    "859": "\t */",
                    "860": "\tif (net_pkt_ipv6_fragment_id(pkt) == 0U) {",
                    "861": "\t\tsize_t pkt_len = net_pkt_get_len(pkt);",
                    "862": "\t\tuint16_t mtu;",
                    "863": "",
                    "864": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {",
                    "865": "\t\t\tstruct net_sockaddr_in6 dst = {",
                    "866": "\t\t\t\t.sin6_family = NET_AF_INET6,",
                    "867": "\t\t\t};",
                    "868": "",
                    "869": "\t\t\tnet_ipv6_addr_copy_raw((uint8_t *)&dst.sin6_addr, ip_hdr->dst);",
                    "870": "",
                    "871": "\t\t\tret = net_pmtu_get_mtu((struct net_sockaddr *)&dst);",
                    "872": "\t\t\tif (ret <= 0) {",
                    "873": "\t\t\t\tgoto use_interface_mtu;",
                    "874": "\t\t\t}",
                    "875": "",
                    "876": "\t\t\tmtu = ret;",
                    "877": "\t\t} else {",
                    "878": "use_interface_mtu:",
                    "879": "\t\t\tmtu = net_if_get_mtu(net_pkt_iface(pkt));",
                    "880": "\t\t\tmtu = MAX(NET_IPV6_MTU, mtu);",
                    "881": "\t\t}",
                    "882": "",
                    "883": "\t\tif (mtu < pkt_len) {",
                    "884": "\t\t\tret = net_ipv6_send_fragmented_pkt(net_pkt_iface(pkt),",
                    "885": "\t\t\t\t\t\t\t   pkt, pkt_len, mtu);",
                    "886": "\t\t\tif (ret < 0) {",
                    "887": "\t\t\t\tNET_DBG(\"Cannot fragment IPv6 pkt (%d)\", ret);",
                    "888": "\t\t\t\treturn NET_DROP;",
                    "889": "\t\t\t}",
                    "890": "",
                    "891": "\t\t\t/* We need to unref here because we simulate the packet",
                    "892": "\t\t\t * sending.",
                    "893": "\t\t\t */",
                    "894": "\t\t\tnet_pkt_unref(pkt);",
                    "895": "",
                    "896": "\t\t\t/* No need to continue with the sending as the packet",
                    "897": "\t\t\t * is now split and its fragments will be sent",
                    "898": "\t\t\t * separately to network.",
                    "899": "\t\t\t */",
                    "900": "\t\t\treturn NET_CONTINUE;",
                    "901": "\t\t}",
                    "902": "\t}",
                    "903": "#endif /* CONFIG_NET_IPV6_FRAGMENT */",
                    "904": "",
                    "905": "\t/* If the IPv6 destination address is not link local, then try to get",
                    "906": "\t * the next hop from routing table if we have multi interface routing",
                    "907": "\t * enabled. The reason for this is that the neighbor cache will not",
                    "908": "\t * contain public IPv6 address information so in that case we should",
                    "909": "\t * not enter this branch.",
                    "910": "\t */",
                    "911": "\tif ((net_pkt_lladdr_dst(pkt)->len > 0 &&",
                    "912": "\t     ((IS_ENABLED(CONFIG_NET_ROUTING) &&",
                    "913": "\t      (net_ipv6_is_ll_addr(&dst_ip) ||",
                    "914": "\t       net_if_ipv6_addr_onlink(NULL, &dst_ip) ||",
                    "915": "\t       net_pkt_forwarding(pkt))) ||",
                    "916": "\t      !IS_ENABLED(CONFIG_NET_ROUTING))) ||",
                    "917": "\t    net_ipv6_is_addr_mcast(&dst_ip) ||",
                    "918": "\t    /* Workaround Linux bug, see:",
                    "919": "\t     * https://github.com/zephyrproject-rtos/zephyr/issues/3111",
                    "920": "\t     */",
                    "921": "\t    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||",
                    "922": "\t    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "923": "\t\treturn NET_OK;",
                    "924": "\t}",
                    "925": "",
                    "926": "\tif (net_if_ipv6_addr_onlink(&iface, &dst_ip)) {",
                    "927": "\t\tnexthop = &dst_ip;",
                    "928": "\t\tnet_pkt_set_iface(pkt, iface);",
                    "929": "\t} else if (net_ipv6_is_ll_addr(&dst_ip)) {",
                    "930": "\t\tnexthop = &dst_ip;",
                    "931": "\t} else {",
                    "932": "\t\t/* We need to figure out where the destination",
                    "933": "\t\t * host is located.",
                    "934": "\t\t */",
                    "935": "\t\tbool try_route = false;",
                    "936": "",
                    "937": "\t\tnexthop = check_route(NULL, &dst_ip, &try_route);",
                    "938": "\t\tif (!nexthop) {",
                    "939": "\t\t\treturn NET_DROP;",
                    "940": "\t\t}",
                    "941": "",
                    "942": "\t\tif (try_route) {",
                    "943": "\t\t\tgoto try_send;",
                    "944": "\t\t}",
                    "945": "\t}",
                    "946": "",
                    "947": "\tif (!iface) {",
                    "948": "\t\t/* This means that the dst was not onlink, so try to",
                    "949": "\t\t * figure out the interface using nexthop instead.",
                    "950": "\t\t */",
                    "951": "\t\tif (net_if_ipv6_addr_onlink(&iface, nexthop)) {",
                    "952": "\t\t\tnet_pkt_set_iface(pkt, iface);",
                    "953": "\t\t} else {",
                    "954": "\t\t\t/* nexthop might be the nbr list, e.g. a link-local",
                    "955": "\t\t\t * address of a connected peer.",
                    "956": "\t\t\t */",
                    "957": "\t\t\tnbr = net_ipv6_nbr_lookup(NULL, nexthop);",
                    "958": "\t\t\tif (nbr) {",
                    "959": "\t\t\t\tiface = nbr->iface;",
                    "960": "\t\t\t\tnet_pkt_set_iface(pkt, iface);",
                    "961": "\t\t\t} else {",
                    "962": "\t\t\t\tiface = net_pkt_iface(pkt);",
                    "963": "\t\t\t}",
                    "964": "\t\t}",
                    "965": "",
                    "966": "\t\t/* If the above check returns null, we try to send",
                    "967": "\t\t * the packet and hope for the best.",
                    "968": "\t\t */",
                    "969": "\t}",
                    "970": "",
                    "971": "try_send:",
                    "972": "\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {",
                    "973": "\t\tstruct net_pmtu_entry *entry;",
                    "974": "\t\tstruct net_sockaddr_in6 dst = {",
                    "975": "\t\t\t.sin6_family = NET_AF_INET6,",
                    "976": "\t\t};",
                    "977": "",
                    "978": "\t\tnet_ipaddr_copy(&dst.sin6_addr, (struct net_in6_addr *)ip_hdr->dst);",
                    "979": "",
                    "980": "\t\tentry = net_pmtu_get_entry((struct net_sockaddr *)&dst);",
                    "981": "\t\tif (entry == NULL) {",
                    "982": "\t\t\tret = net_pmtu_update_mtu((struct net_sockaddr *)&dst,",
                    "983": "\t\t\t\t\t\t  net_if_get_mtu(iface));",
                    "984": "\t\t\tif (ret < 0) {",
                    "985": "\t\t\t\tNET_DBG(\"Cannot update PMTU for %s (%d)\",",
                    "986": "\t\t\t\t\tnet_sprint_ipv6_addr(&dst.sin6_addr),",
                    "987": "\t\t\t\t\tret);",
                    "988": "\t\t\t}",
                    "989": "\t\t}",
                    "990": "\t}",
                    "991": "",
                    "992": "\tnet_ipv6_nbr_lock();",
                    "993": "",
                    "994": "\tnbr = nbr_lookup(&net_neighbor.table, iface, nexthop);",
                    "995": "",
                    "996": "\tNET_DBG(\"Neighbor lookup %p (%d) iface %p/%d addr %s state %s\", nbr,",
                    "997": "\t\tnbr ? nbr->idx : NET_NBR_LLADDR_UNKNOWN,",
                    "998": "\t\tiface, net_if_get_by_iface(iface),",
                    "999": "\t\tnet_sprint_ipv6_addr(nexthop),",
                    "1000": "\t\tnbr ? net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state) :",
                    "1001": "\t\t\"-\");",
                    "1002": "",
                    "1003": "\tif (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {",
                    "1004": "\t\tstruct net_linkaddr *lladdr;",
                    "1005": "",
                    "1006": "\t\tlladdr = net_nbr_get_lladdr(nbr->idx);",
                    "1007": "",
                    "1008": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt), lladdr->addr,",
                    "1009": "\t\t\t\t       lladdr->len);",
                    "1010": "",
                    "1011": "\t\tNET_DBG(\"Neighbor %p addr %s\", nbr,",
                    "1012": "\t\t\tnet_sprint_ll_addr(lladdr->addr, lladdr->len));",
                    "1013": "",
                    "1014": "\t\t/* Start the NUD if we are in STALE state.",
                    "1015": "\t\t * See RFC 4861 ch 7.3.3 for details.",
                    "1016": "\t\t */",
                    "1017": "#if defined(CONFIG_NET_IPV6_ND)",
                    "1018": "\t\tif (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {",
                    "1019": "\t\t\tipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);",
                    "1020": "",
                    "1021": "\t\t\tipv6_nd_restart_reachable_timer(nbr,",
                    "1022": "\t\t\t\t\t\t\tDELAY_FIRST_PROBE_TIME);",
                    "1023": "\t\t}",
                    "1024": "#endif",
                    "1025": "\t\tnet_ipv6_nbr_unlock();",
                    "1026": "\t\treturn NET_OK;",
                    "1027": "\t}",
                    "1028": "",
                    "1029": "\tnet_ipv6_nbr_unlock();",
                    "1030": "",
                    "1031": "#if defined(CONFIG_NET_IPV6_ND)",
                    "1032": "\tstruct net_in6_addr src_ip;",
                    "1033": "",
                    "1034": "\tnet_ipv6_addr_copy_raw(src_ip.s6_addr, ip_hdr->src);",
                    "1035": "",
                    "1036": "\t/* We need to send NS and wait for NA before sending the packet. If the packet was",
                    "1037": "\t * forwarded from another interface do not use the original source address.",
                    "1038": "\t */",
                    "1039": "\tret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,",
                    "1040": "\t\t\t       net_pkt_forwarding(pkt) ? NULL : &src_ip,",
                    "1041": "\t\t\t       NULL, nexthop, false);",
                    "1042": "\tif (ret < 0) {",
                    "1043": "\t\t/* In case of an error, the NS send function will unref",
                    "1044": "\t\t * the pkt.",
                    "1045": "\t\t */",
                    "1046": "\t\tNET_DBG(\"Cannot send NS (%d) iface %p/%d\",",
                    "1047": "\t\t\tret, net_pkt_iface(pkt),",
                    "1048": "\t\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));",
                    "1049": "\t}",
                    "1050": "",
                    "1051": "\tNET_DBG(\"pkt %p (buffer %p) will be sent later to iface %p/%d\",",
                    "1052": "\t\tpkt, pkt->buffer, net_pkt_iface(pkt),",
                    "1053": "\t\tnet_if_get_by_iface(net_pkt_iface(pkt)));",
                    "1054": "",
                    "1055": "\treturn NET_CONTINUE;",
                    "1056": "#else",
                    "1057": "\tARG_UNUSED(ret);",
                    "1058": "",
                    "1059": "\tNET_DBG(\"pkt %p (buffer %p) cannot be sent to iface %p/%d, \"",
                    "1060": "\t\t\"dropping it.\", pkt, pkt->buffer,",
                    "1061": "\t\tnet_pkt_iface(pkt), net_if_get_by_iface(net_pkt_iface(pkt)));",
                    "1062": "",
                    "1063": "\treturn NET_DROP;",
                    "1064": "#endif /* CONFIG_NET_IPV6_ND */",
                    "1065": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ipv6_ns_reply_timeout": {
            "name": "ipv6_ns_reply_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 349,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6_NBR_CACHE */\nstatic void ipv6_ns_reply_timeout(struct k_work *work)\n{\n\tint64_t current = k_uptime_get();\n\tstruct net_nbr *nbr = NULL;\n\tstruct net_ipv6_nbr_data *data;\n\tstruct net_pkt *pending;\n\tint i;\n\n\tARG_UNUSED(work);\n\n\tnet_ipv6_nbr_lock();\n\n\tfor (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {\n\t\tint64_t remaining;\n\t\tnbr = get_nbr(i);\n\n\t\tif (!nbr || !nbr->ref) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata = net_ipv6_nbr_data(nbr);\n\t\tif (!data) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->send_ns) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining = data->send_ns + NS_REPLY_TIMEOUT - current;\n\n\t\tif (remaining > 0) {\n\t\t\tif (!k_work_delayable_remaining_get(\n\t\t\t\t    &ipv6_ns_reply_timer)) {\n\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,\n\t\t\t\t\t\t  K_MSEC(remaining));\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->send_ns = 0;\n\n\t\t/* We did not receive reply to a sent NS */\n\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\t/* Silently return, this is not an error as the work\n\t\t\t * cannot be cancelled in certain cases.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tenum net_verdict verdict;\n\n\t\t\t/* Remove the first pending packet from the queue\n\t\t\t * and unref it. If there are more pending packets,\n\t\t\t * they will be processed in the next round.\n\t\t\t */\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tNET_DBG(\"NS nbr %p pending %p timeout to %s\", nbr, pending,\n\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));\n\n\t\t\tNET_DBG(\"Dropping pending pkt %p\", pending);\n\n\t\t\t/* This gets rid of the reference that was\n\t\t\t * added when the packet was put into the pending queue.\n\t\t\t */\n\t\t\tnet_pkt_unref(pending);\n\n\t\t\t/* To unref the original pkt allocation */\n\t\t\tnet_pkt_unref(pending);\n\n\t\t\t/* If there are no more pending packets, we can\n\t\t\t * unref the neighbor.\n\t\t\t */\n\t\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\t\tnet_nbr_unref(nbr);\n\n\t\t\t\tNET_DBG(\"Dropping neighbor %p\", nbr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If there are more pending packets, we need to\n\t\t\t * reschedule the work so that we can process them and\n\t\t\t * send a new NS.\n\t\t\t */\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tverdict = net_ipv6_prepare_for_send(pending);\n\t\t\tif (verdict == NET_DROP) {\n\t\t\t\t/* The ref when added to the pending queue */\n\t\t\t\tnet_pkt_unref(pending);\n\n\t\t\t\t/* To unref the original pkt allocation */\n\t\t\t\tnet_pkt_unref(pending);\n\n\t\t\t\t/* Get next packet from the list */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Now wait timeout again */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnet_ipv6_nbr_unlock();\n}\n",
                {
                    "349": "static void ipv6_ns_reply_timeout(struct k_work *work)",
                    "350": "{",
                    "351": "\tint64_t current = k_uptime_get();",
                    "352": "\tstruct net_nbr *nbr = NULL;",
                    "353": "\tstruct net_ipv6_nbr_data *data;",
                    "354": "\tstruct net_pkt *pending;",
                    "355": "\tint i;",
                    "356": "",
                    "357": "\tARG_UNUSED(work);",
                    "358": "",
                    "359": "\tnet_ipv6_nbr_lock();",
                    "360": "",
                    "361": "\tfor (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {",
                    "362": "\t\tint64_t remaining;",
                    "363": "\t\tnbr = get_nbr(i);",
                    "364": "",
                    "365": "\t\tif (!nbr || !nbr->ref) {",
                    "366": "\t\t\tcontinue;",
                    "367": "\t\t}",
                    "368": "",
                    "369": "\t\tdata = net_ipv6_nbr_data(nbr);",
                    "370": "\t\tif (!data) {",
                    "371": "\t\t\tcontinue;",
                    "372": "\t\t}",
                    "373": "",
                    "374": "\t\tif (!data->send_ns) {",
                    "375": "\t\t\tcontinue;",
                    "376": "\t\t}",
                    "377": "",
                    "378": "\t\tremaining = data->send_ns + NS_REPLY_TIMEOUT - current;",
                    "379": "",
                    "380": "\t\tif (remaining > 0) {",
                    "381": "\t\t\tif (!k_work_delayable_remaining_get(",
                    "382": "\t\t\t\t    &ipv6_ns_reply_timer)) {",
                    "383": "\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,",
                    "384": "\t\t\t\t\t\t  K_MSEC(remaining));",
                    "385": "\t\t\t}",
                    "386": "",
                    "387": "\t\t\tcontinue;",
                    "388": "\t\t}",
                    "389": "",
                    "390": "\t\tdata->send_ns = 0;",
                    "391": "",
                    "392": "\t\t/* We did not receive reply to a sent NS */",
                    "393": "\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "394": "\t\t\t/* Silently return, this is not an error as the work",
                    "395": "\t\t\t * cannot be cancelled in certain cases.",
                    "396": "\t\t\t */",
                    "397": "\t\t\tcontinue;",
                    "398": "\t\t}",
                    "399": "",
                    "400": "\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "401": "\t\t\tenum net_verdict verdict;",
                    "402": "",
                    "403": "\t\t\t/* Remove the first pending packet from the queue",
                    "404": "\t\t\t * and unref it. If there are more pending packets,",
                    "405": "\t\t\t * they will be processed in the next round.",
                    "406": "\t\t\t */",
                    "407": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "408": "\t\t\t\t\t     K_FOREVER);",
                    "409": "",
                    "410": "\t\t\tNET_DBG(\"NS nbr %p pending %p timeout to %s\", nbr, pending,",
                    "411": "\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));",
                    "412": "",
                    "413": "\t\t\tNET_DBG(\"Dropping pending pkt %p\", pending);",
                    "414": "",
                    "415": "\t\t\t/* This gets rid of the reference that was",
                    "416": "\t\t\t * added when the packet was put into the pending queue.",
                    "417": "\t\t\t */",
                    "418": "\t\t\tnet_pkt_unref(pending);",
                    "419": "",
                    "420": "\t\t\t/* To unref the original pkt allocation */",
                    "421": "\t\t\tnet_pkt_unref(pending);",
                    "422": "",
                    "423": "\t\t\t/* If there are no more pending packets, we can",
                    "424": "\t\t\t * unref the neighbor.",
                    "425": "\t\t\t */",
                    "426": "\t\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "427": "\t\t\t\tnet_nbr_unref(nbr);",
                    "428": "",
                    "429": "\t\t\t\tNET_DBG(\"Dropping neighbor %p\", nbr);",
                    "430": "\t\t\t\tbreak;",
                    "431": "\t\t\t}",
                    "432": "",
                    "433": "\t\t\t/* If there are more pending packets, we need to",
                    "434": "\t\t\t * reschedule the work so that we can process them and",
                    "435": "\t\t\t * send a new NS.",
                    "436": "\t\t\t */",
                    "437": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "438": "\t\t\t\t\t     K_FOREVER);",
                    "439": "",
                    "440": "\t\t\tverdict = net_ipv6_prepare_for_send(pending);",
                    "441": "\t\t\tif (verdict == NET_DROP) {",
                    "442": "\t\t\t\t/* The ref when added to the pending queue */",
                    "443": "\t\t\t\tnet_pkt_unref(pending);",
                    "444": "",
                    "445": "\t\t\t\t/* To unref the original pkt allocation */",
                    "446": "\t\t\t\tnet_pkt_unref(pending);",
                    "447": "",
                    "448": "\t\t\t\t/* Get next packet from the list */",
                    "449": "\t\t\t\tcontinue;",
                    "450": "\t\t\t}",
                    "451": "",
                    "452": "\t\t\t/* Now wait timeout again */",
                    "453": "\t\t\tbreak;",
                    "454": "\t\t}",
                    "455": "\t}",
                    "456": "",
                    "457": "\tnet_ipv6_nbr_unlock();",
                    "458": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_unicast_hop_limit": {
            "name": "set_context_unicast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3641,
            "function_content": [
                "/* If value is -1 then use the system default.\n* This is done same way as in Linux.\n*/\nstatic int set_context_unicast_hop_limit(struct net_context *context,\n\t\t\t\t\t const void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_IPV6)\n\tuint8_t unicast_hop_limit = *((int *)value);\n\n\tlen = sizeof(context->ipv6_hop_limit);\n\n\treturn set_uint8_option(&context->ipv6_hop_limit,\n\t\t\t\t&unicast_hop_limit, len);\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3641": "static int set_context_unicast_hop_limit(struct net_context *context,",
                    "3642": "\t\t\t\t\t const void *value, uint32_t len)",
                    "3643": "{",
                    "3644": "#if defined(CONFIG_NET_IPV6)",
                    "3645": "\tuint8_t unicast_hop_limit = *((int *)value);",
                    "3646": "",
                    "3647": "\tlen = sizeof(context->ipv6_hop_limit);",
                    "3648": "",
                    "3649": "\treturn set_uint8_option(&context->ipv6_hop_limit,",
                    "3650": "\t\t\t\t&unicast_hop_limit, len);",
                    "3651": "#else",
                    "3652": "\tARG_UNUSED(context);",
                    "3653": "\tARG_UNUSED(value);",
                    "3654": "\tARG_UNUSED(len);",
                    "3655": "",
                    "3656": "\treturn -ENOTSUP;",
                    "3657": "#endif",
                    "3658": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_mcast_hop_limit": {
            "name": "set_context_mcast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3605,
            "function_content": [
                "#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */\nstatic int set_context_mcast_hop_limit(struct net_context *context,\n\t\t\t\t       const void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_IPV6)\n\tint mcast_hop_limit = *((int *)value);\n\n\tif (len != sizeof(int)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (mcast_hop_limit == -1) {\n\t\t/* If value is -1 then use the system default.\n\t\t * This is done same way as in Linux.\n\t\t */\n\t\tif (net_if_get_by_index(context->iface) == NULL) {\n\t\t\tmcast_hop_limit = INITIAL_MCAST_HOP_LIMIT;\n\t\t} else {\n\t\t\tmcast_hop_limit = net_if_ipv6_get_mcast_hop_limit(\n\t\t\t\tnet_if_get_by_index(context->iface));\n\t\t}\n\t} else if (mcast_hop_limit < 0 || mcast_hop_limit > 255) {\n\t\treturn -EINVAL;\n\t}\n\n\tcontext->ipv6_mcast_hop_limit = mcast_hop_limit;\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3605": "static int set_context_mcast_hop_limit(struct net_context *context,",
                    "3606": "\t\t\t\t       const void *value, uint32_t len)",
                    "3607": "{",
                    "3608": "#if defined(CONFIG_NET_IPV6)",
                    "3609": "\tint mcast_hop_limit = *((int *)value);",
                    "3610": "",
                    "3611": "\tif (len != sizeof(int)) {",
                    "3612": "\t\treturn -EINVAL;",
                    "3613": "\t}",
                    "3614": "",
                    "3615": "\tif (mcast_hop_limit == -1) {",
                    "3616": "\t\t/* If value is -1 then use the system default.",
                    "3617": "\t\t * This is done same way as in Linux.",
                    "3618": "\t\t */",
                    "3619": "\t\tif (net_if_get_by_index(context->iface) == NULL) {",
                    "3620": "\t\t\tmcast_hop_limit = INITIAL_MCAST_HOP_LIMIT;",
                    "3621": "\t\t} else {",
                    "3622": "\t\t\tmcast_hop_limit = net_if_ipv6_get_mcast_hop_limit(",
                    "3623": "\t\t\t\tnet_if_get_by_index(context->iface));",
                    "3624": "\t\t}",
                    "3625": "\t} else if (mcast_hop_limit < 0 || mcast_hop_limit > 255) {",
                    "3626": "\t\treturn -EINVAL;",
                    "3627": "\t}",
                    "3628": "",
                    "3629": "\tcontext->ipv6_mcast_hop_limit = mcast_hop_limit;",
                    "3630": "",
                    "3631": "\treturn 0;",
                    "3632": "#else",
                    "3633": "\tARG_UNUSED(context);",
                    "3634": "\tARG_UNUSED(value);",
                    "3635": "\tARG_UNUSED(len);",
                    "3636": "",
                    "3637": "\treturn -ENOTSUP;",
                    "3638": "#endif",
                    "3639": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "raw_inet_set_remote": {
            "name": "raw_inet_set_remote",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2840,
            "function_content": [
                "/* The destination address is set in remote for this\n* socket type.\n*/\nstatic void raw_inet_set_remote(struct net_context *context, const void *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct net_if *iface;\n\n\tif (net_context_get_family(context) == NET_AF_INET) {\n\t\tstruct net_sockaddr_in *remote =\n\t\t\t(struct net_sockaddr_in *)&context->remote;\n\t\tconst struct net_ipv4_hdr *iphdr = buf;\n\n\t\tif (len < sizeof(struct net_ipv4_hdr)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!net_ipv4_is_addr_unspecified(\n\t\t\t\t&net_sin(&context->remote)->sin_addr)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote->sin_family = NET_AF_INET;\n\t\tremote->sin_port = 0;\n\t\tmemcpy(&remote->sin_addr, iphdr->dst, sizeof(remote->sin_addr));\n\n\t\tif (net_context_is_bound_to_iface(context)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tiface = net_if_ipv4_select_src_iface(&remote->sin_addr);\n\t\tif (iface == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tnet_context_set_iface(context, iface);\n\t} else if (net_context_get_family(context) == NET_AF_INET6) {\n\t\tstruct net_sockaddr_in6 *remote =\n\t\t\t(struct net_sockaddr_in6 *)&context->remote;\n\t\tconst struct net_ipv6_hdr *iphdr = buf;\n\n\t\tif (len < sizeof(struct net_ipv6_hdr)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!net_ipv6_is_addr_unspecified(\n\t\t\t\t&net_sin6(&context->remote)->sin6_addr)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote->sin6_family = NET_AF_INET6;\n\t\tremote->sin6_port = 0;\n\t\tmemcpy(&remote->sin6_addr, iphdr->dst, sizeof(remote->sin6_addr));\n\n\t\tif (net_context_is_bound_to_iface(context)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tiface = net_if_ipv6_select_src_iface(&remote->sin6_addr);\n\t\tif (iface == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tnet_context_set_iface(context, iface);\n\t} else {\n\t\treturn;\n\t}\n\nout:\n\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;\n}\n",
                {
                    "2840": "static void raw_inet_set_remote(struct net_context *context, const void *buf,",
                    "2841": "\t\t\t\tsize_t len)",
                    "2842": "{",
                    "2843": "\tstruct net_if *iface;",
                    "2844": "",
                    "2845": "\tif (net_context_get_family(context) == NET_AF_INET) {",
                    "2846": "\t\tstruct net_sockaddr_in *remote =",
                    "2847": "\t\t\t(struct net_sockaddr_in *)&context->remote;",
                    "2848": "\t\tconst struct net_ipv4_hdr *iphdr = buf;",
                    "2849": "",
                    "2850": "\t\tif (len < sizeof(struct net_ipv4_hdr)) {",
                    "2851": "\t\t\treturn;",
                    "2852": "\t\t}",
                    "2853": "",
                    "2854": "\t\tif (!net_ipv4_is_addr_unspecified(",
                    "2855": "\t\t\t\t&net_sin(&context->remote)->sin_addr)) {",
                    "2856": "\t\t\tgoto out;",
                    "2857": "\t\t}",
                    "2858": "",
                    "2859": "\t\tremote->sin_family = NET_AF_INET;",
                    "2860": "\t\tremote->sin_port = 0;",
                    "2861": "\t\tmemcpy(&remote->sin_addr, iphdr->dst, sizeof(remote->sin_addr));",
                    "2862": "",
                    "2863": "\t\tif (net_context_is_bound_to_iface(context)) {",
                    "2864": "\t\t\tgoto out;",
                    "2865": "\t\t}",
                    "2866": "",
                    "2867": "\t\tiface = net_if_ipv4_select_src_iface(&remote->sin_addr);",
                    "2868": "\t\tif (iface == NULL) {",
                    "2869": "\t\t\tgoto out;",
                    "2870": "\t\t}",
                    "2871": "",
                    "2872": "\t\tnet_context_set_iface(context, iface);",
                    "2873": "\t} else if (net_context_get_family(context) == NET_AF_INET6) {",
                    "2874": "\t\tstruct net_sockaddr_in6 *remote =",
                    "2875": "\t\t\t(struct net_sockaddr_in6 *)&context->remote;",
                    "2876": "\t\tconst struct net_ipv6_hdr *iphdr = buf;",
                    "2877": "",
                    "2878": "\t\tif (len < sizeof(struct net_ipv6_hdr)) {",
                    "2879": "\t\t\treturn;",
                    "2880": "\t\t}",
                    "2881": "",
                    "2882": "\t\tif (!net_ipv6_is_addr_unspecified(",
                    "2883": "\t\t\t\t&net_sin6(&context->remote)->sin6_addr)) {",
                    "2884": "\t\t\tgoto out;",
                    "2885": "\t\t}",
                    "2886": "",
                    "2887": "\t\tremote->sin6_family = NET_AF_INET6;",
                    "2888": "\t\tremote->sin6_port = 0;",
                    "2889": "\t\tmemcpy(&remote->sin6_addr, iphdr->dst, sizeof(remote->sin6_addr));",
                    "2890": "",
                    "2891": "\t\tif (net_context_is_bound_to_iface(context)) {",
                    "2892": "\t\t\tgoto out;",
                    "2893": "\t\t}",
                    "2894": "",
                    "2895": "\t\tiface = net_if_ipv6_select_src_iface(&remote->sin6_addr);",
                    "2896": "\t\tif (iface == NULL) {",
                    "2897": "\t\t\tgoto out;",
                    "2898": "\t\t}",
                    "2899": "",
                    "2900": "\t\tnet_context_set_iface(context, iface);",
                    "2901": "\t} else {",
                    "2902": "\t\treturn;",
                    "2903": "\t}",
                    "2904": "",
                    "2905": "out:",
                    "2906": "\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;",
                    "2907": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "context_sendto": {
            "name": "context_sendto",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2385,
            "function_content": [
                "/* This function is meant to be temporary: once all moved to new\n* API, it will be up to net_send_data() to finalize the packet.\n*/\nstatic int context_sendto(struct net_context *context,\n\t\t\t  const void *buf,\n\t\t\t  size_t len,\n\t\t\t  const struct net_sockaddr *dst_addr,\n\t\t\t  net_socklen_t addrlen,\n\t\t\t  net_context_send_cb_t cb,\n\t\t\t  k_timeout_t timeout,\n\t\t\t  void *user_data,\n\t\t\t  bool sendto)\n{\n\tconst struct net_msghdr *msghdr = NULL;\n\tstruct net_if *iface = NULL;\n\tstruct net_pkt *pkt = NULL;\n\tnet_sa_family_t family;\n\tsize_t tmp_len;\n\tint ret;\n\n\tNET_ASSERT(PART_OF_ARRAY(contexts, context));\n\n\tif (!net_context_is_used(context)) {\n\t\treturn -EBADF;\n\t}\n\n\tif (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {\n\t\t/* User wants to call sendmsg */\n\t\tmsghdr = buf;\n\t}\n\n\tif (!msghdr && !dst_addr) {\n\t\treturn -EDESTADDRREQ;\n\t}\n\n\t/* Are we trying to send IPv4 packet to mapped V6 address, in that case\n\t * we need to set the family to NET_AF_INET so that various checks below\n\t * are done to the packet correctly and we actually send an IPv4 pkt.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&\n\t    IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_context_get_family(context) == NET_AF_INET6) {\n\t\tconst struct net_sockaddr_in6 *addr6 = NULL;\n\n\t\tif (dst_addr != NULL) {\n\t\t\taddr6 = (const struct net_sockaddr_in6 *)dst_addr;\n\t\t} else if (msghdr != NULL) {\n\t\t\taddr6 = msghdr->msg_name;\n\t\t}\n\n\t\tif (addr6 != NULL && net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {\n\t\t\tfamily = NET_AF_INET;\n\t\t} else {\n\t\t\tfamily = net_context_get_family(context);\n\t\t}\n\t} else {\n\t\tfamily = net_context_get_family(context);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\tconst struct net_sockaddr_in6 *addr6 =\n\t\t\t(const struct net_sockaddr_in6 *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\taddr6 = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!addr6) {\n\t\t\t\taddr6 = net_sin6(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_in6);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr6;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,\n\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,\n\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));\n\t\t\t}\n\n\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr) &&\n\t\t\t    !net_context_is_bound_to_iface(context) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,\n\t\t\t\t\t(addr6->sin6_scope_id > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6, (\n\t\t\t\t\t   iface = net_if_get_by_index(addr6->sin6_scope_id)));\n\t\t\t\tif (iface != NULL) {\n\t\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If application has not yet set the destination address\n\t\t * i.e., by not calling connect(), then set the interface\n\t\t * here so that the packet gets sent to the correct network\n\t\t * interface. This issue can be seen if there are multiple\n\t\t * network interfaces and we are trying to send data to\n\t\t * second or later network interface.\n\t\t */\n\t\tif (iface == NULL) {\n\t\t\tif (net_ipv6_is_addr_unspecified(\n\t\t\t\t    &net_sin6(&context->remote)->sin6_addr) &&\n\t\t\t    !net_context_is_bound_to_iface(context)) {\n\t\t\t\tiface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);\n\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\tconst struct net_sockaddr_in *addr4 = (const struct net_sockaddr_in *)dst_addr;\n\t\tstruct net_sockaddr_in mapped;\n\n\t\tif (msghdr) {\n\t\t\taddr4 = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!addr4) {\n\t\t\t\taddr4 = net_sin(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_in);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr4;\n\t\t}\n\n\t\t/* Get the destination address from the mapped IPv6 address */\n\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&\n\t\t    addr4->sin_family == NET_AF_INET6 &&\n\t\t    net_ipv6_addr_is_v4_mapped(&net_sin6(dst_addr)->sin6_addr)) {\n\t\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;\n\n\t\t\tmapped.sin_port = addr6->sin6_port;\n\t\t\tmapped.sin_family = NET_AF_INET;\n\t\t\tnet_ipaddr_copy(&mapped.sin_addr,\n\t\t\t\t\t(struct net_in_addr *)(&addr6->sin6_addr.s6_addr32[3]));\n\t\t\taddr4 = &mapped;\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr4;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!addr4->sin_addr.s_addr) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV4,\n\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,\n\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));\n\t\t\t}\n\t\t}\n\n\t\t/* If application has not yet set the destination address\n\t\t * i.e., by not calling connect(), then set the interface\n\t\t * here so that the packet gets sent to the correct network\n\t\t * interface. This issue can be seen if there are multiple\n\t\t * network interfaces and we are trying to send data to\n\t\t * second or later network interface.\n\t\t */\n\t\tif (iface == NULL) {\n\t\t\tif (net_sin(&context->remote)->sin_addr.s_addr == 0U &&\n\t\t\t    !net_context_is_bound_to_iface(context)) {\n\t\t\t\tiface = net_if_ipv4_select_src_iface(&addr4->sin_addr);\n\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {\n\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\tll_addr = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!ll_addr) {\n\t\t\t\tll_addr = (struct net_sockaddr_ll *)\n\t\t\t\t\t\t\t(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_ll);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)ll_addr;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiface = net_context_get_iface(context);\n\t\tif (iface == NULL) {\n\t\t\tif (ll_addr->sll_ifindex < 0) {\n\t\t\t\treturn -EDESTADDRREQ;\n\t\t\t}\n\n\t\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);\n\t\t\tif (iface == NULL) {\n\t\t\t\tNET_ERR(\"Cannot bind to interface index %d\",\n\t\t\t\t\tll_addr->sll_ifindex);\n\t\t\t\treturn -EDESTADDRREQ;\n\t\t\t}\n\n\t\t\tnet_context_set_iface(context, iface);\n\t\t}\n\n\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;\n\n\t\t\t/* The user must set the protocol in send call */\n\n\t\t\t/* For sendmsg() call, we might have set ll_addr to\n\t\t\t * point to remote addr.\n\t\t\t */\n\t\t\tif ((void *)&context->remote != (void *)ll_addr) {\n\t\t\t\tmemcpy((struct net_sockaddr_ll *)&context->remote,\n\t\t\t\t       ll_addr, sizeof(struct net_sockaddr_ll));\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN) {\n\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\tcan_addr = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!can_addr) {\n\t\t\t\tcan_addr = (struct net_sockaddr_can *)\n\t\t\t\t\t\t\t(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_can);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)can_addr;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (can_addr->can_ifindex < 0) {\n\t\t\t/* The index should have been set in bind */\n\t\t\tcan_addr->can_ifindex =\n\t\t\t\tnet_can_ptr(&context->local)->can_ifindex;\n\t\t}\n\n\t\tif (can_addr->can_ifindex < 0) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tiface = net_if_get_by_index(can_addr->can_ifindex);\n\t\tif (!iface) {\n\t\t\tNET_ERR(\"Cannot bind to interface index %d\",\n\t\t\t\tcan_addr->can_ifindex);\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\t} else {\n\t\tNET_DBG(\"Invalid protocol family %d\", family);\n\t\treturn -EINVAL;\n\t}\n\n\tif (msghdr && len == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {\n\t\t\tlen += msghdr->msg_iov[i].iov_len;\n\t\t}\n\t}\n\n\tiface = net_context_get_iface(context);\n\tif (iface && !net_if_is_up(iface)) {\n\t\treturn -ENETDOWN;\n\t}\n\n\tcontext->send_cb = cb;\n\tcontext->user_data = user_data;\n\n\tif (IS_ENABLED(CONFIG_NET_TCP) &&\n\t    net_context_get_proto(context) == NET_IPPROTO_TCP &&\n\t    !net_if_is_ip_offloaded(net_context_get_iface(context))) {\n\t\tgoto skip_alloc;\n\t}\n\n\tpkt = context_alloc_pkt(context, family, len, PKT_WAIT_TIME);\n\tif (!pkt) {\n\t\tNET_ERR(\"Failed to allocate net_pkt\");\n\t\treturn -ENOBUFS;\n\t}\n\n\ttmp_len = net_pkt_available_payload_buffer(\n\t\t\t\tpkt, net_context_get_proto(context));\n\tif (tmp_len < len) {\n\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM ||\n\t\t    net_context_get_type(context) == NET_SOCK_RAW) {\n\t\t\tNET_ERR(\"Available payload buffer (%zu) is not enough for requested DGRAM (%zu)\",\n\t\t\t\ttmp_len, len);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tlen = tmp_len;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {\n\t\tuint8_t priority;\n\n\t\tget_context_priority(context, &priority, NULL);\n\t\tnet_pkt_set_priority(pkt, priority);\n\t}\n\n\t/* If there is ancillary data in msghdr, then we need to add that\n\t * to net_pkt as there is no other way to store it.\n\t */\n\tif (msghdr && msghdr->msg_control && msghdr->msg_controllen) {\n\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_TXTIME)) {\n\t\t\tint is_txtime;\n\n\t\t\tget_context_txtime(context, &is_txtime, NULL);\n\t\t\tif (is_txtime) {\n\t\t\t\tset_pkt_txtime(pkt, msghdr);\n\t\t\t}\n\t\t}\n\n\t\tset_pkt_hoplimit(pkt, msghdr);\n\n\t}\n\nskip_alloc:\n\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&\n\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tif (sendto) {\n\t\t\tret = net_offload_sendto(net_context_get_iface(context),\n\t\t\t\t\t\t pkt, dst_addr, addrlen, cb,\n\t\t\t\t\t\t timeout, user_data);\n\t\t} else {\n\t\t\tret = net_offload_send(net_context_get_iface(context),\n\t\t\t\t\t       pkt, cb, timeout, user_data);\n\t\t}\n\t} else if (((IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) ||\n\t\t    (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6)) &&\n\t\t   IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&\n\t\t   net_context_get_type(context) == NET_SOCK_RAW) {\n\t\tret = context_setup_raw_ip_packet(family, pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_UDP) &&\n\t    net_context_get_proto(context) == NET_IPPROTO_UDP) {\n\t\tret = context_setup_udp_packet(context, family, pkt, buf, len, msghdr,\n\t\t\t\t\t       dst_addr, addrlen);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tcontext_finalize_packet(context, family, pkt);\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&\n\t\t   net_context_get_proto(context) == NET_IPPROTO_TCP) {\n\n\t\tret = net_tcp_queue(context, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlen = ret;\n\n\t\tret = net_tcp_send_data(context, cb, user_data);\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tstruct net_sockaddr_ll_ptr *ll_src_addr;\n\t\tstruct net_sockaddr_ll *ll_dst_addr;\n\n\t\t/* The destination address is set in remote for this\n\t\t * socket type.\n\t\t */\n\t\tll_dst_addr = (struct net_sockaddr_ll *)&context->remote;\n\t\tll_src_addr = (struct net_sockaddr_ll_ptr *)&context->local;\n\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),\n\t\t\t\t       ll_dst_addr->sll_addr,\n\t\t\t\t       sizeof(struct net_eth_addr));\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_src(pkt),\n\t\t\t\t       ll_src_addr->sll_addr,\n\t\t\t\t       sizeof(struct net_eth_addr));\n\n\t\tnet_pkt_set_ll_proto_type(pkt, net_ntohs(ll_dst_addr->sll_protocol));\n\n\t\tnet_if_try_queue_tx(net_pkt_iface(pkt), pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN &&\n\t\t   net_context_get_proto(context) == NET_CAN_RAW) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else {\n\t\tNET_DBG(\"Unknown protocol while sending packet: %d\",\n\t\tnet_context_get_proto(context));\n\t\tret = -EPROTONOSUPPORT;\n\t}\n\n\tif (ret < 0) {\n\t\tgoto fail;\n\t}\n\n\treturn len;\nfail:\n\tif (pkt != NULL) {\n\t\tnet_pkt_unref(pkt);\n\t}\n\n\treturn ret;\n}\n",
                {
                    "2385": "static int context_sendto(struct net_context *context,",
                    "2386": "\t\t\t  const void *buf,",
                    "2387": "\t\t\t  size_t len,",
                    "2388": "\t\t\t  const struct net_sockaddr *dst_addr,",
                    "2389": "\t\t\t  net_socklen_t addrlen,",
                    "2390": "\t\t\t  net_context_send_cb_t cb,",
                    "2391": "\t\t\t  k_timeout_t timeout,",
                    "2392": "\t\t\t  void *user_data,",
                    "2393": "\t\t\t  bool sendto)",
                    "2394": "{",
                    "2395": "\tconst struct net_msghdr *msghdr = NULL;",
                    "2396": "\tstruct net_if *iface = NULL;",
                    "2397": "\tstruct net_pkt *pkt = NULL;",
                    "2398": "\tnet_sa_family_t family;",
                    "2399": "\tsize_t tmp_len;",
                    "2400": "\tint ret;",
                    "2401": "",
                    "2402": "\tNET_ASSERT(PART_OF_ARRAY(contexts, context));",
                    "2403": "",
                    "2404": "\tif (!net_context_is_used(context)) {",
                    "2405": "\t\treturn -EBADF;",
                    "2406": "\t}",
                    "2407": "",
                    "2408": "\tif (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {",
                    "2409": "\t\t/* User wants to call sendmsg */",
                    "2410": "\t\tmsghdr = buf;",
                    "2411": "\t}",
                    "2412": "",
                    "2413": "\tif (!msghdr && !dst_addr) {",
                    "2414": "\t\treturn -EDESTADDRREQ;",
                    "2415": "\t}",
                    "2416": "",
                    "2417": "\t/* Are we trying to send IPv4 packet to mapped V6 address, in that case",
                    "2418": "\t * we need to set the family to NET_AF_INET so that various checks below",
                    "2419": "\t * are done to the packet correctly and we actually send an IPv4 pkt.",
                    "2420": "\t */",
                    "2421": "\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&",
                    "2422": "\t    IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "2423": "\t    net_context_get_family(context) == NET_AF_INET6) {",
                    "2424": "\t\tconst struct net_sockaddr_in6 *addr6 = NULL;",
                    "2425": "",
                    "2426": "\t\tif (dst_addr != NULL) {",
                    "2427": "\t\t\taddr6 = (const struct net_sockaddr_in6 *)dst_addr;",
                    "2428": "\t\t} else if (msghdr != NULL) {",
                    "2429": "\t\t\taddr6 = msghdr->msg_name;",
                    "2430": "\t\t}",
                    "2431": "",
                    "2432": "\t\tif (addr6 != NULL && net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {",
                    "2433": "\t\t\tfamily = NET_AF_INET;",
                    "2434": "\t\t} else {",
                    "2435": "\t\t\tfamily = net_context_get_family(context);",
                    "2436": "\t\t}",
                    "2437": "\t} else {",
                    "2438": "\t\tfamily = net_context_get_family(context);",
                    "2439": "\t}",
                    "2440": "",
                    "2441": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "2442": "\t\tconst struct net_sockaddr_in6 *addr6 =",
                    "2443": "\t\t\t(const struct net_sockaddr_in6 *)dst_addr;",
                    "2444": "",
                    "2445": "\t\tif (msghdr) {",
                    "2446": "\t\t\taddr6 = msghdr->msg_name;",
                    "2447": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2448": "",
                    "2449": "\t\t\tif (!addr6) {",
                    "2450": "\t\t\t\taddr6 = net_sin6(&context->remote);",
                    "2451": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_in6);",
                    "2452": "\t\t\t}",
                    "2453": "",
                    "2454": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2455": "\t\t\t */",
                    "2456": "\t\t\tdst_addr = (const struct net_sockaddr *)addr6;",
                    "2457": "\t\t}",
                    "2458": "",
                    "2459": "\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {",
                    "2460": "\t\t\treturn -EINVAL;",
                    "2461": "\t\t}",
                    "2462": "",
                    "2463": "\t\tif (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {",
                    "2464": "\t\t\treturn -EDESTADDRREQ;",
                    "2465": "\t\t}",
                    "2466": "",
                    "2467": "\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2468": "\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2469": "\t\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr) &&",
                    "2470": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,",
                    "2471": "\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0), (false))) {",
                    "2472": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,",
                    "2473": "\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "2474": "\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));",
                    "2475": "\t\t\t}",
                    "2476": "",
                    "2477": "\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr) &&",
                    "2478": "\t\t\t    !net_context_is_bound_to_iface(context) &&",
                    "2479": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,",
                    "2480": "\t\t\t\t\t(addr6->sin6_scope_id > 0), (false))) {",
                    "2481": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6, (",
                    "2482": "\t\t\t\t\t   iface = net_if_get_by_index(addr6->sin6_scope_id)));",
                    "2483": "\t\t\t\tif (iface != NULL) {",
                    "2484": "\t\t\t\t\tnet_context_set_iface(context, iface);",
                    "2485": "\t\t\t\t}",
                    "2486": "\t\t\t}",
                    "2487": "\t\t}",
                    "2488": "",
                    "2489": "\t\t/* If application has not yet set the destination address",
                    "2490": "\t\t * i.e., by not calling connect(), then set the interface",
                    "2491": "\t\t * here so that the packet gets sent to the correct network",
                    "2492": "\t\t * interface. This issue can be seen if there are multiple",
                    "2493": "\t\t * network interfaces and we are trying to send data to",
                    "2494": "\t\t * second or later network interface.",
                    "2495": "\t\t */",
                    "2496": "\t\tif (iface == NULL) {",
                    "2497": "\t\t\tif (net_ipv6_is_addr_unspecified(",
                    "2498": "\t\t\t\t    &net_sin6(&context->remote)->sin6_addr) &&",
                    "2499": "\t\t\t    !net_context_is_bound_to_iface(context)) {",
                    "2500": "\t\t\t\tiface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);",
                    "2501": "\t\t\t\tnet_context_set_iface(context, iface);",
                    "2502": "\t\t\t}",
                    "2503": "\t\t}",
                    "2504": "",
                    "2505": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "2506": "\t\tconst struct net_sockaddr_in *addr4 = (const struct net_sockaddr_in *)dst_addr;",
                    "2507": "\t\tstruct net_sockaddr_in mapped;",
                    "2508": "",
                    "2509": "\t\tif (msghdr) {",
                    "2510": "\t\t\taddr4 = msghdr->msg_name;",
                    "2511": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2512": "",
                    "2513": "\t\t\tif (!addr4) {",
                    "2514": "\t\t\t\taddr4 = net_sin(&context->remote);",
                    "2515": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_in);",
                    "2516": "\t\t\t}",
                    "2517": "",
                    "2518": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2519": "\t\t\t */",
                    "2520": "\t\t\tdst_addr = (const struct net_sockaddr *)addr4;",
                    "2521": "\t\t}",
                    "2522": "",
                    "2523": "\t\t/* Get the destination address from the mapped IPv6 address */",
                    "2524": "\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&",
                    "2525": "\t\t    addr4->sin_family == NET_AF_INET6 &&",
                    "2526": "\t\t    net_ipv6_addr_is_v4_mapped(&net_sin6(dst_addr)->sin6_addr)) {",
                    "2527": "\t\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;",
                    "2528": "",
                    "2529": "\t\t\tmapped.sin_port = addr6->sin6_port;",
                    "2530": "\t\t\tmapped.sin_family = NET_AF_INET;",
                    "2531": "\t\t\tnet_ipaddr_copy(&mapped.sin_addr,",
                    "2532": "\t\t\t\t\t(struct net_in_addr *)(&addr6->sin6_addr.s6_addr32[3]));",
                    "2533": "\t\t\taddr4 = &mapped;",
                    "2534": "",
                    "2535": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2536": "\t\t\t */",
                    "2537": "\t\t\tdst_addr = (const struct net_sockaddr *)addr4;",
                    "2538": "\t\t}",
                    "2539": "",
                    "2540": "\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {",
                    "2541": "\t\t\treturn -EINVAL;",
                    "2542": "\t\t}",
                    "2543": "",
                    "2544": "\t\tif (!addr4->sin_addr.s_addr) {",
                    "2545": "\t\t\treturn -EDESTADDRREQ;",
                    "2546": "\t\t}",
                    "2547": "",
                    "2548": "\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2549": "\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2550": "\t\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr) &&",
                    "2551": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV4,",
                    "2552": "\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0), (false))) {",
                    "2553": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,",
                    "2554": "\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "2555": "\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));",
                    "2556": "\t\t\t}",
                    "2557": "\t\t}",
                    "2558": "",
                    "2559": "\t\t/* If application has not yet set the destination address",
                    "2560": "\t\t * i.e., by not calling connect(), then set the interface",
                    "2561": "\t\t * here so that the packet gets sent to the correct network",
                    "2562": "\t\t * interface. This issue can be seen if there are multiple",
                    "2563": "\t\t * network interfaces and we are trying to send data to",
                    "2564": "\t\t * second or later network interface.",
                    "2565": "\t\t */",
                    "2566": "\t\tif (iface == NULL) {",
                    "2567": "\t\t\tif (net_sin(&context->remote)->sin_addr.s_addr == 0U &&",
                    "2568": "\t\t\t    !net_context_is_bound_to_iface(context)) {",
                    "2569": "\t\t\t\tiface = net_if_ipv4_select_src_iface(&addr4->sin_addr);",
                    "2570": "\t\t\t\tnet_context_set_iface(context, iface);",
                    "2571": "\t\t\t}",
                    "2572": "\t\t}",
                    "2573": "",
                    "2574": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {",
                    "2575": "\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)dst_addr;",
                    "2576": "",
                    "2577": "\t\tif (msghdr) {",
                    "2578": "\t\t\tll_addr = msghdr->msg_name;",
                    "2579": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2580": "",
                    "2581": "\t\t\tif (!ll_addr) {",
                    "2582": "\t\t\t\tll_addr = (struct net_sockaddr_ll *)",
                    "2583": "\t\t\t\t\t\t\t(&context->remote);",
                    "2584": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_ll);",
                    "2585": "\t\t\t}",
                    "2586": "",
                    "2587": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2588": "\t\t\t */",
                    "2589": "\t\t\tdst_addr = (const struct net_sockaddr *)ll_addr;",
                    "2590": "\t\t}",
                    "2591": "",
                    "2592": "\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {",
                    "2593": "\t\t\treturn -EINVAL;",
                    "2594": "\t\t}",
                    "2595": "",
                    "2596": "\t\tiface = net_context_get_iface(context);",
                    "2597": "\t\tif (iface == NULL) {",
                    "2598": "\t\t\tif (ll_addr->sll_ifindex < 0) {",
                    "2599": "\t\t\t\treturn -EDESTADDRREQ;",
                    "2600": "\t\t\t}",
                    "2601": "",
                    "2602": "\t\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);",
                    "2603": "\t\t\tif (iface == NULL) {",
                    "2604": "\t\t\t\tNET_ERR(\"Cannot bind to interface index %d\",",
                    "2605": "\t\t\t\t\tll_addr->sll_ifindex);",
                    "2606": "\t\t\t\treturn -EDESTADDRREQ;",
                    "2607": "\t\t\t}",
                    "2608": "",
                    "2609": "\t\t\tnet_context_set_iface(context, iface);",
                    "2610": "\t\t}",
                    "2611": "",
                    "2612": "\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2613": "\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;",
                    "2614": "",
                    "2615": "\t\t\t/* The user must set the protocol in send call */",
                    "2616": "",
                    "2617": "\t\t\t/* For sendmsg() call, we might have set ll_addr to",
                    "2618": "\t\t\t * point to remote addr.",
                    "2619": "\t\t\t */",
                    "2620": "\t\t\tif ((void *)&context->remote != (void *)ll_addr) {",
                    "2621": "\t\t\t\tmemcpy((struct net_sockaddr_ll *)&context->remote,",
                    "2622": "\t\t\t\t       ll_addr, sizeof(struct net_sockaddr_ll));",
                    "2623": "\t\t\t}",
                    "2624": "\t\t}",
                    "2625": "",
                    "2626": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN) {",
                    "2627": "\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)dst_addr;",
                    "2628": "",
                    "2629": "\t\tif (msghdr) {",
                    "2630": "\t\t\tcan_addr = msghdr->msg_name;",
                    "2631": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2632": "",
                    "2633": "\t\t\tif (!can_addr) {",
                    "2634": "\t\t\t\tcan_addr = (struct net_sockaddr_can *)",
                    "2635": "\t\t\t\t\t\t\t(&context->remote);",
                    "2636": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_can);",
                    "2637": "\t\t\t}",
                    "2638": "",
                    "2639": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2640": "\t\t\t */",
                    "2641": "\t\t\tdst_addr = (const struct net_sockaddr *)can_addr;",
                    "2642": "\t\t}",
                    "2643": "",
                    "2644": "\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {",
                    "2645": "\t\t\treturn -EINVAL;",
                    "2646": "\t\t}",
                    "2647": "",
                    "2648": "\t\tif (can_addr->can_ifindex < 0) {",
                    "2649": "\t\t\t/* The index should have been set in bind */",
                    "2650": "\t\t\tcan_addr->can_ifindex =",
                    "2651": "\t\t\t\tnet_can_ptr(&context->local)->can_ifindex;",
                    "2652": "\t\t}",
                    "2653": "",
                    "2654": "\t\tif (can_addr->can_ifindex < 0) {",
                    "2655": "\t\t\treturn -EDESTADDRREQ;",
                    "2656": "\t\t}",
                    "2657": "",
                    "2658": "\t\tiface = net_if_get_by_index(can_addr->can_ifindex);",
                    "2659": "\t\tif (!iface) {",
                    "2660": "\t\t\tNET_ERR(\"Cannot bind to interface index %d\",",
                    "2661": "\t\t\t\tcan_addr->can_ifindex);",
                    "2662": "\t\t\treturn -EDESTADDRREQ;",
                    "2663": "\t\t}",
                    "2664": "\t} else {",
                    "2665": "\t\tNET_DBG(\"Invalid protocol family %d\", family);",
                    "2666": "\t\treturn -EINVAL;",
                    "2667": "\t}",
                    "2668": "",
                    "2669": "\tif (msghdr && len == 0) {",
                    "2670": "\t\tint i;",
                    "2671": "",
                    "2672": "\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {",
                    "2673": "\t\t\tlen += msghdr->msg_iov[i].iov_len;",
                    "2674": "\t\t}",
                    "2675": "\t}",
                    "2676": "",
                    "2677": "\tiface = net_context_get_iface(context);",
                    "2678": "\tif (iface && !net_if_is_up(iface)) {",
                    "2679": "\t\treturn -ENETDOWN;",
                    "2680": "\t}",
                    "2681": "",
                    "2682": "\tcontext->send_cb = cb;",
                    "2683": "\tcontext->user_data = user_data;",
                    "2684": "",
                    "2685": "\tif (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "2686": "\t    net_context_get_proto(context) == NET_IPPROTO_TCP &&",
                    "2687": "\t    !net_if_is_ip_offloaded(net_context_get_iface(context))) {",
                    "2688": "\t\tgoto skip_alloc;",
                    "2689": "\t}",
                    "2690": "",
                    "2691": "\tpkt = context_alloc_pkt(context, family, len, PKT_WAIT_TIME);",
                    "2692": "\tif (!pkt) {",
                    "2693": "\t\tNET_ERR(\"Failed to allocate net_pkt\");",
                    "2694": "\t\treturn -ENOBUFS;",
                    "2695": "\t}",
                    "2696": "",
                    "2697": "\ttmp_len = net_pkt_available_payload_buffer(",
                    "2698": "\t\t\t\tpkt, net_context_get_proto(context));",
                    "2699": "\tif (tmp_len < len) {",
                    "2700": "\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM ||",
                    "2701": "\t\t    net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2702": "\t\t\tNET_ERR(\"Available payload buffer (%zu) is not enough for requested DGRAM (%zu)\",",
                    "2703": "\t\t\t\ttmp_len, len);",
                    "2704": "\t\t\tret = -ENOMEM;",
                    "2705": "\t\t\tgoto fail;",
                    "2706": "\t\t}",
                    "2707": "\t\tlen = tmp_len;",
                    "2708": "\t}",
                    "2709": "",
                    "2710": "\tif (IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {",
                    "2711": "\t\tuint8_t priority;",
                    "2712": "",
                    "2713": "\t\tget_context_priority(context, &priority, NULL);",
                    "2714": "\t\tnet_pkt_set_priority(pkt, priority);",
                    "2715": "\t}",
                    "2716": "",
                    "2717": "\t/* If there is ancillary data in msghdr, then we need to add that",
                    "2718": "\t * to net_pkt as there is no other way to store it.",
                    "2719": "\t */",
                    "2720": "\tif (msghdr && msghdr->msg_control && msghdr->msg_controllen) {",
                    "2721": "\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_TXTIME)) {",
                    "2722": "\t\t\tint is_txtime;",
                    "2723": "",
                    "2724": "\t\t\tget_context_txtime(context, &is_txtime, NULL);",
                    "2725": "\t\t\tif (is_txtime) {",
                    "2726": "\t\t\t\tset_pkt_txtime(pkt, msghdr);",
                    "2727": "\t\t\t}",
                    "2728": "\t\t}",
                    "2729": "",
                    "2730": "\t\tset_pkt_hoplimit(pkt, msghdr);",
                    "2731": "",
                    "2732": "\t}",
                    "2733": "",
                    "2734": "skip_alloc:",
                    "2735": "\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&",
                    "2736": "\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {",
                    "2737": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2738": "\t\tif (ret < 0) {",
                    "2739": "\t\t\tgoto fail;",
                    "2740": "\t\t}",
                    "2741": "",
                    "2742": "\t\tnet_pkt_cursor_init(pkt);",
                    "2743": "",
                    "2744": "\t\tif (sendto) {",
                    "2745": "\t\t\tret = net_offload_sendto(net_context_get_iface(context),",
                    "2746": "\t\t\t\t\t\t pkt, dst_addr, addrlen, cb,",
                    "2747": "\t\t\t\t\t\t timeout, user_data);",
                    "2748": "\t\t} else {",
                    "2749": "\t\t\tret = net_offload_send(net_context_get_iface(context),",
                    "2750": "\t\t\t\t\t       pkt, cb, timeout, user_data);",
                    "2751": "\t\t}",
                    "2752": "\t} else if (((IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) ||",
                    "2753": "\t\t    (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6)) &&",
                    "2754": "\t\t   IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&",
                    "2755": "\t\t   net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2756": "\t\tret = context_setup_raw_ip_packet(family, pkt, buf, len, msghdr);",
                    "2757": "\t\tif (ret < 0) {",
                    "2758": "\t\t\tgoto fail;",
                    "2759": "\t\t}",
                    "2760": "",
                    "2761": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2762": "\t} else if (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2763": "\t    net_context_get_proto(context) == NET_IPPROTO_UDP) {",
                    "2764": "\t\tret = context_setup_udp_packet(context, family, pkt, buf, len, msghdr,",
                    "2765": "\t\t\t\t\t       dst_addr, addrlen);",
                    "2766": "\t\tif (ret < 0) {",
                    "2767": "\t\t\tgoto fail;",
                    "2768": "\t\t}",
                    "2769": "",
                    "2770": "\t\tcontext_finalize_packet(context, family, pkt);",
                    "2771": "",
                    "2772": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2773": "\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "2774": "\t\t   net_context_get_proto(context) == NET_IPPROTO_TCP) {",
                    "2775": "",
                    "2776": "\t\tret = net_tcp_queue(context, buf, len, msghdr);",
                    "2777": "\t\tif (ret < 0) {",
                    "2778": "\t\t\tgoto fail;",
                    "2779": "\t\t}",
                    "2780": "",
                    "2781": "\t\tlen = ret;",
                    "2782": "",
                    "2783": "\t\tret = net_tcp_send_data(context, cb, user_data);",
                    "2784": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {",
                    "2785": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2786": "\t\tif (ret < 0) {",
                    "2787": "\t\t\tgoto fail;",
                    "2788": "\t\t}",
                    "2789": "",
                    "2790": "\t\tnet_pkt_cursor_init(pkt);",
                    "2791": "",
                    "2792": "\t\tstruct net_sockaddr_ll_ptr *ll_src_addr;",
                    "2793": "\t\tstruct net_sockaddr_ll *ll_dst_addr;",
                    "2794": "",
                    "2795": "\t\t/* The destination address is set in remote for this",
                    "2796": "\t\t * socket type.",
                    "2797": "\t\t */",
                    "2798": "\t\tll_dst_addr = (struct net_sockaddr_ll *)&context->remote;",
                    "2799": "\t\tll_src_addr = (struct net_sockaddr_ll_ptr *)&context->local;",
                    "2800": "",
                    "2801": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),",
                    "2802": "\t\t\t\t       ll_dst_addr->sll_addr,",
                    "2803": "\t\t\t\t       sizeof(struct net_eth_addr));",
                    "2804": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_src(pkt),",
                    "2805": "\t\t\t\t       ll_src_addr->sll_addr,",
                    "2806": "\t\t\t\t       sizeof(struct net_eth_addr));",
                    "2807": "",
                    "2808": "\t\tnet_pkt_set_ll_proto_type(pkt, net_ntohs(ll_dst_addr->sll_protocol));",
                    "2809": "",
                    "2810": "\t\tnet_if_try_queue_tx(net_pkt_iface(pkt), pkt, timeout);",
                    "2811": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN &&",
                    "2812": "\t\t   net_context_get_proto(context) == NET_CAN_RAW) {",
                    "2813": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2814": "\t\tif (ret < 0) {",
                    "2815": "\t\t\tgoto fail;",
                    "2816": "\t\t}",
                    "2817": "",
                    "2818": "\t\tnet_pkt_cursor_init(pkt);",
                    "2819": "",
                    "2820": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2821": "\t} else {",
                    "2822": "\t\tNET_DBG(\"Unknown protocol while sending packet: %d\",",
                    "2823": "\t\tnet_context_get_proto(context));",
                    "2824": "\t\tret = -EPROTONOSUPPORT;",
                    "2825": "\t}",
                    "2826": "",
                    "2827": "\tif (ret < 0) {",
                    "2828": "\t\tgoto fail;",
                    "2829": "\t}",
                    "2830": "",
                    "2831": "\treturn len;",
                    "2832": "fail:",
                    "2833": "\tif (pkt != NULL) {",
                    "2834": "\t\tnet_pkt_unref(pkt);",
                    "2835": "\t}",
                    "2836": "",
                    "2837": "\treturn ret;",
                    "2838": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_pkt_hoplimit": {
            "name": "set_pkt_hoplimit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2345,
            "function_content": [
                "/* This function is meant to be temporary: once all moved to new\n* API, it will be up to net_send_data() to finalize the packet.\n*/\nstatic void set_pkt_hoplimit(struct net_pkt *pkt, const struct net_msghdr *msg_hdr)\n{\n\tstruct net_cmsghdr *cmsg;\n\tconst struct net_sockaddr_in6 *addr6 = NULL;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) && IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\taddr6 = msg_hdr->msg_name;\n\t}\n\n\tfor (cmsg = NET_CMSG_FIRSTHDR(msg_hdr); cmsg != NULL;\n\t     cmsg = NET_CMSG_NXTHDR(msg_hdr, cmsg)) {\n\t\tif (net_pkt_family(pkt) == NET_AF_INET6) {\n\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&\n\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {\n\t\t\t\tnet_pkt_set_ipv6_hop_limit(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (net_pkt_family(pkt) == NET_AF_INET) {\n\t\t\tif (addr6  == NULL ||\n\t\t\t    (addr6 != NULL && !net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr))) {\n\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IP &&\n\t\t\t\t    cmsg->cmsg_type == ZSOCK_IP_TTL) {\n\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (addr6 != NULL &&\n\t\t\t\t   net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {\n\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&\n\t\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {\n\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
                {
                    "2345": "static void set_pkt_hoplimit(struct net_pkt *pkt, const struct net_msghdr *msg_hdr)",
                    "2346": "{",
                    "2347": "\tstruct net_cmsghdr *cmsg;",
                    "2348": "\tconst struct net_sockaddr_in6 *addr6 = NULL;",
                    "2349": "",
                    "2350": "\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) && IS_ENABLED(CONFIG_NET_IPV6)) {",
                    "2351": "\t\taddr6 = msg_hdr->msg_name;",
                    "2352": "\t}",
                    "2353": "",
                    "2354": "\tfor (cmsg = NET_CMSG_FIRSTHDR(msg_hdr); cmsg != NULL;",
                    "2355": "\t     cmsg = NET_CMSG_NXTHDR(msg_hdr, cmsg)) {",
                    "2356": "\t\tif (net_pkt_family(pkt) == NET_AF_INET6) {",
                    "2357": "\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2358": "\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&",
                    "2359": "\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {",
                    "2360": "\t\t\t\tnet_pkt_set_ipv6_hop_limit(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2361": "\t\t\t\tbreak;",
                    "2362": "\t\t\t}",
                    "2363": "\t\t} else if (net_pkt_family(pkt) == NET_AF_INET) {",
                    "2364": "\t\t\tif (addr6  == NULL ||",
                    "2365": "\t\t\t    (addr6 != NULL && !net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr))) {",
                    "2366": "\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2367": "\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IP &&",
                    "2368": "\t\t\t\t    cmsg->cmsg_type == ZSOCK_IP_TTL) {",
                    "2369": "\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2370": "\t\t\t\t\tbreak;",
                    "2371": "\t\t\t\t}",
                    "2372": "\t\t\t} else if (addr6 != NULL &&",
                    "2373": "\t\t\t\t   net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {",
                    "2374": "\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2375": "\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&",
                    "2376": "\t\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {",
                    "2377": "\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2378": "\t\t\t\t\tbreak;",
                    "2379": "\t\t\t\t}",
                    "2380": "\t\t\t}",
                    "2381": "\t\t}",
                    "2382": "\t}",
                    "2383": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_context_unicast_hop_limit": {
            "name": "get_context_unicast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1864,
            "function_content": [
                "ret = -EINVAL; /* Not IPv4 or IPv6 */\nstatic int get_context_unicast_hop_limit(struct net_context *context,\n\t\t\t\t\t void *value, uint32_t *len)\n{\n#if defined(CONFIG_NET_IPV6)\n\t*((int *)value) = context->ipv6_hop_limit;\n\n\tif (len) {\n\t\t*len = sizeof(int);\n\t}\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "1864": "static int get_context_unicast_hop_limit(struct net_context *context,",
                    "1865": "\t\t\t\t\t void *value, uint32_t *len)",
                    "1866": "{",
                    "1867": "#if defined(CONFIG_NET_IPV6)",
                    "1868": "\t*((int *)value) = context->ipv6_hop_limit;",
                    "1869": "",
                    "1870": "\tif (len) {",
                    "1871": "\t\t*len = sizeof(int);",
                    "1872": "\t}",
                    "1873": "",
                    "1874": "\treturn 0;",
                    "1875": "#else",
                    "1876": "\tARG_UNUSED(context);",
                    "1877": "\tARG_UNUSED(value);",
                    "1878": "\tARG_UNUSED(len);",
                    "1879": "",
                    "1880": "\treturn -ENOTSUP;",
                    "1881": "#endif",
                    "1882": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_context_mcast_hop_limit": {
            "name": "get_context_mcast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1844,
            "function_content": [
                "ret = -EINVAL; /* Not IPv4 or IPv6 */\nstatic int get_context_mcast_hop_limit(struct net_context *context,\n\t\t\t\t       void *value, uint32_t *len)\n{\n#if defined(CONFIG_NET_IPV6)\n\t*((int *)value) = context->ipv6_mcast_hop_limit;\n\n\tif (len) {\n\t\t*len = sizeof(int);\n\t}\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "1844": "static int get_context_mcast_hop_limit(struct net_context *context,",
                    "1845": "\t\t\t\t       void *value, uint32_t *len)",
                    "1846": "{",
                    "1847": "#if defined(CONFIG_NET_IPV6)",
                    "1848": "\t*((int *)value) = context->ipv6_mcast_hop_limit;",
                    "1849": "",
                    "1850": "\tif (len) {",
                    "1851": "\t\t*len = sizeof(int);",
                    "1852": "\t}",
                    "1853": "",
                    "1854": "\treturn 0;",
                    "1855": "#else",
                    "1856": "\tARG_UNUSED(context);",
                    "1857": "\tARG_UNUSED(value);",
                    "1858": "\tARG_UNUSED(len);",
                    "1859": "",
                    "1860": "\treturn -ENOTSUP;",
                    "1861": "#endif",
                    "1862": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "check_used_port": {
            "name": "check_used_port",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 184,
            "function_content": [
                "/* We need to lock the contexts array as these APIs are typically called\n* from applications which are usually run in task context.\n*/\nstatic int check_used_port(struct net_context *context,\n\t\t\t   struct net_if *iface,\n\t\t\t   enum net_ip_protocol proto,\n\t\t\t   uint16_t local_port,\n\t\t\t   const struct net_sockaddr *local_addr,\n\t\t\t   bool reuseaddr_set,\n\t\t\t   bool reuseport_set,\n\t\t\t   bool check_port_range)\n{\n\tint i;\n\n\tfor (i = 0; i < NET_MAX_CONTEXT; i++) {\n\t\tif (!net_context_is_used(&contexts[i])) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (context != NULL && context == &contexts[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(net_context_get_proto(&contexts[i]) == proto &&\n\t\t      net_sin((struct net_sockaddr *)&\n\t\t\t      contexts[i].local)->sin_port == local_port)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_context_is_bound_to_iface(&contexts[i])) {\n\t\t\tif (iface != NULL && iface != net_context_get_iface(&contexts[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t    local_addr->sa_family == NET_AF_INET6) {\n\t\t\tif (net_sin6_ptr(&contexts[i].local)->sin6_addr == NULL ||\n\t\t\t    net_sin6_ptr(&contexts[i].local)->sin6_family != NET_AF_INET6) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((net_ipv6_is_addr_unspecified(\n\t\t\t\t\tnet_sin6_ptr(&contexts[i].local)->sin6_addr) ||\n\t\t\t     net_ipv6_is_addr_unspecified(\n\t\t\t\t\t&net_sin6(local_addr)->sin6_addr))) {\n\t\t\t\tif (reuseport_set &&\n\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {\n\t\t\t\t\t/* When both context have the REUSEPORT set, both\n\t\t\t\t\t * may be unspecified.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reuseaddr_set &&\n\t\t\t\t\t   !is_in_tcp_listen_state(&contexts[i]) &&\n\t\t\t\t\t   !(net_ipv6_is_addr_unspecified(\n\t\t\t\t\t\tnet_sin6_ptr(&contexts[i].local)->sin6_addr) &&\n\t\t\t\t\t     net_ipv6_is_addr_unspecified(\n\t\t\t\t\t\t&net_sin6(local_addr)->sin6_addr))) {\n\t\t\t\t\t/* In case of REUSEADDR, only one context may be\n\t\t\t\t\t * bound to the unspecified address, but not both.\n\t\t\t\t\t * Furthermore, in case the existing context is in\n\t\t\t\t\t * TCP LISTEN state, we ignore the REUSEADDR option\n\t\t\t\t\t * (Linux behavior).\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (net_ipv6_addr_cmp(\n\t\t\t\t    net_sin6_ptr(&contexts[i].local)->\n\t\t\t\t\t\t\t     sin6_addr,\n\t\t\t\t    &((struct net_sockaddr_in6 *)\n\t\t\t\t      local_addr)->sin6_addr)) {\n\t\t\t\tif (reuseport_set &&\n\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {\n\t\t\t\t\t/* When both context have the REUSEPORT set, both\n\t\t\t\t\t * may be bound to exactly the same address.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reuseaddr_set &&\n\t\t\t\t\t   is_in_tcp_time_wait_state(&contexts[i])) {\n\t\t\t\t\t/* With REUSEADDR, the existing context must be\n\t\t\t\t\t * in the TCP TIME_WAIT state.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t\t   local_addr->sa_family == NET_AF_INET) {\n\t\t\t/* If there is an IPv6 socket already bound and\n\t\t\t * if v6only option is enabled, then it is possible to\n\t\t\t * bind IPv4 address to it.\n\t\t\t */\n\t\t\tif (net_sin_ptr(&contexts[i].local)->sin_addr == NULL ||\n\t\t\t    ((IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) ?\n\t\t\t      net_context_is_v6only_set(&contexts[i]) : true) &&\n\t\t\t     net_sin_ptr(&contexts[i].local)->sin_family != NET_AF_INET)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((net_ipv4_is_addr_unspecified(\n\t\t\t\t\tnet_sin_ptr(&contexts[i].local)->sin_addr) ||\n\t\t\t     net_ipv4_is_addr_unspecified(\n\t\t\t\t\t&net_sin(local_addr)->sin_addr))) {\n\t\t\t\tif (reuseport_set &&\n\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {\n\t\t\t\t\t/* When both context have the REUSEPORT set, both\n\t\t\t\t\t * may be unspecified.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reuseaddr_set &&\n\t\t\t\t\t   !is_in_tcp_listen_state(&contexts[i]) &&\n\t\t\t\t\t   !(net_ipv4_is_addr_unspecified(\n\t\t\t\t\t\tnet_sin_ptr(&contexts[i].local)->sin_addr) &&\n\t\t\t\t\t     net_ipv4_is_addr_unspecified(\n\t\t\t\t\t\t&net_sin(local_addr)->sin_addr))) {\n\t\t\t\t\t/* In case of REUSEADDR, only one context may be\n\t\t\t\t\t * bound to the unspecified address, but not both.\n\t\t\t\t\t * Furthermore, in case the existing context is in\n\t\t\t\t\t * TCP LISTEN state, we ignore the REUSEADDR option\n\t\t\t\t\t * (Linux behavior).\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (net_ipv4_addr_cmp(\n\t\t\t\t    net_sin_ptr(&contexts[i].local)->\n\t\t\t\t\t\t\t      sin_addr,\n\t\t\t\t    &((struct net_sockaddr_in *)\n\t\t\t\t      local_addr)->sin_addr)) {\n\t\t\t\tif (reuseport_set &&\n\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {\n\t\t\t\t\t/* When both context have the REUSEPORT set, both\n\t\t\t\t\t * may be bound to exactly the same address.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reuseaddr_set &&\n\t\t\t\t\t   is_in_tcp_time_wait_state(&contexts[i])) {\n\t\t\t\t\t/* With REUSEADDR, the existing context must be\n\t\t\t\t\t * in the TCP TIME_WAIT state.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make sure that if the port range is active, the port is\n\t * within the range.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE) && check_port_range) {\n\t\tuint16_t upper, lower;\n\n\t\tupper = COND_CODE_1(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE,\n\t\t\t\t    (context->options.port_range >> 16),\n\t\t\t\t    (0));\n\t\tlower = COND_CODE_1(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE,\n\t\t\t\t    (context->options.port_range & 0xffff),\n\t\t\t\t    (0));\n\n\t\tif (upper != 0 && lower != 0 && lower < upper) {\n\t\t\tif (net_ntohs(local_port) < lower || net_ntohs(local_port) > upper) {\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
                {
                    "184": "static int check_used_port(struct net_context *context,",
                    "185": "\t\t\t   struct net_if *iface,",
                    "186": "\t\t\t   enum net_ip_protocol proto,",
                    "187": "\t\t\t   uint16_t local_port,",
                    "188": "\t\t\t   const struct net_sockaddr *local_addr,",
                    "189": "\t\t\t   bool reuseaddr_set,",
                    "190": "\t\t\t   bool reuseport_set,",
                    "191": "\t\t\t   bool check_port_range)",
                    "192": "{",
                    "193": "\tint i;",
                    "194": "",
                    "195": "\tfor (i = 0; i < NET_MAX_CONTEXT; i++) {",
                    "196": "\t\tif (!net_context_is_used(&contexts[i])) {",
                    "197": "\t\t\tcontinue;",
                    "198": "\t\t}",
                    "199": "",
                    "200": "\t\tif (context != NULL && context == &contexts[i]) {",
                    "201": "\t\t\tcontinue;",
                    "202": "\t\t}",
                    "203": "",
                    "204": "\t\tif (!(net_context_get_proto(&contexts[i]) == proto &&",
                    "205": "\t\t      net_sin((struct net_sockaddr *)&",
                    "206": "\t\t\t      contexts[i].local)->sin_port == local_port)) {",
                    "207": "\t\t\tcontinue;",
                    "208": "\t\t}",
                    "209": "",
                    "210": "\t\tif (net_context_is_bound_to_iface(&contexts[i])) {",
                    "211": "\t\t\tif (iface != NULL && iface != net_context_get_iface(&contexts[i])) {",
                    "212": "\t\t\t\tcontinue;",
                    "213": "\t\t\t}",
                    "214": "\t\t}",
                    "215": "",
                    "216": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "217": "\t\t    local_addr->sa_family == NET_AF_INET6) {",
                    "218": "\t\t\tif (net_sin6_ptr(&contexts[i].local)->sin6_addr == NULL ||",
                    "219": "\t\t\t    net_sin6_ptr(&contexts[i].local)->sin6_family != NET_AF_INET6) {",
                    "220": "\t\t\t\tcontinue;",
                    "221": "\t\t\t}",
                    "222": "",
                    "223": "\t\t\tif ((net_ipv6_is_addr_unspecified(",
                    "224": "\t\t\t\t\tnet_sin6_ptr(&contexts[i].local)->sin6_addr) ||",
                    "225": "\t\t\t     net_ipv6_is_addr_unspecified(",
                    "226": "\t\t\t\t\t&net_sin6(local_addr)->sin6_addr))) {",
                    "227": "\t\t\t\tif (reuseport_set &&",
                    "228": "\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {",
                    "229": "\t\t\t\t\t/* When both context have the REUSEPORT set, both",
                    "230": "\t\t\t\t\t * may be unspecified.",
                    "231": "\t\t\t\t\t */",
                    "232": "\t\t\t\t\tcontinue;",
                    "233": "\t\t\t\t} else if (reuseaddr_set &&",
                    "234": "\t\t\t\t\t   !is_in_tcp_listen_state(&contexts[i]) &&",
                    "235": "\t\t\t\t\t   !(net_ipv6_is_addr_unspecified(",
                    "236": "\t\t\t\t\t\tnet_sin6_ptr(&contexts[i].local)->sin6_addr) &&",
                    "237": "\t\t\t\t\t     net_ipv6_is_addr_unspecified(",
                    "238": "\t\t\t\t\t\t&net_sin6(local_addr)->sin6_addr))) {",
                    "239": "\t\t\t\t\t/* In case of REUSEADDR, only one context may be",
                    "240": "\t\t\t\t\t * bound to the unspecified address, but not both.",
                    "241": "\t\t\t\t\t * Furthermore, in case the existing context is in",
                    "242": "\t\t\t\t\t * TCP LISTEN state, we ignore the REUSEADDR option",
                    "243": "\t\t\t\t\t * (Linux behavior).",
                    "244": "\t\t\t\t\t */",
                    "245": "\t\t\t\t\tcontinue;",
                    "246": "\t\t\t\t} else {",
                    "247": "\t\t\t\t\treturn -EEXIST;",
                    "248": "\t\t\t\t}",
                    "249": "\t\t\t}",
                    "250": "",
                    "251": "\t\t\tif (net_ipv6_addr_cmp(",
                    "252": "\t\t\t\t    net_sin6_ptr(&contexts[i].local)->",
                    "253": "\t\t\t\t\t\t\t     sin6_addr,",
                    "254": "\t\t\t\t    &((struct net_sockaddr_in6 *)",
                    "255": "\t\t\t\t      local_addr)->sin6_addr)) {",
                    "256": "\t\t\t\tif (reuseport_set &&",
                    "257": "\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {",
                    "258": "\t\t\t\t\t/* When both context have the REUSEPORT set, both",
                    "259": "\t\t\t\t\t * may be bound to exactly the same address.",
                    "260": "\t\t\t\t\t */",
                    "261": "\t\t\t\t\tcontinue;",
                    "262": "\t\t\t\t} else if (reuseaddr_set &&",
                    "263": "\t\t\t\t\t   is_in_tcp_time_wait_state(&contexts[i])) {",
                    "264": "\t\t\t\t\t/* With REUSEADDR, the existing context must be",
                    "265": "\t\t\t\t\t * in the TCP TIME_WAIT state.",
                    "266": "\t\t\t\t\t */",
                    "267": "\t\t\t\t\tcontinue;",
                    "268": "\t\t\t\t} else {",
                    "269": "\t\t\t\t\treturn -EEXIST;",
                    "270": "\t\t\t\t}",
                    "271": "\t\t\t}",
                    "272": "\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "273": "\t\t\t   local_addr->sa_family == NET_AF_INET) {",
                    "274": "\t\t\t/* If there is an IPv6 socket already bound and",
                    "275": "\t\t\t * if v6only option is enabled, then it is possible to",
                    "276": "\t\t\t * bind IPv4 address to it.",
                    "277": "\t\t\t */",
                    "278": "\t\t\tif (net_sin_ptr(&contexts[i].local)->sin_addr == NULL ||",
                    "279": "\t\t\t    ((IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) ?",
                    "280": "\t\t\t      net_context_is_v6only_set(&contexts[i]) : true) &&",
                    "281": "\t\t\t     net_sin_ptr(&contexts[i].local)->sin_family != NET_AF_INET)) {",
                    "282": "\t\t\t\tcontinue;",
                    "283": "\t\t\t}",
                    "284": "",
                    "285": "\t\t\tif ((net_ipv4_is_addr_unspecified(",
                    "286": "\t\t\t\t\tnet_sin_ptr(&contexts[i].local)->sin_addr) ||",
                    "287": "\t\t\t     net_ipv4_is_addr_unspecified(",
                    "288": "\t\t\t\t\t&net_sin(local_addr)->sin_addr))) {",
                    "289": "\t\t\t\tif (reuseport_set &&",
                    "290": "\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {",
                    "291": "\t\t\t\t\t/* When both context have the REUSEPORT set, both",
                    "292": "\t\t\t\t\t * may be unspecified.",
                    "293": "\t\t\t\t\t */",
                    "294": "\t\t\t\t\tcontinue;",
                    "295": "\t\t\t\t} else if (reuseaddr_set &&",
                    "296": "\t\t\t\t\t   !is_in_tcp_listen_state(&contexts[i]) &&",
                    "297": "\t\t\t\t\t   !(net_ipv4_is_addr_unspecified(",
                    "298": "\t\t\t\t\t\tnet_sin_ptr(&contexts[i].local)->sin_addr) &&",
                    "299": "\t\t\t\t\t     net_ipv4_is_addr_unspecified(",
                    "300": "\t\t\t\t\t\t&net_sin(local_addr)->sin_addr))) {",
                    "301": "\t\t\t\t\t/* In case of REUSEADDR, only one context may be",
                    "302": "\t\t\t\t\t * bound to the unspecified address, but not both.",
                    "303": "\t\t\t\t\t * Furthermore, in case the existing context is in",
                    "304": "\t\t\t\t\t * TCP LISTEN state, we ignore the REUSEADDR option",
                    "305": "\t\t\t\t\t * (Linux behavior).",
                    "306": "\t\t\t\t\t */",
                    "307": "\t\t\t\t\tcontinue;",
                    "308": "\t\t\t\t} else {",
                    "309": "\t\t\t\t\treturn -EEXIST;",
                    "310": "\t\t\t\t}",
                    "311": "\t\t\t}",
                    "312": "",
                    "313": "\t\t\tif (net_ipv4_addr_cmp(",
                    "314": "\t\t\t\t    net_sin_ptr(&contexts[i].local)->",
                    "315": "\t\t\t\t\t\t\t      sin_addr,",
                    "316": "\t\t\t\t    &((struct net_sockaddr_in *)",
                    "317": "\t\t\t\t      local_addr)->sin_addr)) {",
                    "318": "\t\t\t\tif (reuseport_set &&",
                    "319": "\t\t\t\t    net_context_is_reuseport_set(&contexts[i])) {",
                    "320": "\t\t\t\t\t/* When both context have the REUSEPORT set, both",
                    "321": "\t\t\t\t\t * may be bound to exactly the same address.",
                    "322": "\t\t\t\t\t */",
                    "323": "\t\t\t\t\tcontinue;",
                    "324": "\t\t\t\t} else if (reuseaddr_set &&",
                    "325": "\t\t\t\t\t   is_in_tcp_time_wait_state(&contexts[i])) {",
                    "326": "\t\t\t\t\t/* With REUSEADDR, the existing context must be",
                    "327": "\t\t\t\t\t * in the TCP TIME_WAIT state.",
                    "328": "\t\t\t\t\t */",
                    "329": "\t\t\t\t\tcontinue;",
                    "330": "\t\t\t\t} else {",
                    "331": "\t\t\t\t\treturn -EEXIST;",
                    "332": "\t\t\t\t}",
                    "333": "\t\t\t}",
                    "334": "\t\t}",
                    "335": "\t}",
                    "336": "",
                    "337": "\t/* Make sure that if the port range is active, the port is",
                    "338": "\t * within the range.",
                    "339": "\t */",
                    "340": "\tif (IS_ENABLED(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE) && check_port_range) {",
                    "341": "\t\tuint16_t upper, lower;",
                    "342": "",
                    "343": "\t\tupper = COND_CODE_1(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE,",
                    "344": "\t\t\t\t    (context->options.port_range >> 16),",
                    "345": "\t\t\t\t    (0));",
                    "346": "\t\tlower = COND_CODE_1(CONFIG_NET_CONTEXT_CLAMP_PORT_RANGE,",
                    "347": "\t\t\t\t    (context->options.port_range & 0xffff),",
                    "348": "\t\t\t\t    (0));",
                    "349": "",
                    "350": "\t\tif (upper != 0 && lower != 0 && lower < upper) {",
                    "351": "\t\t\tif (net_ntohs(local_port) < lower || net_ntohs(local_port) > upper) {",
                    "352": "\t\t\t\treturn -ERANGE;",
                    "353": "\t\t\t}",
                    "354": "\t\t}",
                    "355": "\t}",
                    "356": "",
                    "357": "\treturn 0;",
                    "358": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_queue_rx": {
            "name": "net_queue_rx",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_core.c",
            "location_line": 520,
            "function_content": [
                "/* The pkt might contain garbage already after the call to\n* net_if_try_send_data(), so do not use pkt after that call.\n* Remember the iface and family for statistics update.\n*/\nstatic void net_queue_rx(struct net_if *iface, struct net_pkt *pkt)\n{\n\tsize_t len = net_pkt_get_len(pkt);\n\tuint8_t prio = net_pkt_priority(pkt);\n\tuint8_t tc = net_rx_priority2tc(prio);\n\n#if NET_TC_RX_COUNT > 1\n\tNET_DBG(\"TC %d with prio %d pkt %p\", tc, prio, pkt);\n#endif\n\tif (net_tc_rx_is_immediate(tc, prio)) {\n\t\tnet_process_rx_packet(pkt);\n\t} else {\n\t\tif (net_tc_submit_to_rx_queue(tc, pkt) != NET_OK) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_stats_update_tc_recv_pkt(iface, tc);\n\tnet_stats_update_tc_recv_bytes(iface, tc, len);\n\tnet_stats_update_tc_recv_priority(iface, tc, prio);\n\treturn;\n\ndrop:\n\tnet_pkt_unref(pkt);\n\tnet_stats_update_tc_recv_dropped(iface, tc);\n\treturn;\n}\n",
                {
                    "520": "static void net_queue_rx(struct net_if *iface, struct net_pkt *pkt)",
                    "521": "{",
                    "522": "\tsize_t len = net_pkt_get_len(pkt);",
                    "523": "\tuint8_t prio = net_pkt_priority(pkt);",
                    "524": "\tuint8_t tc = net_rx_priority2tc(prio);",
                    "525": "",
                    "526": "#if NET_TC_RX_COUNT > 1",
                    "527": "\tNET_DBG(\"TC %d with prio %d pkt %p\", tc, prio, pkt);",
                    "528": "#endif",
                    "529": "\tif (net_tc_rx_is_immediate(tc, prio)) {",
                    "530": "\t\tnet_process_rx_packet(pkt);",
                    "531": "\t} else {",
                    "532": "\t\tif (net_tc_submit_to_rx_queue(tc, pkt) != NET_OK) {",
                    "533": "\t\t\tgoto drop;",
                    "534": "\t\t}",
                    "535": "\t}",
                    "536": "",
                    "537": "\tnet_stats_update_tc_recv_pkt(iface, tc);",
                    "538": "\tnet_stats_update_tc_recv_bytes(iface, tc, len);",
                    "539": "\tnet_stats_update_tc_recv_priority(iface, tc, prio);",
                    "540": "\treturn;",
                    "541": "",
                    "542": "drop:",
                    "543": "\tnet_pkt_unref(pkt);",
                    "544": "\tnet_stats_update_tc_recv_dropped(iface, tc);",
                    "545": "\treturn;",
                    "546": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_rx": {
            "name": "net_rx",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_core.c",
            "location_line": 485,
            "function_content": [
                "/* The pkt might contain garbage already after the call to\n* net_if_try_send_data(), so do not use pkt after that call.\n* Remember the iface and family for statistics update.\n*/\nstatic void net_rx(struct net_if *iface, struct net_pkt *pkt)\n{\n\tsize_t pkt_len;\n\n\tpkt_len = net_pkt_get_len(pkt);\n\n\tNET_DBG(\"Received pkt %p len %zu\", pkt, pkt_len);\n\n\tnet_stats_update_bytes_recv(iface, pkt_len);\n\tconn_mgr_if_used(iface);\n\n\tif (IS_ENABLED(CONFIG_NET_LOOPBACK)) {\n#ifdef CONFIG_NET_L2_DUMMY\n\t\tif (net_if_l2(iface) == &NET_L2_GET_NAME(DUMMY)) {\n\t\t\tnet_pkt_set_loopback(pkt, true);\n\t\t\tnet_pkt_set_l2_processed(pkt, true);\n\t\t}\n#endif\n\t}\n\n\tprocessing_data(pkt);\n\n\tnet_print_statistics();\n\tnet_pkt_print();\n}\n",
                {
                    "485": "static void net_rx(struct net_if *iface, struct net_pkt *pkt)",
                    "486": "{",
                    "487": "\tsize_t pkt_len;",
                    "488": "",
                    "489": "\tpkt_len = net_pkt_get_len(pkt);",
                    "490": "",
                    "491": "\tNET_DBG(\"Received pkt %p len %zu\", pkt, pkt_len);",
                    "492": "",
                    "493": "\tnet_stats_update_bytes_recv(iface, pkt_len);",
                    "494": "\tconn_mgr_if_used(iface);",
                    "495": "",
                    "496": "\tif (IS_ENABLED(CONFIG_NET_LOOPBACK)) {",
                    "497": "#ifdef CONFIG_NET_L2_DUMMY",
                    "498": "\t\tif (net_if_l2(iface) == &NET_L2_GET_NAME(DUMMY)) {",
                    "499": "\t\t\tnet_pkt_set_loopback(pkt, true);",
                    "500": "\t\t\tnet_pkt_set_l2_processed(pkt, true);",
                    "501": "\t\t}",
                    "502": "#endif",
                    "503": "\t}",
                    "504": "",
                    "505": "\tprocessing_data(pkt);",
                    "506": "",
                    "507": "\tnet_print_statistics();",
                    "508": "\tnet_pkt_print();",
                    "509": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "processing_data": {
            "name": "processing_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_core.c",
            "location_line": 134,
            "function_content": [
                "/* IP version and header length. */\nstatic void processing_data(struct net_pkt *pkt)\n{\nagain:\n\tswitch (process_data(pkt)) {\n\tcase NET_CONTINUE:\n\t\tif (IS_ENABLED(CONFIG_NET_L2_VIRTUAL)) {\n\t\t\t/* If we have a tunneling packet, feed it back\n\t\t\t * to the stack in this case.\n\t\t\t */\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tNET_DBG(\"Dropping pkt %p\", pkt);\n\t\t\tnet_pkt_unref(pkt);\n\t\t}\n\t\tbreak;\n\tcase NET_OK:\n\t\tNET_DBG(\"Consumed pkt %p\", pkt);\n\t\tbreak;\n\tcase NET_DROP:\n\tdefault:\n\t\tNET_DBG(\"Dropping pkt %p\", pkt);\n\t\tnet_pkt_unref(pkt);\n\t\tbreak;\n\t}\n}\n",
                {
                    "134": "static void processing_data(struct net_pkt *pkt)",
                    "135": "{",
                    "136": "again:",
                    "137": "\tswitch (process_data(pkt)) {",
                    "138": "\tcase NET_CONTINUE:",
                    "139": "\t\tif (IS_ENABLED(CONFIG_NET_L2_VIRTUAL)) {",
                    "140": "\t\t\t/* If we have a tunneling packet, feed it back",
                    "141": "\t\t\t * to the stack in this case.",
                    "142": "\t\t\t */",
                    "143": "\t\t\tgoto again;",
                    "144": "\t\t} else {",
                    "145": "\t\t\tNET_DBG(\"Dropping pkt %p\", pkt);",
                    "146": "\t\t\tnet_pkt_unref(pkt);",
                    "147": "\t\t}",
                    "148": "\t\tbreak;",
                    "149": "\tcase NET_OK:",
                    "150": "\t\tNET_DBG(\"Consumed pkt %p\", pkt);",
                    "151": "\t\tbreak;",
                    "152": "\tcase NET_DROP:",
                    "153": "\tdefault:",
                    "154": "\t\tNET_DBG(\"Dropping pkt %p\", pkt);",
                    "155": "\t\tnet_pkt_unref(pkt);",
                    "156": "\t\tbreak;",
                    "157": "\t}",
                    "158": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "remove_ipv6_ifaddr": {
            "name": "remove_ipv6_ifaddr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 5346,
            "function_content": [
                "#endif /* CONFIG_NET_TEST */\nstatic void remove_ipv6_ifaddr(struct net_if *iface,\n\t\t\t       struct net_if_addr *ifaddr,\n\t\t\t       unsigned int maddr_count)\n{\n\tstruct net_if_ipv6 *ipv6;\n\n\tnet_if_lock(iface);\n\n\tipv6 = COND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tif (!ifaddr->is_infinite) {\n\t\tk_mutex_lock(&lock, K_FOREVER);\n\n#if defined(CONFIG_NET_NATIVE_IPV6)\n\t\tsys_slist_find_and_remove(&active_address_lifetime_timers,\n\t\t\t\t\t  &ifaddr->lifetime.node);\n\n\t\tif (sys_slist_is_empty(&active_address_lifetime_timers)) {\n\t\t\tk_work_cancel_delayable(&address_lifetime_timer);\n\t\t}\n#endif\n\t\tk_mutex_unlock(&lock);\n\t}\n\n#if defined(CONFIG_NET_IPV6_DAD)\n\tif (!net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {\n\t\tk_mutex_lock(&lock, K_FOREVER);\n\t\tif (sys_slist_find_and_remove(&active_dad_timers,\n\t\t\t\t\t      &ifaddr->dad_node)) {\n\t\t\t/* Addreess with active DAD timer would still have\n\t\t\t * stale entry in the neighbor cache.\n\t\t\t */\n\t\t\tnet_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);\n\t\t}\n\t\tk_mutex_unlock(&lock);\n\t}\n#endif\n\n\tif (maddr_count == 1) {\n\t\t/* Remove the solicited-node multicast address only if no other\n\t\t * unicast address is also using it\n\t\t */\n\t\tstruct net_in6_addr maddr;\n\n\t\tnet_ipv6_addr_create_solicited_node(&ifaddr->address.in6_addr,\n\t\t\t\t\t\t    &maddr);\n\t\tnet_if_ipv6_maddr_rm(iface, &maddr);\n\t}\n\n\t/* Using the IPv6 address pointer here can give false\n\t * info if someone adds a new IP address into this position\n\t * in the address array. This is quite unlikely thou.\n\t */\n\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_ADDR_DEL,\n\t\t\t\t\tiface,\n\t\t\t\t\t&ifaddr->address.in6_addr,\n\t\t\t\t\tsizeof(struct net_in6_addr));\nout:\n\tnet_if_unlock(iface);\n}\n",
                {
                    "5346": "static void remove_ipv6_ifaddr(struct net_if *iface,",
                    "5347": "\t\t\t       struct net_if_addr *ifaddr,",
                    "5348": "\t\t\t       unsigned int maddr_count)",
                    "5349": "{",
                    "5350": "\tstruct net_if_ipv6 *ipv6;",
                    "5351": "",
                    "5352": "\tnet_if_lock(iface);",
                    "5353": "",
                    "5354": "\tipv6 = COND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));",
                    "5355": "\tif (!ipv6) {",
                    "5356": "\t\tgoto out;",
                    "5357": "\t}",
                    "5358": "",
                    "5359": "\tif (!ifaddr->is_infinite) {",
                    "5360": "\t\tk_mutex_lock(&lock, K_FOREVER);",
                    "5361": "",
                    "5362": "#if defined(CONFIG_NET_NATIVE_IPV6)",
                    "5363": "\t\tsys_slist_find_and_remove(&active_address_lifetime_timers,",
                    "5364": "\t\t\t\t\t  &ifaddr->lifetime.node);",
                    "5365": "",
                    "5366": "\t\tif (sys_slist_is_empty(&active_address_lifetime_timers)) {",
                    "5367": "\t\t\tk_work_cancel_delayable(&address_lifetime_timer);",
                    "5368": "\t\t}",
                    "5369": "#endif",
                    "5370": "\t\tk_mutex_unlock(&lock);",
                    "5371": "\t}",
                    "5372": "",
                    "5373": "#if defined(CONFIG_NET_IPV6_DAD)",
                    "5374": "\tif (!net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {",
                    "5375": "\t\tk_mutex_lock(&lock, K_FOREVER);",
                    "5376": "\t\tif (sys_slist_find_and_remove(&active_dad_timers,",
                    "5377": "\t\t\t\t\t      &ifaddr->dad_node)) {",
                    "5378": "\t\t\t/* Addreess with active DAD timer would still have",
                    "5379": "\t\t\t * stale entry in the neighbor cache.",
                    "5380": "\t\t\t */",
                    "5381": "\t\t\tnet_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);",
                    "5382": "\t\t}",
                    "5383": "\t\tk_mutex_unlock(&lock);",
                    "5384": "\t}",
                    "5385": "#endif",
                    "5386": "",
                    "5387": "\tif (maddr_count == 1) {",
                    "5388": "\t\t/* Remove the solicited-node multicast address only if no other",
                    "5389": "\t\t * unicast address is also using it",
                    "5390": "\t\t */",
                    "5391": "\t\tstruct net_in6_addr maddr;",
                    "5392": "",
                    "5393": "\t\tnet_ipv6_addr_create_solicited_node(&ifaddr->address.in6_addr,",
                    "5394": "\t\t\t\t\t\t    &maddr);",
                    "5395": "\t\tnet_if_ipv6_maddr_rm(iface, &maddr);",
                    "5396": "\t}",
                    "5397": "",
                    "5398": "\t/* Using the IPv6 address pointer here can give false",
                    "5399": "\t * info if someone adds a new IP address into this position",
                    "5400": "\t * in the address array. This is quite unlikely thou.",
                    "5401": "\t */",
                    "5402": "\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_ADDR_DEL,",
                    "5403": "\t\t\t\t\tiface,",
                    "5404": "\t\t\t\t\t&ifaddr->address.in6_addr,",
                    "5405": "\t\t\t\t\tsizeof(struct net_in6_addr));",
                    "5406": "out:",
                    "5407": "\tnet_if_unlock(iface);",
                    "5408": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_ifaddr": {
            "name": "get_ifaddr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 5248,
            "function_content": [
                "#endif /* !CONFIG_NET_NATIVE_IPV4 */\nstatic struct net_if_addr *get_ifaddr(struct net_if *iface,\n\t\t\t\t      net_sa_family_t family,\n\t\t\t\t      const void *addr,\n\t\t\t\t      unsigned int *mcast_addr_count)\n{\n\tstruct net_if_addr *ifaddr = NULL;\n\n\tnet_if_lock(iface);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\tstruct net_if_ipv6 *ipv6 =\n\t\t\tCOND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));\n\t\tstruct net_in6_addr maddr;\n\t\tunsigned int maddr_count = 0;\n\t\tint found = -1;\n\n\t\tif (ipv6 == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tnet_ipv6_addr_create_solicited_node((struct net_in6_addr *)addr,\n\t\t\t\t\t\t    &maddr);\n\n\t\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\t\tstruct net_in6_addr unicast_maddr;\n\n\t\t\tif (!ipv6->unicast[i].is_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Count how many times this solicited-node multicast address is identical\n\t\t\t * for all the used unicast addresses\n\t\t\t */\n\t\t\tnet_ipv6_addr_create_solicited_node(\n\t\t\t\t&ipv6->unicast[i].address.in6_addr,\n\t\t\t\t&unicast_maddr);\n\n\t\t\tif (net_ipv6_addr_cmp(&maddr, &unicast_maddr)) {\n\t\t\t\tmaddr_count++;\n\t\t\t}\n\n\t\t\tif (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr, addr)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = i;\n\t\t}\n\n\t\tif (found >= 0) {\n\t\t\tifaddr = &ipv6->unicast[found];\n\n\t\t\tif (mcast_addr_count != NULL) {\n\t\t\t\t*mcast_addr_count = maddr_count;\n\t\t\t}\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\tstruct net_if_ipv4 *ipv4 =\n\t\t\tCOND_CODE_1(CONFIG_NET_IPV4, (iface->config.ip.ipv4), (NULL));\n\n\t\tif (ipv4 == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tARRAY_FOR_EACH(ipv4->unicast, i) {\n\t\t\tif (!ipv4->unicast[i].ipv4.is_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!net_ipv4_addr_cmp(&ipv4->unicast[i].ipv4.address.in_addr,\n\t\t\t\t\t       addr)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tifaddr = &ipv4->unicast[i].ipv4;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn ifaddr;\n}\n",
                {
                    "5248": "static struct net_if_addr *get_ifaddr(struct net_if *iface,",
                    "5249": "\t\t\t\t      net_sa_family_t family,",
                    "5250": "\t\t\t\t      const void *addr,",
                    "5251": "\t\t\t\t      unsigned int *mcast_addr_count)",
                    "5252": "{",
                    "5253": "\tstruct net_if_addr *ifaddr = NULL;",
                    "5254": "",
                    "5255": "\tnet_if_lock(iface);",
                    "5256": "",
                    "5257": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "5258": "\t\tstruct net_if_ipv6 *ipv6 =",
                    "5259": "\t\t\tCOND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));",
                    "5260": "\t\tstruct net_in6_addr maddr;",
                    "5261": "\t\tunsigned int maddr_count = 0;",
                    "5262": "\t\tint found = -1;",
                    "5263": "",
                    "5264": "\t\tif (ipv6 == NULL) {",
                    "5265": "\t\t\tgoto out;",
                    "5266": "\t\t}",
                    "5267": "",
                    "5268": "\t\tnet_ipv6_addr_create_solicited_node((struct net_in6_addr *)addr,",
                    "5269": "\t\t\t\t\t\t    &maddr);",
                    "5270": "",
                    "5271": "\t\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "5272": "\t\t\tstruct net_in6_addr unicast_maddr;",
                    "5273": "",
                    "5274": "\t\t\tif (!ipv6->unicast[i].is_used) {",
                    "5275": "\t\t\t\tcontinue;",
                    "5276": "\t\t\t}",
                    "5277": "",
                    "5278": "\t\t\t/* Count how many times this solicited-node multicast address is identical",
                    "5279": "\t\t\t * for all the used unicast addresses",
                    "5280": "\t\t\t */",
                    "5281": "\t\t\tnet_ipv6_addr_create_solicited_node(",
                    "5282": "\t\t\t\t&ipv6->unicast[i].address.in6_addr,",
                    "5283": "\t\t\t\t&unicast_maddr);",
                    "5284": "",
                    "5285": "\t\t\tif (net_ipv6_addr_cmp(&maddr, &unicast_maddr)) {",
                    "5286": "\t\t\t\tmaddr_count++;",
                    "5287": "\t\t\t}",
                    "5288": "",
                    "5289": "\t\t\tif (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr, addr)) {",
                    "5290": "\t\t\t\tcontinue;",
                    "5291": "\t\t\t}",
                    "5292": "",
                    "5293": "\t\t\tfound = i;",
                    "5294": "\t\t}",
                    "5295": "",
                    "5296": "\t\tif (found >= 0) {",
                    "5297": "\t\t\tifaddr = &ipv6->unicast[found];",
                    "5298": "",
                    "5299": "\t\t\tif (mcast_addr_count != NULL) {",
                    "5300": "\t\t\t\t*mcast_addr_count = maddr_count;",
                    "5301": "\t\t\t}",
                    "5302": "\t\t}",
                    "5303": "",
                    "5304": "\t\tgoto out;",
                    "5305": "\t}",
                    "5306": "",
                    "5307": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "5308": "\t\tstruct net_if_ipv4 *ipv4 =",
                    "5309": "\t\t\tCOND_CODE_1(CONFIG_NET_IPV4, (iface->config.ip.ipv4), (NULL));",
                    "5310": "",
                    "5311": "\t\tif (ipv4 == NULL) {",
                    "5312": "\t\t\tgoto out;",
                    "5313": "\t\t}",
                    "5314": "",
                    "5315": "\t\tARRAY_FOR_EACH(ipv4->unicast, i) {",
                    "5316": "\t\t\tif (!ipv4->unicast[i].ipv4.is_used) {",
                    "5317": "\t\t\t\tcontinue;",
                    "5318": "\t\t\t}",
                    "5319": "",
                    "5320": "\t\t\tif (!net_ipv4_addr_cmp(&ipv4->unicast[i].ipv4.address.in_addr,",
                    "5321": "\t\t\t\t\t       addr)) {",
                    "5322": "\t\t\t\tcontinue;",
                    "5323": "\t\t\t}",
                    "5324": "",
                    "5325": "\t\t\tifaddr = &ipv4->unicast[i].ipv4;",
                    "5326": "",
                    "5327": "\t\t\tgoto out;",
                    "5328": "\t\t}",
                    "5329": "\t}",
                    "5330": "",
                    "5331": "out:",
                    "5332": "\tnet_if_unlock(iface);",
                    "5333": "",
                    "5334": "\treturn ifaddr;",
                    "5335": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_get_best_match": {
            "name": "net_if_ipv6_get_best_match",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 3149,
            "function_content": [
                "/* Allow socket to override the kconfig option */\nstatic struct net_in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,\n\t\t\t\t\t\t   const struct net_in6_addr *dst,\n\t\t\t\t\t\t   uint8_t prefix_len,\n\t\t\t\t\t\t   uint8_t *best_so_far,\n\t\t\t\t\t\t   int flags)\n{\n\tenum net_addr_state addr_state = NET_ADDR_ANY_STATE;\n\tstruct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;\n\tstruct net_if_addr *public_addr = NULL;\n\tstruct net_in6_addr *src = NULL;\n\tuint8_t public_addr_len = 0;\n\tstruct net_in6_addr *temp_addr = NULL;\n\tuint8_t len, temp_addr_len = 0;\n\tbool ret;\n\n\tnet_if_lock(iface);\n\n\tipv6 = iface->config.ip.ipv6;\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (!is_proper_ipv6_address(&ipv6->unicast[i])) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* This is a dirty hack until we have proper IPv6 routing.\n\t\t * Without this the IPv6 packets might go to VPN interface for\n\t\t * subnets that are not on the same subnet as the VPN interface\n\t\t * which typically is not desired.\n\t\t * TODO: Implement IPv6 routing support and remove this hack.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_NET_VPN)) {\n\t\t\t/* For the VPN interface, we need to check if\n\t\t\t * address matches exactly the address of the interface.\n\t\t\t */\n\t\t\tif (net_if_l2(iface) == &NET_L2_GET_NAME(VIRTUAL) &&\n\t\t\t    net_virtual_get_iface_capabilities(iface) == VIRTUAL_INTERFACE_VPN) {\n\t\t\t\t/* FIXME: Do not hard code the prefix length */\n\t\t\t\tif (!net_ipv6_is_prefix(\n\t\t\t\t\t    (const uint8_t *)&ipv6->unicast[i].address.in6_addr,\n\t\t\t\t\t    (const uint8_t *)dst,\n\t\t\t\t\t    64)) {\n\t\t\t\t\t/* Skip this address as it is no match */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlen = get_diff_ipv6(dst, &ipv6->unicast[i].address.in6_addr);\n\t\tif (len >= prefix_len) {\n\t\t\tlen = prefix_len;\n\t\t}\n\n\t\tif (ipv6->unicast[i].addr_state == NET_ADDR_DEPRECATED &&\n\t\t    addr_state == NET_ADDR_PREFERRED) {\n\t\t\t/* We have a preferred address and a deprecated\n\t\t\t * address. We prefer always the preferred address\n\t\t\t * over the deprecated address.\n\t\t\t * See RFC 6724 chapter 5.\n\t\t\t */\n\t\t\tNET_DBG(\"skipping deprecated address %s\",\n\t\t\t\tnet_sprint_ipv6_addr(&ipv6->unicast[i].address.in6_addr));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len >= *best_so_far ||\n\t\t    (ipv6->unicast[i].addr_state == NET_ADDR_PREFERRED &&\n\t\t     addr_state == NET_ADDR_DEPRECATED)) {\n\t\t\t/* Currently we have best deprecated address, but\n\t\t\t * should now choose the preferred address regardless\n\t\t\t * of the length.\n\t\t\t */\n\n\t\t\t/* Mesh local address can only be selected for the same\n\t\t\t * subnet.\n\t\t\t */\n\t\t\tif (ipv6->unicast[i].is_mesh_local && len < 64 &&\n\t\t\t    !net_ipv6_is_addr_mcast_mesh(dst)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddr_state = ipv6->unicast[i].addr_state;\n\n\t\t\tNET_DBG(\"[%zd] Checking %s (%s) dst %s/%d\", i,\n\t\t\t\tnet_sprint_ipv6_addr(&ipv6->unicast[i].address.in6_addr),\n\t\t\t\taddr_state == NET_ADDR_PREFERRED ? \"preferred\" :\n\t\t\t\taddr_state == NET_ADDR_DEPRECATED ? \"deprecated\" : \"?\",\n\t\t\t\tnet_sprint_ipv6_addr(dst), prefix_len);\n\n\t\t\tret = use_public_address(iface->pe_prefer_public,\n\t\t\t\t\t\t ipv6->unicast[i].is_temporary,\n\t\t\t\t\t\t flags);\n\t\t\tif (!ret) {\n\t\t\t\ttemp_addr = &ipv6->unicast[i].address.in6_addr;\n\t\t\t\ttemp_addr_len = len;\n\n\t\t\t\t*best_so_far = len;\n\t\t\t\tsrc = &ipv6->unicast[i].address.in6_addr;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ipv6->unicast[i].is_temporary) {\n\t\t\t\tpublic_addr = &ipv6->unicast[i];\n\t\t\t\tpublic_addr_len = len;\n\t\t\t}\n\n\t\t\t*best_so_far = len;\n\t\t\tsrc = &ipv6->unicast[i].address.in6_addr;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_PE) && !iface->pe_prefer_public && temp_addr) {\n\t\tif (temp_addr_len >= *best_so_far) {\n\t\t\t*best_so_far = temp_addr_len;\n\t\t\tsrc = temp_addr;\n\t\t}\n\t} else {\n\t\t/* By default prefer always public address if found */\n\t\tif (flags & ZSOCK_IPV6_PREFER_SRC_PUBLIC) {\nuse_public:\n\t\t\tif (public_addr &&\n\t\t\t    !net_ipv6_addr_cmp(&public_addr->address.in6_addr, src)) {\n\t\t\t\tsrc = &public_addr->address.in6_addr;\n\t\t\t\t*best_so_far = public_addr_len;\n\t\t\t}\n\t\t} else if (flags & ZSOCK_IPV6_PREFER_SRC_TMP) {\n\t\t\tif (temp_addr && !net_ipv6_addr_cmp(temp_addr, src)) {\n\t\t\t\tsrc = temp_addr;\n\t\t\t\t*best_so_far = temp_addr_len;\n\t\t\t}\n\t\t} else if (flags & ZSOCK_IPV6_PREFER_SRC_PUBTMP_DEFAULT) {\n\t\t\tgoto use_public;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\tif (src != NULL) {\n\t\tNET_DBG(\"Selected %s (%s) dst %s/%d\",\n\t\t\tnet_sprint_ipv6_addr(src),\n\t\t\taddr_state == NET_ADDR_PREFERRED ? \"preferred\" :\n\t\t\taddr_state == NET_ADDR_DEPRECATED ? \"deprecated\" : \"?\",\n\t\t\tnet_sprint_ipv6_addr(dst), prefix_len);\n\t}\n\n\treturn src;\n}\n",
                {
                    "3149": "static struct net_in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,",
                    "3150": "\t\t\t\t\t\t   const struct net_in6_addr *dst,",
                    "3151": "\t\t\t\t\t\t   uint8_t prefix_len,",
                    "3152": "\t\t\t\t\t\t   uint8_t *best_so_far,",
                    "3153": "\t\t\t\t\t\t   int flags)",
                    "3154": "{",
                    "3155": "\tenum net_addr_state addr_state = NET_ADDR_ANY_STATE;",
                    "3156": "\tstruct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;",
                    "3157": "\tstruct net_if_addr *public_addr = NULL;",
                    "3158": "\tstruct net_in6_addr *src = NULL;",
                    "3159": "\tuint8_t public_addr_len = 0;",
                    "3160": "\tstruct net_in6_addr *temp_addr = NULL;",
                    "3161": "\tuint8_t len, temp_addr_len = 0;",
                    "3162": "\tbool ret;",
                    "3163": "",
                    "3164": "\tnet_if_lock(iface);",
                    "3165": "",
                    "3166": "\tipv6 = iface->config.ip.ipv6;",
                    "3167": "\tif (!ipv6) {",
                    "3168": "\t\tgoto out;",
                    "3169": "\t}",
                    "3170": "",
                    "3171": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "3172": "\t\tif (!is_proper_ipv6_address(&ipv6->unicast[i])) {",
                    "3173": "\t\t\tcontinue;",
                    "3174": "\t\t}",
                    "3175": "",
                    "3176": "\t\t/* This is a dirty hack until we have proper IPv6 routing.",
                    "3177": "\t\t * Without this the IPv6 packets might go to VPN interface for",
                    "3178": "\t\t * subnets that are not on the same subnet as the VPN interface",
                    "3179": "\t\t * which typically is not desired.",
                    "3180": "\t\t * TODO: Implement IPv6 routing support and remove this hack.",
                    "3181": "\t\t */",
                    "3182": "\t\tif (IS_ENABLED(CONFIG_NET_VPN)) {",
                    "3183": "\t\t\t/* For the VPN interface, we need to check if",
                    "3184": "\t\t\t * address matches exactly the address of the interface.",
                    "3185": "\t\t\t */",
                    "3186": "\t\t\tif (net_if_l2(iface) == &NET_L2_GET_NAME(VIRTUAL) &&",
                    "3187": "\t\t\t    net_virtual_get_iface_capabilities(iface) == VIRTUAL_INTERFACE_VPN) {",
                    "3188": "\t\t\t\t/* FIXME: Do not hard code the prefix length */",
                    "3189": "\t\t\t\tif (!net_ipv6_is_prefix(",
                    "3190": "\t\t\t\t\t    (const uint8_t *)&ipv6->unicast[i].address.in6_addr,",
                    "3191": "\t\t\t\t\t    (const uint8_t *)dst,",
                    "3192": "\t\t\t\t\t    64)) {",
                    "3193": "\t\t\t\t\t/* Skip this address as it is no match */",
                    "3194": "\t\t\t\t\tcontinue;",
                    "3195": "\t\t\t\t}",
                    "3196": "\t\t\t}",
                    "3197": "\t\t}",
                    "3198": "",
                    "3199": "\t\tlen = get_diff_ipv6(dst, &ipv6->unicast[i].address.in6_addr);",
                    "3200": "\t\tif (len >= prefix_len) {",
                    "3201": "\t\t\tlen = prefix_len;",
                    "3202": "\t\t}",
                    "3203": "",
                    "3204": "\t\tif (ipv6->unicast[i].addr_state == NET_ADDR_DEPRECATED &&",
                    "3205": "\t\t    addr_state == NET_ADDR_PREFERRED) {",
                    "3206": "\t\t\t/* We have a preferred address and a deprecated",
                    "3207": "\t\t\t * address. We prefer always the preferred address",
                    "3208": "\t\t\t * over the deprecated address.",
                    "3209": "\t\t\t * See RFC 6724 chapter 5.",
                    "3210": "\t\t\t */",
                    "3211": "\t\t\tNET_DBG(\"skipping deprecated address %s\",",
                    "3212": "\t\t\t\tnet_sprint_ipv6_addr(&ipv6->unicast[i].address.in6_addr));",
                    "3213": "\t\t\tcontinue;",
                    "3214": "\t\t}",
                    "3215": "",
                    "3216": "\t\tif (len >= *best_so_far ||",
                    "3217": "\t\t    (ipv6->unicast[i].addr_state == NET_ADDR_PREFERRED &&",
                    "3218": "\t\t     addr_state == NET_ADDR_DEPRECATED)) {",
                    "3219": "\t\t\t/* Currently we have best deprecated address, but",
                    "3220": "\t\t\t * should now choose the preferred address regardless",
                    "3221": "\t\t\t * of the length.",
                    "3222": "\t\t\t */",
                    "3223": "",
                    "3224": "\t\t\t/* Mesh local address can only be selected for the same",
                    "3225": "\t\t\t * subnet.",
                    "3226": "\t\t\t */",
                    "3227": "\t\t\tif (ipv6->unicast[i].is_mesh_local && len < 64 &&",
                    "3228": "\t\t\t    !net_ipv6_is_addr_mcast_mesh(dst)) {",
                    "3229": "\t\t\t\tcontinue;",
                    "3230": "\t\t\t}",
                    "3231": "",
                    "3232": "\t\t\taddr_state = ipv6->unicast[i].addr_state;",
                    "3233": "",
                    "3234": "\t\t\tNET_DBG(\"[%zd] Checking %s (%s) dst %s/%d\", i,",
                    "3235": "\t\t\t\tnet_sprint_ipv6_addr(&ipv6->unicast[i].address.in6_addr),",
                    "3236": "\t\t\t\taddr_state == NET_ADDR_PREFERRED ? \"preferred\" :",
                    "3237": "\t\t\t\taddr_state == NET_ADDR_DEPRECATED ? \"deprecated\" : \"?\",",
                    "3238": "\t\t\t\tnet_sprint_ipv6_addr(dst), prefix_len);",
                    "3239": "",
                    "3240": "\t\t\tret = use_public_address(iface->pe_prefer_public,",
                    "3241": "\t\t\t\t\t\t ipv6->unicast[i].is_temporary,",
                    "3242": "\t\t\t\t\t\t flags);",
                    "3243": "\t\t\tif (!ret) {",
                    "3244": "\t\t\t\ttemp_addr = &ipv6->unicast[i].address.in6_addr;",
                    "3245": "\t\t\t\ttemp_addr_len = len;",
                    "3246": "",
                    "3247": "\t\t\t\t*best_so_far = len;",
                    "3248": "\t\t\t\tsrc = &ipv6->unicast[i].address.in6_addr;",
                    "3249": "\t\t\t\tcontinue;",
                    "3250": "\t\t\t}",
                    "3251": "",
                    "3252": "\t\t\tif (!ipv6->unicast[i].is_temporary) {",
                    "3253": "\t\t\t\tpublic_addr = &ipv6->unicast[i];",
                    "3254": "\t\t\t\tpublic_addr_len = len;",
                    "3255": "\t\t\t}",
                    "3256": "",
                    "3257": "\t\t\t*best_so_far = len;",
                    "3258": "\t\t\tsrc = &ipv6->unicast[i].address.in6_addr;",
                    "3259": "\t\t}",
                    "3260": "\t}",
                    "3261": "",
                    "3262": "\tif (IS_ENABLED(CONFIG_NET_IPV6_PE) && !iface->pe_prefer_public && temp_addr) {",
                    "3263": "\t\tif (temp_addr_len >= *best_so_far) {",
                    "3264": "\t\t\t*best_so_far = temp_addr_len;",
                    "3265": "\t\t\tsrc = temp_addr;",
                    "3266": "\t\t}",
                    "3267": "\t} else {",
                    "3268": "\t\t/* By default prefer always public address if found */",
                    "3269": "\t\tif (flags & ZSOCK_IPV6_PREFER_SRC_PUBLIC) {",
                    "3270": "use_public:",
                    "3271": "\t\t\tif (public_addr &&",
                    "3272": "\t\t\t    !net_ipv6_addr_cmp(&public_addr->address.in6_addr, src)) {",
                    "3273": "\t\t\t\tsrc = &public_addr->address.in6_addr;",
                    "3274": "\t\t\t\t*best_so_far = public_addr_len;",
                    "3275": "\t\t\t}",
                    "3276": "\t\t} else if (flags & ZSOCK_IPV6_PREFER_SRC_TMP) {",
                    "3277": "\t\t\tif (temp_addr && !net_ipv6_addr_cmp(temp_addr, src)) {",
                    "3278": "\t\t\t\tsrc = temp_addr;",
                    "3279": "\t\t\t\t*best_so_far = temp_addr_len;",
                    "3280": "\t\t\t}",
                    "3281": "\t\t} else if (flags & ZSOCK_IPV6_PREFER_SRC_PUBTMP_DEFAULT) {",
                    "3282": "\t\t\tgoto use_public;",
                    "3283": "\t\t}",
                    "3284": "\t}",
                    "3285": "",
                    "3286": "out:",
                    "3287": "\tnet_if_unlock(iface);",
                    "3288": "",
                    "3289": "\tif (src != NULL) {",
                    "3290": "\t\tNET_DBG(\"Selected %s (%s) dst %s/%d\",",
                    "3291": "\t\t\tnet_sprint_ipv6_addr(src),",
                    "3292": "\t\t\taddr_state == NET_ADDR_PREFERRED ? \"preferred\" :",
                    "3293": "\t\t\taddr_state == NET_ADDR_DEPRECATED ? \"deprecated\" : \"?\",",
                    "3294": "\t\t\tnet_sprint_ipv6_addr(dst), prefix_len);",
                    "3295": "\t}",
                    "3296": "",
                    "3297": "\treturn src;",
                    "3298": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "remove_prefix_addresses": {
            "name": "remove_prefix_addresses",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 2551,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic void remove_prefix_addresses(struct net_if *iface,\n\t\t\t\t    struct net_if_ipv6 *ipv6,\n\t\t\t\t    const struct net_in6_addr *addr,\n\t\t\t\t    uint8_t len)\n{\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (!ipv6->unicast[i].is_used ||\n\t\t    ipv6->unicast[i].address.family != NET_AF_INET6 ||\n\t\t    ipv6->unicast[i].addr_type != NET_ADDR_AUTOCONF) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ipv6_is_prefix(\n\t\t\t\taddr->s6_addr,\n\t\t\t\tipv6->unicast[i].address.in6_addr.s6_addr,\n\t\t\t\tlen)) {\n\t\t\tnet_if_ipv6_addr_rm(iface,\n\t\t\t\t\t    &ipv6->unicast[i].address.in6_addr);\n\t\t}\n\t}\n}\n",
                {
                    "2551": "static void remove_prefix_addresses(struct net_if *iface,",
                    "2552": "\t\t\t\t    struct net_if_ipv6 *ipv6,",
                    "2553": "\t\t\t\t    const struct net_in6_addr *addr,",
                    "2554": "\t\t\t\t    uint8_t len)",
                    "2555": "{",
                    "2556": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "2557": "\t\tif (!ipv6->unicast[i].is_used ||",
                    "2558": "\t\t    ipv6->unicast[i].address.family != NET_AF_INET6 ||",
                    "2559": "\t\t    ipv6->unicast[i].addr_type != NET_ADDR_AUTOCONF) {",
                    "2560": "\t\t\tcontinue;",
                    "2561": "\t\t}",
                    "2562": "",
                    "2563": "\t\tif (net_ipv6_is_prefix(",
                    "2564": "\t\t\t\taddr->s6_addr,",
                    "2565": "\t\t\t\tipv6->unicast[i].address.in6_addr.s6_addr,",
                    "2566": "\t\t\t\tlen)) {",
                    "2567": "\t\t\tnet_if_ipv6_addr_rm(iface,",
                    "2568": "\t\t\t\t\t    &ipv6->unicast[i].address.in6_addr);",
                    "2569": "\t\t}",
                    "2570": "\t}",
                    "2571": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_start_dad": {
            "name": "net_if_ipv6_start_dad",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1291,
            "function_content": [
                "/* The address gets added to neighbor cache which is not\n* needed in this case as the address is our own one.\n*/\nvoid net_if_ipv6_start_dad(struct net_if *iface,\n\t\t\t   struct net_if_addr *ifaddr)\n{\n\tifaddr->addr_state = NET_ADDR_TENTATIVE;\n\n\tif (net_if_is_up(iface)) {\n\t\tNET_DBG(\"Interface %p ll addr %s tentative IPv6 addr %s\",\n\t\t\tiface,\n\t\t\tnet_sprint_ll_addr(\n\t\t\t\t\t   net_if_get_link_addr(iface)->addr,\n\t\t\t\t\t   net_if_get_link_addr(iface)->len),\n\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));\n\n\t\tifaddr->dad_count = 1U;\n\n\t\tif (net_ipv6_start_dad(iface, ifaddr) != 0) {\n\t\t\tNET_ERR(\"Interface %p failed to send DAD query for %s\",\n\t\t\t\tiface,\n\t\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));\n\t\t}\n\n\t\tifaddr->dad_start = k_uptime_get_32();\n\t\tifaddr->ifindex = net_if_get_by_iface(iface);\n\n\t\tk_mutex_lock(&lock, K_FOREVER);\n\t\tsys_slist_find_and_remove(&active_dad_timers,\n\t\t\t\t\t  &ifaddr->dad_node);\n\t\tsys_slist_append(&active_dad_timers, &ifaddr->dad_node);\n\t\tk_mutex_unlock(&lock);\n\n\t\t/* FUTURE: use schedule, not reschedule. */\n\t\tif (!k_work_delayable_remaining_get(&dad_timer)) {\n\t\t\tk_work_reschedule(&dad_timer,\n\t\t\t\t\t  K_MSEC(DAD_TIMEOUT));\n\t\t}\n\t} else {\n\t\tNET_DBG(\"Interface %p is down, starting DAD for %s later.\",\n\t\t\tiface,\n\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));\n\t}\n}\n",
                {
                    "1291": "void net_if_ipv6_start_dad(struct net_if *iface,",
                    "1292": "\t\t\t   struct net_if_addr *ifaddr)",
                    "1293": "{",
                    "1294": "\tifaddr->addr_state = NET_ADDR_TENTATIVE;",
                    "1295": "",
                    "1296": "\tif (net_if_is_up(iface)) {",
                    "1297": "\t\tNET_DBG(\"Interface %p ll addr %s tentative IPv6 addr %s\",",
                    "1298": "\t\t\tiface,",
                    "1299": "\t\t\tnet_sprint_ll_addr(",
                    "1300": "\t\t\t\t\t   net_if_get_link_addr(iface)->addr,",
                    "1301": "\t\t\t\t\t   net_if_get_link_addr(iface)->len),",
                    "1302": "\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));",
                    "1303": "",
                    "1304": "\t\tifaddr->dad_count = 1U;",
                    "1305": "",
                    "1306": "\t\tif (net_ipv6_start_dad(iface, ifaddr) != 0) {",
                    "1307": "\t\t\tNET_ERR(\"Interface %p failed to send DAD query for %s\",",
                    "1308": "\t\t\t\tiface,",
                    "1309": "\t\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));",
                    "1310": "\t\t}",
                    "1311": "",
                    "1312": "\t\tifaddr->dad_start = k_uptime_get_32();",
                    "1313": "\t\tifaddr->ifindex = net_if_get_by_iface(iface);",
                    "1314": "",
                    "1315": "\t\tk_mutex_lock(&lock, K_FOREVER);",
                    "1316": "\t\tsys_slist_find_and_remove(&active_dad_timers,",
                    "1317": "\t\t\t\t\t  &ifaddr->dad_node);",
                    "1318": "\t\tsys_slist_append(&active_dad_timers, &ifaddr->dad_node);",
                    "1319": "\t\tk_mutex_unlock(&lock);",
                    "1320": "",
                    "1321": "\t\t/* FUTURE: use schedule, not reschedule. */",
                    "1322": "\t\tif (!k_work_delayable_remaining_get(&dad_timer)) {",
                    "1323": "\t\t\tk_work_reschedule(&dad_timer,",
                    "1324": "\t\t\t\t\t  K_MSEC(DAD_TIMEOUT));",
                    "1325": "\t\t}",
                    "1326": "\t} else {",
                    "1327": "\t\tNET_DBG(\"Interface %p is down, starting DAD for %s later.\",",
                    "1328": "\t\t\tiface,",
                    "1329": "\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr));",
                    "1330": "\t}",
                    "1331": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "dad_timeout": {
            "name": "dad_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1232,
            "function_content": [
                "#define DAD_TIMEOUT 100U /* ms */\nstatic void dad_timeout(struct k_work *work)\n{\n\tuint32_t current_time = k_uptime_get_32();\n\tstruct net_if_addr *ifaddr, *next;\n\tint32_t delay = -1;\n\tsys_slist_t expired_list;\n\n\tARG_UNUSED(work);\n\n\tsys_slist_init(&expired_list);\n\n\tk_mutex_lock(&lock, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,\n\t\t\t\t\t  ifaddr, next, dad_node) {\n\t\t/* DAD entries are ordered by construction.  Stop when\n\t\t * we find one that hasn't expired.\n\t\t */\n\t\tdelay = (int32_t)(ifaddr->dad_start +\n\t\t\t\t  DAD_TIMEOUT - current_time);\n\t\tif (delay > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Removing the ifaddr from active_dad_timers list */\n\t\tsys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);\n\t\tsys_slist_append(&expired_list, &ifaddr->dad_node);\n\n\t\tifaddr = NULL;\n\t}\n\n\tif ((ifaddr != NULL) && (delay > 0)) {\n\t\tk_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));\n\t}\n\n\tk_mutex_unlock(&lock);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&expired_list, ifaddr, dad_node) {\n\t\tstruct net_if *iface;\n\n\t\tNET_DBG(\"DAD succeeded for %s at interface %d\",\n\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr),\n\t\t\tifaddr->ifindex);\n\n\t\tifaddr->addr_state = NET_ADDR_PREFERRED;\n\t\tiface = net_if_get_by_index(ifaddr->ifindex);\n\n\t\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_SUCCEED,\n\t\t\t\t\t\tiface,\n\t\t\t\t\t\t&ifaddr->address.in6_addr,\n\t\t\t\t\t\tsizeof(struct net_in6_addr));\n\n\t\t/* The address gets added to neighbor cache which is not\n\t\t * needed in this case as the address is our own one.\n\t\t */\n\t\tnet_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);\n\t}\n}\n",
                {
                    "1232": "static void dad_timeout(struct k_work *work)",
                    "1233": "{",
                    "1234": "\tuint32_t current_time = k_uptime_get_32();",
                    "1235": "\tstruct net_if_addr *ifaddr, *next;",
                    "1236": "\tint32_t delay = -1;",
                    "1237": "\tsys_slist_t expired_list;",
                    "1238": "",
                    "1239": "\tARG_UNUSED(work);",
                    "1240": "",
                    "1241": "\tsys_slist_init(&expired_list);",
                    "1242": "",
                    "1243": "\tk_mutex_lock(&lock, K_FOREVER);",
                    "1244": "",
                    "1245": "\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,",
                    "1246": "\t\t\t\t\t  ifaddr, next, dad_node) {",
                    "1247": "\t\t/* DAD entries are ordered by construction.  Stop when",
                    "1248": "\t\t * we find one that hasn't expired.",
                    "1249": "\t\t */",
                    "1250": "\t\tdelay = (int32_t)(ifaddr->dad_start +",
                    "1251": "\t\t\t\t  DAD_TIMEOUT - current_time);",
                    "1252": "\t\tif (delay > 0) {",
                    "1253": "\t\t\tbreak;",
                    "1254": "\t\t}",
                    "1255": "",
                    "1256": "\t\t/* Removing the ifaddr from active_dad_timers list */",
                    "1257": "\t\tsys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);",
                    "1258": "\t\tsys_slist_append(&expired_list, &ifaddr->dad_node);",
                    "1259": "",
                    "1260": "\t\tifaddr = NULL;",
                    "1261": "\t}",
                    "1262": "",
                    "1263": "\tif ((ifaddr != NULL) && (delay > 0)) {",
                    "1264": "\t\tk_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));",
                    "1265": "\t}",
                    "1266": "",
                    "1267": "\tk_mutex_unlock(&lock);",
                    "1268": "",
                    "1269": "\tSYS_SLIST_FOR_EACH_CONTAINER(&expired_list, ifaddr, dad_node) {",
                    "1270": "\t\tstruct net_if *iface;",
                    "1271": "",
                    "1272": "\t\tNET_DBG(\"DAD succeeded for %s at interface %d\",",
                    "1273": "\t\t\tnet_sprint_ipv6_addr(&ifaddr->address.in6_addr),",
                    "1274": "\t\t\tifaddr->ifindex);",
                    "1275": "",
                    "1276": "\t\tifaddr->addr_state = NET_ADDR_PREFERRED;",
                    "1277": "\t\tiface = net_if_get_by_index(ifaddr->ifindex);",
                    "1278": "",
                    "1279": "\t\tnet_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_SUCCEED,",
                    "1280": "\t\t\t\t\t\tiface,",
                    "1281": "\t\t\t\t\t\t&ifaddr->address.in6_addr,",
                    "1282": "\t\t\t\t\t\tsizeof(struct net_in6_addr));",
                    "1283": "",
                    "1284": "\t\t/* The address gets added to neighbor cache which is not",
                    "1285": "\t\t * needed in this case as the address is our own one.",
                    "1286": "\t\t */",
                    "1287": "\t\tnet_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);",
                    "1288": "\t}",
                    "1289": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "join_mcast_solicit_node": {
            "name": "join_mcast_solicit_node",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1159,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE_IPV4 || CONFIG_NET_NATIVE_IPV6 */\nstatic void join_mcast_solicit_node(struct net_if *iface,\n\t\t\t\t    struct net_in6_addr *my_addr)\n{\n\tstruct net_in6_addr addr;\n\tint ret;\n\n\tif (iface->config.ip.ipv6 == NULL) {\n\t\treturn;\n\t}\n\n\t/* Join to needed multicast groups, RFC 4291 ch 2.8 */\n\tnet_ipv6_addr_create_solicited_node(my_addr, &addr);\n\n\tret = net_ipv6_mld_join(iface, &addr);\n\tif (ret < 0) {\n\t\tif (ret != -EALREADY && ret != -ENETDOWN) {\n\t\t\tNET_ERR(\"Cannot join solicit node address %s for %d (%d)\",\n\t\t\t\tnet_sprint_ipv6_addr(&addr),\n\t\t\t\tnet_if_get_by_iface(iface), ret);\n\t\t}\n\t} else {\n\t\tNET_DBG(\"Join solicit node address %s (ifindex %d)\",\n\t\t\tnet_sprint_ipv6_addr(&addr),\n\t\t\tnet_if_get_by_iface(iface));\n\t}\n}\n",
                {
                    "1159": "static void join_mcast_solicit_node(struct net_if *iface,",
                    "1160": "\t\t\t\t    struct net_in6_addr *my_addr)",
                    "1161": "{",
                    "1162": "\tstruct net_in6_addr addr;",
                    "1163": "\tint ret;",
                    "1164": "",
                    "1165": "\tif (iface->config.ip.ipv6 == NULL) {",
                    "1166": "\t\treturn;",
                    "1167": "\t}",
                    "1168": "",
                    "1169": "\t/* Join to needed multicast groups, RFC 4291 ch 2.8 */",
                    "1170": "\tnet_ipv6_addr_create_solicited_node(my_addr, &addr);",
                    "1171": "",
                    "1172": "\tret = net_ipv6_mld_join(iface, &addr);",
                    "1173": "\tif (ret < 0) {",
                    "1174": "\t\tif (ret != -EALREADY && ret != -ENETDOWN) {",
                    "1175": "\t\t\tNET_ERR(\"Cannot join solicit node address %s for %d (%d)\",",
                    "1176": "\t\t\t\tnet_sprint_ipv6_addr(&addr),",
                    "1177": "\t\t\t\tnet_if_get_by_iface(iface), ret);",
                    "1178": "\t\t}",
                    "1179": "\t} else {",
                    "1180": "\t\tNET_DBG(\"Join solicit node address %s (ifindex %d)\",",
                    "1181": "\t\t\tnet_sprint_ipv6_addr(&addr),",
                    "1182": "\t\t\tnet_if_get_by_iface(iface));",
                    "1183": "\t}",
                    "1184": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "join_mcast_allnodes": {
            "name": "join_mcast_allnodes",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1140,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE_IPV4 || CONFIG_NET_NATIVE_IPV6 */\nstatic void join_mcast_allnodes(struct net_if *iface)\n{\n\tstruct net_in6_addr addr;\n\tint ret;\n\n\tif (iface->config.ip.ipv6 == NULL) {\n\t\treturn;\n\t}\n\n\tnet_ipv6_addr_create_ll_allnodes_mcast(&addr);\n\n\tret = net_ipv6_mld_join(iface, &addr);\n\tif (ret < 0 && ret != -EALREADY && ret != -ENETDOWN) {\n\t\tNET_ERR(\"Cannot join all nodes address %s for %d (%d)\",\n\t\t\tnet_sprint_ipv6_addr(&addr),\n\t\t\tnet_if_get_by_iface(iface), ret);\n\t}\n}\n",
                {
                    "1140": "static void join_mcast_allnodes(struct net_if *iface)",
                    "1141": "{",
                    "1142": "\tstruct net_in6_addr addr;",
                    "1143": "\tint ret;",
                    "1144": "",
                    "1145": "\tif (iface->config.ip.ipv6 == NULL) {",
                    "1146": "\t\treturn;",
                    "1147": "\t}",
                    "1148": "",
                    "1149": "\tnet_ipv6_addr_create_ll_allnodes_mcast(&addr);",
                    "1150": "",
                    "1151": "\tret = net_ipv6_mld_join(iface, &addr);",
                    "1152": "\tif (ret < 0 && ret != -EALREADY && ret != -ENETDOWN) {",
                    "1153": "\t\tNET_ERR(\"Cannot join all nodes address %s for %d (%d)\",",
                    "1154": "\t\t\tnet_sprint_ipv6_addr(&addr),",
                    "1155": "\t\t\tnet_if_get_by_iface(iface), ret);",
                    "1156": "\t}",
                    "1157": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "iface_router_lookup": {
            "name": "iface_router_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 719,
            "function_content": [
                "#endif /* CONFIG_NET_IP */\nstatic struct net_if_router *iface_router_lookup(struct net_if *iface,\n\t\t\t\t\t\t uint8_t family,\n\t\t\t\t\t\t const void *addr)\n{\n\tstruct net_if_router *router = NULL;\n\tint i;\n\n\tk_mutex_lock(&lock, K_FOREVER);\n\n\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {\n\t\tif (!routers[i].is_used ||\n\t\t    routers[i].address.family != family ||\n\t\t    routers[i].iface != iface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 &&\n\t\t     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),\n\t\t\t\t       (const struct net_in6_addr *)addr)) ||\n\t\t    (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET &&\n\t\t     net_ipv4_addr_cmp(net_if_router_ipv4(&routers[i]),\n\t\t\t\t       (const struct net_in_addr *)addr))) {\n\t\t\trouter = &routers[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tk_mutex_unlock(&lock);\n\n\treturn router;\n}\n",
                {
                    "719": "static struct net_if_router *iface_router_lookup(struct net_if *iface,",
                    "720": "\t\t\t\t\t\t uint8_t family,",
                    "721": "\t\t\t\t\t\t const void *addr)",
                    "722": "{",
                    "723": "\tstruct net_if_router *router = NULL;",
                    "724": "\tint i;",
                    "725": "",
                    "726": "\tk_mutex_lock(&lock, K_FOREVER);",
                    "727": "",
                    "728": "\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {",
                    "729": "\t\tif (!routers[i].is_used ||",
                    "730": "\t\t    routers[i].address.family != family ||",
                    "731": "\t\t    routers[i].iface != iface) {",
                    "732": "\t\t\tcontinue;",
                    "733": "\t\t}",
                    "734": "",
                    "735": "\t\tif ((IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 &&",
                    "736": "\t\t     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),",
                    "737": "\t\t\t\t       (const struct net_in6_addr *)addr)) ||",
                    "738": "\t\t    (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET &&",
                    "739": "\t\t     net_ipv4_addr_cmp(net_if_router_ipv4(&routers[i]),",
                    "740": "\t\t\t\t       (const struct net_in_addr *)addr))) {",
                    "741": "\t\t\trouter = &routers[i];",
                    "742": "\t\t\tgoto out;",
                    "743": "\t\t}",
                    "744": "\t}",
                    "745": "",
                    "746": "out:",
                    "747": "\tk_mutex_unlock(&lock);",
                    "748": "",
                    "749": "\treturn router;",
                    "750": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_set_hdr": {
            "name": "net_udp_set_hdr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 95,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstruct net_udp_hdr *net_udp_set_hdr(struct net_pkt *pkt,\n\t\t\t\t    struct net_udp_hdr *hdr)\n{\n\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);\n\tstruct net_pkt_cursor backup;\n\tstruct net_udp_hdr *udp_hdr;\n\tbool overwrite;\n\n\toverwrite = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t net_pkt_ip_opts_len(pkt))) {\n\t\tudp_hdr = NULL;\n\t\tgoto out;\n\t}\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);\n\tif (!udp_hdr) {\n\t\tgoto out;\n\t}\n\n\tmemcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));\n\n\tnet_pkt_set_data(pkt, &udp_access);\nout:\n\tnet_pkt_cursor_restore(pkt, &backup);\n\tnet_pkt_set_overwrite(pkt, overwrite);\n\n\treturn udp_hdr == NULL ? NULL : hdr;\n}\n",
                {
                    "95": "struct net_udp_hdr *net_udp_set_hdr(struct net_pkt *pkt,",
                    "96": "\t\t\t\t    struct net_udp_hdr *hdr)",
                    "97": "{",
                    "98": "\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);",
                    "99": "\tstruct net_pkt_cursor backup;",
                    "100": "\tstruct net_udp_hdr *udp_hdr;",
                    "101": "\tbool overwrite;",
                    "102": "",
                    "103": "\toverwrite = net_pkt_is_being_overwritten(pkt);",
                    "104": "\tnet_pkt_set_overwrite(pkt, true);",
                    "105": "",
                    "106": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "107": "\tnet_pkt_cursor_init(pkt);",
                    "108": "",
                    "109": "\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "110": "\t\t\t net_pkt_ip_opts_len(pkt))) {",
                    "111": "\t\tudp_hdr = NULL;",
                    "112": "\t\tgoto out;",
                    "113": "\t}",
                    "114": "",
                    "115": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);",
                    "116": "\tif (!udp_hdr) {",
                    "117": "\t\tgoto out;",
                    "118": "\t}",
                    "119": "",
                    "120": "\tmemcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));",
                    "121": "",
                    "122": "\tnet_pkt_set_data(pkt, &udp_access);",
                    "123": "out:",
                    "124": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "125": "\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "126": "",
                    "127": "\treturn udp_hdr == NULL ? NULL : hdr;",
                    "128": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_get_hdr": {
            "name": "net_udp_get_hdr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 64,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstruct net_udp_hdr *net_udp_get_hdr(struct net_pkt *pkt,\n\t\t\t\t    struct net_udp_hdr *hdr)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(udp_access, struct net_udp_hdr);\n\tstruct net_pkt_cursor backup;\n\tstruct net_udp_hdr *udp_hdr;\n\tbool overwrite;\n\n\tudp_access.data = hdr;\n\n\toverwrite = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t net_pkt_ip_opts_len(pkt))) {\n\t\tudp_hdr = NULL;\n\t\tgoto out;\n\t}\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);\n\nout:\n\tnet_pkt_cursor_restore(pkt, &backup);\n\tnet_pkt_set_overwrite(pkt, overwrite);\n\n\treturn udp_hdr;\n}\n",
                {
                    "64": "struct net_udp_hdr *net_udp_get_hdr(struct net_pkt *pkt,",
                    "65": "\t\t\t\t    struct net_udp_hdr *hdr)",
                    "66": "{",
                    "67": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(udp_access, struct net_udp_hdr);",
                    "68": "\tstruct net_pkt_cursor backup;",
                    "69": "\tstruct net_udp_hdr *udp_hdr;",
                    "70": "\tbool overwrite;",
                    "71": "",
                    "72": "\tudp_access.data = hdr;",
                    "73": "",
                    "74": "\toverwrite = net_pkt_is_being_overwritten(pkt);",
                    "75": "\tnet_pkt_set_overwrite(pkt, true);",
                    "76": "",
                    "77": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "78": "\tnet_pkt_cursor_init(pkt);",
                    "79": "",
                    "80": "\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "81": "\t\t\t net_pkt_ip_opts_len(pkt))) {",
                    "82": "\t\tudp_hdr = NULL;",
                    "83": "\t\tgoto out;",
                    "84": "\t}",
                    "85": "",
                    "86": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);",
                    "87": "",
                    "88": "out:",
                    "89": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "90": "\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "91": "",
                    "92": "\treturn udp_hdr;",
                    "93": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_clone_internal": {
            "name": "net_pkt_clone_internal",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2093,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nstatic struct net_pkt *net_pkt_clone_internal(struct net_pkt *pkt,\n\t\t\t\t\t      struct k_mem_slab *slab,\n\t\t\t\t\t      k_timeout_t timeout)\n{\n\tsize_t cursor_offset = net_pkt_get_current_offset(pkt);\n\tbool overwrite = net_pkt_is_being_overwritten(pkt);\n\tstruct net_pkt_cursor backup;\n\tstruct net_pkt *clone_pkt;\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tclone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),\n\t\t\t\t\t  net_pkt_get_len(pkt),\n\t\t\t\t\t  NET_AF_UNSPEC, 0, timeout,\n\t\t\t\t\t  __func__, __LINE__);\n#else\n\tclone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),\n\t\t\t\t\t  net_pkt_get_len(pkt),\n\t\t\t\t\t  NET_AF_UNSPEC, 0, timeout);\n#endif\n\tif (!clone_pkt) {\n\t\treturn NULL;\n\t}\n\n\tnet_pkt_set_overwrite(pkt, true);\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tif (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {\n\t\tnet_pkt_unref(clone_pkt);\n\t\tnet_pkt_cursor_restore(pkt, &backup);\n\t\tnet_pkt_set_overwrite(pkt, overwrite);\n\t\treturn NULL;\n\t}\n\tnet_pkt_set_overwrite(clone_pkt, true);\n\n\tclone_pkt_attributes(pkt, clone_pkt);\n\n\tnet_pkt_cursor_init(clone_pkt);\n\n\tif (cursor_offset) {\n\t\tnet_pkt_skip(clone_pkt, cursor_offset);\n\t}\n\tnet_pkt_set_overwrite(clone_pkt, overwrite);\n\n\tnet_pkt_cursor_restore(pkt, &backup);\n\tnet_pkt_set_overwrite(pkt, overwrite);\n\n\tNET_DBG(\"Cloned %p to %p\", pkt, clone_pkt);\n\n\treturn clone_pkt;\n}\n",
                {
                    "2093": "static struct net_pkt *net_pkt_clone_internal(struct net_pkt *pkt,",
                    "2094": "\t\t\t\t\t      struct k_mem_slab *slab,",
                    "2095": "\t\t\t\t\t      k_timeout_t timeout)",
                    "2096": "{",
                    "2097": "\tsize_t cursor_offset = net_pkt_get_current_offset(pkt);",
                    "2098": "\tbool overwrite = net_pkt_is_being_overwritten(pkt);",
                    "2099": "\tstruct net_pkt_cursor backup;",
                    "2100": "\tstruct net_pkt *clone_pkt;",
                    "2101": "",
                    "2102": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "2103": "\tclone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),",
                    "2104": "\t\t\t\t\t  net_pkt_get_len(pkt),",
                    "2105": "\t\t\t\t\t  NET_AF_UNSPEC, 0, timeout,",
                    "2106": "\t\t\t\t\t  __func__, __LINE__);",
                    "2107": "#else",
                    "2108": "\tclone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),",
                    "2109": "\t\t\t\t\t  net_pkt_get_len(pkt),",
                    "2110": "\t\t\t\t\t  NET_AF_UNSPEC, 0, timeout);",
                    "2111": "#endif",
                    "2112": "\tif (!clone_pkt) {",
                    "2113": "\t\treturn NULL;",
                    "2114": "\t}",
                    "2115": "",
                    "2116": "\tnet_pkt_set_overwrite(pkt, true);",
                    "2117": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "2118": "\tnet_pkt_cursor_init(pkt);",
                    "2119": "",
                    "2120": "\tif (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {",
                    "2121": "\t\tnet_pkt_unref(clone_pkt);",
                    "2122": "\t\tnet_pkt_cursor_restore(pkt, &backup);",
                    "2123": "\t\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "2124": "\t\treturn NULL;",
                    "2125": "\t}",
                    "2126": "\tnet_pkt_set_overwrite(clone_pkt, true);",
                    "2127": "",
                    "2128": "\tclone_pkt_attributes(pkt, clone_pkt);",
                    "2129": "",
                    "2130": "\tnet_pkt_cursor_init(clone_pkt);",
                    "2131": "",
                    "2132": "\tif (cursor_offset) {",
                    "2133": "\t\tnet_pkt_skip(clone_pkt, cursor_offset);",
                    "2134": "\t}",
                    "2135": "\tnet_pkt_set_overwrite(clone_pkt, overwrite);",
                    "2136": "",
                    "2137": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "2138": "\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "2139": "",
                    "2140": "\tNET_DBG(\"Cloned %p to %p\", pkt, clone_pkt);",
                    "2141": "",
                    "2142": "\treturn clone_pkt;",
                    "2143": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "clone_pkt_attributes": {
            "name": "clone_pkt_attributes",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2032,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nstatic void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)\n{\n\tnet_pkt_set_family(clone_pkt, net_pkt_family(pkt));\n\tnet_pkt_set_context(clone_pkt, net_pkt_context(pkt));\n\tnet_pkt_set_ip_hdr_len(clone_pkt, net_pkt_ip_hdr_len(pkt));\n\tnet_pkt_set_ip_dscp(clone_pkt, net_pkt_ip_dscp(pkt));\n\tnet_pkt_set_ip_ecn(clone_pkt, net_pkt_ip_ecn(pkt));\n\tnet_pkt_set_vlan_tag(clone_pkt, net_pkt_vlan_tag(pkt));\n\tnet_pkt_set_timestamp(clone_pkt, net_pkt_timestamp(pkt));\n\tnet_pkt_set_priority(clone_pkt, net_pkt_priority(pkt));\n\tnet_pkt_set_orig_iface(clone_pkt, net_pkt_orig_iface(pkt));\n\tnet_pkt_set_captured(clone_pkt, net_pkt_is_captured(pkt));\n\tnet_pkt_set_eof(clone_pkt, net_pkt_eof(pkt));\n\tnet_pkt_set_ptp(clone_pkt, net_pkt_is_ptp(pkt));\n\tnet_pkt_set_ppp(clone_pkt, net_pkt_is_ppp(pkt));\n\tnet_pkt_set_lldp(clone_pkt, net_pkt_is_lldp(pkt));\n\tnet_pkt_set_ipv4_acd(clone_pkt, net_pkt_ipv4_acd(pkt));\n\tnet_pkt_set_tx_timestamping(clone_pkt, net_pkt_is_tx_timestamping(pkt));\n\tnet_pkt_set_rx_timestamping(clone_pkt, net_pkt_is_rx_timestamping(pkt));\n\tnet_pkt_set_forwarding(clone_pkt, net_pkt_forwarding(pkt));\n\tnet_pkt_set_chksum_done(clone_pkt, net_pkt_is_chksum_done(pkt));\n\tnet_pkt_set_loopback(pkt, net_pkt_is_loopback(pkt));\n\tnet_pkt_set_ip_reassembled(pkt, net_pkt_is_ip_reassembled(pkt));\n\tnet_pkt_set_cooked_mode(clone_pkt, net_pkt_is_cooked_mode(pkt));\n\tnet_pkt_set_ipv4_pmtu(clone_pkt, net_pkt_ipv4_pmtu(pkt));\n\tnet_pkt_set_l2_bridged(clone_pkt, net_pkt_is_l2_bridged(pkt));\n\tnet_pkt_set_l2_processed(clone_pkt, net_pkt_is_l2_processed(pkt));\n\tnet_pkt_set_ll_proto_type(clone_pkt, net_pkt_ll_proto_type(pkt));\n\n#if defined(CONFIG_NET_OFFLOAD) || defined(CONFIG_NET_L2_IPIP)\n\tnet_pkt_set_remote_address(clone_pkt, net_pkt_remote_address(pkt),\n\t\t\t\t   sizeof(struct net_sockaddr_storage));\n#endif\n\n\tif (pkt->buffer && clone_pkt->buffer) {\n\t\tmemcpy(net_pkt_lladdr_src(clone_pkt), net_pkt_lladdr_src(pkt),\n\t\t       sizeof(struct net_linkaddr));\n\t\tmemcpy(net_pkt_lladdr_dst(clone_pkt), net_pkt_lladdr_dst(pkt),\n\t\t       sizeof(struct net_linkaddr));\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == NET_AF_INET) {\n\t\tnet_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));\n\t\tnet_pkt_set_ipv4_opts_len(clone_pkt,\n\t\t\t\t\t  net_pkt_ipv4_opts_len(pkt));\n\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t   net_pkt_family(pkt) == NET_AF_INET6) {\n\t\tnet_pkt_set_ipv6_hop_limit(clone_pkt,\n\t\t\t\t\t   net_pkt_ipv6_hop_limit(pkt));\n\t\tnet_pkt_set_ipv6_ext_len(clone_pkt, net_pkt_ipv6_ext_len(pkt));\n\t\tnet_pkt_set_ipv6_ext_opt_len(clone_pkt,\n\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt));\n\t\tnet_pkt_set_ipv6_hdr_prev(clone_pkt,\n\t\t\t\t\t  net_pkt_ipv6_hdr_prev(pkt));\n\t\tnet_pkt_set_ipv6_next_hdr(clone_pkt,\n\t\t\t\t\t  net_pkt_ipv6_next_hdr(pkt));\n\t}\n\n\tclone_pkt_cb(pkt, clone_pkt);\n}\n",
                {
                    "2032": "static void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)",
                    "2033": "{",
                    "2034": "\tnet_pkt_set_family(clone_pkt, net_pkt_family(pkt));",
                    "2035": "\tnet_pkt_set_context(clone_pkt, net_pkt_context(pkt));",
                    "2036": "\tnet_pkt_set_ip_hdr_len(clone_pkt, net_pkt_ip_hdr_len(pkt));",
                    "2037": "\tnet_pkt_set_ip_dscp(clone_pkt, net_pkt_ip_dscp(pkt));",
                    "2038": "\tnet_pkt_set_ip_ecn(clone_pkt, net_pkt_ip_ecn(pkt));",
                    "2039": "\tnet_pkt_set_vlan_tag(clone_pkt, net_pkt_vlan_tag(pkt));",
                    "2040": "\tnet_pkt_set_timestamp(clone_pkt, net_pkt_timestamp(pkt));",
                    "2041": "\tnet_pkt_set_priority(clone_pkt, net_pkt_priority(pkt));",
                    "2042": "\tnet_pkt_set_orig_iface(clone_pkt, net_pkt_orig_iface(pkt));",
                    "2043": "\tnet_pkt_set_captured(clone_pkt, net_pkt_is_captured(pkt));",
                    "2044": "\tnet_pkt_set_eof(clone_pkt, net_pkt_eof(pkt));",
                    "2045": "\tnet_pkt_set_ptp(clone_pkt, net_pkt_is_ptp(pkt));",
                    "2046": "\tnet_pkt_set_ppp(clone_pkt, net_pkt_is_ppp(pkt));",
                    "2047": "\tnet_pkt_set_lldp(clone_pkt, net_pkt_is_lldp(pkt));",
                    "2048": "\tnet_pkt_set_ipv4_acd(clone_pkt, net_pkt_ipv4_acd(pkt));",
                    "2049": "\tnet_pkt_set_tx_timestamping(clone_pkt, net_pkt_is_tx_timestamping(pkt));",
                    "2050": "\tnet_pkt_set_rx_timestamping(clone_pkt, net_pkt_is_rx_timestamping(pkt));",
                    "2051": "\tnet_pkt_set_forwarding(clone_pkt, net_pkt_forwarding(pkt));",
                    "2052": "\tnet_pkt_set_chksum_done(clone_pkt, net_pkt_is_chksum_done(pkt));",
                    "2053": "\tnet_pkt_set_loopback(pkt, net_pkt_is_loopback(pkt));",
                    "2054": "\tnet_pkt_set_ip_reassembled(pkt, net_pkt_is_ip_reassembled(pkt));",
                    "2055": "\tnet_pkt_set_cooked_mode(clone_pkt, net_pkt_is_cooked_mode(pkt));",
                    "2056": "\tnet_pkt_set_ipv4_pmtu(clone_pkt, net_pkt_ipv4_pmtu(pkt));",
                    "2057": "\tnet_pkt_set_l2_bridged(clone_pkt, net_pkt_is_l2_bridged(pkt));",
                    "2058": "\tnet_pkt_set_l2_processed(clone_pkt, net_pkt_is_l2_processed(pkt));",
                    "2059": "\tnet_pkt_set_ll_proto_type(clone_pkt, net_pkt_ll_proto_type(pkt));",
                    "2060": "",
                    "2061": "#if defined(CONFIG_NET_OFFLOAD) || defined(CONFIG_NET_L2_IPIP)",
                    "2062": "\tnet_pkt_set_remote_address(clone_pkt, net_pkt_remote_address(pkt),",
                    "2063": "\t\t\t\t   sizeof(struct net_sockaddr_storage));",
                    "2064": "#endif",
                    "2065": "",
                    "2066": "\tif (pkt->buffer && clone_pkt->buffer) {",
                    "2067": "\t\tmemcpy(net_pkt_lladdr_src(clone_pkt), net_pkt_lladdr_src(pkt),",
                    "2068": "\t\t       sizeof(struct net_linkaddr));",
                    "2069": "\t\tmemcpy(net_pkt_lladdr_dst(clone_pkt), net_pkt_lladdr_dst(pkt),",
                    "2070": "\t\t       sizeof(struct net_linkaddr));",
                    "2071": "\t}",
                    "2072": "",
                    "2073": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == NET_AF_INET) {",
                    "2074": "\t\tnet_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));",
                    "2075": "\t\tnet_pkt_set_ipv4_opts_len(clone_pkt,",
                    "2076": "\t\t\t\t\t  net_pkt_ipv4_opts_len(pkt));",
                    "2077": "\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "2078": "\t\t   net_pkt_family(pkt) == NET_AF_INET6) {",
                    "2079": "\t\tnet_pkt_set_ipv6_hop_limit(clone_pkt,",
                    "2080": "\t\t\t\t\t   net_pkt_ipv6_hop_limit(pkt));",
                    "2081": "\t\tnet_pkt_set_ipv6_ext_len(clone_pkt, net_pkt_ipv6_ext_len(pkt));",
                    "2082": "\t\tnet_pkt_set_ipv6_ext_opt_len(clone_pkt,",
                    "2083": "\t\t\t\t\t     net_pkt_ipv6_ext_opt_len(pkt));",
                    "2084": "\t\tnet_pkt_set_ipv6_hdr_prev(clone_pkt,",
                    "2085": "\t\t\t\t\t  net_pkt_ipv6_hdr_prev(pkt));",
                    "2086": "\t\tnet_pkt_set_ipv6_next_hdr(clone_pkt,",
                    "2087": "\t\t\t\t\t  net_pkt_ipv6_next_hdr(pkt));",
                    "2088": "\t}",
                    "2089": "",
                    "2090": "\tclone_pkt_cb(pkt, clone_pkt);",
                    "2091": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_cursor_operate": {
            "name": "net_pkt_cursor_operate",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1835,
            "function_content": [
                "/* Internal function that does all operation (skip/read/write/memset) */\nstatic int net_pkt_cursor_operate(struct net_pkt *pkt,\n\t\t\t\t  void *data, size_t length,\n\t\t\t\t  bool copy, bool write)\n{\n\t/* We use such variable to avoid lengthy lines */\n\tstruct net_pkt_cursor *c_op = &pkt->cursor;\n\n\twhile (c_op->buf && length) {\n\t\tsize_t d_len, len;\n\n\t\tpkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?\n\t\t\t\t   false : write);\n\t\tif (c_op->buf == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {\n\t\t\td_len = net_buf_max_len(c_op->buf) -\n\t\t\t\t(c_op->pos - c_op->buf->data);\n\t\t} else {\n\t\t\td_len = c_op->buf->len - (c_op->pos - c_op->buf->data);\n\t\t}\n\n\t\tif (!d_len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (length < d_len) {\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tlen = d_len;\n\t\t}\n\n\t\tif (copy && data) {\n\t\t\tmemcpy(write ? c_op->pos : data,\n\t\t\t       write ? data : c_op->pos,\n\t\t\t       len);\n\t\t} else if (data) {\n\t\t\tmemset(c_op->pos, *(int *)data, len);\n\t\t}\n\n\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {\n\t\t\tnet_buf_add(c_op->buf, len);\n\t\t}\n\n\t\tpkt_cursor_update(pkt, len, write);\n\n\t\tif (copy && data) {\n\t\t\tdata = (uint8_t *) data + len;\n\t\t}\n\n\t\tlength -= len;\n\t}\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1835": "static int net_pkt_cursor_operate(struct net_pkt *pkt,",
                    "1836": "\t\t\t\t  void *data, size_t length,",
                    "1837": "\t\t\t\t  bool copy, bool write)",
                    "1838": "{",
                    "1839": "\t/* We use such variable to avoid lengthy lines */",
                    "1840": "\tstruct net_pkt_cursor *c_op = &pkt->cursor;",
                    "1841": "",
                    "1842": "\twhile (c_op->buf && length) {",
                    "1843": "\t\tsize_t d_len, len;",
                    "1844": "",
                    "1845": "\t\tpkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?",
                    "1846": "\t\t\t\t   false : write);",
                    "1847": "\t\tif (c_op->buf == NULL) {",
                    "1848": "\t\t\tbreak;",
                    "1849": "\t\t}",
                    "1850": "",
                    "1851": "\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {",
                    "1852": "\t\t\td_len = net_buf_max_len(c_op->buf) -",
                    "1853": "\t\t\t\t(c_op->pos - c_op->buf->data);",
                    "1854": "\t\t} else {",
                    "1855": "\t\t\td_len = c_op->buf->len - (c_op->pos - c_op->buf->data);",
                    "1856": "\t\t}",
                    "1857": "",
                    "1858": "\t\tif (!d_len) {",
                    "1859": "\t\t\tbreak;",
                    "1860": "\t\t}",
                    "1861": "",
                    "1862": "\t\tif (length < d_len) {",
                    "1863": "\t\t\tlen = length;",
                    "1864": "\t\t} else {",
                    "1865": "\t\t\tlen = d_len;",
                    "1866": "\t\t}",
                    "1867": "",
                    "1868": "\t\tif (copy && data) {",
                    "1869": "\t\t\tmemcpy(write ? c_op->pos : data,",
                    "1870": "\t\t\t       write ? data : c_op->pos,",
                    "1871": "\t\t\t       len);",
                    "1872": "\t\t} else if (data) {",
                    "1873": "\t\t\tmemset(c_op->pos, *(int *)data, len);",
                    "1874": "\t\t}",
                    "1875": "",
                    "1876": "\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {",
                    "1877": "\t\t\tnet_buf_add(c_op->buf, len);",
                    "1878": "\t\t}",
                    "1879": "",
                    "1880": "\t\tpkt_cursor_update(pkt, len, write);",
                    "1881": "",
                    "1882": "\t\tif (copy && data) {",
                    "1883": "\t\t\tdata = (uint8_t *) data + len;",
                    "1884": "\t\t}",
                    "1885": "",
                    "1886": "\t\tlength -= len;",
                    "1887": "\t}",
                    "1888": "",
                    "1889": "\tif (length) {",
                    "1890": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "1891": "\t\treturn -ENOBUFS;",
                    "1892": "\t}",
                    "1893": "",
                    "1894": "\treturn 0;",
                    "1895": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_update": {
            "name": "pkt_cursor_update",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1814,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_update(struct net_pkt *pkt,\n\t\t\t      size_t length, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\tsize_t len;\n\n\tif (net_pkt_is_being_overwritten(pkt)) {\n\t\twrite = false;\n\t}\n\n\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\tif (length + (cursor->pos - cursor->buf->data) == len &&\n\t    !(net_pkt_is_being_overwritten(pkt) &&\n\t      len < net_buf_max_len(cursor->buf))) {\n\t\tpkt_cursor_jump(pkt, write);\n\t} else {\n\t\tcursor->pos += length;\n\t}\n}\n",
                {
                    "1814": "static void pkt_cursor_update(struct net_pkt *pkt,",
                    "1815": "\t\t\t      size_t length, bool write)",
                    "1816": "{",
                    "1817": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1818": "\tsize_t len;",
                    "1819": "",
                    "1820": "\tif (net_pkt_is_being_overwritten(pkt)) {",
                    "1821": "\t\twrite = false;",
                    "1822": "\t}",
                    "1823": "",
                    "1824": "\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1825": "\tif (length + (cursor->pos - cursor->buf->data) == len &&",
                    "1826": "\t    !(net_pkt_is_being_overwritten(pkt) &&",
                    "1827": "\t      len < net_buf_max_len(cursor->buf))) {",
                    "1828": "\t\tpkt_cursor_jump(pkt, write);",
                    "1829": "\t} else {",
                    "1830": "\t\tcursor->pos += length;",
                    "1831": "\t}",
                    "1832": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_advance": {
            "name": "pkt_cursor_advance",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1799,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_advance(struct net_pkt *pkt, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\tsize_t len;\n\n\tif (!cursor->buf) {\n\t\treturn;\n\t}\n\n\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\tif ((cursor->pos - cursor->buf->data) == len) {\n\t\tpkt_cursor_jump(pkt, write);\n\t}\n}\n",
                {
                    "1799": "static void pkt_cursor_advance(struct net_pkt *pkt, bool write)",
                    "1800": "{",
                    "1801": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1802": "\tsize_t len;",
                    "1803": "",
                    "1804": "\tif (!cursor->buf) {",
                    "1805": "\t\treturn;",
                    "1806": "\t}",
                    "1807": "",
                    "1808": "\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1809": "\tif ((cursor->pos - cursor->buf->data) == len) {",
                    "1810": "\t\tpkt_cursor_jump(pkt, write);",
                    "1811": "\t}",
                    "1812": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_jump": {
            "name": "pkt_cursor_jump",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1776,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_jump(struct net_pkt *pkt, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\n\tcursor->buf = cursor->buf->frags;\n\twhile (cursor->buf) {\n\t\tconst size_t len =\n\t\t\twrite ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\n\t\tif (!len) {\n\t\t\tcursor->buf = cursor->buf->frags;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cursor->buf) {\n\t\tcursor->pos = cursor->buf->data;\n\t} else {\n\t\tcursor->pos = NULL;\n\t}\n}\n",
                {
                    "1776": "static void pkt_cursor_jump(struct net_pkt *pkt, bool write)",
                    "1777": "{",
                    "1778": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1779": "",
                    "1780": "\tcursor->buf = cursor->buf->frags;",
                    "1781": "\twhile (cursor->buf) {",
                    "1782": "\t\tconst size_t len =",
                    "1783": "\t\t\twrite ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1784": "",
                    "1785": "\t\tif (!len) {",
                    "1786": "\t\t\tcursor->buf = cursor->buf->frags;",
                    "1787": "\t\t} else {",
                    "1788": "\t\t\tbreak;",
                    "1789": "\t\t}",
                    "1790": "\t}",
                    "1791": "",
                    "1792": "\tif (cursor->buf) {",
                    "1793": "\t\tcursor->pos = cursor->buf->data;",
                    "1794": "\t} else {",
                    "1795": "\t\tcursor->pos = NULL;",
                    "1796": "\t}",
                    "1797": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_get_max_len": {
            "name": "pkt_get_max_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1155,
            "function_content": [
                "/* + protocol header */\nstatic size_t pkt_get_max_len(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf = pkt->buffer;\n\tsize_t size = 0;\n\n\twhile (buf) {\n\t\tsize += net_buf_max_len(buf);\n\t\tbuf = buf->frags;\n\t}\n\n\treturn size;\n}\n",
                {
                    "1155": "static size_t pkt_get_max_len(struct net_pkt *pkt)",
                    "1156": "{",
                    "1157": "\tstruct net_buf *buf = pkt->buffer;",
                    "1158": "\tsize_t size = 0;",
                    "1159": "",
                    "1160": "\twhile (buf) {",
                    "1161": "\t\tsize += net_buf_max_len(buf);",
                    "1162": "\t\tbuf = buf->frags;",
                    "1163": "\t}",
                    "1164": "",
                    "1165": "\treturn size;",
                    "1166": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_alloc_buffer": {
            "name": "pkt_alloc_buffer",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 934,
            "function_content": [
                "#endif /* CONFIG_NET_PKT_ALLOC_STATS */\nstatic struct net_buf *pkt_alloc_buffer(struct net_pkt *pkt,\n\t\t\t\t\tstruct net_buf_pool *pool,\n\t\t\t\t\tsize_t size, size_t headroom,\n\t\t\t\t\tk_timeout_t timeout)\n#endif\n{\n#if defined(CONFIG_NET_PKT_ALLOC_STATS)\n\tuint32_t start_time = k_cycle_get_32();\n\tsize_t total_size = size;\n#else\n\tARG_UNUSED(pkt);\n#endif\n\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tstruct net_buf *first = NULL;\n\tstruct net_buf *current = NULL;\n\n\tdo {\n\t\tstruct net_buf *new;\n\n\t\tnew = net_buf_alloc_fixed(pool, timeout);\n\t\tif (!new) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!first && !current) {\n\t\t\tfirst = new;\n\t\t} else {\n\t\t\tcurrent->frags = new;\n\t\t}\n\n\t\tcurrent = new;\n\n\t\t/* If there is headroom reserved, then allocate that to the\n\t\t * first buf.\n\t\t */\n\t\tif (current == first && headroom > 0) {\n\t\t\tif (current->size > (headroom + size)) {\n\t\t\t\tcurrent->size = size + headroom;\n\n\t\t\t\tsize = 0U;\n\t\t\t} else {\n\t\t\t\tsize -= current->size - headroom;\n\t\t\t}\n\t\t} else {\n\t\t\tif (current->size > size) {\n\t\t\t\tcurrent->size = size;\n\t\t\t}\n\n\t\t\tsize -= current->size;\n\t\t}\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\n#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_FRAG_CHECK_IF_NOT_IN_USE(new, new->ref + 1);\n\n\t\tnet_pkt_alloc_add(new, false, caller, line);\n\n\t\tNET_DBG(\"%s (%s) [%d] frag %p ref %d (%s():%d)\",\n\t\t\tpool2str(pool), get_name(pool), get_frees(pool),\n\t\t\tnew, new->ref, caller, line);\n#endif\n\t} while (size);\n\n#if defined(CONFIG_NET_PKT_ALLOC_STATS)\n\tif (NET_PKT_ALLOC_STATS_UPDATE(pkt, total_size, start_time) == 0) {\n\t\tNET_DBG(\"pkt %p %s stats rollover\", pkt, \"ok\");\n\t}\n#endif\n\n\treturn first;\nerror:\n\tif (first) {\n\t\tnet_buf_unref(first);\n\t}\n\n#if defined(CONFIG_NET_PKT_ALLOC_STATS)\n\tif (NET_PKT_ALLOC_STATS_FAIL(pkt, total_size, start_time) == 0) {\n\t\tNET_DBG(\"pkt %p %s stats rollover\", pkt, \"fail\");\n\t}\n#endif\n\n\treturn NULL;\n}\n",
                {
                    "934": "static struct net_buf *pkt_alloc_buffer(struct net_pkt *pkt,",
                    "935": "\t\t\t\t\tstruct net_buf_pool *pool,",
                    "936": "\t\t\t\t\tsize_t size, size_t headroom,",
                    "937": "\t\t\t\t\tk_timeout_t timeout)",
                    "938": "#endif",
                    "939": "{",
                    "940": "#if defined(CONFIG_NET_PKT_ALLOC_STATS)",
                    "941": "\tuint32_t start_time = k_cycle_get_32();",
                    "942": "\tsize_t total_size = size;",
                    "943": "#else",
                    "944": "\tARG_UNUSED(pkt);",
                    "945": "#endif",
                    "946": "",
                    "947": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "948": "\tstruct net_buf *first = NULL;",
                    "949": "\tstruct net_buf *current = NULL;",
                    "950": "",
                    "951": "\tdo {",
                    "952": "\t\tstruct net_buf *new;",
                    "953": "",
                    "954": "\t\tnew = net_buf_alloc_fixed(pool, timeout);",
                    "955": "\t\tif (!new) {",
                    "956": "\t\t\tgoto error;",
                    "957": "\t\t}",
                    "958": "",
                    "959": "\t\tif (!first && !current) {",
                    "960": "\t\t\tfirst = new;",
                    "961": "\t\t} else {",
                    "962": "\t\t\tcurrent->frags = new;",
                    "963": "\t\t}",
                    "964": "",
                    "965": "\t\tcurrent = new;",
                    "966": "",
                    "967": "\t\t/* If there is headroom reserved, then allocate that to the",
                    "968": "\t\t * first buf.",
                    "969": "\t\t */",
                    "970": "\t\tif (current == first && headroom > 0) {",
                    "971": "\t\t\tif (current->size > (headroom + size)) {",
                    "972": "\t\t\t\tcurrent->size = size + headroom;",
                    "973": "",
                    "974": "\t\t\t\tsize = 0U;",
                    "975": "\t\t\t} else {",
                    "976": "\t\t\t\tsize -= current->size - headroom;",
                    "977": "\t\t\t}",
                    "978": "\t\t} else {",
                    "979": "\t\t\tif (current->size > size) {",
                    "980": "\t\t\t\tcurrent->size = size;",
                    "981": "\t\t\t}",
                    "982": "",
                    "983": "\t\t\tsize -= current->size;",
                    "984": "\t\t}",
                    "985": "",
                    "986": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "987": "",
                    "988": "#if CONFIG_NET_PKT_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "989": "\t\tNET_FRAG_CHECK_IF_NOT_IN_USE(new, new->ref + 1);",
                    "990": "",
                    "991": "\t\tnet_pkt_alloc_add(new, false, caller, line);",
                    "992": "",
                    "993": "\t\tNET_DBG(\"%s (%s) [%d] frag %p ref %d (%s():%d)\",",
                    "994": "\t\t\tpool2str(pool), get_name(pool), get_frees(pool),",
                    "995": "\t\t\tnew, new->ref, caller, line);",
                    "996": "#endif",
                    "997": "\t} while (size);",
                    "998": "",
                    "999": "#if defined(CONFIG_NET_PKT_ALLOC_STATS)",
                    "1000": "\tif (NET_PKT_ALLOC_STATS_UPDATE(pkt, total_size, start_time) == 0) {",
                    "1001": "\t\tNET_DBG(\"pkt %p %s stats rollover\", pkt, \"ok\");",
                    "1002": "\t}",
                    "1003": "#endif",
                    "1004": "",
                    "1005": "\treturn first;",
                    "1006": "error:",
                    "1007": "\tif (first) {",
                    "1008": "\t\tnet_buf_unref(first);",
                    "1009": "\t}",
                    "1010": "",
                    "1011": "#if defined(CONFIG_NET_PKT_ALLOC_STATS)",
                    "1012": "\tif (NET_PKT_ALLOC_STATS_FAIL(pkt, total_size, start_time) == 0) {",
                    "1013": "\t\tNET_DBG(\"pkt %p %s stats rollover\", pkt, \"fail\");",
                    "1014": "\t}",
                    "1015": "#endif",
                    "1016": "",
                    "1017": "\treturn NULL;",
                    "1018": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_calc_chksum": {
            "name": "net_calc_chksum",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 687,
            "function_content": [
                "/* Sum in is in host endianness, working order endianness is both dependent on endianness\n* and the offset of starting\n*/\nuint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)\n{\n\tsize_t len = 0U;\n\tuint16_t sum = 0U;\n\tstruct net_pkt_cursor backup;\n\tbool ow;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t    net_pkt_family(pkt) == NET_AF_INET) {\n\t\tif (proto != NET_IPPROTO_ICMP && proto != NET_IPPROTO_IGMP) {\n\t\t\tlen = 2 * sizeof(struct net_in_addr);\n\t\t\tsum = net_pkt_get_len(pkt) -\n\t\t\t\tnet_pkt_ip_hdr_len(pkt) -\n\t\t\t\tnet_pkt_ipv4_opts_len(pkt) + proto;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t   net_pkt_family(pkt) == NET_AF_INET6) {\n\t\tlen = 2 * sizeof(struct net_in6_addr);\n\t\tsum =  net_pkt_get_len(pkt) -\n\t\t\tnet_pkt_ip_hdr_len(pkt) -\n\t\t\tnet_pkt_ipv6_ext_len(pkt) + proto;\n\t} else {\n\t\tNET_DBG(\"Unknown protocol family %d\", net_pkt_family(pkt));\n\t\treturn 0;\n\t}\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tow = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);\n\n\tsum = calc_chksum(sum, pkt->cursor.pos, len);\n\tnet_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));\n\n\tsum = pkt_calc_chksum(pkt, sum);\n\n\tsum = (sum == 0U) ? 0xffff : net_htons(sum);\n\n\tnet_pkt_cursor_restore(pkt, &backup);\n\n\tnet_pkt_set_overwrite(pkt, ow);\n\n\treturn ~sum;\n}\n",
                {
                    "687": "uint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)",
                    "688": "{",
                    "689": "\tsize_t len = 0U;",
                    "690": "\tuint16_t sum = 0U;",
                    "691": "\tstruct net_pkt_cursor backup;",
                    "692": "\tbool ow;",
                    "693": "",
                    "694": "\tif (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "695": "\t    net_pkt_family(pkt) == NET_AF_INET) {",
                    "696": "\t\tif (proto != NET_IPPROTO_ICMP && proto != NET_IPPROTO_IGMP) {",
                    "697": "\t\t\tlen = 2 * sizeof(struct net_in_addr);",
                    "698": "\t\t\tsum = net_pkt_get_len(pkt) -",
                    "699": "\t\t\t\tnet_pkt_ip_hdr_len(pkt) -",
                    "700": "\t\t\t\tnet_pkt_ipv4_opts_len(pkt) + proto;",
                    "701": "\t\t}",
                    "702": "\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "703": "\t\t   net_pkt_family(pkt) == NET_AF_INET6) {",
                    "704": "\t\tlen = 2 * sizeof(struct net_in6_addr);",
                    "705": "\t\tsum =  net_pkt_get_len(pkt) -",
                    "706": "\t\t\tnet_pkt_ip_hdr_len(pkt) -",
                    "707": "\t\t\tnet_pkt_ipv6_ext_len(pkt) + proto;",
                    "708": "\t} else {",
                    "709": "\t\tNET_DBG(\"Unknown protocol family %d\", net_pkt_family(pkt));",
                    "710": "\t\treturn 0;",
                    "711": "\t}",
                    "712": "",
                    "713": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "714": "\tnet_pkt_cursor_init(pkt);",
                    "715": "",
                    "716": "\tow = net_pkt_is_being_overwritten(pkt);",
                    "717": "\tnet_pkt_set_overwrite(pkt, true);",
                    "718": "",
                    "719": "\tnet_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);",
                    "720": "",
                    "721": "\tsum = calc_chksum(sum, pkt->cursor.pos, len);",
                    "722": "\tnet_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));",
                    "723": "",
                    "724": "\tsum = pkt_calc_chksum(pkt, sum);",
                    "725": "",
                    "726": "\tsum = (sum == 0U) ? 0xffff : net_htons(sum);",
                    "727": "",
                    "728": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "729": "",
                    "730": "\tnet_pkt_set_overwrite(pkt, ow);",
                    "731": "",
                    "732": "\treturn ~sum;",
                    "733": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_route_lookup": {
            "name": "net_route_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/route.c",
            "location_line": 270,
            "function_content": [
                "/* Route was accessed, so place it in front of the routes list */\nstruct net_route_entry *net_route_lookup(struct net_if *iface,\n\t\t\t\t\t struct net_in6_addr *dst)\n{\n\tstruct net_route_entry *route, *found = NULL;\n\tuint8_t longest_match = 0U;\n\tint i;\n\n\tnet_ipv6_nbr_lock();\n\n\tfor (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {\n\t\tstruct net_nbr *nbr = get_nbr(i);\n\n\t\tif (!nbr->ref) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iface && nbr->iface != iface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\troute = net_route_data(nbr);\n\n\t\tif (route->prefix_len >= longest_match &&\n\t\t    net_ipv6_is_prefix(dst->s6_addr,\n\t\t\t\t       route->addr.s6_addr,\n\t\t\t\t       route->prefix_len)) {\n\t\t\tfound = route;\n\t\t\tlongest_match = route->prefix_len;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tnet_route_info(\"Found\", found, dst);\n\n\t\tupdate_route_access(found);\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\treturn found;\n}\n",
                {
                    "270": "struct net_route_entry *net_route_lookup(struct net_if *iface,",
                    "271": "\t\t\t\t\t struct net_in6_addr *dst)",
                    "272": "{",
                    "273": "\tstruct net_route_entry *route, *found = NULL;",
                    "274": "\tuint8_t longest_match = 0U;",
                    "275": "\tint i;",
                    "276": "",
                    "277": "\tnet_ipv6_nbr_lock();",
                    "278": "",
                    "279": "\tfor (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {",
                    "280": "\t\tstruct net_nbr *nbr = get_nbr(i);",
                    "281": "",
                    "282": "\t\tif (!nbr->ref) {",
                    "283": "\t\t\tcontinue;",
                    "284": "\t\t}",
                    "285": "",
                    "286": "\t\tif (iface && nbr->iface != iface) {",
                    "287": "\t\t\tcontinue;",
                    "288": "\t\t}",
                    "289": "",
                    "290": "\t\troute = net_route_data(nbr);",
                    "291": "",
                    "292": "\t\tif (route->prefix_len >= longest_match &&",
                    "293": "\t\t    net_ipv6_is_prefix(dst->s6_addr,",
                    "294": "\t\t\t\t       route->addr.s6_addr,",
                    "295": "\t\t\t\t       route->prefix_len)) {",
                    "296": "\t\t\tfound = route;",
                    "297": "\t\t\tlongest_match = route->prefix_len;",
                    "298": "\t\t}",
                    "299": "\t}",
                    "300": "",
                    "301": "\tif (found) {",
                    "302": "\t\tnet_route_info(\"Found\", found, dst);",
                    "303": "",
                    "304": "\t\tupdate_route_access(found);",
                    "305": "\t}",
                    "306": "",
                    "307": "\tnet_ipv6_nbr_unlock();",
                    "308": "\treturn found;",
                    "309": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_send": {
            "name": "ethernet_send",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 682,
            "function_content": [
                "/* Make room for the header */\nstatic int ethernet_send(struct net_if *iface, struct net_pkt *pkt)\n{\n\tconst struct ethernet_api *api = net_if_get_device(iface)->api;\n\tstruct ethernet_context *ctx = net_if_l2_data(iface);\n\tuint16_t ptype = net_htons(net_pkt_ll_proto_type(pkt));\n\tstruct net_pkt *orig_pkt = pkt;\n\tint ret;\n\n\tif (!api) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\n\tif (!api->send) {\n\t\tret = -ENOTSUP;\n\t\tgoto error;\n\t}\n\n\t/* We are trying to send a packet that is from bridge interface,\n\t * so all the bits and pieces should be there (like Ethernet header etc)\n\t * so just send it.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_pkt_is_l2_bridged(pkt)) {\n\t\tgoto send;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == NET_AF_INET &&\n\t    net_pkt_ll_proto_type(pkt) == NET_ETH_PTYPE_IP) {\n\t\tif (!net_pkt_ipv4_acd(pkt)) {\n\t\t\tstruct net_pkt *arp;\n\n\t\t\tret = ethernet_ll_prepare_on_ipv4(iface, pkt, &arp);\n\t\t\tif (ret == NET_ARP_COMPLETE) {\n\t\t\t\t/* ARP resolution complete, packet ready to send */\n\t\t\t\tNET_DBG(\"Found ARP entry, sending pkt %p to iface %d (%p)\",\n\t\t\t\t\tpkt, net_if_get_by_iface(iface), iface);\n\t\t\t} else if (ret == NET_ARP_PKT_REPLACED) {\n\t\t\t\t/* Original pkt got queued and is replaced\n\t\t\t\t * by an ARP request packet.\n\t\t\t\t */\n\t\t\t\tNET_DBG(\"Sending arp pkt %p (orig %p) to iface %d (%p)\",\n\t\t\t\t\tarp, pkt, net_if_get_by_iface(iface), iface);\n\t\t\t\tnet_pkt_unref(pkt);\n\t\t\t\tpkt = arp;\n\t\t\t\tptype = net_htons(net_pkt_ll_proto_type(pkt));\n\t\t\t} else if (ret == NET_ARP_PKT_QUEUED) {\n\t\t\t\t/* Original pkt got queued, pending resolution\n\t\t\t\t * of an ongoing ARP request.\n\t\t\t\t */\n\t\t\t\tNET_DBG(\"Pending ARP request, pkt %p queued\", pkt);\n\t\t\t\tnet_pkt_unref(pkt);\n\t\t\t\tret = 0;\n\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\t__ASSERT_NO_MSG(ret < 0);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&\n\t\t   net_pkt_family(pkt) == NET_AF_PACKET) {\n\t\tstruct net_context *context = net_pkt_context(pkt);\n\n\t\tif (!(context && net_context_get_type(context) == NET_SOCK_DGRAM)) {\n\t\t\t/* Raw packet, just send it */\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tif (ptype == 0) {\n\t\t/* Caller of this function has not set the ptype */\n\t\tNET_ERR(\"No protocol set for pkt %p\", pkt);\n\t\tret = -ENOTSUP;\n\t\tgoto error;\n\t}\n\n\t/* If the ll dst addr has not been set before, let's assume\n\t * temporarily it's a broadcast one. When filling the header,\n\t * it might detect this should be multicast and act accordingly.\n\t */\n\tif (net_pkt_lladdr_dst(pkt)->len == 0) {\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),\n\t\t\t\t       broadcast_eth_addr.addr,\n\t\t\t\t       sizeof(struct net_eth_addr));\n\t}\n\n\t/* Then set the ethernet header. Note that the iface parameter tells\n\t * where we are actually sending the packet. The interface in net_pkt\n\t * is used to determine if the VLAN header is added to Ethernet frame.\n\t */\n\tif (!ethernet_fill_header(ctx, iface, pkt, ptype)) {\n\t\tret = -ENOMEM;\n\t\tgoto arp_error;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\nsend:\n\tret = net_l2_send(api->send, net_if_get_device(iface), iface, pkt);\n\tif (ret != 0) {\n\t\teth_stats_update_errors_tx(iface);\n\t\tgoto arp_error;\n\t}\n\n\tethernet_update_tx_stats(iface, pkt);\n\n\tret = net_pkt_get_len(pkt);\n\n\tnet_pkt_unref(pkt);\nerror:\n\treturn ret;\n\narp_error:\n\tif (IS_ENABLED(CONFIG_NET_ARP) && ptype == net_htons(NET_ETH_PTYPE_ARP)) {\n\t\t/* Original packet was added to ARP's pending Q, so, to avoid it\n\t\t * being freed, take a reference, the reference is dropped when we\n\t\t * clear the pending Q in ARP and then it will be freed by net_if.\n\t\t */\n\t\tnet_pkt_ref(orig_pkt);\n\t\tif (net_arp_clear_pending(\n\t\t\t    iface, (struct net_in_addr *)NET_IPV4_HDR(pkt)->dst)) {\n\t\t\tNET_DBG(\"Could not find pending ARP entry\");\n\t\t}\n\t\t/* Free the ARP request */\n\t\tnet_pkt_unref(pkt);\n\t}\n\n\treturn ret;\n}\n",
                {
                    "682": "static int ethernet_send(struct net_if *iface, struct net_pkt *pkt)",
                    "683": "{",
                    "684": "\tconst struct ethernet_api *api = net_if_get_device(iface)->api;",
                    "685": "\tstruct ethernet_context *ctx = net_if_l2_data(iface);",
                    "686": "\tuint16_t ptype = net_htons(net_pkt_ll_proto_type(pkt));",
                    "687": "\tstruct net_pkt *orig_pkt = pkt;",
                    "688": "\tint ret;",
                    "689": "",
                    "690": "\tif (!api) {",
                    "691": "\t\tret = -ENOENT;",
                    "692": "\t\tgoto error;",
                    "693": "\t}",
                    "694": "",
                    "695": "\tif (!api->send) {",
                    "696": "\t\tret = -ENOTSUP;",
                    "697": "\t\tgoto error;",
                    "698": "\t}",
                    "699": "",
                    "700": "\t/* We are trying to send a packet that is from bridge interface,",
                    "701": "\t * so all the bits and pieces should be there (like Ethernet header etc)",
                    "702": "\t * so just send it.",
                    "703": "\t */",
                    "704": "\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_pkt_is_l2_bridged(pkt)) {",
                    "705": "\t\tgoto send;",
                    "706": "\t}",
                    "707": "",
                    "708": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == NET_AF_INET &&",
                    "709": "\t    net_pkt_ll_proto_type(pkt) == NET_ETH_PTYPE_IP) {",
                    "710": "\t\tif (!net_pkt_ipv4_acd(pkt)) {",
                    "711": "\t\t\tstruct net_pkt *arp;",
                    "712": "",
                    "713": "\t\t\tret = ethernet_ll_prepare_on_ipv4(iface, pkt, &arp);",
                    "714": "\t\t\tif (ret == NET_ARP_COMPLETE) {",
                    "715": "\t\t\t\t/* ARP resolution complete, packet ready to send */",
                    "716": "\t\t\t\tNET_DBG(\"Found ARP entry, sending pkt %p to iface %d (%p)\",",
                    "717": "\t\t\t\t\tpkt, net_if_get_by_iface(iface), iface);",
                    "718": "\t\t\t} else if (ret == NET_ARP_PKT_REPLACED) {",
                    "719": "\t\t\t\t/* Original pkt got queued and is replaced",
                    "720": "\t\t\t\t * by an ARP request packet.",
                    "721": "\t\t\t\t */",
                    "722": "\t\t\t\tNET_DBG(\"Sending arp pkt %p (orig %p) to iface %d (%p)\",",
                    "723": "\t\t\t\t\tarp, pkt, net_if_get_by_iface(iface), iface);",
                    "724": "\t\t\t\tnet_pkt_unref(pkt);",
                    "725": "\t\t\t\tpkt = arp;",
                    "726": "\t\t\t\tptype = net_htons(net_pkt_ll_proto_type(pkt));",
                    "727": "\t\t\t} else if (ret == NET_ARP_PKT_QUEUED) {",
                    "728": "\t\t\t\t/* Original pkt got queued, pending resolution",
                    "729": "\t\t\t\t * of an ongoing ARP request.",
                    "730": "\t\t\t\t */",
                    "731": "\t\t\t\tNET_DBG(\"Pending ARP request, pkt %p queued\", pkt);",
                    "732": "\t\t\t\tnet_pkt_unref(pkt);",
                    "733": "\t\t\t\tret = 0;",
                    "734": "\t\t\t\tgoto error;",
                    "735": "\t\t\t} else {",
                    "736": "\t\t\t\t__ASSERT_NO_MSG(ret < 0);",
                    "737": "\t\t\t\tgoto error;",
                    "738": "\t\t\t}",
                    "739": "\t\t}",
                    "740": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&",
                    "741": "\t\t   net_pkt_family(pkt) == NET_AF_PACKET) {",
                    "742": "\t\tstruct net_context *context = net_pkt_context(pkt);",
                    "743": "",
                    "744": "\t\tif (!(context && net_context_get_type(context) == NET_SOCK_DGRAM)) {",
                    "745": "\t\t\t/* Raw packet, just send it */",
                    "746": "\t\t\tgoto send;",
                    "747": "\t\t}",
                    "748": "\t}",
                    "749": "",
                    "750": "\tif (ptype == 0) {",
                    "751": "\t\t/* Caller of this function has not set the ptype */",
                    "752": "\t\tNET_ERR(\"No protocol set for pkt %p\", pkt);",
                    "753": "\t\tret = -ENOTSUP;",
                    "754": "\t\tgoto error;",
                    "755": "\t}",
                    "756": "",
                    "757": "\t/* If the ll dst addr has not been set before, let's assume",
                    "758": "\t * temporarily it's a broadcast one. When filling the header,",
                    "759": "\t * it might detect this should be multicast and act accordingly.",
                    "760": "\t */",
                    "761": "\tif (net_pkt_lladdr_dst(pkt)->len == 0) {",
                    "762": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),",
                    "763": "\t\t\t\t       broadcast_eth_addr.addr,",
                    "764": "\t\t\t\t       sizeof(struct net_eth_addr));",
                    "765": "\t}",
                    "766": "",
                    "767": "\t/* Then set the ethernet header. Note that the iface parameter tells",
                    "768": "\t * where we are actually sending the packet. The interface in net_pkt",
                    "769": "\t * is used to determine if the VLAN header is added to Ethernet frame.",
                    "770": "\t */",
                    "771": "\tif (!ethernet_fill_header(ctx, iface, pkt, ptype)) {",
                    "772": "\t\tret = -ENOMEM;",
                    "773": "\t\tgoto arp_error;",
                    "774": "\t}",
                    "775": "",
                    "776": "\tnet_pkt_cursor_init(pkt);",
                    "777": "",
                    "778": "send:",
                    "779": "\tret = net_l2_send(api->send, net_if_get_device(iface), iface, pkt);",
                    "780": "\tif (ret != 0) {",
                    "781": "\t\teth_stats_update_errors_tx(iface);",
                    "782": "\t\tgoto arp_error;",
                    "783": "\t}",
                    "784": "",
                    "785": "\tethernet_update_tx_stats(iface, pkt);",
                    "786": "",
                    "787": "\tret = net_pkt_get_len(pkt);",
                    "788": "",
                    "789": "\tnet_pkt_unref(pkt);",
                    "790": "error:",
                    "791": "\treturn ret;",
                    "792": "",
                    "793": "arp_error:",
                    "794": "\tif (IS_ENABLED(CONFIG_NET_ARP) && ptype == net_htons(NET_ETH_PTYPE_ARP)) {",
                    "795": "\t\t/* Original packet was added to ARP's pending Q, so, to avoid it",
                    "796": "\t\t * being freed, take a reference, the reference is dropped when we",
                    "797": "\t\t * clear the pending Q in ARP and then it will be freed by net_if.",
                    "798": "\t\t */",
                    "799": "\t\tnet_pkt_ref(orig_pkt);",
                    "800": "\t\tif (net_arp_clear_pending(",
                    "801": "\t\t\t    iface, (struct net_in_addr *)NET_IPV4_HDR(pkt)->dst)) {",
                    "802": "\t\t\tNET_DBG(\"Could not find pending ARP entry\");",
                    "803": "\t\t}",
                    "804": "\t\t/* Free the ARP request */",
                    "805": "\t\tnet_pkt_unref(pkt);",
                    "806": "\t}",
                    "807": "",
                    "808": "\treturn ret;",
                    "809": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_update_tx_stats": {
            "name": "ethernet_update_tx_stats",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 664,
            "function_content": [
                "/* Make room for the header */\nstatic void ethernet_update_tx_stats(struct net_if *iface, struct net_pkt *pkt)\n{\n\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\n\tif (!IS_ENABLED(CONFIG_NET_STATISTICS_ETHERNET)) {\n\t\treturn;\n\t}\n\n\teth_stats_update_bytes_tx(iface, net_pkt_get_len(pkt));\n\teth_stats_update_pkts_tx(iface);\n\n\tif (net_eth_is_addr_multicast(&hdr->dst)) {\n\t\teth_stats_update_multicast_tx(iface);\n\t} else if (net_eth_is_addr_broadcast(&hdr->dst)) {\n\t\teth_stats_update_broadcast_tx(iface);\n\t}\n}\n",
                {
                    "664": "static void ethernet_update_tx_stats(struct net_if *iface, struct net_pkt *pkt)",
                    "665": "{",
                    "666": "\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "667": "",
                    "668": "\tif (!IS_ENABLED(CONFIG_NET_STATISTICS_ETHERNET)) {",
                    "669": "\t\treturn;",
                    "670": "\t}",
                    "671": "",
                    "672": "\teth_stats_update_bytes_tx(iface, net_pkt_get_len(pkt));",
                    "673": "\teth_stats_update_pkts_tx(iface);",
                    "674": "",
                    "675": "\tif (net_eth_is_addr_multicast(&hdr->dst)) {",
                    "676": "\t\teth_stats_update_multicast_tx(iface);",
                    "677": "\t} else if (net_eth_is_addr_broadcast(&hdr->dst)) {",
                    "678": "\t\teth_stats_update_broadcast_tx(iface);",
                    "679": "\t}",
                    "680": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_fill_header": {
            "name": "ethernet_fill_header",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 566,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6 */\nstatic struct net_buf *ethernet_fill_header(struct ethernet_context *ctx,\n\t\t\t\t\t    struct net_if *iface,\n\t\t\t\t\t    struct net_pkt *pkt,\n\t\t\t\t\t    uint32_t ptype)\n{\n\tstruct net_if *orig_iface = iface;\n\tstruct net_buf *hdr_frag;\n\tstruct net_eth_hdr *hdr;\n\tsize_t reserve_ll_header;\n\tsize_t hdr_len;\n\tbool is_vlan;\n\n\tis_vlan = IS_ENABLED(CONFIG_NET_VLAN) &&\n\t\tnet_eth_is_vlan_enabled(ctx, iface) &&\n\t\tnet_pkt_vlan_tag(pkt) != NET_VLAN_TAG_UNSPEC;\n\tif (is_vlan) {\n\t\torig_iface = net_eth_get_vlan_iface(iface, net_pkt_vlan_tag(pkt));\n\t}\n\n\treserve_ll_header = get_reserve_ll_header_size(orig_iface);\n\tif (reserve_ll_header > 0) {\n\t\thdr_len = reserve_ll_header;\n\t\thdr_frag = pkt->buffer;\n\n\t\tNET_DBG(\"Making room for link header %zd bytes\", hdr_len);\n\n\t\t/* Make room for the header */\n\t\tnet_buf_push(pkt->buffer, hdr_len);\n\t} else {\n\t\thdr_len = IS_ENABLED(CONFIG_NET_VLAN) ?\n\t\t\tsizeof(struct net_eth_vlan_hdr) :\n\t\t\tsizeof(struct net_eth_hdr);\n\n\t\thdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);\n\t\tif (!hdr_frag) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_vlan) {\n\t\tstruct net_eth_vlan_hdr *hdr_vlan;\n\n\t\tif (reserve_ll_header == 0U) {\n\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);\n\t\t\tnet_buf_add(hdr_frag, hdr_len);\n\t\t}\n\n\t\thdr_vlan = (struct net_eth_vlan_hdr *)(hdr_frag->data);\n\n\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||\n\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr_vlan->dst) &&\n\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr_vlan->dst))) {\n\t\t\tmemcpy(&hdr_vlan->dst, net_pkt_lladdr_dst(pkt)->addr,\n\t\t\t       sizeof(struct net_eth_addr));\n\t\t}\n\n\t\tmemcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,\n\t\t       sizeof(struct net_eth_addr));\n\n\t\thdr_vlan->type = ptype;\n\t\thdr_vlan->vlan.tpid = net_htons(NET_ETH_PTYPE_VLAN);\n\t\thdr_vlan->vlan.tci = net_htons(net_pkt_vlan_tci(pkt));\n\n\t\tprint_vlan_ll_addrs(pkt, net_ntohs(hdr_vlan->type),\n\t\t\t\t    net_pkt_vlan_tci(pkt),\n\t\t\t\t    hdr_len,\n\t\t\t\t    &hdr_vlan->src, &hdr_vlan->dst, false);\n\t} else {\n\t\thdr = (struct net_eth_hdr *)(hdr_frag->data);\n\n\t\tif (reserve_ll_header == 0U) {\n\t\t\thdr_len = sizeof(struct net_eth_hdr);\n\t\t\tnet_buf_add(hdr_frag, hdr_len);\n\t\t}\n\n\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||\n\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr->dst) &&\n\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr->dst))) {\n\t\t\tmemcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,\n\t\t\t       sizeof(struct net_eth_addr));\n\t\t}\n\n\t\tmemcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,\n\t\t       sizeof(struct net_eth_addr));\n\n\t\thdr->type = ptype;\n\n\t\tprint_ll_addrs(pkt, net_ntohs(hdr->type),\n\t\t\t       hdr_len, &hdr->src, &hdr->dst);\n\t}\n\n\tif (reserve_ll_header == 0U) {\n\t\tnet_pkt_frag_insert(pkt, hdr_frag);\n\t}\n\n\treturn hdr_frag;\n}\n",
                {
                    "566": "static struct net_buf *ethernet_fill_header(struct ethernet_context *ctx,",
                    "567": "\t\t\t\t\t    struct net_if *iface,",
                    "568": "\t\t\t\t\t    struct net_pkt *pkt,",
                    "569": "\t\t\t\t\t    uint32_t ptype)",
                    "570": "{",
                    "571": "\tstruct net_if *orig_iface = iface;",
                    "572": "\tstruct net_buf *hdr_frag;",
                    "573": "\tstruct net_eth_hdr *hdr;",
                    "574": "\tsize_t reserve_ll_header;",
                    "575": "\tsize_t hdr_len;",
                    "576": "\tbool is_vlan;",
                    "577": "",
                    "578": "\tis_vlan = IS_ENABLED(CONFIG_NET_VLAN) &&",
                    "579": "\t\tnet_eth_is_vlan_enabled(ctx, iface) &&",
                    "580": "\t\tnet_pkt_vlan_tag(pkt) != NET_VLAN_TAG_UNSPEC;",
                    "581": "\tif (is_vlan) {",
                    "582": "\t\torig_iface = net_eth_get_vlan_iface(iface, net_pkt_vlan_tag(pkt));",
                    "583": "\t}",
                    "584": "",
                    "585": "\treserve_ll_header = get_reserve_ll_header_size(orig_iface);",
                    "586": "\tif (reserve_ll_header > 0) {",
                    "587": "\t\thdr_len = reserve_ll_header;",
                    "588": "\t\thdr_frag = pkt->buffer;",
                    "589": "",
                    "590": "\t\tNET_DBG(\"Making room for link header %zd bytes\", hdr_len);",
                    "591": "",
                    "592": "\t\t/* Make room for the header */",
                    "593": "\t\tnet_buf_push(pkt->buffer, hdr_len);",
                    "594": "\t} else {",
                    "595": "\t\thdr_len = IS_ENABLED(CONFIG_NET_VLAN) ?",
                    "596": "\t\t\tsizeof(struct net_eth_vlan_hdr) :",
                    "597": "\t\t\tsizeof(struct net_eth_hdr);",
                    "598": "",
                    "599": "\t\thdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);",
                    "600": "\t\tif (!hdr_frag) {",
                    "601": "\t\t\treturn NULL;",
                    "602": "\t\t}",
                    "603": "\t}",
                    "604": "",
                    "605": "\tif (is_vlan) {",
                    "606": "\t\tstruct net_eth_vlan_hdr *hdr_vlan;",
                    "607": "",
                    "608": "\t\tif (reserve_ll_header == 0U) {",
                    "609": "\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);",
                    "610": "\t\t\tnet_buf_add(hdr_frag, hdr_len);",
                    "611": "\t\t}",
                    "612": "",
                    "613": "\t\thdr_vlan = (struct net_eth_vlan_hdr *)(hdr_frag->data);",
                    "614": "",
                    "615": "\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||",
                    "616": "\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr_vlan->dst) &&",
                    "617": "\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr_vlan->dst))) {",
                    "618": "\t\t\tmemcpy(&hdr_vlan->dst, net_pkt_lladdr_dst(pkt)->addr,",
                    "619": "\t\t\t       sizeof(struct net_eth_addr));",
                    "620": "\t\t}",
                    "621": "",
                    "622": "\t\tmemcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,",
                    "623": "\t\t       sizeof(struct net_eth_addr));",
                    "624": "",
                    "625": "\t\thdr_vlan->type = ptype;",
                    "626": "\t\thdr_vlan->vlan.tpid = net_htons(NET_ETH_PTYPE_VLAN);",
                    "627": "\t\thdr_vlan->vlan.tci = net_htons(net_pkt_vlan_tci(pkt));",
                    "628": "",
                    "629": "\t\tprint_vlan_ll_addrs(pkt, net_ntohs(hdr_vlan->type),",
                    "630": "\t\t\t\t    net_pkt_vlan_tci(pkt),",
                    "631": "\t\t\t\t    hdr_len,",
                    "632": "\t\t\t\t    &hdr_vlan->src, &hdr_vlan->dst, false);",
                    "633": "\t} else {",
                    "634": "\t\thdr = (struct net_eth_hdr *)(hdr_frag->data);",
                    "635": "",
                    "636": "\t\tif (reserve_ll_header == 0U) {",
                    "637": "\t\t\thdr_len = sizeof(struct net_eth_hdr);",
                    "638": "\t\t\tnet_buf_add(hdr_frag, hdr_len);",
                    "639": "\t\t}",
                    "640": "",
                    "641": "\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||",
                    "642": "\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr->dst) &&",
                    "643": "\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr->dst))) {",
                    "644": "\t\t\tmemcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,",
                    "645": "\t\t\t       sizeof(struct net_eth_addr));",
                    "646": "\t\t}",
                    "647": "",
                    "648": "\t\tmemcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,",
                    "649": "\t\t       sizeof(struct net_eth_addr));",
                    "650": "",
                    "651": "\t\thdr->type = ptype;",
                    "652": "",
                    "653": "\t\tprint_ll_addrs(pkt, net_ntohs(hdr->type),",
                    "654": "\t\t\t       hdr_len, &hdr->src, &hdr->dst);",
                    "655": "\t}",
                    "656": "",
                    "657": "\tif (reserve_ll_header == 0U) {",
                    "658": "\t\tnet_pkt_frag_insert(pkt, hdr_frag);",
                    "659": "\t}",
                    "660": "",
                    "661": "\treturn hdr_frag;",
                    "662": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_fill_in_dst_on_ipv6_mcast": {
            "name": "ethernet_fill_in_dst_on_ipv6_mcast",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 520,
            "function_content": [
                "#endif /* CONFIG_NET_IPV4 */\nstatic bool ethernet_fill_in_dst_on_ipv6_mcast(struct net_pkt *pkt,\n\t\t\t\t\t       struct net_eth_addr *dst)\n{\n\tif (net_pkt_family(pkt) == NET_AF_INET6 &&\n\t    net_ipv6_is_addr_mcast_raw(NET_IPV6_HDR(pkt)->dst)) {\n\t\tmemcpy(dst, (uint8_t *)multicast_eth_addr.addr,\n\t\t       sizeof(struct net_eth_addr) - 4);\n\t\tmemcpy((uint8_t *)dst + 2,\n\t\t       NET_IPV6_HDR(pkt)->dst + 12,\n\t\t       sizeof(struct net_eth_addr) - 2);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
                {
                    "520": "static bool ethernet_fill_in_dst_on_ipv6_mcast(struct net_pkt *pkt,",
                    "521": "\t\t\t\t\t       struct net_eth_addr *dst)",
                    "522": "{",
                    "523": "\tif (net_pkt_family(pkt) == NET_AF_INET6 &&",
                    "524": "\t    net_ipv6_is_addr_mcast_raw(NET_IPV6_HDR(pkt)->dst)) {",
                    "525": "\t\tmemcpy(dst, (uint8_t *)multicast_eth_addr.addr,",
                    "526": "\t\t       sizeof(struct net_eth_addr) - 4);",
                    "527": "\t\tmemcpy((uint8_t *)dst + 2,",
                    "528": "\t\t       NET_IPV6_HDR(pkt)->dst + 12,",
                    "529": "\t\t       sizeof(struct net_eth_addr) - 2);",
                    "530": "",
                    "531": "\t\treturn true;",
                    "532": "\t}",
                    "533": "",
                    "534": "\treturn false;",
                    "535": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_ip_recv": {
            "name": "ethernet_ip_recv",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 429,
            "function_content": [
                "/* The packet will be processed further by IP-stack\n* when NET_CONTINUE is returned\n*/\nstatic enum net_verdict ethernet_ip_recv(struct net_if *iface,\n\t\t\t\t\t uint16_t ptype,\n\t\t\t\t\t struct net_pkt *pkt)\n{\n\tARG_UNUSED(iface);\n\n\tif (ptype == NET_ETH_PTYPE_IP) {\n\t\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\n\t\tif (ethernet_check_ipv4_bcast_addr(pkt, hdr) == NET_DROP) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tnet_pkt_set_family(pkt, NET_AF_INET);\n\t} else if (ptype == NET_ETH_PTYPE_IPV6) {\n\t\tnet_pkt_set_family(pkt, NET_AF_INET6);\n\t} else {\n\t\treturn NET_DROP;\n\t}\n\n\treturn NET_CONTINUE;\n}\n",
                {
                    "429": "static enum net_verdict ethernet_ip_recv(struct net_if *iface,",
                    "430": "\t\t\t\t\t uint16_t ptype,",
                    "431": "\t\t\t\t\t struct net_pkt *pkt)",
                    "432": "{",
                    "433": "\tARG_UNUSED(iface);",
                    "434": "",
                    "435": "\tif (ptype == NET_ETH_PTYPE_IP) {",
                    "436": "\t\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "437": "",
                    "438": "\t\tif (ethernet_check_ipv4_bcast_addr(pkt, hdr) == NET_DROP) {",
                    "439": "\t\t\treturn NET_DROP;",
                    "440": "\t\t}",
                    "441": "",
                    "442": "\t\tnet_pkt_set_family(pkt, NET_AF_INET);",
                    "443": "\t} else if (ptype == NET_ETH_PTYPE_IPV6) {",
                    "444": "\t\tnet_pkt_set_family(pkt, NET_AF_INET6);",
                    "445": "\t} else {",
                    "446": "\t\treturn NET_DROP;",
                    "447": "\t}",
                    "448": "",
                    "449": "\treturn NET_CONTINUE;",
                    "450": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_recv": {
            "name": "ethernet_recv",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 257,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6 */\nstatic enum net_verdict ethernet_recv(struct net_if *iface,\n\t\t\t\t      struct net_pkt *pkt)\n{\n\tstruct ethernet_context *ctx = net_if_l2_data(iface);\n\tuint8_t hdr_len = sizeof(struct net_eth_hdr);\n\tsize_t body_len;\n\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\tenum net_verdict verdict = NET_CONTINUE;\n\tbool is_vlan_pkt = false;\n\tbool handled = false;\n\tstruct net_linkaddr *lladdr;\n\tuint16_t type;\n\tbool dst_broadcast, dst_eth_multicast, dst_iface_addr;\n\tstruct net_if *iface_eth = iface;\n\n\t/* This expects that the Ethernet header is in the first net_buf\n\t * fragment. This is a safe expectation here as it would not make\n\t * any sense to split the Ethernet header to two net_buf's by the\n\t * Ethernet driver.\n\t */\n\tif (hdr == NULL || pkt->buffer->len < hdr_len) {\n\t\tgoto drop;\n\t}\n\n\t/* Set the pointers to ll src and dst addresses */\n\t(void)net_linkaddr_create(net_pkt_lladdr_src(pkt), hdr->src.addr,\n\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);\n\n\t(void)net_linkaddr_create(net_pkt_lladdr_dst(pkt), hdr->dst.addr,\n\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);\n\n\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_eth_iface_is_bridged(ctx)) {\n\t\tverdict = eth_bridge_input_process(iface, pkt);\n\t\tif (verdict == NET_DROP) {\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Handled by bridge locally */\n\t\tif (verdict == NET_OK) {\n\t\t\tiface = net_eth_get_bridge(ctx);\n\t\t}\n\t}\n\n\ttype = net_ntohs(hdr->type);\n\n\tif (IS_ENABLED(CONFIG_NET_VLAN) && type == NET_ETH_PTYPE_VLAN) {\n\t\tif (net_eth_is_vlan_enabled(ctx, iface) &&\n\t\t    !eth_is_vlan_tag_stripped(iface)) {\n\t\t\tstruct net_eth_vlan_hdr *hdr_vlan =\n\t\t\t\t(struct net_eth_vlan_hdr *)NET_ETH_HDR(pkt);\n\t\t\tstruct net_if *vlan_iface;\n\n\t\t\tnet_pkt_set_vlan_tci(pkt, net_ntohs(hdr_vlan->vlan.tci));\n\t\t\ttype = net_ntohs(hdr_vlan->type);\n\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);\n\t\t\tis_vlan_pkt = true;\n\n\t\t\t/* If we receive a packet with a VLAN tag, for that we don't\n\t\t\t * have a VLAN interface, drop the packet.\n\t\t\t */\n\t\t\tvlan_iface = net_eth_get_vlan_iface(iface,\n\t\t\t\t\t\t\t    net_pkt_vlan_tag(pkt));\n\t\t\tif (vlan_iface == NULL) {\n\t\t\t\tNET_DBG(\"Dropping frame, no VLAN interface for tag %d\",\n\t\t\t\t\tnet_pkt_vlan_tag(pkt));\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tnet_pkt_set_iface(pkt, vlan_iface);\n\n\t\t\tif (net_if_l2(net_pkt_iface(pkt)) == NULL) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (net_pkt_vlan_tag(pkt) != NET_VLAN_TAG_PRIORITY) {\n\t\t\t\t/* We could call VLAN interface directly but then the\n\t\t\t\t * interface statistics would not get updated so route\n\t\t\t\t * the call via Virtual L2 layer.\n\t\t\t\t */\n\t\t\t\tif (net_if_l2(net_pkt_iface(pkt))->recv != NULL) {\n\t\t\t\t\tverdict = net_if_l2(net_pkt_iface(pkt))->recv(iface, pkt);\n\t\t\t\t\tif (verdict == NET_DROP) {\n\t\t\t\t\t\tgoto drop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlladdr = net_pkt_lladdr_dst(pkt);\n\n\tnet_pkt_set_ll_proto_type(pkt, type);\n\tdst_broadcast = net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr);\n\tdst_eth_multicast = net_eth_is_addr_group((struct net_eth_addr *)lladdr->addr);\n\tdst_iface_addr = net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr);\n\n\tif (is_vlan_pkt) {\n\t\tprint_vlan_ll_addrs(pkt, type, net_pkt_vlan_tci(pkt),\n\t\t\t\t    net_pkt_get_len(pkt),\n\t\t\t\t    net_pkt_lladdr_src(pkt),\n\t\t\t\t    net_pkt_lladdr_dst(pkt),\n\t\t\t\t    eth_is_vlan_tag_stripped(iface));\n\t} else {\n\t\tprint_ll_addrs(pkt, type, net_pkt_get_len(pkt),\n\t\t\t       net_pkt_lladdr_src(pkt),\n\t\t\t       net_pkt_lladdr_dst(pkt));\n\t}\n\n\tif (!(dst_broadcast || dst_eth_multicast || dst_iface_addr)) {\n\t\t/* The ethernet frame is not for me as the link addresses\n\t\t * are different.\n\t\t */\n\t\tNET_DBG(\"Dropping frame, not for me [%s]\",\n\t\t\tnet_sprint_ll_addr(net_if_get_link_addr(iface)->addr,\n\t\t\t\t\t   sizeof(struct net_eth_addr)));\n\t\tgoto drop;\n\t}\n\n\t/* Get rid of the Ethernet header. */\n\tnet_buf_pull(pkt->frags, hdr_len);\n\n\tbody_len = net_pkt_get_len(pkt);\n\n\tSTRUCT_SECTION_FOREACH(net_l3_register, l3) {\n\t\tif (l3->ptype != type || l3->l2 != &NET_L2_GET_NAME(ETHERNET) ||\n\t\t    l3->handler == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tNET_DBG(\"Calling L3 %s handler for type 0x%04x iface %d (%p)\",\n\t\t\tl3->name, type, net_if_get_by_iface(iface), iface);\n\n\t\tverdict = l3->handler(iface, type, pkt);\n\t\tif (verdict == NET_OK) {\n\t\t\t/* the packet was consumed by the l3-handler */\n\t\t\tgoto out;\n\t\t} else if (verdict == NET_DROP) {\n\t\t\tNET_DBG(\"Dropping frame, packet rejected by %s\", l3->name);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* The packet will be processed further by IP-stack\n\t\t * when NET_CONTINUE is returned\n\t\t */\n\t\thandled = true;\n\t\tbreak;\n\t}\n\n\tif (!handled) {\n\t\tif (IS_ENABLED(CONFIG_NET_ETHERNET_FORWARD_UNRECOGNISED_ETHERTYPE)) {\n\t\t\tnet_pkt_set_family(pkt, NET_AF_UNSPEC);\n\t\t} else {\n\t\t\tNET_DBG(\"Unknown hdr type 0x%04x iface %d (%p)\", type,\n\t\t\t\tnet_if_get_by_iface(iface), iface);\n\t\t\teth_stats_update_unknown_protocol(iface_eth);\n\t\t\treturn NET_DROP;\n\t\t}\n\t}\n\n\tif (type != NET_ETH_PTYPE_EAPOL) {\n\t\tethernet_update_length(iface, pkt);\n\t}\n\nout:\n\tethernet_update_rx_stats(iface_eth, body_len + hdr_len, dst_broadcast, dst_eth_multicast);\n\treturn verdict;\ndrop:\n\teth_stats_update_errors_rx(iface_eth);\n\treturn NET_DROP;\n}\n",
                {
                    "257": "static enum net_verdict ethernet_recv(struct net_if *iface,",
                    "258": "\t\t\t\t      struct net_pkt *pkt)",
                    "259": "{",
                    "260": "\tstruct ethernet_context *ctx = net_if_l2_data(iface);",
                    "261": "\tuint8_t hdr_len = sizeof(struct net_eth_hdr);",
                    "262": "\tsize_t body_len;",
                    "263": "\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "264": "\tenum net_verdict verdict = NET_CONTINUE;",
                    "265": "\tbool is_vlan_pkt = false;",
                    "266": "\tbool handled = false;",
                    "267": "\tstruct net_linkaddr *lladdr;",
                    "268": "\tuint16_t type;",
                    "269": "\tbool dst_broadcast, dst_eth_multicast, dst_iface_addr;",
                    "270": "\tstruct net_if *iface_eth = iface;",
                    "271": "",
                    "272": "\t/* This expects that the Ethernet header is in the first net_buf",
                    "273": "\t * fragment. This is a safe expectation here as it would not make",
                    "274": "\t * any sense to split the Ethernet header to two net_buf's by the",
                    "275": "\t * Ethernet driver.",
                    "276": "\t */",
                    "277": "\tif (hdr == NULL || pkt->buffer->len < hdr_len) {",
                    "278": "\t\tgoto drop;",
                    "279": "\t}",
                    "280": "",
                    "281": "\t/* Set the pointers to ll src and dst addresses */",
                    "282": "\t(void)net_linkaddr_create(net_pkt_lladdr_src(pkt), hdr->src.addr,",
                    "283": "\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);",
                    "284": "",
                    "285": "\t(void)net_linkaddr_create(net_pkt_lladdr_dst(pkt), hdr->dst.addr,",
                    "286": "\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);",
                    "287": "",
                    "288": "\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_eth_iface_is_bridged(ctx)) {",
                    "289": "\t\tverdict = eth_bridge_input_process(iface, pkt);",
                    "290": "\t\tif (verdict == NET_DROP) {",
                    "291": "\t\t\tgoto drop;",
                    "292": "\t\t}",
                    "293": "",
                    "294": "\t\t/* Handled by bridge locally */",
                    "295": "\t\tif (verdict == NET_OK) {",
                    "296": "\t\t\tiface = net_eth_get_bridge(ctx);",
                    "297": "\t\t}",
                    "298": "\t}",
                    "299": "",
                    "300": "\ttype = net_ntohs(hdr->type);",
                    "301": "",
                    "302": "\tif (IS_ENABLED(CONFIG_NET_VLAN) && type == NET_ETH_PTYPE_VLAN) {",
                    "303": "\t\tif (net_eth_is_vlan_enabled(ctx, iface) &&",
                    "304": "\t\t    !eth_is_vlan_tag_stripped(iface)) {",
                    "305": "\t\t\tstruct net_eth_vlan_hdr *hdr_vlan =",
                    "306": "\t\t\t\t(struct net_eth_vlan_hdr *)NET_ETH_HDR(pkt);",
                    "307": "\t\t\tstruct net_if *vlan_iface;",
                    "308": "",
                    "309": "\t\t\tnet_pkt_set_vlan_tci(pkt, net_ntohs(hdr_vlan->vlan.tci));",
                    "310": "\t\t\ttype = net_ntohs(hdr_vlan->type);",
                    "311": "\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);",
                    "312": "\t\t\tis_vlan_pkt = true;",
                    "313": "",
                    "314": "\t\t\t/* If we receive a packet with a VLAN tag, for that we don't",
                    "315": "\t\t\t * have a VLAN interface, drop the packet.",
                    "316": "\t\t\t */",
                    "317": "\t\t\tvlan_iface = net_eth_get_vlan_iface(iface,",
                    "318": "\t\t\t\t\t\t\t    net_pkt_vlan_tag(pkt));",
                    "319": "\t\t\tif (vlan_iface == NULL) {",
                    "320": "\t\t\t\tNET_DBG(\"Dropping frame, no VLAN interface for tag %d\",",
                    "321": "\t\t\t\t\tnet_pkt_vlan_tag(pkt));",
                    "322": "\t\t\t\tgoto drop;",
                    "323": "\t\t\t}",
                    "324": "",
                    "325": "\t\t\tnet_pkt_set_iface(pkt, vlan_iface);",
                    "326": "",
                    "327": "\t\t\tif (net_if_l2(net_pkt_iface(pkt)) == NULL) {",
                    "328": "\t\t\t\tgoto drop;",
                    "329": "\t\t\t}",
                    "330": "",
                    "331": "\t\t\tif (net_pkt_vlan_tag(pkt) != NET_VLAN_TAG_PRIORITY) {",
                    "332": "\t\t\t\t/* We could call VLAN interface directly but then the",
                    "333": "\t\t\t\t * interface statistics would not get updated so route",
                    "334": "\t\t\t\t * the call via Virtual L2 layer.",
                    "335": "\t\t\t\t */",
                    "336": "\t\t\t\tif (net_if_l2(net_pkt_iface(pkt))->recv != NULL) {",
                    "337": "\t\t\t\t\tverdict = net_if_l2(net_pkt_iface(pkt))->recv(iface, pkt);",
                    "338": "\t\t\t\t\tif (verdict == NET_DROP) {",
                    "339": "\t\t\t\t\t\tgoto drop;",
                    "340": "\t\t\t\t\t}",
                    "341": "\t\t\t\t}",
                    "342": "\t\t\t}",
                    "343": "\t\t}",
                    "344": "\t}",
                    "345": "",
                    "346": "\tlladdr = net_pkt_lladdr_dst(pkt);",
                    "347": "",
                    "348": "\tnet_pkt_set_ll_proto_type(pkt, type);",
                    "349": "\tdst_broadcast = net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr);",
                    "350": "\tdst_eth_multicast = net_eth_is_addr_group((struct net_eth_addr *)lladdr->addr);",
                    "351": "\tdst_iface_addr = net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr);",
                    "352": "",
                    "353": "\tif (is_vlan_pkt) {",
                    "354": "\t\tprint_vlan_ll_addrs(pkt, type, net_pkt_vlan_tci(pkt),",
                    "355": "\t\t\t\t    net_pkt_get_len(pkt),",
                    "356": "\t\t\t\t    net_pkt_lladdr_src(pkt),",
                    "357": "\t\t\t\t    net_pkt_lladdr_dst(pkt),",
                    "358": "\t\t\t\t    eth_is_vlan_tag_stripped(iface));",
                    "359": "\t} else {",
                    "360": "\t\tprint_ll_addrs(pkt, type, net_pkt_get_len(pkt),",
                    "361": "\t\t\t       net_pkt_lladdr_src(pkt),",
                    "362": "\t\t\t       net_pkt_lladdr_dst(pkt));",
                    "363": "\t}",
                    "364": "",
                    "365": "\tif (!(dst_broadcast || dst_eth_multicast || dst_iface_addr)) {",
                    "366": "\t\t/* The ethernet frame is not for me as the link addresses",
                    "367": "\t\t * are different.",
                    "368": "\t\t */",
                    "369": "\t\tNET_DBG(\"Dropping frame, not for me [%s]\",",
                    "370": "\t\t\tnet_sprint_ll_addr(net_if_get_link_addr(iface)->addr,",
                    "371": "\t\t\t\t\t   sizeof(struct net_eth_addr)));",
                    "372": "\t\tgoto drop;",
                    "373": "\t}",
                    "374": "",
                    "375": "\t/* Get rid of the Ethernet header. */",
                    "376": "\tnet_buf_pull(pkt->frags, hdr_len);",
                    "377": "",
                    "378": "\tbody_len = net_pkt_get_len(pkt);",
                    "379": "",
                    "380": "\tSTRUCT_SECTION_FOREACH(net_l3_register, l3) {",
                    "381": "\t\tif (l3->ptype != type || l3->l2 != &NET_L2_GET_NAME(ETHERNET) ||",
                    "382": "\t\t    l3->handler == NULL) {",
                    "383": "\t\t\tcontinue;",
                    "384": "\t\t}",
                    "385": "",
                    "386": "\t\tNET_DBG(\"Calling L3 %s handler for type 0x%04x iface %d (%p)\",",
                    "387": "\t\t\tl3->name, type, net_if_get_by_iface(iface), iface);",
                    "388": "",
                    "389": "\t\tverdict = l3->handler(iface, type, pkt);",
                    "390": "\t\tif (verdict == NET_OK) {",
                    "391": "\t\t\t/* the packet was consumed by the l3-handler */",
                    "392": "\t\t\tgoto out;",
                    "393": "\t\t} else if (verdict == NET_DROP) {",
                    "394": "\t\t\tNET_DBG(\"Dropping frame, packet rejected by %s\", l3->name);",
                    "395": "\t\t\tgoto drop;",
                    "396": "\t\t}",
                    "397": "",
                    "398": "\t\t/* The packet will be processed further by IP-stack",
                    "399": "\t\t * when NET_CONTINUE is returned",
                    "400": "\t\t */",
                    "401": "\t\thandled = true;",
                    "402": "\t\tbreak;",
                    "403": "\t}",
                    "404": "",
                    "405": "\tif (!handled) {",
                    "406": "\t\tif (IS_ENABLED(CONFIG_NET_ETHERNET_FORWARD_UNRECOGNISED_ETHERTYPE)) {",
                    "407": "\t\t\tnet_pkt_set_family(pkt, NET_AF_UNSPEC);",
                    "408": "\t\t} else {",
                    "409": "\t\t\tNET_DBG(\"Unknown hdr type 0x%04x iface %d (%p)\", type,",
                    "410": "\t\t\t\tnet_if_get_by_iface(iface), iface);",
                    "411": "\t\t\teth_stats_update_unknown_protocol(iface_eth);",
                    "412": "\t\t\treturn NET_DROP;",
                    "413": "\t\t}",
                    "414": "\t}",
                    "415": "",
                    "416": "\tif (type != NET_ETH_PTYPE_EAPOL) {",
                    "417": "\t\tethernet_update_length(iface, pkt);",
                    "418": "\t}",
                    "419": "",
                    "420": "out:",
                    "421": "\tethernet_update_rx_stats(iface_eth, body_len + hdr_len, dst_broadcast, dst_eth_multicast);",
                    "422": "\treturn verdict;",
                    "423": "drop:",
                    "424": "\teth_stats_update_errors_rx(iface_eth);",
                    "425": "\treturn NET_DROP;",
                    "426": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_mcast_monitor_cb": {
            "name": "ethernet_mcast_monitor_cb",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 212,
            "function_content": [
                "/* Drop packet if it has broadcast destination MAC address but the IP\n* address is not multicast or broadcast address. See RFC 1122 ch 3.3.6\n*/\nstatic void ethernet_mcast_monitor_cb(struct net_if *iface, const struct net_addr *addr,\n\t\t\t\t      bool is_joined)\n{\n\tstruct ethernet_config cfg = {\n\t\t.filter = {\n\t\t\t.set = is_joined,\n\t\t\t.type = ETHERNET_FILTER_TYPE_DST_MAC_ADDRESS,\n\t\t},\n\t};\n\n\tconst struct device *dev = net_if_get_device(iface);\n\tconst struct ethernet_api *api = dev->api;\n\n\t/* Make sure we're an ethernet device */\n\tif (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {\n\t\treturn;\n\t}\n\n\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING)) {\n\t\treturn;\n\t}\n\n\tif (!api || !api->set_config) {\n\t\treturn;\n\t}\n\n\tswitch (addr->family) {\n#if defined(CONFIG_NET_IPV4)\n\tcase NET_AF_INET:\n\t\tnet_eth_ipv4_mcast_to_mac_addr(&addr->in_addr, &cfg.filter.mac_address);\n\t\tbreak;\n#endif /* CONFIG_NET_IPV4 */\n#if defined(CONFIG_NET_IPV6)\n\tcase NET_AF_INET6:\n\t\tnet_eth_ipv6_mcast_to_mac_addr(&addr->in6_addr, &cfg.filter.mac_address);\n\t\tbreak;\n#endif /* CONFIG_NET_IPV6 */\n\tdefault:\n\t\treturn;\n\t}\n\n\tapi->set_config(dev, ETHERNET_CONFIG_TYPE_FILTER, &cfg);\n}\n",
                {
                    "212": "static void ethernet_mcast_monitor_cb(struct net_if *iface, const struct net_addr *addr,",
                    "213": "\t\t\t\t      bool is_joined)",
                    "214": "{",
                    "215": "\tstruct ethernet_config cfg = {",
                    "216": "\t\t.filter = {",
                    "217": "\t\t\t.set = is_joined,",
                    "218": "\t\t\t.type = ETHERNET_FILTER_TYPE_DST_MAC_ADDRESS,",
                    "219": "\t\t},",
                    "220": "\t};",
                    "221": "",
                    "222": "\tconst struct device *dev = net_if_get_device(iface);",
                    "223": "\tconst struct ethernet_api *api = dev->api;",
                    "224": "",
                    "225": "\t/* Make sure we're an ethernet device */",
                    "226": "\tif (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {",
                    "227": "\t\treturn;",
                    "228": "\t}",
                    "229": "",
                    "230": "\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING)) {",
                    "231": "\t\treturn;",
                    "232": "\t}",
                    "233": "",
                    "234": "\tif (!api || !api->set_config) {",
                    "235": "\t\treturn;",
                    "236": "\t}",
                    "237": "",
                    "238": "\tswitch (addr->family) {",
                    "239": "#if defined(CONFIG_NET_IPV4)",
                    "240": "\tcase NET_AF_INET:",
                    "241": "\t\tnet_eth_ipv4_mcast_to_mac_addr(&addr->in_addr, &cfg.filter.mac_address);",
                    "242": "\t\tbreak;",
                    "243": "#endif /* CONFIG_NET_IPV4 */",
                    "244": "#if defined(CONFIG_NET_IPV6)",
                    "245": "\tcase NET_AF_INET6:",
                    "246": "\t\tnet_eth_ipv6_mcast_to_mac_addr(&addr->in6_addr, &cfg.filter.mac_address);",
                    "247": "\t\tbreak;",
                    "248": "#endif /* CONFIG_NET_IPV6 */",
                    "249": "\tdefault:",
                    "250": "\t\treturn;",
                    "251": "\t}",
                    "252": "",
                    "253": "\tapi->set_config(dev, ETHERNET_CONFIG_TYPE_FILTER, &cfg);",
                    "254": "}"
                }
            ],
            "function_content_in_lines": {}
        }
    },
    "driver_functions": {},
    "buffer_functions": {
        "next": {
            "name": "next",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 48,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *next(struct _timeout *t)\n{\n\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);\n\n\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);\n}\n",
                {
                    "48": "static struct _timeout *next(struct _timeout *t)",
                    "49": "{",
                    "50": "\tsys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);",
                    "51": "",
                    "52": "\treturn (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);",
                    "53": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_usable_size": {
            "name": "sys_heap_usable_size",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 200,
            "function_content": [
                "/*\n* It is easy to catch many common memory overflow cases with\n* a quick check on this and next chunk header fields that are\n* immediately before and after the freed memory.\n*/\nsize_t sys_heap_usable_size(struct sys_heap *heap, void *mem)\n{\n\tstruct z_heap *h = heap->heap;\n\tchunkid_t c = mem_to_chunkid(h, mem);\n\tsize_t addr = (size_t)mem;\n\tsize_t chunk_base = (size_t)&chunk_buf(h)[c];\n\tsize_t chunk_sz = chunk_size(h, c) * CHUNK_UNIT;\n\n\treturn chunk_sz - (addr - chunk_base);\n}\n",
                {
                    "200": "size_t sys_heap_usable_size(struct sys_heap *heap, void *mem)",
                    "201": "{",
                    "202": "\tstruct z_heap *h = heap->heap;",
                    "203": "\tchunkid_t c = mem_to_chunkid(h, mem);",
                    "204": "\tsize_t addr = (size_t)mem;",
                    "205": "\tsize_t chunk_base = (size_t)&chunk_buf(h)[c];",
                    "206": "\tsize_t chunk_sz = chunk_size(h, c) * CHUNK_UNIT;",
                    "207": "",
                    "208": "\treturn chunk_sz - (addr - chunk_base);",
                    "209": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_aligned_realloc": {
            "name": "sys_heap_aligned_realloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 491,
            "function_content": [
                "/* In-place realloc was not possible: fallback to allocate and copy. */\nvoid *sys_heap_aligned_realloc(struct sys_heap *heap, void *ptr,\n\t\t\t       size_t align, size_t bytes)\n{\n\t/* special realloc semantics */\n\tif (ptr == NULL) {\n\t\treturn sys_heap_aligned_alloc(heap, align, bytes);\n\t}\n\tif (bytes == 0) {\n\t\tsys_heap_free(heap, ptr);\n\t\treturn NULL;\n\t}\n\n\t__ASSERT((align & (align - 1)) == 0, \"align must be a power of 2\");\n\n\tif ((align == 0 || ((uintptr_t)ptr & (align - 1)) == 0) &&\n\t    inplace_realloc(heap, ptr, bytes)) {\n\t\treturn ptr;\n\t}\n\n\t/*\n\t * Either ptr is not sufficiently aligned for in-place realloc or\n\t * in-place realloc was not possible: fallback to allocate and copy.\n\t */\n\tvoid *ptr2 = sys_heap_aligned_alloc(heap, align, bytes);\n\n\tif (ptr2 != NULL) {\n\t\tsize_t prev_size = sys_heap_usable_size(heap, ptr);\n\n\t\tmemcpy(ptr2, ptr, min(prev_size, bytes));\n\t\tsys_heap_free(heap, ptr);\n\t}\n\treturn ptr2;\n}\n",
                {
                    "491": "void *sys_heap_aligned_realloc(struct sys_heap *heap, void *ptr,",
                    "492": "\t\t\t       size_t align, size_t bytes)",
                    "493": "{",
                    "494": "\t/* special realloc semantics */",
                    "495": "\tif (ptr == NULL) {",
                    "496": "\t\treturn sys_heap_aligned_alloc(heap, align, bytes);",
                    "497": "\t}",
                    "498": "\tif (bytes == 0) {",
                    "499": "\t\tsys_heap_free(heap, ptr);",
                    "500": "\t\treturn NULL;",
                    "501": "\t}",
                    "502": "",
                    "503": "\t__ASSERT((align & (align - 1)) == 0, \"align must be a power of 2\");",
                    "504": "",
                    "505": "\tif ((align == 0 || ((uintptr_t)ptr & (align - 1)) == 0) &&",
                    "506": "\t    inplace_realloc(heap, ptr, bytes)) {",
                    "507": "\t\treturn ptr;",
                    "508": "\t}",
                    "509": "",
                    "510": "\t/*",
                    "511": "\t * Either ptr is not sufficiently aligned for in-place realloc or",
                    "512": "\t * in-place realloc was not possible: fallback to allocate and copy.",
                    "513": "\t */",
                    "514": "\tvoid *ptr2 = sys_heap_aligned_alloc(heap, align, bytes);",
                    "515": "",
                    "516": "\tif (ptr2 != NULL) {",
                    "517": "\t\tsize_t prev_size = sys_heap_usable_size(heap, ptr);",
                    "518": "",
                    "519": "\t\tmemcpy(ptr2, ptr, min(prev_size, bytes));",
                    "520": "\t\tsys_heap_free(heap, ptr);",
                    "521": "\t}",
                    "522": "\treturn ptr2;",
                    "523": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_realloc": {
            "name": "sys_heap_realloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 464,
            "function_content": [
                "/* Expand: split the right chunk and append */\nvoid *sys_heap_realloc(struct sys_heap *heap, void *ptr, size_t bytes)\n{\n\t/* special realloc semantics */\n\tif (ptr == NULL) {\n\t\treturn sys_heap_alloc(heap, bytes);\n\t}\n\tif (bytes == 0) {\n\t\tsys_heap_free(heap, ptr);\n\t\treturn NULL;\n\t}\n\n\tif (inplace_realloc(heap, ptr, bytes)) {\n\t\treturn ptr;\n\t}\n\n\t/* In-place realloc was not possible: fallback to allocate and copy. */\n\tvoid *ptr2 = sys_heap_alloc(heap, bytes);\n\n\tif (ptr2 != NULL) {\n\t\tsize_t prev_size = sys_heap_usable_size(heap, ptr);\n\n\t\tmemcpy(ptr2, ptr, min(prev_size, bytes));\n\t\tsys_heap_free(heap, ptr);\n\t}\n\treturn ptr2;\n}\n",
                {
                    "464": "void *sys_heap_realloc(struct sys_heap *heap, void *ptr, size_t bytes)",
                    "465": "{",
                    "466": "\t/* special realloc semantics */",
                    "467": "\tif (ptr == NULL) {",
                    "468": "\t\treturn sys_heap_alloc(heap, bytes);",
                    "469": "\t}",
                    "470": "\tif (bytes == 0) {",
                    "471": "\t\tsys_heap_free(heap, ptr);",
                    "472": "\t\treturn NULL;",
                    "473": "\t}",
                    "474": "",
                    "475": "\tif (inplace_realloc(heap, ptr, bytes)) {",
                    "476": "\t\treturn ptr;",
                    "477": "\t}",
                    "478": "",
                    "479": "\t/* In-place realloc was not possible: fallback to allocate and copy. */",
                    "480": "\tvoid *ptr2 = sys_heap_alloc(heap, bytes);",
                    "481": "",
                    "482": "\tif (ptr2 != NULL) {",
                    "483": "\t\tsize_t prev_size = sys_heap_usable_size(heap, ptr);",
                    "484": "",
                    "485": "\t\tmemcpy(ptr2, ptr, min(prev_size, bytes));",
                    "486": "\t\tsys_heap_free(heap, ptr);",
                    "487": "\t}",
                    "488": "\treturn ptr2;",
                    "489": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_free": {
            "name": "sys_heap_free",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 163,
            "function_content": [
                "/*\n* Return the closest chunk ID corresponding to given memory pointer.\n* Here \"closest\" is only meaningful in the context of sys_heap_aligned_alloc()\n* where wanted alignment might not always correspond to a chunk header\n* boundary.\n*/\nvoid sys_heap_free(struct sys_heap *heap, void *mem)\n{\n\tif (mem == NULL) {\n\t\treturn; /* ISO C free() semantics */\n\t}\n\tstruct z_heap *h = heap->heap;\n\tchunkid_t c = mem_to_chunkid(h, mem);\n\n\t/*\n\t * This should catch many double-free cases.\n\t * This is cheap enough so let's do it all the time.\n\t */\n\t__ASSERT(chunk_used(h, c),\n\t\t \"unexpected heap state (double-free?) for memory at %p\", mem);\n\n\t/*\n\t * It is easy to catch many common memory overflow cases with\n\t * a quick check on this and next chunk header fields that are\n\t * immediately before and after the freed memory.\n\t */\n\t__ASSERT(left_chunk(h, right_chunk(h, c)) == c,\n\t\t \"corrupted heap bounds (buffer overflow?) for memory at %p\",\n\t\t mem);\n\n\tset_chunk_used(h, c, false);\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\th->allocated_bytes -= chunksz_to_bytes(h, chunk_size(h, c));\n#endif\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), mem,\n\t\t\t\t  chunksz_to_bytes(h, chunk_size(h, c)));\n#endif\n\n\tfree_chunk(h, c);\n}\n",
                {
                    "163": "void sys_heap_free(struct sys_heap *heap, void *mem)",
                    "164": "{",
                    "165": "\tif (mem == NULL) {",
                    "166": "\t\treturn; /* ISO C free() semantics */",
                    "167": "\t}",
                    "168": "\tstruct z_heap *h = heap->heap;",
                    "169": "\tchunkid_t c = mem_to_chunkid(h, mem);",
                    "170": "",
                    "171": "\t/*",
                    "172": "\t * This should catch many double-free cases.",
                    "173": "\t * This is cheap enough so let's do it all the time.",
                    "174": "\t */",
                    "175": "\t__ASSERT(chunk_used(h, c),",
                    "176": "\t\t \"unexpected heap state (double-free?) for memory at %p\", mem);",
                    "177": "",
                    "178": "\t/*",
                    "179": "\t * It is easy to catch many common memory overflow cases with",
                    "180": "\t * a quick check on this and next chunk header fields that are",
                    "181": "\t * immediately before and after the freed memory.",
                    "182": "\t */",
                    "183": "\t__ASSERT(left_chunk(h, right_chunk(h, c)) == c,",
                    "184": "\t\t \"corrupted heap bounds (buffer overflow?) for memory at %p\",",
                    "185": "\t\t mem);",
                    "186": "",
                    "187": "\tset_chunk_used(h, c, false);",
                    "188": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "189": "\th->allocated_bytes -= chunksz_to_bytes(h, chunk_size(h, c));",
                    "190": "#endif",
                    "191": "",
                    "192": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "193": "\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), mem,",
                    "194": "\t\t\t\t  chunksz_to_bytes(h, chunk_size(h, c)));",
                    "195": "#endif",
                    "196": "",
                    "197": "\tfree_chunk(h, c);",
                    "198": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_aligned_alloc": {
            "name": "sys_heap_aligned_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 309,
            "function_content": [
                "/* Split off remainder if any */\nvoid *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)\n{\n\tstruct z_heap *h = heap->heap;\n\tsize_t gap, rew;\n\n\t/*\n\t * Split align and rewind values (if any).\n\t * We allow for one bit of rewind in addition to the alignment\n\t * value to efficiently accommodate z_alloc_helper().\n\t * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte\n\t * boundary and then rewind 8 bytes.\n\t */\n\trew = align & -align;\n\tif (align != rew) {\n\t\talign -= rew;\n\t\tgap = min(rew, chunk_header_bytes(h));\n\t} else {\n\t\tif (align <= chunk_header_bytes(h)) {\n\t\t\treturn sys_heap_alloc(heap, bytes);\n\t\t}\n\t\trew = 0;\n\t\tgap = chunk_header_bytes(h);\n\t}\n\t__ASSERT((align & (align - 1)) == 0, \"align must be a power of 2\");\n\n\tif (bytes == 0) {\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Find a free block that is guaranteed to fit.\n\t * We over-allocate to account for alignment and then free\n\t * the extra allocations afterwards.\n\t */\n\tchunksz_t padded_sz = bytes_to_chunksz(h, bytes, align - gap);\n\tchunkid_t c0 = alloc_chunk(h, padded_sz);\n\n\tif (c0 == 0) {\n\t\treturn NULL;\n\t}\n\tuint8_t *mem = chunk_mem(h, c0);\n\n\t/* Align allocated memory */\n\tmem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;\n\tchunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);\n\n\t/* Get corresponding chunks */\n\tchunkid_t c = mem_to_chunkid(h, mem);\n\tchunkid_t c_end = end - chunk_buf(h);\n\tCHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);\n\n\t/* Split and free unused prefix */\n\tif (c > c0) {\n\t\tsplit_chunks(h, c0, c);\n\t\tfree_list_add(h, c0);\n\t}\n\n\t/* Split and free unused suffix */\n\tif (right_chunk(h, c) > c_end) {\n\t\tsplit_chunks(h, c, c_end);\n\t\tfree_list_add(h, c_end);\n\t}\n\n\tset_chunk_used(h, c, true);\n\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\tincrease_allocated_bytes(h, chunksz_to_bytes(h, chunk_size(h, c)));\n#endif\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,\n\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));\n#endif\n\n\tIF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));\n\treturn mem;\n}\n",
                {
                    "309": "void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)",
                    "310": "{",
                    "311": "\tstruct z_heap *h = heap->heap;",
                    "312": "\tsize_t gap, rew;",
                    "313": "",
                    "314": "\t/*",
                    "315": "\t * Split align and rewind values (if any).",
                    "316": "\t * We allow for one bit of rewind in addition to the alignment",
                    "317": "\t * value to efficiently accommodate z_alloc_helper().",
                    "318": "\t * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte",
                    "319": "\t * boundary and then rewind 8 bytes.",
                    "320": "\t */",
                    "321": "\trew = align & -align;",
                    "322": "\tif (align != rew) {",
                    "323": "\t\talign -= rew;",
                    "324": "\t\tgap = min(rew, chunk_header_bytes(h));",
                    "325": "\t} else {",
                    "326": "\t\tif (align <= chunk_header_bytes(h)) {",
                    "327": "\t\t\treturn sys_heap_alloc(heap, bytes);",
                    "328": "\t\t}",
                    "329": "\t\trew = 0;",
                    "330": "\t\tgap = chunk_header_bytes(h);",
                    "331": "\t}",
                    "332": "\t__ASSERT((align & (align - 1)) == 0, \"align must be a power of 2\");",
                    "333": "",
                    "334": "\tif (bytes == 0) {",
                    "335": "\t\treturn NULL;",
                    "336": "\t}",
                    "337": "",
                    "338": "\t/*",
                    "339": "\t * Find a free block that is guaranteed to fit.",
                    "340": "\t * We over-allocate to account for alignment and then free",
                    "341": "\t * the extra allocations afterwards.",
                    "342": "\t */",
                    "343": "\tchunksz_t padded_sz = bytes_to_chunksz(h, bytes, align - gap);",
                    "344": "\tchunkid_t c0 = alloc_chunk(h, padded_sz);",
                    "345": "",
                    "346": "\tif (c0 == 0) {",
                    "347": "\t\treturn NULL;",
                    "348": "\t}",
                    "349": "\tuint8_t *mem = chunk_mem(h, c0);",
                    "350": "",
                    "351": "\t/* Align allocated memory */",
                    "352": "\tmem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;",
                    "353": "\tchunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);",
                    "354": "",
                    "355": "\t/* Get corresponding chunks */",
                    "356": "\tchunkid_t c = mem_to_chunkid(h, mem);",
                    "357": "\tchunkid_t c_end = end - chunk_buf(h);",
                    "358": "\tCHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);",
                    "359": "",
                    "360": "\t/* Split and free unused prefix */",
                    "361": "\tif (c > c0) {",
                    "362": "\t\tsplit_chunks(h, c0, c);",
                    "363": "\t\tfree_list_add(h, c0);",
                    "364": "\t}",
                    "365": "",
                    "366": "\t/* Split and free unused suffix */",
                    "367": "\tif (right_chunk(h, c) > c_end) {",
                    "368": "\t\tsplit_chunks(h, c, c_end);",
                    "369": "\t\tfree_list_add(h, c_end);",
                    "370": "\t}",
                    "371": "",
                    "372": "\tset_chunk_used(h, c, true);",
                    "373": "",
                    "374": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "375": "\tincrease_allocated_bytes(h, chunksz_to_bytes(h, chunk_size(h, c)));",
                    "376": "#endif",
                    "377": "",
                    "378": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "379": "\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,",
                    "380": "\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));",
                    "381": "#endif",
                    "382": "",
                    "383": "\tIF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));",
                    "384": "\treturn mem;",
                    "385": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_alloc": {
            "name": "sys_heap_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 263,
            "function_content": [
                "/* Otherwise pick the smallest non-empty bucket guaranteed to\n* fit and use that unconditionally.\n*/\nvoid *sys_heap_alloc(struct sys_heap *heap, size_t bytes)\n{\n\tstruct z_heap *h = heap->heap;\n\tvoid *mem;\n\n\tif (bytes == 0U) {\n\t\treturn NULL;\n\t}\n\n\tchunksz_t chunk_sz = bytes_to_chunksz(h, bytes, 0);\n\tchunkid_t c = alloc_chunk(h, chunk_sz);\n\n\tif (c == 0U) {\n\t\treturn NULL;\n\t}\n\n\t/* Split off remainder if any */\n\tif (chunk_size(h, c) > chunk_sz) {\n\t\tsplit_chunks(h, c, c + chunk_sz);\n\t\tfree_list_add(h, c + chunk_sz);\n\t}\n\n\tset_chunk_used(h, c, true);\n\n\tmem = chunk_mem(h, c);\n\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\tincrease_allocated_bytes(h, chunksz_to_bytes(h, chunk_size(h, c)));\n#endif\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,\n\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));\n#endif\n\n\tIF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));\n\treturn mem;\n}\n",
                {
                    "263": "void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)",
                    "264": "{",
                    "265": "\tstruct z_heap *h = heap->heap;",
                    "266": "\tvoid *mem;",
                    "267": "",
                    "268": "\tif (bytes == 0U) {",
                    "269": "\t\treturn NULL;",
                    "270": "\t}",
                    "271": "",
                    "272": "\tchunksz_t chunk_sz = bytes_to_chunksz(h, bytes, 0);",
                    "273": "\tchunkid_t c = alloc_chunk(h, chunk_sz);",
                    "274": "",
                    "275": "\tif (c == 0U) {",
                    "276": "\t\treturn NULL;",
                    "277": "\t}",
                    "278": "",
                    "279": "\t/* Split off remainder if any */",
                    "280": "\tif (chunk_size(h, c) > chunk_sz) {",
                    "281": "\t\tsplit_chunks(h, c, c + chunk_sz);",
                    "282": "\t\tfree_list_add(h, c + chunk_sz);",
                    "283": "\t}",
                    "284": "",
                    "285": "\tset_chunk_used(h, c, true);",
                    "286": "",
                    "287": "\tmem = chunk_mem(h, c);",
                    "288": "",
                    "289": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "290": "\tincrease_allocated_bytes(h, chunksz_to_bytes(h, chunk_size(h, c)));",
                    "291": "#endif",
                    "292": "",
                    "293": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "294": "\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,",
                    "295": "\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));",
                    "296": "#endif",
                    "297": "",
                    "298": "\tIF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));",
                    "299": "\treturn mem;",
                    "300": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "sys_heap_init": {
            "name": "sys_heap_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 525,
            "function_content": [
                "/*\n* Either ptr is not sufficiently aligned for in-place realloc or\n* in-place realloc was not possible: fallback to allocate and copy.\n*/\nvoid sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)\n{\n\tIF_ENABLED(CONFIG_MSAN, (__sanitizer_dtor_callback(mem, bytes)));\n\n\tif (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {\n\t\t/* Must fit in a 15 bit count of HUNK_UNIT */\n\t\t__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, \"heap size is too big\");\n\t} else {\n\t\t/* Must fit in a 31 bit count of HUNK_UNIT */\n\t\t__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, \"heap size is too big\");\n\t}\n\n\t/* Reserve the end marker chunk's header */\n\t__ASSERT(bytes > heap_footer_bytes(bytes), \"heap size is too small\");\n\tbytes -= heap_footer_bytes(bytes);\n\n\t/* Round the start up, the end down */\n\tuintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);\n\tuintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);\n\tchunksz_t heap_sz = (end - addr) / CHUNK_UNIT;\n\n\tCHECK(end > addr);\n\t__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), \"heap size is too small\");\n\n\tstruct z_heap *h = (struct z_heap *)addr;\n\theap->heap = h;\n\th->end_chunk = heap_sz;\n\th->avail_buckets = 0;\n\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\th->free_bytes = 0;\n\th->allocated_bytes = 0;\n\th->max_allocated_bytes = 0;\n#endif\n\n#if CONFIG_SYS_HEAP_ARRAY_SIZE\n\tsys_heap_array_save(heap);\n#endif\n\n\tint nb_buckets = bucket_idx(h, heap_sz) + 1;\n\tchunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +\n\t\t\t\t     nb_buckets * sizeof(struct z_heap_bucket));\n\n\t__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, \"heap size is too small\");\n\n\tfor (int i = 0; i < nb_buckets; i++) {\n\t\th->buckets[i].next = 0;\n\t}\n\n\t/* chunk containing our struct z_heap */\n\tset_chunk_size(h, 0, chunk0_size);\n\tset_left_chunk_size(h, 0, 0);\n\tset_chunk_used(h, 0, true);\n\n\t/* chunk containing the free heap */\n\tset_chunk_size(h, chunk0_size, heap_sz - chunk0_size);\n\tset_left_chunk_size(h, chunk0_size, chunk0_size);\n\n\t/* the end marker chunk */\n\tset_chunk_size(h, heap_sz, 0);\n\tset_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);\n\tset_chunk_used(h, heap_sz, true);\n\n\tfree_list_add(h, chunk0_size);\n}\n",
                {
                    "525": "void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)",
                    "526": "{",
                    "527": "\tIF_ENABLED(CONFIG_MSAN, (__sanitizer_dtor_callback(mem, bytes)));",
                    "528": "",
                    "529": "\tif (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {",
                    "530": "\t\t/* Must fit in a 15 bit count of HUNK_UNIT */",
                    "531": "\t\t__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, \"heap size is too big\");",
                    "532": "\t} else {",
                    "533": "\t\t/* Must fit in a 31 bit count of HUNK_UNIT */",
                    "534": "\t\t__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, \"heap size is too big\");",
                    "535": "\t}",
                    "536": "",
                    "537": "\t/* Reserve the end marker chunk's header */",
                    "538": "\t__ASSERT(bytes > heap_footer_bytes(bytes), \"heap size is too small\");",
                    "539": "\tbytes -= heap_footer_bytes(bytes);",
                    "540": "",
                    "541": "\t/* Round the start up, the end down */",
                    "542": "\tuintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);",
                    "543": "\tuintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);",
                    "544": "\tchunksz_t heap_sz = (end - addr) / CHUNK_UNIT;",
                    "545": "",
                    "546": "\tCHECK(end > addr);",
                    "547": "\t__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), \"heap size is too small\");",
                    "548": "",
                    "549": "\tstruct z_heap *h = (struct z_heap *)addr;",
                    "550": "\theap->heap = h;",
                    "551": "\th->end_chunk = heap_sz;",
                    "552": "\th->avail_buckets = 0;",
                    "553": "",
                    "554": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "555": "\th->free_bytes = 0;",
                    "556": "\th->allocated_bytes = 0;",
                    "557": "\th->max_allocated_bytes = 0;",
                    "558": "#endif",
                    "559": "",
                    "560": "#if CONFIG_SYS_HEAP_ARRAY_SIZE",
                    "561": "\tsys_heap_array_save(heap);",
                    "562": "#endif",
                    "563": "",
                    "564": "\tint nb_buckets = bucket_idx(h, heap_sz) + 1;",
                    "565": "\tchunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +",
                    "566": "\t\t\t\t     nb_buckets * sizeof(struct z_heap_bucket));",
                    "567": "",
                    "568": "\t__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, \"heap size is too small\");",
                    "569": "",
                    "570": "\tfor (int i = 0; i < nb_buckets; i++) {",
                    "571": "\t\th->buckets[i].next = 0;",
                    "572": "\t}",
                    "573": "",
                    "574": "\t/* chunk containing our struct z_heap */",
                    "575": "\tset_chunk_size(h, 0, chunk0_size);",
                    "576": "\tset_left_chunk_size(h, 0, 0);",
                    "577": "\tset_chunk_used(h, 0, true);",
                    "578": "",
                    "579": "\t/* chunk containing the free heap */",
                    "580": "\tset_chunk_size(h, chunk0_size, heap_sz - chunk0_size);",
                    "581": "\tset_left_chunk_size(h, chunk0_size, chunk0_size);",
                    "582": "",
                    "583": "\t/* the end marker chunk */",
                    "584": "\tset_chunk_size(h, heap_sz, 0);",
                    "585": "\tset_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);",
                    "586": "\tset_chunk_used(h, heap_sz, true);",
                    "587": "",
                    "588": "\tfree_list_add(h, chunk0_size);",
                    "589": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "vsnprintk": {
            "name": "vsnprintk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/printk.c",
            "location_line": 243,
            "function_content": [
                "#endif /* defined(CONFIG_PRINTK) */\nint vsnprintk(char *str, size_t size, const char *fmt, va_list ap)\n{\n\tstruct str_context ctx = { str, size, 0 };\n\n\tcbvprintf(str_out, &ctx, fmt, ap);\n\n\tif (ctx.count < ctx.max) {\n\t\tstr[ctx.count] = '\\0';\n\t}\n\n\treturn ctx.count;\n}\n",
                {
                    "243": "int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)",
                    "244": "{",
                    "245": "\tstruct str_context ctx = { str, size, 0 };",
                    "246": "",
                    "247": "\tcbvprintf(str_out, &ctx, fmt, ap);",
                    "248": "",
                    "249": "\tif (ctx.count < ctx.max) {",
                    "250": "\t\tstr[ctx.count] = '\\0';",
                    "251": "\t}",
                    "252": "",
                    "253": "\treturn ctx.count;",
                    "254": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "snprintk": {
            "name": "snprintk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/printk.c",
            "location_line": 231,
            "function_content": [
                "#endif /* defined(CONFIG_PRINTK) */\nint snprintk(char *str, size_t size, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintk(str, size, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n",
                {
                    "231": "int snprintk(char *str, size_t size, const char *fmt, ...)",
                    "232": "{",
                    "233": "\tva_list ap;",
                    "234": "\tint ret;",
                    "235": "",
                    "236": "\tva_start(ap, fmt);",
                    "237": "\tret = vsnprintk(str, size, fmt, ap);",
                    "238": "\tva_end(ap);",
                    "239": "",
                    "240": "\treturn ret;",
                    "241": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "vprintk": {
            "name": "vprintk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/printk.c",
            "location_line": 101,
            "function_content": [
                "/* LCOV_EXCL_STOP */\nvoid vprintk(const char *fmt, va_list ap)\n{\n\tif (IS_ENABLED(CONFIG_LOG_PRINTK)) {\n\t\tz_log_vprintk(fmt, ap);\n\t\treturn;\n\t}\n\n\tif (k_is_user_context()) {\n\t\tstruct buf_out_context ctx = {\n#ifdef CONFIG_PICOLIBC\n\t\t\t.file = FDEV_SETUP_STREAM((int(*)(char, FILE *))buf_char_out,\n\t\t\t\t\t\t  NULL, NULL, _FDEV_SETUP_WRITE),\n#else\n\t\t\t0\n#endif\n\t\t};\n\n#ifdef CONFIG_PICOLIBC\n\t\t(void) vfprintf(&ctx.file, fmt, ap);\n#else\n\t\tcbvprintf(buf_char_out, &ctx, fmt, ap);\n#endif\n\t\tif (ctx.buf_count) {\n\t\t\tbuf_flush(&ctx);\n\t\t}\n\t} else {\n#ifdef CONFIG_PRINTK_SYNC\n\t\tk_spinlock_key_t key = k_spin_lock(&lock);\n#endif\n\n#ifdef CONFIG_PICOLIBC\n\t\tFILE console = FDEV_SETUP_STREAM((int(*)(char, FILE *))char_out,\n\t\t\t\t\t\t NULL, NULL, _FDEV_SETUP_WRITE);\n\t\t(void) vfprintf(&console, fmt, ap);\n#else\n\t\tcbvprintf(char_out, NULL, fmt, ap);\n#endif\n\n#ifdef CONFIG_PRINTK_SYNC\n\t\tk_spin_unlock(&lock, key);\n#endif\n\t}\n}\n",
                {
                    "101": "void vprintk(const char *fmt, va_list ap)",
                    "102": "{",
                    "103": "\tif (IS_ENABLED(CONFIG_LOG_PRINTK)) {",
                    "104": "\t\tz_log_vprintk(fmt, ap);",
                    "105": "\t\treturn;",
                    "106": "\t}",
                    "107": "",
                    "108": "\tif (k_is_user_context()) {",
                    "109": "\t\tstruct buf_out_context ctx = {",
                    "110": "#ifdef CONFIG_PICOLIBC",
                    "111": "\t\t\t.file = FDEV_SETUP_STREAM((int(*)(char, FILE *))buf_char_out,",
                    "112": "\t\t\t\t\t\t  NULL, NULL, _FDEV_SETUP_WRITE),",
                    "113": "#else",
                    "114": "\t\t\t0",
                    "115": "#endif",
                    "116": "\t\t};",
                    "117": "",
                    "118": "#ifdef CONFIG_PICOLIBC",
                    "119": "\t\t(void) vfprintf(&ctx.file, fmt, ap);",
                    "120": "#else",
                    "121": "\t\tcbvprintf(buf_char_out, &ctx, fmt, ap);",
                    "122": "#endif",
                    "123": "\t\tif (ctx.buf_count) {",
                    "124": "\t\t\tbuf_flush(&ctx);",
                    "125": "\t\t}",
                    "126": "\t} else {",
                    "127": "#ifdef CONFIG_PRINTK_SYNC",
                    "128": "\t\tk_spinlock_key_t key = k_spin_lock(&lock);",
                    "129": "#endif",
                    "130": "",
                    "131": "#ifdef CONFIG_PICOLIBC",
                    "132": "\t\tFILE console = FDEV_SETUP_STREAM((int(*)(char, FILE *))char_out,",
                    "133": "\t\t\t\t\t\t NULL, NULL, _FDEV_SETUP_WRITE);",
                    "134": "\t\t(void) vfprintf(&console, fmt, ap);",
                    "135": "#else",
                    "136": "\t\tcbvprintf(char_out, NULL, fmt, ap);",
                    "137": "#endif",
                    "138": "",
                    "139": "#ifdef CONFIG_PRINTK_SYNC",
                    "140": "\t\tk_spin_unlock(&lock, key);",
                    "141": "#endif",
                    "142": "\t}",
                    "143": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "printk": {
            "name": "printk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/printk.c",
            "location_line": 192,
            "function_content": [
                "/**\n* @brief Output a string\n*\n* Output a string on output installed by platform at init time. Some\n* printf-like formatting is available.\n*\n* Available formatting:\n* - %x/%X:  outputs a number in hexadecimal format\n* - %s:     outputs a null-terminated string\n* - %p:     pointer, same as %x with a 0x prefix\n* - %u:     outputs a number in unsigned decimal format\n* - %d/%i:  outputs a number in signed decimal format\n*\n* Field width (with or without leading zeroes) is supported.\n* Length attributes h, hh, l, ll and z are supported. However, integral\n* values with %lld and %lli are only printed if they fit in a long\n* otherwise 'ERR' is printed. Full 64-bit values may be printed with %llx.\n*\n* @param fmt formatted string to output\n*/\nvoid printk(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\tvprintk(fmt, ap);\n\n\tva_end(ap);\n}\n",
                {
                    "192": "void printk(const char *fmt, ...)",
                    "193": "{",
                    "194": "\tva_list ap;",
                    "195": "",
                    "196": "\tva_start(ap, fmt);",
                    "197": "",
                    "198": "\tvprintk(fmt, ap);",
                    "199": "",
                    "200": "\tva_end(ap);",
                    "201": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_item_get": {
            "name": "ring_buf_item_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 186,
            "function_content": [
                "uint32_t  value  :8;  /**< Room for small integral values */\nint ring_buf_item_get(struct ring_buf *buf, uint16_t *type, uint8_t *value,\n\t\t      uint32_t *data32, uint8_t *size32)\n{\n\tuint8_t *src, *data = (uint8_t *)data32;\n\tstruct ring_element *header;\n\tuint32_t size, partial_size, total_size;\n\tint err;\n\n\tif (ring_buf_is_empty(buf)) {\n\t\treturn -EAGAIN;\n\t}\n\n\terr = ring_buf_get_claim(buf, &src, sizeof(struct ring_element));\n\t__ASSERT_NO_MSG(err == sizeof(struct ring_element));\n\n\theader = (struct ring_element *)src;\n\n\tif (data && (header->length > *size32)) {\n\t\t*size32 = header->length;\n\t\tring_buf_get_finish(buf, 0);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t*size32 = header->length;\n\t*type = header->type;\n\t*value = header->value;\n\ttotal_size = sizeof(struct ring_element);\n\n\tsize = *size32 * 4;\n\n\tdo {\n\t\tpartial_size = ring_buf_get_claim(buf, &src, size);\n\t\tif (partial_size == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (data) {\n\t\t\tmemcpy(data, src, partial_size);\n\t\t\tdata += partial_size;\n\t\t}\n\t\ttotal_size += partial_size;\n\t\tsize -= partial_size;\n\t} while (size != 0);\n\n\terr = ring_buf_get_finish(buf, total_size);\n\t__ASSERT_NO_MSG(err == 0);\n\tARG_UNUSED(err);\n\n\treturn 0;\n}\n",
                {
                    "186": "int ring_buf_item_get(struct ring_buf *buf, uint16_t *type, uint8_t *value,",
                    "187": "\t\t      uint32_t *data32, uint8_t *size32)",
                    "188": "{",
                    "189": "\tuint8_t *src, *data = (uint8_t *)data32;",
                    "190": "\tstruct ring_element *header;",
                    "191": "\tuint32_t size, partial_size, total_size;",
                    "192": "\tint err;",
                    "193": "",
                    "194": "\tif (ring_buf_is_empty(buf)) {",
                    "195": "\t\treturn -EAGAIN;",
                    "196": "\t}",
                    "197": "",
                    "198": "\terr = ring_buf_get_claim(buf, &src, sizeof(struct ring_element));",
                    "199": "\t__ASSERT_NO_MSG(err == sizeof(struct ring_element));",
                    "200": "",
                    "201": "\theader = (struct ring_element *)src;",
                    "202": "",
                    "203": "\tif (data && (header->length > *size32)) {",
                    "204": "\t\t*size32 = header->length;",
                    "205": "\t\tring_buf_get_finish(buf, 0);",
                    "206": "\t\treturn -EMSGSIZE;",
                    "207": "\t}",
                    "208": "",
                    "209": "\t*size32 = header->length;",
                    "210": "\t*type = header->type;",
                    "211": "\t*value = header->value;",
                    "212": "\ttotal_size = sizeof(struct ring_element);",
                    "213": "",
                    "214": "\tsize = *size32 * 4;",
                    "215": "",
                    "216": "\tdo {",
                    "217": "\t\tpartial_size = ring_buf_get_claim(buf, &src, size);",
                    "218": "\t\tif (partial_size == 0) {",
                    "219": "\t\t\tbreak;",
                    "220": "\t\t}",
                    "221": "\t\tif (data) {",
                    "222": "\t\t\tmemcpy(data, src, partial_size);",
                    "223": "\t\t\tdata += partial_size;",
                    "224": "\t\t}",
                    "225": "\t\ttotal_size += partial_size;",
                    "226": "\t\tsize -= partial_size;",
                    "227": "\t} while (size != 0);",
                    "228": "",
                    "229": "\terr = ring_buf_get_finish(buf, total_size);",
                    "230": "\t__ASSERT_NO_MSG(err == 0);",
                    "231": "\tARG_UNUSED(err);",
                    "232": "",
                    "233": "\treturn 0;",
                    "234": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_item_put": {
            "name": "ring_buf_item_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 144,
            "function_content": [
                "uint32_t  value  :8;  /**< Room for small integral values */\nint ring_buf_item_put(struct ring_buf *buf, uint16_t type, uint8_t value,\n\t\t      uint32_t *data32, uint8_t size32)\n{\n\tuint8_t *dst, *data = (uint8_t *)data32;\n\tstruct ring_element *header;\n\tuint32_t space, size, partial_size, total_size;\n\tint err;\n\n\tspace = ring_buf_space_get(buf);\n\tsize = size32 * 4;\n\tif (size + sizeof(struct ring_element) > space) {\n\t\treturn -EMSGSIZE;\n\t}\n\n\terr = ring_buf_put_claim(buf, &dst, sizeof(struct ring_element));\n\t__ASSERT_NO_MSG(err == sizeof(struct ring_element));\n\n\theader = (struct ring_element *)dst;\n\theader->type = type;\n\theader->length = size32;\n\theader->value = value;\n\ttotal_size = sizeof(struct ring_element);\n\n\tdo {\n\t\tpartial_size = ring_buf_put_claim(buf, &dst, size);\n\t\tif (partial_size == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(dst, data, partial_size);\n\t\tsize -= partial_size;\n\t\ttotal_size += partial_size;\n\t\tdata += partial_size;\n\t} while (size != 0);\n\t__ASSERT_NO_MSG(size == 0);\n\n\terr = ring_buf_put_finish(buf, total_size);\n\t__ASSERT_NO_MSG(err == 0);\n\tARG_UNUSED(err);\n\n\treturn 0;\n}\n",
                {
                    "144": "int ring_buf_item_put(struct ring_buf *buf, uint16_t type, uint8_t value,",
                    "145": "\t\t      uint32_t *data32, uint8_t size32)",
                    "146": "{",
                    "147": "\tuint8_t *dst, *data = (uint8_t *)data32;",
                    "148": "\tstruct ring_element *header;",
                    "149": "\tuint32_t space, size, partial_size, total_size;",
                    "150": "\tint err;",
                    "151": "",
                    "152": "\tspace = ring_buf_space_get(buf);",
                    "153": "\tsize = size32 * 4;",
                    "154": "\tif (size + sizeof(struct ring_element) > space) {",
                    "155": "\t\treturn -EMSGSIZE;",
                    "156": "\t}",
                    "157": "",
                    "158": "\terr = ring_buf_put_claim(buf, &dst, sizeof(struct ring_element));",
                    "159": "\t__ASSERT_NO_MSG(err == sizeof(struct ring_element));",
                    "160": "",
                    "161": "\theader = (struct ring_element *)dst;",
                    "162": "\theader->type = type;",
                    "163": "\theader->length = size32;",
                    "164": "\theader->value = value;",
                    "165": "\ttotal_size = sizeof(struct ring_element);",
                    "166": "",
                    "167": "\tdo {",
                    "168": "\t\tpartial_size = ring_buf_put_claim(buf, &dst, size);",
                    "169": "\t\tif (partial_size == 0) {",
                    "170": "\t\t\tbreak;",
                    "171": "\t\t}",
                    "172": "\t\tmemcpy(dst, data, partial_size);",
                    "173": "\t\tsize -= partial_size;",
                    "174": "\t\ttotal_size += partial_size;",
                    "175": "\t\tdata += partial_size;",
                    "176": "\t} while (size != 0);",
                    "177": "\t__ASSERT_NO_MSG(size == 0);",
                    "178": "",
                    "179": "\terr = ring_buf_put_finish(buf, total_size);",
                    "180": "\t__ASSERT_NO_MSG(err == 0);",
                    "181": "\tARG_UNUSED(err);",
                    "182": "",
                    "183": "\treturn 0;",
                    "184": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_peek": {
            "name": "ring_buf_peek",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 105,
            "function_content": [
                "/* we wrapped: adjust ring->base */\nuint32_t ring_buf_peek(struct ring_buf *buf, uint8_t *data, uint32_t size)\n{\n\tuint8_t *src;\n\tuint32_t partial_size;\n\tuint32_t total_size = 0U;\n\tint err;\n\n\tdo {\n\t\tpartial_size = ring_buf_get_claim(buf, &src, size);\n\t\tif (partial_size == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t__ASSERT_NO_MSG(data != NULL);\n\t\tmemcpy(data, src, partial_size);\n\t\tdata += partial_size;\n\t\ttotal_size += partial_size;\n\t\tsize -= partial_size;\n\t} while (size != 0);\n\n\t/* effectively unclaim total_size bytes */\n\terr = ring_buf_get_finish(buf, 0);\n\t__ASSERT_NO_MSG(err == 0);\n\tARG_UNUSED(err);\n\n\treturn total_size;\n}\n",
                {
                    "105": "uint32_t ring_buf_peek(struct ring_buf *buf, uint8_t *data, uint32_t size)",
                    "106": "{",
                    "107": "\tuint8_t *src;",
                    "108": "\tuint32_t partial_size;",
                    "109": "\tuint32_t total_size = 0U;",
                    "110": "\tint err;",
                    "111": "",
                    "112": "\tdo {",
                    "113": "\t\tpartial_size = ring_buf_get_claim(buf, &src, size);",
                    "114": "\t\tif (partial_size == 0) {",
                    "115": "\t\t\tbreak;",
                    "116": "\t\t}",
                    "117": "\t\t__ASSERT_NO_MSG(data != NULL);",
                    "118": "\t\tmemcpy(data, src, partial_size);",
                    "119": "\t\tdata += partial_size;",
                    "120": "\t\ttotal_size += partial_size;",
                    "121": "\t\tsize -= partial_size;",
                    "122": "\t} while (size != 0);",
                    "123": "",
                    "124": "\t/* effectively unclaim total_size bytes */",
                    "125": "\terr = ring_buf_get_finish(buf, 0);",
                    "126": "\t__ASSERT_NO_MSG(err == 0);",
                    "127": "\tARG_UNUSED(err);",
                    "128": "",
                    "129": "\treturn total_size;",
                    "130": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_get": {
            "name": "ring_buf_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 78,
            "function_content": [
                "/* we wrapped: adjust ring->base */\nuint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)\n{\n\tuint8_t *src;\n\tuint32_t partial_size;\n\tuint32_t total_size = 0U;\n\tint err;\n\n\tdo {\n\t\tpartial_size = ring_buf_get_claim(buf, &src, size);\n\t\tif (partial_size == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (data) {\n\t\t\tmemcpy(data, src, partial_size);\n\t\t\tdata += partial_size;\n\t\t}\n\t\ttotal_size += partial_size;\n\t\tsize -= partial_size;\n\t} while (size != 0);\n\n\terr = ring_buf_get_finish(buf, total_size);\n\t__ASSERT_NO_MSG(err == 0);\n\tARG_UNUSED(err);\n\n\treturn total_size;\n}\n",
                {
                    "78": "uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)",
                    "79": "{",
                    "80": "\tuint8_t *src;",
                    "81": "\tuint32_t partial_size;",
                    "82": "\tuint32_t total_size = 0U;",
                    "83": "\tint err;",
                    "84": "",
                    "85": "\tdo {",
                    "86": "\t\tpartial_size = ring_buf_get_claim(buf, &src, size);",
                    "87": "\t\tif (partial_size == 0) {",
                    "88": "\t\t\tbreak;",
                    "89": "\t\t}",
                    "90": "\t\tif (data) {",
                    "91": "\t\t\tmemcpy(data, src, partial_size);",
                    "92": "\t\t\tdata += partial_size;",
                    "93": "\t\t}",
                    "94": "\t\ttotal_size += partial_size;",
                    "95": "\t\tsize -= partial_size;",
                    "96": "\t} while (size != 0);",
                    "97": "",
                    "98": "\terr = ring_buf_get_finish(buf, total_size);",
                    "99": "\t__ASSERT_NO_MSG(err == 0);",
                    "100": "\tARG_UNUSED(err);",
                    "101": "",
                    "102": "\treturn total_size;",
                    "103": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_put": {
            "name": "ring_buf_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 53,
            "function_content": [
                "/* we wrapped: adjust ring->base */\nuint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)\n{\n\tuint8_t *dst;\n\tuint32_t partial_size;\n\tuint32_t total_size = 0U;\n\tint err;\n\n\tdo {\n\t\tpartial_size = ring_buf_put_claim(buf, &dst, size);\n\t\tif (partial_size == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(dst, data, partial_size);\n\t\ttotal_size += partial_size;\n\t\tsize -= partial_size;\n\t\tdata += partial_size;\n\t} while (size != 0);\n\n\terr = ring_buf_put_finish(buf, total_size);\n\t__ASSERT_NO_MSG(err == 0);\n\tARG_UNUSED(err);\n\n\treturn total_size;\n}\n",
                {
                    "53": "uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)",
                    "54": "{",
                    "55": "\tuint8_t *dst;",
                    "56": "\tuint32_t partial_size;",
                    "57": "\tuint32_t total_size = 0U;",
                    "58": "\tint err;",
                    "59": "",
                    "60": "\tdo {",
                    "61": "\t\tpartial_size = ring_buf_put_claim(buf, &dst, size);",
                    "62": "\t\tif (partial_size == 0) {",
                    "63": "\t\t\tbreak;",
                    "64": "\t\t}",
                    "65": "\t\tmemcpy(dst, data, partial_size);",
                    "66": "\t\ttotal_size += partial_size;",
                    "67": "\t\tsize -= partial_size;",
                    "68": "\t\tdata += partial_size;",
                    "69": "\t} while (size != 0);",
                    "70": "",
                    "71": "\terr = ring_buf_put_finish(buf, total_size);",
                    "72": "\t__ASSERT_NO_MSG(err == 0);",
                    "73": "\tARG_UNUSED(err);",
                    "74": "",
                    "75": "\treturn total_size;",
                    "76": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ring_buf_area_claim": {
            "name": "ring_buf_area_claim",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/utils/ring_buffer.c",
            "location_line": 12,
            "function_content": [
                "/*\n* Copyright (c) 2015 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nuint32_t ring_buf_area_claim(struct ring_buf *buf, struct ring_buf_index *ring,\n\t\t\t     uint8_t **data, uint32_t size)\n{\n\tring_buf_idx_t head_offset, wrap_size;\n\n\thead_offset = ring->head - ring->base;\n\tif (unlikely(head_offset >= buf->size)) {\n\t\t/* ring->base is not yet adjusted */\n\t\thead_offset -= buf->size;\n\t}\n\twrap_size = buf->size - head_offset;\n\tsize = min(size, wrap_size);\n\n\t*data = &buf->buffer[head_offset];\n\tring->head += size;\n\n\treturn size;\n}\n",
                {
                    "12": "uint32_t ring_buf_area_claim(struct ring_buf *buf, struct ring_buf_index *ring,",
                    "13": "\t\t\t     uint8_t **data, uint32_t size)",
                    "14": "{",
                    "15": "\tring_buf_idx_t head_offset, wrap_size;",
                    "16": "",
                    "17": "\thead_offset = ring->head - ring->base;",
                    "18": "\tif (unlikely(head_offset >= buf->size)) {",
                    "19": "\t\t/* ring->base is not yet adjusted */",
                    "20": "\t\thead_offset -= buf->size;",
                    "21": "\t}",
                    "22": "\twrap_size = buf->size - head_offset;",
                    "23": "\tsize = min(size, wrap_size);",
                    "24": "",
                    "25": "\t*data = &buf->buffer[head_offset];",
                    "26": "\tring->head += size;",
                    "27": "",
                    "28": "\treturn size;",
                    "29": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_pipe_read": {
            "name": "z_impl_k_pipe_read",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 220,
            "function_content": [
                "#endif /* CONFIG_POLL */\nint z_impl_k_pipe_read(struct k_pipe *pipe, uint8_t *data, size_t len, k_timeout_t timeout)\n{\n\tstruct pipe_buf_spec buf = { data, len, 0 };\n\tint rc;\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tk_spinlock_key_t key = k_spin_lock(&pipe->lock);\n\tbool need_resched = false;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, read, pipe, data, len, timeout);\n\n\tif (unlikely(pipe_resetting(pipe))) {\n\t\trc = -ECANCELED;\n\t\tgoto exit;\n\t}\n\n\tfor (;;) {\n\t\tif (pipe_full(pipe)) {\n\t\t\t/* One or more pending writers may exist. */\n\t\t\tneed_resched = z_sched_wake_all(&pipe->space, 0, NULL);\n\t\t}\n\n\t\tbuf.used += ring_buf_get(&pipe->buf, &data[buf.used], len - buf.used);\n\t\tif (likely(buf.used == len)) {\n\t\t\trc = buf.used;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(pipe_closed(pipe))) {\n\t\t\trc = buf.used ? buf.used : -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* provide our \"direct copy\" info to potential writers */\n\t\t_current->base.swap_data = &buf;\n\n\t\trc = wait_for(&pipe->data, pipe, &key, end, &need_resched);\n\t\tif (rc != 0) {\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = buf.used ? buf.used : -EAGAIN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, read, pipe, rc);\n\tif (need_resched) {\n\t\tz_reschedule(&pipe->lock, key);\n\t} else {\n\t\tk_spin_unlock(&pipe->lock, key);\n\t}\n\treturn rc;\n}\n",
                {
                    "220": "int z_impl_k_pipe_read(struct k_pipe *pipe, uint8_t *data, size_t len, k_timeout_t timeout)",
                    "221": "{",
                    "222": "\tstruct pipe_buf_spec buf = { data, len, 0 };",
                    "223": "\tint rc;",
                    "224": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "225": "\tk_spinlock_key_t key = k_spin_lock(&pipe->lock);",
                    "226": "\tbool need_resched = false;",
                    "227": "",
                    "228": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, read, pipe, data, len, timeout);",
                    "229": "",
                    "230": "\tif (unlikely(pipe_resetting(pipe))) {",
                    "231": "\t\trc = -ECANCELED;",
                    "232": "\t\tgoto exit;",
                    "233": "\t}",
                    "234": "",
                    "235": "\tfor (;;) {",
                    "236": "\t\tif (pipe_full(pipe)) {",
                    "237": "\t\t\t/* One or more pending writers may exist. */",
                    "238": "\t\t\tneed_resched = z_sched_wake_all(&pipe->space, 0, NULL);",
                    "239": "\t\t}",
                    "240": "",
                    "241": "\t\tbuf.used += ring_buf_get(&pipe->buf, &data[buf.used], len - buf.used);",
                    "242": "\t\tif (likely(buf.used == len)) {",
                    "243": "\t\t\trc = buf.used;",
                    "244": "\t\t\tbreak;",
                    "245": "\t\t}",
                    "246": "",
                    "247": "\t\tif (unlikely(pipe_closed(pipe))) {",
                    "248": "\t\t\trc = buf.used ? buf.used : -EPIPE;",
                    "249": "\t\t\tbreak;",
                    "250": "\t\t}",
                    "251": "",
                    "252": "\t\t/* provide our \"direct copy\" info to potential writers */",
                    "253": "\t\t_current->base.swap_data = &buf;",
                    "254": "",
                    "255": "\t\trc = wait_for(&pipe->data, pipe, &key, end, &need_resched);",
                    "256": "\t\tif (rc != 0) {",
                    "257": "\t\t\tif (rc == -EAGAIN) {",
                    "258": "\t\t\t\trc = buf.used ? buf.used : -EAGAIN;",
                    "259": "\t\t\t}",
                    "260": "\t\t\tbreak;",
                    "261": "\t\t}",
                    "262": "\t}",
                    "263": "exit:",
                    "264": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, read, pipe, rc);",
                    "265": "\tif (need_resched) {",
                    "266": "\t\tz_reschedule(&pipe->lock, key);",
                    "267": "\t} else {",
                    "268": "\t\tk_spin_unlock(&pipe->lock, key);",
                    "269": "\t}",
                    "270": "\treturn rc;",
                    "271": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_pipe_write": {
            "name": "z_impl_k_pipe_write",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 147,
            "function_content": [
                "/* rest of thread wake-up outside the scheduler lock */\nint z_impl_k_pipe_write(struct k_pipe *pipe, const uint8_t *data, size_t len, k_timeout_t timeout)\n{\n\tint rc;\n\tsize_t written = 0;\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tk_spinlock_key_t key = k_spin_lock(&pipe->lock);\n\tbool need_resched = false;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, write, pipe, data, len, timeout);\n\n\tif (unlikely(pipe_resetting(pipe))) {\n\t\trc = -ECANCELED;\n\t\tgoto exit;\n\t}\n\n\tfor (;;) {\n\t\tif (unlikely(pipe_closed(pipe))) {\n\t\t\trc = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe_empty(pipe)) {\n\t\t\tif (IS_ENABLED(CONFIG_KERNEL_COHERENCE)) {\n\t\t\t\t/*\n\t\t\t\t * Systems that enabled this option don't have\n\t\t\t\t * their stacks in coherent memory. Given our\n\t\t\t\t * pipe_buf_spec is stored on the stack, and\n\t\t\t\t * readers may also have their destination\n\t\t\t\t * buffer on their stack too, it is not worth\n\t\t\t\t * supporting direct-to-readers copy with them.\n\t\t\t\t * Simply wake up all pending readers instead.\n\t\t\t\t */\n\t\t\t\tneed_resched = z_sched_wake_all(&pipe->data, 0, NULL);\n\t\t\t} else if (pipe->waiting != 0) {\n\t\t\t\twritten += copy_to_pending_readers(pipe, &need_resched,\n\t\t\t\t\t\t\t\t   &data[written],\n\t\t\t\t\t\t\t\t   len - written);\n\t\t\t\tif (written >= len) {\n\t\t\t\t\trc = written;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef CONFIG_POLL\n\t\tneed_resched |= z_handle_obj_poll_events(&pipe->poll_events,\n\t\t\t\t\t\t\t K_POLL_STATE_PIPE_DATA_AVAILABLE);\n#endif /* CONFIG_POLL */\n\n\t\twritten += ring_buf_put(&pipe->buf, &data[written], len - written);\n\t\tif (likely(written == len)) {\n\t\t\trc = written;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = wait_for(&pipe->space, pipe, &key, end, &need_resched);\n\t\tif (rc != 0) {\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = written ? written : -EAGAIN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, write, pipe, rc);\n\tif (need_resched) {\n\t\tz_reschedule(&pipe->lock, key);\n\t} else {\n\t\tk_spin_unlock(&pipe->lock, key);\n\t}\n\treturn rc;\n}\n",
                {
                    "147": "int z_impl_k_pipe_write(struct k_pipe *pipe, const uint8_t *data, size_t len, k_timeout_t timeout)",
                    "148": "{",
                    "149": "\tint rc;",
                    "150": "\tsize_t written = 0;",
                    "151": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "152": "\tk_spinlock_key_t key = k_spin_lock(&pipe->lock);",
                    "153": "\tbool need_resched = false;",
                    "154": "",
                    "155": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, write, pipe, data, len, timeout);",
                    "156": "",
                    "157": "\tif (unlikely(pipe_resetting(pipe))) {",
                    "158": "\t\trc = -ECANCELED;",
                    "159": "\t\tgoto exit;",
                    "160": "\t}",
                    "161": "",
                    "162": "\tfor (;;) {",
                    "163": "\t\tif (unlikely(pipe_closed(pipe))) {",
                    "164": "\t\t\trc = -EPIPE;",
                    "165": "\t\t\tbreak;",
                    "166": "\t\t}",
                    "167": "",
                    "168": "\t\tif (pipe_empty(pipe)) {",
                    "169": "\t\t\tif (IS_ENABLED(CONFIG_KERNEL_COHERENCE)) {",
                    "170": "\t\t\t\t/*",
                    "171": "\t\t\t\t * Systems that enabled this option don't have",
                    "172": "\t\t\t\t * their stacks in coherent memory. Given our",
                    "173": "\t\t\t\t * pipe_buf_spec is stored on the stack, and",
                    "174": "\t\t\t\t * readers may also have their destination",
                    "175": "\t\t\t\t * buffer on their stack too, it is not worth",
                    "176": "\t\t\t\t * supporting direct-to-readers copy with them.",
                    "177": "\t\t\t\t * Simply wake up all pending readers instead.",
                    "178": "\t\t\t\t */",
                    "179": "\t\t\t\tneed_resched = z_sched_wake_all(&pipe->data, 0, NULL);",
                    "180": "\t\t\t} else if (pipe->waiting != 0) {",
                    "181": "\t\t\t\twritten += copy_to_pending_readers(pipe, &need_resched,",
                    "182": "\t\t\t\t\t\t\t\t   &data[written],",
                    "183": "\t\t\t\t\t\t\t\t   len - written);",
                    "184": "\t\t\t\tif (written >= len) {",
                    "185": "\t\t\t\t\trc = written;",
                    "186": "\t\t\t\t\tbreak;",
                    "187": "\t\t\t\t}",
                    "188": "\t\t\t}",
                    "189": "\t\t}",
                    "190": "",
                    "191": "#ifdef CONFIG_POLL",
                    "192": "\t\tneed_resched |= z_handle_obj_poll_events(&pipe->poll_events,",
                    "193": "\t\t\t\t\t\t\t K_POLL_STATE_PIPE_DATA_AVAILABLE);",
                    "194": "#endif /* CONFIG_POLL */",
                    "195": "",
                    "196": "\t\twritten += ring_buf_put(&pipe->buf, &data[written], len - written);",
                    "197": "\t\tif (likely(written == len)) {",
                    "198": "\t\t\trc = written;",
                    "199": "\t\t\tbreak;",
                    "200": "\t\t}",
                    "201": "",
                    "202": "\t\trc = wait_for(&pipe->space, pipe, &key, end, &need_resched);",
                    "203": "\t\tif (rc != 0) {",
                    "204": "\t\t\tif (rc == -EAGAIN) {",
                    "205": "\t\t\t\trc = written ? written : -EAGAIN;",
                    "206": "\t\t\t}",
                    "207": "\t\t\tbreak;",
                    "208": "\t\t}",
                    "209": "\t}",
                    "210": "exit:",
                    "211": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, write, pipe, rc);",
                    "212": "\tif (need_resched) {",
                    "213": "\t\tz_reschedule(&pipe->lock, key);",
                    "214": "\t} else {",
                    "215": "\t\tk_spin_unlock(&pipe->lock, key);",
                    "216": "\t}",
                    "217": "\treturn rc;",
                    "218": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_pipe_init": {
            "name": "z_impl_k_pipe_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 67,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_PIPE */\nvoid z_impl_k_pipe_init(struct k_pipe *pipe, uint8_t *buffer, size_t buffer_size)\n{\n\tring_buf_init(&pipe->buf, buffer_size, buffer);\n\tpipe->flags = PIPE_FLAG_OPEN;\n\tpipe->waiting = 0;\n\n\tpipe->lock = (struct k_spinlock){};\n\tz_waitq_init(&pipe->data);\n\tz_waitq_init(&pipe->space);\n\tk_object_init(pipe);\n\n#ifdef CONFIG_POLL\n\tsys_dlist_init(&pipe->poll_events);\n#endif /* CONFIG_POLL */\n#ifdef CONFIG_OBJ_CORE_PIPE\n\tk_obj_core_init_and_link(K_OBJ_CORE(pipe), &obj_type_pipe);\n#endif /* CONFIG_OBJ_CORE_PIPE */\n\tSYS_PORT_TRACING_OBJ_INIT(k_pipe, pipe, buffer, buffer_size);\n}\n",
                {
                    "67": "void z_impl_k_pipe_init(struct k_pipe *pipe, uint8_t *buffer, size_t buffer_size)",
                    "68": "{",
                    "69": "\tring_buf_init(&pipe->buf, buffer_size, buffer);",
                    "70": "\tpipe->flags = PIPE_FLAG_OPEN;",
                    "71": "\tpipe->waiting = 0;",
                    "72": "",
                    "73": "\tpipe->lock = (struct k_spinlock){};",
                    "74": "\tz_waitq_init(&pipe->data);",
                    "75": "\tz_waitq_init(&pipe->space);",
                    "76": "\tk_object_init(pipe);",
                    "77": "",
                    "78": "#ifdef CONFIG_POLL",
                    "79": "\tsys_dlist_init(&pipe->poll_events);",
                    "80": "#endif /* CONFIG_POLL */",
                    "81": "#ifdef CONFIG_OBJ_CORE_PIPE",
                    "82": "\tk_obj_core_init_and_link(K_OBJ_CORE(pipe), &obj_type_pipe);",
                    "83": "#endif /* CONFIG_OBJ_CORE_PIPE */",
                    "84": "\tSYS_PORT_TRACING_OBJ_INIT(k_pipe, pipe, buffer, buffer_size);",
                    "85": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_purge": {
            "name": "z_impl_k_msgq_purge",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 435,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nvoid z_impl_k_msgq_purge(struct k_msgq *msgq)\n{\n\tk_spinlock_key_t key;\n\tstruct k_thread *pending_thread;\n\tbool resched = false;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);\n\n\t/* wake up any threads that are waiting to write */\n\tfor (pending_thread = z_unpend_first_thread(&msgq->wait_q);\n\t     pending_thread != NULL;\n\t     pending_thread = z_unpend_first_thread(&msgq->wait_q)) {\n\t\tarch_thread_return_value_set(pending_thread, -ENOMSG);\n\t\tz_ready_thread(pending_thread);\n\t\tresched = true;\n\t}\n\n\tmsgq->used_msgs = 0;\n\tmsgq->read_ptr = msgq->write_ptr;\n\n\tif (resched) {\n\t\tz_reschedule(&msgq->lock, key);\n\t} else {\n\t\tk_spin_unlock(&msgq->lock, key);\n\t}\n}\n",
                {
                    "435": "void z_impl_k_msgq_purge(struct k_msgq *msgq)",
                    "436": "{",
                    "437": "\tk_spinlock_key_t key;",
                    "438": "\tstruct k_thread *pending_thread;",
                    "439": "\tbool resched = false;",
                    "440": "",
                    "441": "\tkey = k_spin_lock(&msgq->lock);",
                    "442": "",
                    "443": "\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);",
                    "444": "",
                    "445": "\t/* wake up any threads that are waiting to write */",
                    "446": "\tfor (pending_thread = z_unpend_first_thread(&msgq->wait_q);",
                    "447": "\t     pending_thread != NULL;",
                    "448": "\t     pending_thread = z_unpend_first_thread(&msgq->wait_q)) {",
                    "449": "\t\tarch_thread_return_value_set(pending_thread, -ENOMSG);",
                    "450": "\t\tz_ready_thread(pending_thread);",
                    "451": "\t\tresched = true;",
                    "452": "\t}",
                    "453": "",
                    "454": "\tmsgq->used_msgs = 0;",
                    "455": "\tmsgq->read_ptr = msgq->write_ptr;",
                    "456": "",
                    "457": "\tif (resched) {",
                    "458": "\t\tz_reschedule(&msgq->lock, key);",
                    "459": "\t} else {",
                    "460": "\t\tk_spin_unlock(&msgq->lock, key);",
                    "461": "\t}",
                    "462": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_peek_at": {
            "name": "z_impl_k_msgq_peek_at",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 389,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_msgq_peek_at(struct k_msgq *msgq, void *data, uint32_t idx)\n{\n\tk_spinlock_key_t key;\n\tint result;\n\tuint32_t bytes_to_end;\n\tuint32_t byte_offset;\n\tchar *start_addr;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tif (msgq->used_msgs > idx) {\n\t\tbytes_to_end = (msgq->buffer_end - msgq->read_ptr);\n\t\tbyte_offset = idx * msgq->msg_size;\n\t\tstart_addr = msgq->read_ptr;\n\t\t/* check item available in start/end of ring buffer */\n\t\tif (bytes_to_end <= byte_offset) {\n\t\t\t/* Tweak the values in case */\n\t\t\tbyte_offset -= bytes_to_end;\n\t\t\t/* wrap-around is required */\n\t\t\tstart_addr = msgq->buffer_start;\n\t\t}\n\t\t(void)memcpy(data, start_addr + byte_offset, msgq->msg_size);\n\t\tresult = 0;\n\t} else {\n\t\t/* don't wait for a message to become available */\n\t\tresult = -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);\n\n\tk_spin_unlock(&msgq->lock, key);\n\n\treturn result;\n}\n",
                {
                    "389": "int z_impl_k_msgq_peek_at(struct k_msgq *msgq, void *data, uint32_t idx)",
                    "390": "{",
                    "391": "\tk_spinlock_key_t key;",
                    "392": "\tint result;",
                    "393": "\tuint32_t bytes_to_end;",
                    "394": "\tuint32_t byte_offset;",
                    "395": "\tchar *start_addr;",
                    "396": "",
                    "397": "\tkey = k_spin_lock(&msgq->lock);",
                    "398": "",
                    "399": "\tif (msgq->used_msgs > idx) {",
                    "400": "\t\tbytes_to_end = (msgq->buffer_end - msgq->read_ptr);",
                    "401": "\t\tbyte_offset = idx * msgq->msg_size;",
                    "402": "\t\tstart_addr = msgq->read_ptr;",
                    "403": "\t\t/* check item available in start/end of ring buffer */",
                    "404": "\t\tif (bytes_to_end <= byte_offset) {",
                    "405": "\t\t\t/* Tweak the values in case */",
                    "406": "\t\t\tbyte_offset -= bytes_to_end;",
                    "407": "\t\t\t/* wrap-around is required */",
                    "408": "\t\t\tstart_addr = msgq->buffer_start;",
                    "409": "\t\t}",
                    "410": "\t\t(void)memcpy(data, start_addr + byte_offset, msgq->msg_size);",
                    "411": "\t\tresult = 0;",
                    "412": "\t} else {",
                    "413": "\t\t/* don't wait for a message to become available */",
                    "414": "\t\tresult = -ENOMSG;",
                    "415": "\t}",
                    "416": "",
                    "417": "\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);",
                    "418": "",
                    "419": "\tk_spin_unlock(&msgq->lock, key);",
                    "420": "",
                    "421": "\treturn result;",
                    "422": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_peek": {
            "name": "z_impl_k_msgq_peek",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 355,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)\n{\n\tk_spinlock_key_t key;\n\tint result;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tif (msgq->used_msgs > 0U) {\n\t\t/* take first available message from queue */\n\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);\n\t\tresult = 0;\n\t} else {\n\t\t/* don't wait for a message to become available */\n\t\tresult = -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);\n\n\tk_spin_unlock(&msgq->lock, key);\n\n\treturn result;\n}\n",
                {
                    "355": "int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)",
                    "356": "{",
                    "357": "\tk_spinlock_key_t key;",
                    "358": "\tint result;",
                    "359": "",
                    "360": "\tkey = k_spin_lock(&msgq->lock);",
                    "361": "",
                    "362": "\tif (msgq->used_msgs > 0U) {",
                    "363": "\t\t/* take first available message from queue */",
                    "364": "\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);",
                    "365": "\t\tresult = 0;",
                    "366": "\t} else {",
                    "367": "\t\t/* don't wait for a message to become available */",
                    "368": "\t\tresult = -ENOMSG;",
                    "369": "\t}",
                    "370": "",
                    "371": "\tSYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);",
                    "372": "",
                    "373": "\tk_spin_unlock(&msgq->lock, key);",
                    "374": "",
                    "375": "\treturn result;",
                    "376": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_get": {
            "name": "z_impl_k_msgq_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 274,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)\n{\n\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");\n\n\tk_spinlock_key_t key;\n\tstruct k_thread *pending_thread;\n\tint result;\n\tbool resched = false;\n\n\tkey = k_spin_lock(&msgq->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);\n\n\tif (msgq->used_msgs > 0U) {\n\t\t/* take first available message from queue */\n\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);\n\t\tmsgq->read_ptr += msgq->msg_size;\n\t\tif (msgq->read_ptr == msgq->buffer_end) {\n\t\t\tmsgq->read_ptr = msgq->buffer_start;\n\t\t}\n\t\tmsgq->used_msgs--;\n\n\t\t/* handle first thread waiting to write (if any) */\n\t\tpending_thread = z_unpend_first_thread(&msgq->wait_q);\n\t\tif (unlikely(pending_thread != NULL)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);\n\n\t\t\t/* add thread's message to queue */\n\t\t\t__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&\n\t\t\t\t\tmsgq->write_ptr < msgq->buffer_end);\n\t\t\t(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,\n\t\t\t       msgq->msg_size);\n\t\t\tmsgq->write_ptr += msgq->msg_size;\n\t\t\tif (msgq->write_ptr == msgq->buffer_end) {\n\t\t\t\tmsgq->write_ptr = msgq->buffer_start;\n\t\t\t}\n\t\t\tmsgq->used_msgs++;\n\n\t\t\t/* wake up waiting thread */\n\t\t\tarch_thread_return_value_set(pending_thread, 0);\n\t\t\tz_ready_thread(pending_thread);\n\t\t\tresched = true;\n\t\t}\n\t\tresult = 0;\n\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t/* don't wait for a message to become available */\n\t\tresult = -ENOMSG;\n\t} else {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);\n\n\t\t/* wait for get message success or timeout */\n\t\t_current->base.swap_data = data;\n\n\t\tresult = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);\n\t\treturn result;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);\n\n\tif (resched) {\n\t\tz_reschedule(&msgq->lock, key);\n\t} else {\n\t\tk_spin_unlock(&msgq->lock, key);\n\t}\n\n\treturn result;\n}\n",
                {
                    "274": "int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)",
                    "275": "{",
                    "276": "\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");",
                    "277": "",
                    "278": "\tk_spinlock_key_t key;",
                    "279": "\tstruct k_thread *pending_thread;",
                    "280": "\tint result;",
                    "281": "\tbool resched = false;",
                    "282": "",
                    "283": "\tkey = k_spin_lock(&msgq->lock);",
                    "284": "",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);",
                    "286": "",
                    "287": "\tif (msgq->used_msgs > 0U) {",
                    "288": "\t\t/* take first available message from queue */",
                    "289": "\t\t(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);",
                    "290": "\t\tmsgq->read_ptr += msgq->msg_size;",
                    "291": "\t\tif (msgq->read_ptr == msgq->buffer_end) {",
                    "292": "\t\t\tmsgq->read_ptr = msgq->buffer_start;",
                    "293": "\t\t}",
                    "294": "\t\tmsgq->used_msgs--;",
                    "295": "",
                    "296": "\t\t/* handle first thread waiting to write (if any) */",
                    "297": "\t\tpending_thread = z_unpend_first_thread(&msgq->wait_q);",
                    "298": "\t\tif (unlikely(pending_thread != NULL)) {",
                    "299": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);",
                    "300": "",
                    "301": "\t\t\t/* add thread's message to queue */",
                    "302": "\t\t\t__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&",
                    "303": "\t\t\t\t\tmsgq->write_ptr < msgq->buffer_end);",
                    "304": "\t\t\t(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,",
                    "305": "\t\t\t       msgq->msg_size);",
                    "306": "\t\t\tmsgq->write_ptr += msgq->msg_size;",
                    "307": "\t\t\tif (msgq->write_ptr == msgq->buffer_end) {",
                    "308": "\t\t\t\tmsgq->write_ptr = msgq->buffer_start;",
                    "309": "\t\t\t}",
                    "310": "\t\t\tmsgq->used_msgs++;",
                    "311": "",
                    "312": "\t\t\t/* wake up waiting thread */",
                    "313": "\t\t\tarch_thread_return_value_set(pending_thread, 0);",
                    "314": "\t\t\tz_ready_thread(pending_thread);",
                    "315": "\t\t\tresched = true;",
                    "316": "\t\t}",
                    "317": "\t\tresult = 0;",
                    "318": "\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "319": "\t\t/* don't wait for a message to become available */",
                    "320": "\t\tresult = -ENOMSG;",
                    "321": "\t} else {",
                    "322": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);",
                    "323": "",
                    "324": "\t\t/* wait for get message success or timeout */",
                    "325": "\t\t_current->base.swap_data = data;",
                    "326": "",
                    "327": "\t\tresult = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);",
                    "328": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);",
                    "329": "\t\treturn result;",
                    "330": "\t}",
                    "331": "",
                    "332": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);",
                    "333": "",
                    "334": "\tif (resched) {",
                    "335": "\t\tz_reschedule(&msgq->lock, key);",
                    "336": "\t} else {",
                    "337": "\t\tk_spin_unlock(&msgq->lock, key);",
                    "338": "\t}",
                    "339": "",
                    "340": "\treturn result;",
                    "341": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_put_front": {
            "name": "z_impl_k_msgq_put_front",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 230,
            "function_content": [
                "/* wait for put message success, failure, or timeout */\nint z_impl_k_msgq_put_front(struct k_msgq *msgq, const void *data)\n{\n\treturn put_msg_in_queue(msgq, data, K_NO_WAIT, false);\n}\n",
                {
                    "230": "int z_impl_k_msgq_put_front(struct k_msgq *msgq, const void *data)",
                    "231": "{",
                    "232": "\treturn put_msg_in_queue(msgq, data, K_NO_WAIT, false);",
                    "233": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_put": {
            "name": "z_impl_k_msgq_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 225,
            "function_content": [
                "/* wait for put message success, failure, or timeout */\nint z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)\n{\n\treturn put_msg_in_queue(msgq, data, timeout, true);\n}\n",
                {
                    "225": "int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)",
                    "226": "{",
                    "227": "\treturn put_msg_in_queue(msgq, data, timeout, true);",
                    "228": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_msgq_alloc_init": {
            "name": "z_impl_k_msgq_alloc_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 69,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MSGQ */\nint z_impl_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,\n\t\t\t    uint32_t max_msgs)\n{\n\tvoid *buffer;\n\tint ret;\n\tsize_t total_size;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, alloc_init, msgq);\n\n\tif (size_mul_overflow(msg_size, max_msgs, &total_size)) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tbuffer = z_thread_malloc(total_size);\n\t\tif (buffer != NULL) {\n\t\t\tk_msgq_init(msgq, buffer, msg_size, max_msgs);\n\t\t\tmsgq->flags = K_MSGQ_FLAG_ALLOC;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, alloc_init, msgq, ret);\n\treturn ret;\n}\n",
                {
                    "69": "int z_impl_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,",
                    "70": "\t\t\t    uint32_t max_msgs)",
                    "71": "{",
                    "72": "\tvoid *buffer;",
                    "73": "\tint ret;",
                    "74": "\tsize_t total_size;",
                    "75": "",
                    "76": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, alloc_init, msgq);",
                    "77": "",
                    "78": "\tif (size_mul_overflow(msg_size, max_msgs, &total_size)) {",
                    "79": "\t\tret = -EINVAL;",
                    "80": "\t} else {",
                    "81": "\t\tbuffer = z_thread_malloc(total_size);",
                    "82": "\t\tif (buffer != NULL) {",
                    "83": "\t\t\tk_msgq_init(msgq, buffer, msg_size, max_msgs);",
                    "84": "\t\t\tmsgq->flags = K_MSGQ_FLAG_ALLOC;",
                    "85": "\t\t\tret = 0;",
                    "86": "\t\t} else {",
                    "87": "\t\t\tret = -ENOMEM;",
                    "88": "\t\t}",
                    "89": "\t}",
                    "90": "",
                    "91": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, alloc_init, msgq, ret);",
                    "92": "\treturn ret;",
                    "93": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_stack_pop": {
            "name": "z_impl_k_stack_pop",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/stack.c",
            "location_line": 148,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_k_stack_pop(struct k_stack *stack, stack_data_t *data,\n\t\t       k_timeout_t timeout)\n{\n\tk_spinlock_key_t key;\n\tint result;\n\n\tkey = k_spin_lock(&stack->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, pop, stack, timeout);\n\n\tif (likely(stack->next > stack->base)) {\n\t\tstack->next--;\n\t\t*data = *(stack->next);\n\t\tk_spin_unlock(&stack->lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);\n\n\t\treturn 0;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_stack, pop, stack, timeout);\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tk_spin_unlock(&stack->lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EBUSY);\n\n\t\treturn -EBUSY;\n\t}\n\n\tresult = z_pend_curr(&stack->lock, key, &stack->wait_q, timeout);\n\tif (result == -EAGAIN) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EAGAIN);\n\n\t\treturn -EAGAIN;\n\t}\n\n\t*data = (stack_data_t)_current->base.swap_data;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);\n\n\treturn 0;\n}\n",
                {
                    "148": "int z_impl_k_stack_pop(struct k_stack *stack, stack_data_t *data,",
                    "149": "\t\t       k_timeout_t timeout)",
                    "150": "{",
                    "151": "\tk_spinlock_key_t key;",
                    "152": "\tint result;",
                    "153": "",
                    "154": "\tkey = k_spin_lock(&stack->lock);",
                    "155": "",
                    "156": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, pop, stack, timeout);",
                    "157": "",
                    "158": "\tif (likely(stack->next > stack->base)) {",
                    "159": "\t\tstack->next--;",
                    "160": "\t\t*data = *(stack->next);",
                    "161": "\t\tk_spin_unlock(&stack->lock, key);",
                    "162": "",
                    "163": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);",
                    "164": "",
                    "165": "\t\treturn 0;",
                    "166": "\t}",
                    "167": "",
                    "168": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_stack, pop, stack, timeout);",
                    "169": "",
                    "170": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "171": "\t\tk_spin_unlock(&stack->lock, key);",
                    "172": "",
                    "173": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EBUSY);",
                    "174": "",
                    "175": "\t\treturn -EBUSY;",
                    "176": "\t}",
                    "177": "",
                    "178": "\tresult = z_pend_curr(&stack->lock, key, &stack->wait_q, timeout);",
                    "179": "\tif (result == -EAGAIN) {",
                    "180": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EAGAIN);",
                    "181": "",
                    "182": "\t\treturn -EAGAIN;",
                    "183": "\t}",
                    "184": "",
                    "185": "\t*data = (stack_data_t)_current->base.swap_data;",
                    "186": "",
                    "187": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);",
                    "188": "",
                    "189": "\treturn 0;",
                    "190": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_get": {
            "name": "z_impl_k_queue_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 335,
            "function_content": [
                "/*\n* note: this works as long as:\n* - the slist implementation keeps the next pointer as the first\n*   field of the node object type\n* - list->tail->next = NULL.\n* - sflist implementation only differs from slist by stuffing\n*   flag bytes in the lower order bits of the data pointer\n* - source list is really an slist and not an sflist with flags set\n*/\nvoid *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)\n{\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tvoid *data;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);\n\n\tif (likely(!sys_sflist_is_empty(&queue->data_q))) {\n\t\tsys_sfnode_t *node;\n\n\t\tnode = sys_sflist_get_not_empty(&queue->data_q);\n\t\tdata = z_queue_node_peek(node, true);\n\t\tk_spin_unlock(&queue->lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, data);\n\n\t\treturn data;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tk_spin_unlock(&queue->lock, key);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);\n\n\t\treturn NULL;\n\t}\n\n\tint ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,\n\t\t(ret != 0) ? NULL : _current->base.swap_data);\n\n\treturn (ret != 0) ? NULL : _current->base.swap_data;\n}\n",
                {
                    "335": "void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)",
                    "336": "{",
                    "337": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "338": "\tvoid *data;",
                    "339": "",
                    "340": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);",
                    "341": "",
                    "342": "\tif (likely(!sys_sflist_is_empty(&queue->data_q))) {",
                    "343": "\t\tsys_sfnode_t *node;",
                    "344": "",
                    "345": "\t\tnode = sys_sflist_get_not_empty(&queue->data_q);",
                    "346": "\t\tdata = z_queue_node_peek(node, true);",
                    "347": "\t\tk_spin_unlock(&queue->lock, key);",
                    "348": "",
                    "349": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, data);",
                    "350": "",
                    "351": "\t\treturn data;",
                    "352": "\t}",
                    "353": "",
                    "354": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);",
                    "355": "",
                    "356": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "357": "\t\tk_spin_unlock(&queue->lock, key);",
                    "358": "",
                    "359": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);",
                    "360": "",
                    "361": "\t\treturn NULL;",
                    "362": "\t}",
                    "363": "",
                    "364": "\tint ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);",
                    "365": "",
                    "366": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,",
                    "367": "\t\t(ret != 0) ? NULL : _current->base.swap_data);",
                    "368": "",
                    "369": "\treturn (ret != 0) ? NULL : _current->base.swap_data;",
                    "370": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_alloc_prepend": {
            "name": "z_impl_k_queue_alloc_prepend",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 236,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint32_t z_impl_k_queue_alloc_prepend(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_prepend, queue);\n\n\tint32_t ret = queue_insert(queue, NULL, data, true, false);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_prepend, queue, ret);\n\n\treturn ret;\n}\n",
                {
                    "236": "int32_t z_impl_k_queue_alloc_prepend(struct k_queue *queue, void *data)",
                    "237": "{",
                    "238": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_prepend, queue);",
                    "239": "",
                    "240": "\tint32_t ret = queue_insert(queue, NULL, data, true, false);",
                    "241": "",
                    "242": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_prepend, queue, ret);",
                    "243": "",
                    "244": "\treturn ret;",
                    "245": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_k_queue_alloc_append": {
            "name": "z_impl_k_queue_alloc_append",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 215,
            "function_content": [
                "/* Only need to actually allocate if no threads are pending */\nint32_t z_impl_k_queue_alloc_append(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_append, queue);\n\n\tint32_t ret = queue_insert(queue, NULL, data, true, true);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_append, queue, ret);\n\n\treturn ret;\n}\n",
                {
                    "215": "int32_t z_impl_k_queue_alloc_append(struct k_queue *queue, void *data)",
                    "216": "{",
                    "217": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_append, queue);",
                    "218": "",
                    "219": "\tint32_t ret = queue_insert(queue, NULL, data, true, true);",
                    "220": "",
                    "221": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_append, queue, ret);",
                    "222": "",
                    "223": "\treturn ret;",
                    "224": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_poll_event_init": {
            "name": "k_poll_event_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 43,
            "function_content": [
                "/* Single subsystem lock.  Locking per-event would be better on highly\n* contended SMP systems, but the original locking scheme here is\n* subtle (it relies on releasing/reacquiring the lock in areas for\n* latency control and it's sometimes hard to see exactly what data is\n* \"inside\" a given critical section).  Do the synchronization port\n* later as an optimization.\n*/\nvoid k_poll_event_init(struct k_poll_event *event, uint32_t type,\n\t\t       int mode, void *obj)\n{\n\t__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,\n\t\t \"only NOTIFY_ONLY mode is supported\\n\");\n\t__ASSERT(type < (BIT(_POLL_NUM_TYPES)), \"invalid type\\n\");\n\t__ASSERT(obj != NULL, \"must provide an object\\n\");\n\n\tevent->poller = NULL;\n\t/* event->tag is left uninitialized: the user will set it if needed */\n\tevent->type = type;\n\tevent->state = K_POLL_STATE_NOT_READY;\n\tevent->mode = mode;\n\tevent->unused = 0U;\n\tevent->obj = obj;\n\n\tSYS_PORT_TRACING_FUNC(k_poll_api, event_init, event);\n}\n",
                {
                    "43": "void k_poll_event_init(struct k_poll_event *event, uint32_t type,",
                    "44": "\t\t       int mode, void *obj)",
                    "45": "{",
                    "46": "\t__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,",
                    "47": "\t\t \"only NOTIFY_ONLY mode is supported\\n\");",
                    "48": "\t__ASSERT(type < (BIT(_POLL_NUM_TYPES)), \"invalid type\\n\");",
                    "49": "\t__ASSERT(obj != NULL, \"must provide an object\\n\");",
                    "50": "",
                    "51": "\tevent->poller = NULL;",
                    "52": "\t/* event->tag is left uninitialized: the user will set it if needed */",
                    "53": "\tevent->type = type;",
                    "54": "\tevent->state = K_POLL_STATE_NOT_READY;",
                    "55": "\tevent->mode = mode;",
                    "56": "\tevent->unused = 0U;",
                    "57": "\tevent->obj = obj;",
                    "58": "",
                    "59": "\tSYS_PORT_TRACING_FUNC(k_poll_api, event_init, event);",
                    "60": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_realloc": {
            "name": "k_realloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 125,
            "function_content": [
                "/*\n* No point calling k_heap_malloc/k_heap_aligned_alloc with K_NO_WAIT.\n* Better bypass them and go directly to sys_heap_*() instead.\n*/\nvoid *k_realloc(void *ptr, size_t size)\n{\n\tstruct k_heap *heap, **heap_ref;\n\tk_spinlock_key_t key;\n\tvoid *ret;\n\n\tif (size == 0) {\n\t\tk_free(ptr);\n\t\treturn NULL;\n\t}\n\tif (ptr == NULL) {\n\t\treturn k_malloc(size);\n\t}\n\theap_ref = ptr;\n\tptr = --heap_ref;\n\theap = *heap_ref;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_realloc, heap, ptr);\n\n\tif (size_add_overflow(size, sizeof(heap_ref), &size)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_realloc, heap, ptr, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * No point calling k_heap_realloc() with K_NO_WAIT here.\n\t * Better bypass it and go directly to sys_heap_realloc() instead.\n\t */\n\tkey = k_spin_lock(&heap->lock);\n\tret = sys_heap_realloc(&heap->heap, ptr, size);\n\tk_spin_unlock(&heap->lock, key);\n\n\tif (ret != NULL) {\n\t\theap_ref = ret;\n\t\tret = ++heap_ref;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_realloc, heap, ptr, ret);\n\n\treturn ret;\n}\n",
                {
                    "125": "void *k_realloc(void *ptr, size_t size)",
                    "126": "{",
                    "127": "\tstruct k_heap *heap, **heap_ref;",
                    "128": "\tk_spinlock_key_t key;",
                    "129": "\tvoid *ret;",
                    "130": "",
                    "131": "\tif (size == 0) {",
                    "132": "\t\tk_free(ptr);",
                    "133": "\t\treturn NULL;",
                    "134": "\t}",
                    "135": "\tif (ptr == NULL) {",
                    "136": "\t\treturn k_malloc(size);",
                    "137": "\t}",
                    "138": "\theap_ref = ptr;",
                    "139": "\tptr = --heap_ref;",
                    "140": "\theap = *heap_ref;",
                    "141": "",
                    "142": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_realloc, heap, ptr);",
                    "143": "",
                    "144": "\tif (size_add_overflow(size, sizeof(heap_ref), &size)) {",
                    "145": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_realloc, heap, ptr, NULL);",
                    "146": "\t\treturn NULL;",
                    "147": "\t}",
                    "148": "",
                    "149": "\t/*",
                    "150": "\t * No point calling k_heap_realloc() with K_NO_WAIT here.",
                    "151": "\t * Better bypass it and go directly to sys_heap_realloc() instead.",
                    "152": "\t */",
                    "153": "\tkey = k_spin_lock(&heap->lock);",
                    "154": "\tret = sys_heap_realloc(&heap->heap, ptr, size);",
                    "155": "\tk_spin_unlock(&heap->lock, key);",
                    "156": "",
                    "157": "\tif (ret != NULL) {",
                    "158": "\t\theap_ref = ret;",
                    "159": "\t\tret = ++heap_ref;",
                    "160": "\t}",
                    "161": "",
                    "162": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_realloc, heap, ptr, ret);",
                    "163": "",
                    "164": "\treturn ret;",
                    "165": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_calloc": {
            "name": "k_calloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 102,
            "function_content": [
                "/*\n* No point calling k_heap_malloc/k_heap_aligned_alloc with K_NO_WAIT.\n* Better bypass them and go directly to sys_heap_*() instead.\n*/\nvoid *k_calloc(size_t nmemb, size_t size)\n{\n\tvoid *ret;\n\tsize_t bounds;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_calloc, _SYSTEM_HEAP);\n\n\tif (size_mul_overflow(nmemb, size, &bounds)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_calloc, _SYSTEM_HEAP, NULL);\n\n\t\treturn NULL;\n\t}\n\n\tret = k_malloc(bounds);\n\tif (ret != NULL) {\n\t\t(void)memset(ret, 0, bounds);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_calloc, _SYSTEM_HEAP, ret);\n\n\treturn ret;\n}\n",
                {
                    "102": "void *k_calloc(size_t nmemb, size_t size)",
                    "103": "{",
                    "104": "\tvoid *ret;",
                    "105": "\tsize_t bounds;",
                    "106": "",
                    "107": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_calloc, _SYSTEM_HEAP);",
                    "108": "",
                    "109": "\tif (size_mul_overflow(nmemb, size, &bounds)) {",
                    "110": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_calloc, _SYSTEM_HEAP, NULL);",
                    "111": "",
                    "112": "\t\treturn NULL;",
                    "113": "\t}",
                    "114": "",
                    "115": "\tret = k_malloc(bounds);",
                    "116": "\tif (ret != NULL) {",
                    "117": "\t\t(void)memset(ret, 0, bounds);",
                    "118": "\t}",
                    "119": "",
                    "120": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_calloc, _SYSTEM_HEAP, ret);",
                    "121": "",
                    "122": "\treturn ret;",
                    "123": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_free": {
            "name": "k_free",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 58,
            "function_content": [
                "/*\n* No point calling k_heap_malloc/k_heap_aligned_alloc with K_NO_WAIT.\n* Better bypass them and go directly to sys_heap_*() instead.\n*/\nvoid k_free(void *ptr)\n{\n\tstruct k_heap **heap_ref;\n\n\tif (ptr != NULL) {\n\t\theap_ref = ptr;\n\t\t--heap_ref;\n\t\tptr = heap_ref;\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);\n\n\t\tk_heap_free(*heap_ref, ptr);\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);\n\t}\n}\n",
                {
                    "58": "void k_free(void *ptr)",
                    "59": "{",
                    "60": "\tstruct k_heap **heap_ref;",
                    "61": "",
                    "62": "\tif (ptr != NULL) {",
                    "63": "\t\theap_ref = ptr;",
                    "64": "\t\t--heap_ref;",
                    "65": "\t\tptr = heap_ref;",
                    "66": "",
                    "67": "\t\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);",
                    "68": "",
                    "69": "\t\tk_heap_free(*heap_ref, ptr);",
                    "70": "",
                    "71": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);",
                    "72": "\t}",
                    "73": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_free": {
            "name": "k_heap_free",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/kheap.c",
            "location_line": 206,
            "function_content": [
                "/*\n* modules/debug/percepio/TraceRecorder/kernelports/Zephyr/include/tracing_tracerecorder.h\n* contains a concealed non-parameterized direct reference to a local\n* variable through the SYS_PORT_TRACING_OBJ_FUNC_EXIT macro below\n* that is no longer in scope. Provide a dummy stub for compilation\n* to still succeed until that module's layering violation is fixed.\n*/\nvoid k_heap_free(struct k_heap *heap, void *mem)\n{\n\tk_spinlock_key_t key = k_spin_lock(&heap->lock);\n\n\tsys_heap_free(&heap->heap, mem);\n\n\tSYS_PORT_TRACING_OBJ_FUNC(k_heap, free, heap);\n\tif (IS_ENABLED(CONFIG_MULTITHREADING) && (z_unpend_all(&heap->wait_q) != 0)) {\n\t\tz_reschedule(&heap->lock, key);\n\t} else {\n\t\tk_spin_unlock(&heap->lock, key);\n\t}\n}\n",
                {
                    "206": "void k_heap_free(struct k_heap *heap, void *mem)",
                    "207": "{",
                    "208": "\tk_spinlock_key_t key = k_spin_lock(&heap->lock);",
                    "209": "",
                    "210": "\tsys_heap_free(&heap->heap, mem);",
                    "211": "",
                    "212": "\tSYS_PORT_TRACING_OBJ_FUNC(k_heap, free, heap);",
                    "213": "\tif (IS_ENABLED(CONFIG_MULTITHREADING) && (z_unpend_all(&heap->wait_q) != 0)) {",
                    "214": "\t\tz_reschedule(&heap->lock, key);",
                    "215": "\t} else {",
                    "216": "\t\tk_spin_unlock(&heap->lock, key);",
                    "217": "\t}",
                    "218": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_realloc": {
            "name": "k_heap_realloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/kheap.c",
            "location_line": 176,
            "function_content": [
                "/*\n* modules/debug/percepio/TraceRecorder/kernelports/Zephyr/include/tracing_tracerecorder.h\n* contains a concealed non-parameterized direct reference to a local\n* variable through the SYS_PORT_TRACING_OBJ_FUNC_EXIT macro below\n* that is no longer in scope. Provide a dummy stub for compilation\n* to still succeed until that module's layering violation is fixed.\n*/\nvoid *k_heap_realloc(struct k_heap *heap, void *ptr, size_t bytes, k_timeout_t timeout)\n{\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tvoid *ret = NULL;\n\n\tk_spinlock_key_t key = k_spin_lock(&heap->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, realloc, heap, ptr, bytes, timeout);\n\n\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");\n\n\twhile (ret == NULL) {\n\t\tret = sys_heap_realloc(&heap->heap, ptr, bytes);\n\n\t\tif (!IS_ENABLED(CONFIG_MULTITHREADING) ||\n\t\t    (ret != NULL) || K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\t\t(void) z_pend_curr(&heap->lock, key, &heap->wait_q, timeout);\n\t\tkey = k_spin_lock(&heap->lock);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, realloc, heap, ptr, bytes, timeout, ret);\n\n\tk_spin_unlock(&heap->lock, key);\n\treturn ret;\n}\n",
                {
                    "176": "void *k_heap_realloc(struct k_heap *heap, void *ptr, size_t bytes, k_timeout_t timeout)",
                    "177": "{",
                    "178": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "179": "\tvoid *ret = NULL;",
                    "180": "",
                    "181": "\tk_spinlock_key_t key = k_spin_lock(&heap->lock);",
                    "182": "",
                    "183": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, realloc, heap, ptr, bytes, timeout);",
                    "184": "",
                    "185": "\t__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), \"\");",
                    "186": "",
                    "187": "\twhile (ret == NULL) {",
                    "188": "\t\tret = sys_heap_realloc(&heap->heap, ptr, bytes);",
                    "189": "",
                    "190": "\t\tif (!IS_ENABLED(CONFIG_MULTITHREADING) ||",
                    "191": "\t\t    (ret != NULL) || K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "192": "\t\t\tbreak;",
                    "193": "\t\t}",
                    "194": "",
                    "195": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "196": "\t\t(void) z_pend_curr(&heap->lock, key, &heap->wait_q, timeout);",
                    "197": "\t\tkey = k_spin_lock(&heap->lock);",
                    "198": "\t}",
                    "199": "",
                    "200": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, realloc, heap, ptr, bytes, timeout, ret);",
                    "201": "",
                    "202": "\tk_spin_unlock(&heap->lock, key);",
                    "203": "\treturn ret;",
                    "204": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_calloc": {
            "name": "k_heap_calloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/kheap.c",
            "location_line": 157,
            "function_content": [
                "/*\n* modules/debug/percepio/TraceRecorder/kernelports/Zephyr/include/tracing_tracerecorder.h\n* contains a concealed non-parameterized direct reference to a local\n* variable through the SYS_PORT_TRACING_OBJ_FUNC_EXIT macro below\n* that is no longer in scope. Provide a dummy stub for compilation\n* to still succeed until that module's layering violation is fixed.\n*/\nvoid *k_heap_calloc(struct k_heap *heap, size_t num, size_t size, k_timeout_t timeout)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, calloc, heap, timeout);\n\n\tvoid *ret = NULL;\n\tsize_t bounds = 0U;\n\n\tif (!size_mul_overflow(num, size, &bounds)) {\n\t\tret = k_heap_alloc(heap, bounds, timeout);\n\t}\n\tif (ret != NULL) {\n\t\t(void)memset(ret, 0, bounds);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, calloc, heap, timeout, ret);\n\n\treturn ret;\n}\n",
                {
                    "157": "void *k_heap_calloc(struct k_heap *heap, size_t num, size_t size, k_timeout_t timeout)",
                    "158": "{",
                    "159": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, calloc, heap, timeout);",
                    "160": "",
                    "161": "\tvoid *ret = NULL;",
                    "162": "\tsize_t bounds = 0U;",
                    "163": "",
                    "164": "\tif (!size_mul_overflow(num, size, &bounds)) {",
                    "165": "\t\tret = k_heap_alloc(heap, bounds, timeout);",
                    "166": "\t}",
                    "167": "\tif (ret != NULL) {",
                    "168": "\t\t(void)memset(ret, 0, bounds);",
                    "169": "\t}",
                    "170": "",
                    "171": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, calloc, heap, timeout, ret);",
                    "172": "",
                    "173": "\treturn ret;",
                    "174": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_heap_init": {
            "name": "k_heap_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/kheap.c",
            "location_line": 26,
            "function_content": [
                "/* Number of statically defined heaps */\nvoid k_heap_init(struct k_heap *heap, void *mem, size_t bytes)\n{\n\tz_waitq_init(&heap->wait_q);\n\theap->lock = (struct k_spinlock) {};\n\tsys_heap_init(&heap->heap, mem, bytes);\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);\n}\n",
                {
                    "26": "void k_heap_init(struct k_heap *heap, void *mem, size_t bytes)",
                    "27": "{",
                    "28": "\tz_waitq_init(&heap->wait_q);",
                    "29": "\theap->lock = (struct k_spinlock) {};",
                    "30": "\tsys_heap_init(&heap->heap, mem, bytes);",
                    "31": "",
                    "32": "\tSYS_PORT_TRACING_OBJ_INIT(k_heap, heap);",
                    "33": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_free": {
            "name": "k_mem_slab_free",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 271,
            "function_content": [
                "/* wait for a free block or timeout */\nvoid k_mem_slab_free(struct k_mem_slab *slab, void *mem)\n{\n\tif (!slab_ptr_is_good(slab, mem)) {\n\t\t__ASSERT(false, \"Invalid memory pointer provided\");\n\t\tk_panic();\n\t\treturn;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&slab->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);\n\tif (unlikely(slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\tstruct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);\n\n\t\tif (unlikely(pending_thread != NULL)) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);\n\n\t\t\tz_thread_return_value_set_with_data(pending_thread, 0, mem);\n\t\t\tz_ready_thread(pending_thread);\n\t\t\tz_reschedule(&slab->lock, key);\n\t\t\treturn;\n\t\t}\n\t}\n\t*(char **) mem = slab->free_list;\n\tslab->free_list = (char *) mem;\n\tslab->info.num_used--;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);\n\n\tk_spin_unlock(&slab->lock, key);\n}\n",
                {
                    "271": "void k_mem_slab_free(struct k_mem_slab *slab, void *mem)",
                    "272": "{",
                    "273": "\tif (!slab_ptr_is_good(slab, mem)) {",
                    "274": "\t\t__ASSERT(false, \"Invalid memory pointer provided\");",
                    "275": "\t\tk_panic();",
                    "276": "\t\treturn;",
                    "277": "\t}",
                    "278": "",
                    "279": "\tk_spinlock_key_t key = k_spin_lock(&slab->lock);",
                    "280": "",
                    "281": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);",
                    "282": "\tif (unlikely(slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "283": "\t\tstruct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);",
                    "284": "",
                    "285": "\t\tif (unlikely(pending_thread != NULL)) {",
                    "286": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);",
                    "287": "",
                    "288": "\t\t\tz_thread_return_value_set_with_data(pending_thread, 0, mem);",
                    "289": "\t\t\tz_ready_thread(pending_thread);",
                    "290": "\t\t\tz_reschedule(&slab->lock, key);",
                    "291": "\t\t\treturn;",
                    "292": "\t\t}",
                    "293": "\t}",
                    "294": "\t*(char **) mem = slab->free_list;",
                    "295": "\tslab->free_list = (char *) mem;",
                    "296": "\tslab->info.num_used--;",
                    "297": "",
                    "298": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);",
                    "299": "",
                    "300": "\tk_spin_unlock(&slab->lock, key);",
                    "301": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_alloc": {
            "name": "k_mem_slab_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 222,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */\nint k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)\n{\n\tk_spinlock_key_t key = k_spin_lock(&slab->lock);\n\tint result;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);\n\n\tif (slab->free_list != NULL) {\n\t\t/* take a free block */\n\t\t*mem = slab->free_list;\n\t\tslab->free_list = *(char **)(slab->free_list);\n\t\tslab->info.num_used++;\n\t\t__ASSERT((slab->free_list == NULL &&\n\t\t\t  slab->info.num_used == slab->info.num_blocks) ||\n\t\t\t slab_ptr_is_good(slab, slab->free_list),\n\t\t\t \"slab corruption detected\");\n\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\t\tslab->info.max_used = max(slab->info.num_used,\n\t\t\t\t\t  slab->info.max_used);\n#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */\n\n\t\tresult = 0;\n\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||\n\t\t   !IS_ENABLED(CONFIG_MULTITHREADING)) {\n\t\t/* don't wait for a free block to become available */\n\t\t*mem = NULL;\n\t\tresult = -ENOMEM;\n\t} else {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);\n\n\t\t/* wait for a free block or timeout */\n\t\tresult = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);\n\t\tif (result == 0) {\n\t\t\t*mem = _current->base.swap_data;\n\t\t}\n\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);\n\n\t\treturn result;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);\n\n\tk_spin_unlock(&slab->lock, key);\n\n\treturn result;\n}\n",
                {
                    "222": "int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)",
                    "223": "{",
                    "224": "\tk_spinlock_key_t key = k_spin_lock(&slab->lock);",
                    "225": "\tint result;",
                    "226": "",
                    "227": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);",
                    "228": "",
                    "229": "\tif (slab->free_list != NULL) {",
                    "230": "\t\t/* take a free block */",
                    "231": "\t\t*mem = slab->free_list;",
                    "232": "\t\tslab->free_list = *(char **)(slab->free_list);",
                    "233": "\t\tslab->info.num_used++;",
                    "234": "\t\t__ASSERT((slab->free_list == NULL &&",
                    "235": "\t\t\t  slab->info.num_used == slab->info.num_blocks) ||",
                    "236": "\t\t\t slab_ptr_is_good(slab, slab->free_list),",
                    "237": "\t\t\t \"slab corruption detected\");",
                    "238": "",
                    "239": "#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION",
                    "240": "\t\tslab->info.max_used = max(slab->info.num_used,",
                    "241": "\t\t\t\t\t  slab->info.max_used);",
                    "242": "#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */",
                    "243": "",
                    "244": "\t\tresult = 0;",
                    "245": "\t} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||",
                    "246": "\t\t   !IS_ENABLED(CONFIG_MULTITHREADING)) {",
                    "247": "\t\t/* don't wait for a free block to become available */",
                    "248": "\t\t*mem = NULL;",
                    "249": "\t\tresult = -ENOMEM;",
                    "250": "\t} else {",
                    "251": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);",
                    "252": "",
                    "253": "\t\t/* wait for a free block or timeout */",
                    "254": "\t\tresult = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);",
                    "255": "\t\tif (result == 0) {",
                    "256": "\t\t\t*mem = _current->base.swap_data;",
                    "257": "\t\t}",
                    "258": "",
                    "259": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);",
                    "260": "",
                    "261": "\t\treturn result;",
                    "262": "\t}",
                    "263": "",
                    "264": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);",
                    "265": "",
                    "266": "\tk_spin_unlock(&slab->lock, key);",
                    "267": "",
                    "268": "\treturn result;",
                    "269": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mem_slab_init": {
            "name": "k_mem_slab_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 172,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\nint k_mem_slab_init(struct k_mem_slab *slab, void *buffer,\n\t\t    size_t block_size, uint32_t num_blocks)\n{\n\tint rc;\n\n\tslab->info.num_blocks = num_blocks;\n\tslab->info.block_size = block_size;\n\tslab->buffer = buffer;\n\tslab->info.num_used = 0U;\n\tslab->lock = (struct k_spinlock) {};\n\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\tslab->info.max_used = 0U;\n#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */\n\n\trc = create_free_list(slab);\n\tif (rc < 0) {\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_OBJ_CORE_MEM_SLAB\n\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);\n#endif /* CONFIG_OBJ_CORE_MEM_SLAB */\n#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB\n\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,\n\t\t\t\t  sizeof(struct k_mem_slab_info));\n#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */\n\n\tz_waitq_init(&slab->wait_q);\n\tk_object_init(slab);\nout:\n\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);\n\n\treturn rc;\n}\n",
                {
                    "172": "int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,",
                    "173": "\t\t    size_t block_size, uint32_t num_blocks)",
                    "174": "{",
                    "175": "\tint rc;",
                    "176": "",
                    "177": "\tslab->info.num_blocks = num_blocks;",
                    "178": "\tslab->info.block_size = block_size;",
                    "179": "\tslab->buffer = buffer;",
                    "180": "\tslab->info.num_used = 0U;",
                    "181": "\tslab->lock = (struct k_spinlock) {};",
                    "182": "",
                    "183": "#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION",
                    "184": "\tslab->info.max_used = 0U;",
                    "185": "#endif /* CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION */",
                    "186": "",
                    "187": "\trc = create_free_list(slab);",
                    "188": "\tif (rc < 0) {",
                    "189": "\t\tgoto out;",
                    "190": "\t}",
                    "191": "",
                    "192": "#ifdef CONFIG_OBJ_CORE_MEM_SLAB",
                    "193": "\tk_obj_core_init_and_link(K_OBJ_CORE(slab), &obj_type_mem_slab);",
                    "194": "#endif /* CONFIG_OBJ_CORE_MEM_SLAB */",
                    "195": "#ifdef CONFIG_OBJ_CORE_STATS_MEM_SLAB",
                    "196": "\tk_obj_core_stats_register(K_OBJ_CORE(slab), &slab->info,",
                    "197": "\t\t\t\t  sizeof(struct k_mem_slab_info));",
                    "198": "#endif /* CONFIG_OBJ_CORE_STATS_MEM_SLAB */",
                    "199": "",
                    "200": "\tz_waitq_init(&slab->wait_q);",
                    "201": "\tk_object_init(slab);",
                    "202": "out:",
                    "203": "\tSYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);",
                    "204": "",
                    "205": "\treturn rc;",
                    "206": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_data_get": {
            "name": "k_mbox_data_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 335,
            "function_content": [
                "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\nvoid k_mbox_data_get(struct k_mbox_msg *rx_msg, void *buffer)\n{\n\t/* handle case where data is to be discarded */\n\tif (buffer == NULL) {\n\t\trx_msg->size = 0;\n\t\tmbox_message_dispose(rx_msg);\n\t\treturn;\n\t}\n\n\t/* copy message data to buffer, then dispose of message */\n\tif ((rx_msg->tx_data != NULL) && (rx_msg->size > 0U)) {\n\t\t(void)memcpy(buffer, rx_msg->tx_data, rx_msg->size);\n\t}\n\tmbox_message_dispose(rx_msg);\n}\n",
                {
                    "335": "void k_mbox_data_get(struct k_mbox_msg *rx_msg, void *buffer)",
                    "336": "{",
                    "337": "\t/* handle case where data is to be discarded */",
                    "338": "\tif (buffer == NULL) {",
                    "339": "\t\trx_msg->size = 0;",
                    "340": "\t\tmbox_message_dispose(rx_msg);",
                    "341": "\t\treturn;",
                    "342": "\t}",
                    "343": "",
                    "344": "\t/* copy message data to buffer, then dispose of message */",
                    "345": "\tif ((rx_msg->tx_data != NULL) && (rx_msg->size > 0U)) {",
                    "346": "\t\t(void)memcpy(buffer, rx_msg->tx_data, rx_msg->size);",
                    "347": "\t}",
                    "348": "\tmbox_message_dispose(rx_msg);",
                    "349": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_mbox_get": {
            "name": "k_mbox_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 382,
            "function_content": [
                "/* keep message around for later data retrieval */\nint k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,\n\t       k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_mbox_msg *tx_msg;\n\tk_spinlock_key_t key;\n\tint result;\n\n\t/* save receiver id so it can be used during message matching */\n\trx_msg->tx_target_thread = _current;\n\n\t/* search mailbox's tx queue for a compatible sender */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {\n\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take sender out of mailbox's tx queue */\n\t\t\tz_unpend_thread(sending_thread);\n\n\t\t\tk_spin_unlock(&mbox->lock, key);\n\n\t\t\t/* consume message data immediately, if needed */\n\t\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* didn't find a matching sender */\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);\n\n\t\t/* don't wait for a matching sender to appear */\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);\n\n\t/* wait until a matching sender appears or a timeout occurs */\n\t_current->base.swap_data = rx_msg;\n\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);\n\n\t/* consume message data immediately, if needed */\n\tif (result == 0) {\n\t\tresult = mbox_message_data_check(rx_msg, buffer);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);\n\n\treturn result;\n}\n",
                {
                    "382": "int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,",
                    "383": "\t       k_timeout_t timeout)",
                    "384": "{",
                    "385": "\tstruct k_thread *sending_thread;",
                    "386": "\tstruct k_mbox_msg *tx_msg;",
                    "387": "\tk_spinlock_key_t key;",
                    "388": "\tint result;",
                    "389": "",
                    "390": "\t/* save receiver id so it can be used during message matching */",
                    "391": "\trx_msg->tx_target_thread = _current;",
                    "392": "",
                    "393": "\t/* search mailbox's tx queue for a compatible sender */",
                    "394": "\tkey = k_spin_lock(&mbox->lock);",
                    "395": "",
                    "396": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, get, mbox, timeout);",
                    "397": "",
                    "398": "\t_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {",
                    "399": "\t\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;",
                    "400": "",
                    "401": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "402": "\t\t\t/* take sender out of mailbox's tx queue */",
                    "403": "\t\t\tz_unpend_thread(sending_thread);",
                    "404": "",
                    "405": "\t\t\tk_spin_unlock(&mbox->lock, key);",
                    "406": "",
                    "407": "\t\t\t/* consume message data immediately, if needed */",
                    "408": "\t\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "409": "",
                    "410": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "411": "\t\t\treturn result;",
                    "412": "\t\t}",
                    "413": "\t}",
                    "414": "",
                    "415": "\t/* didn't find a matching sender */",
                    "416": "",
                    "417": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "418": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, -ENOMSG);",
                    "419": "",
                    "420": "\t\t/* don't wait for a matching sender to appear */",
                    "421": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "422": "\t\treturn -ENOMSG;",
                    "423": "\t}",
                    "424": "",
                    "425": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, get, mbox, timeout);",
                    "426": "",
                    "427": "\t/* wait until a matching sender appears or a timeout occurs */",
                    "428": "\t_current->base.swap_data = rx_msg;",
                    "429": "\tresult = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);",
                    "430": "",
                    "431": "\t/* consume message data immediately, if needed */",
                    "432": "\tif (result == 0) {",
                    "433": "\t\tresult = mbox_message_data_check(rx_msg, buffer);",
                    "434": "\t}",
                    "435": "",
                    "436": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, get, mbox, timeout, result);",
                    "437": "",
                    "438": "\treturn result;",
                    "439": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_cleanup": {
            "name": "k_msgq_cleanup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 106,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_msgq_cleanup(struct k_msgq *msgq)\n{\n\tint ret = 0;\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);\n\n\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {\n\t\tk_free(msgq->buffer_start);\n\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;\n\t}\n\nexit:\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, ret);\n\treturn ret;\n}\n",
                {
                    "106": "int k_msgq_cleanup(struct k_msgq *msgq)",
                    "107": "{",
                    "108": "\tint ret = 0;",
                    "109": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);",
                    "110": "",
                    "111": "\tCHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {",
                    "112": "\t\tret = -EBUSY;",
                    "113": "\t\tgoto exit;",
                    "114": "\t}",
                    "115": "",
                    "116": "\tif ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {",
                    "117": "\t\tk_free(msgq->buffer_start);",
                    "118": "\t\tmsgq->flags &= ~K_MSGQ_FLAG_ALLOC;",
                    "119": "\t}",
                    "120": "",
                    "121": "exit:",
                    "122": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, ret);",
                    "123": "\treturn ret;",
                    "124": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_msgq_init": {
            "name": "k_msgq_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/msg_q.c",
            "location_line": 43,
            "function_content": [
                "#endif /* CONFIG_POLL */\nvoid k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,\n\t\t uint32_t max_msgs)\n{\n\tmsgq->msg_size = msg_size;\n\tmsgq->max_msgs = max_msgs;\n\tmsgq->buffer_start = buffer;\n\tmsgq->buffer_end = buffer + (max_msgs * msg_size);\n\tmsgq->read_ptr = buffer;\n\tmsgq->write_ptr = buffer;\n\tmsgq->used_msgs = 0;\n\tmsgq->flags = 0;\n\tz_waitq_init(&msgq->wait_q);\n\tmsgq->lock = (struct k_spinlock) {};\n#ifdef CONFIG_POLL\n\tsys_dlist_init(&msgq->poll_events);\n#endif\t/* CONFIG_POLL */\n\n#ifdef CONFIG_OBJ_CORE_MSGQ\n\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);\n#endif /* CONFIG_OBJ_CORE_MSGQ */\n\n\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);\n\n\tk_object_init(msgq);\n}\n",
                {
                    "43": "void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,",
                    "44": "\t\t uint32_t max_msgs)",
                    "45": "{",
                    "46": "\tmsgq->msg_size = msg_size;",
                    "47": "\tmsgq->max_msgs = max_msgs;",
                    "48": "\tmsgq->buffer_start = buffer;",
                    "49": "\tmsgq->buffer_end = buffer + (max_msgs * msg_size);",
                    "50": "\tmsgq->read_ptr = buffer;",
                    "51": "\tmsgq->write_ptr = buffer;",
                    "52": "\tmsgq->used_msgs = 0;",
                    "53": "\tmsgq->flags = 0;",
                    "54": "\tz_waitq_init(&msgq->wait_q);",
                    "55": "\tmsgq->lock = (struct k_spinlock) {};",
                    "56": "#ifdef CONFIG_POLL",
                    "57": "\tsys_dlist_init(&msgq->poll_events);",
                    "58": "#endif\t/* CONFIG_POLL */",
                    "59": "",
                    "60": "#ifdef CONFIG_OBJ_CORE_MSGQ",
                    "61": "\tk_obj_core_init_and_link(K_OBJ_CORE(msgq), &obj_type_msgq);",
                    "62": "#endif /* CONFIG_OBJ_CORE_MSGQ */",
                    "63": "",
                    "64": "\tSYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);",
                    "65": "",
                    "66": "\tk_object_init(msgq);",
                    "67": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_stack_cleanup": {
            "name": "k_stack_cleanup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/stack.c",
            "location_line": 80,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_stack_cleanup(struct k_stack *stack)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);\n\n\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {\n\t\tk_free(stack->base);\n\t\tstack->base = NULL;\n\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);\n\n\treturn 0;\n}\n",
                {
                    "80": "int k_stack_cleanup(struct k_stack *stack)",
                    "81": "{",
                    "82": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);",
                    "83": "",
                    "84": "\tCHECKIF(z_waitq_head(&stack->wait_q) != NULL) {",
                    "85": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);",
                    "86": "",
                    "87": "\t\treturn -EAGAIN;",
                    "88": "\t}",
                    "89": "",
                    "90": "\tif ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {",
                    "91": "\t\tk_free(stack->base);",
                    "92": "\t\tstack->base = NULL;",
                    "93": "\t\tstack->flags &= ~K_STACK_FLAG_ALLOC;",
                    "94": "\t}",
                    "95": "",
                    "96": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);",
                    "97": "",
                    "98": "\treturn 0;",
                    "99": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_unique_append": {
            "name": "k_queue_unique_append",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 383,
            "function_content": [
                "/*\n* note: this works as long as:\n* - the slist implementation keeps the next pointer as the first\n*   field of the node object type\n* - list->tail->next = NULL.\n* - sflist implementation only differs from slist by stuffing\n*   flag bytes in the lower order bits of the data pointer\n* - source list is really an slist and not an sflist with flags set\n*/\nbool k_queue_unique_append(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, unique_append, queue);\n\n\tsys_sfnode_t *test;\n\n\tSYS_SFLIST_FOR_EACH_NODE(&queue->data_q, test) {\n\t\tif (test == (sys_sfnode_t *) data) {\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, false);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tk_queue_append(queue, data);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, true);\n\n\treturn true;\n}\n",
                {
                    "383": "bool k_queue_unique_append(struct k_queue *queue, void *data)",
                    "384": "{",
                    "385": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, unique_append, queue);",
                    "386": "",
                    "387": "\tsys_sfnode_t *test;",
                    "388": "",
                    "389": "\tSYS_SFLIST_FOR_EACH_NODE(&queue->data_q, test) {",
                    "390": "\t\tif (test == (sys_sfnode_t *) data) {",
                    "391": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, false);",
                    "392": "",
                    "393": "\t\t\treturn false;",
                    "394": "\t\t}",
                    "395": "\t}",
                    "396": "",
                    "397": "\tk_queue_append(queue, data);",
                    "398": "",
                    "399": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, true);",
                    "400": "",
                    "401": "\treturn true;",
                    "402": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_remove": {
            "name": "k_queue_remove",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 372,
            "function_content": [
                "/*\n* note: this works as long as:\n* - the slist implementation keeps the next pointer as the first\n*   field of the node object type\n* - list->tail->next = NULL.\n* - sflist implementation only differs from slist by stuffing\n*   flag bytes in the lower order bits of the data pointer\n* - source list is really an slist and not an sflist with flags set\n*/\nbool k_queue_remove(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, remove, queue);\n\n\tbool ret = sys_sflist_find_and_remove(&queue->data_q, (sys_sfnode_t *)data);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, remove, queue, ret);\n\n\treturn ret;\n}\n",
                {
                    "372": "bool k_queue_remove(struct k_queue *queue, void *data)",
                    "373": "{",
                    "374": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, remove, queue);",
                    "375": "",
                    "376": "\tbool ret = sys_sflist_find_and_remove(&queue->data_q, (sys_sfnode_t *)data);",
                    "377": "",
                    "378": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, remove, queue, ret);",
                    "379": "",
                    "380": "\treturn ret;",
                    "381": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_append_list": {
            "name": "k_queue_append_list",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 257,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint k_queue_append_list(struct k_queue *queue, void *head, void *tail)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append_list, queue);\n\tbool resched = false;\n\n\t/* invalid head or tail of list */\n\tCHECKIF((head == NULL) || (tail == NULL)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, -EINVAL);\n\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tstruct k_thread *thread = NULL;\n\n\tif (head != NULL) {\n\t\tthread = z_unpend_first_thread(&queue->wait_q);\n\t}\n\n\twhile ((head != NULL) && (thread != NULL)) {\n\t\tresched = true;\n\t\tprepare_thread_to_run(thread, head);\n\t\thead = *(void **)head;\n\t\tthread = z_unpend_first_thread(&queue->wait_q);\n\t}\n\n\tif (head != NULL) {\n\t\tsys_sflist_append_list(&queue->data_q, head, tail);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, 0);\n\n\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE) || resched;\n\n\tif (resched) {\n\t\tz_reschedule(&queue->lock, key);\n\t} else {\n\t\tk_spin_unlock(&queue->lock, key);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "257": "int k_queue_append_list(struct k_queue *queue, void *head, void *tail)",
                    "258": "{",
                    "259": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append_list, queue);",
                    "260": "\tbool resched = false;",
                    "261": "",
                    "262": "\t/* invalid head or tail of list */",
                    "263": "\tCHECKIF((head == NULL) || (tail == NULL)) {",
                    "264": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, -EINVAL);",
                    "265": "",
                    "266": "\t\treturn -EINVAL;",
                    "267": "\t}",
                    "268": "",
                    "269": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "270": "\tstruct k_thread *thread = NULL;",
                    "271": "",
                    "272": "\tif (head != NULL) {",
                    "273": "\t\tthread = z_unpend_first_thread(&queue->wait_q);",
                    "274": "\t}",
                    "275": "",
                    "276": "\twhile ((head != NULL) && (thread != NULL)) {",
                    "277": "\t\tresched = true;",
                    "278": "\t\tprepare_thread_to_run(thread, head);",
                    "279": "\t\thead = *(void **)head;",
                    "280": "\t\tthread = z_unpend_first_thread(&queue->wait_q);",
                    "281": "\t}",
                    "282": "",
                    "283": "\tif (head != NULL) {",
                    "284": "\t\tsys_sflist_append_list(&queue->data_q, head, tail);",
                    "285": "\t}",
                    "286": "",
                    "287": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, 0);",
                    "288": "",
                    "289": "\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE) || resched;",
                    "290": "",
                    "291": "\tif (resched) {",
                    "292": "\t\tz_reschedule(&queue->lock, key);",
                    "293": "\t} else {",
                    "294": "\t\tk_spin_unlock(&queue->lock, key);",
                    "295": "\t}",
                    "296": "",
                    "297": "\treturn 0;",
                    "298": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_insert": {
            "name": "k_queue_insert",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 188,
            "function_content": [
                "/* Only need to actually allocate if no threads are pending */\nvoid k_queue_insert(struct k_queue *queue, void *prev, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, insert, queue);\n\n\t(void)queue_insert(queue, prev, data, false, false);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);\n}\n",
                {
                    "188": "void k_queue_insert(struct k_queue *queue, void *prev, void *data)",
                    "189": "{",
                    "190": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, insert, queue);",
                    "191": "",
                    "192": "\t(void)queue_insert(queue, prev, data, false, false);",
                    "193": "",
                    "194": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);",
                    "195": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_prepend": {
            "name": "k_queue_prepend",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 206,
            "function_content": [
                "/* Only need to actually allocate if no threads are pending */\nvoid k_queue_prepend(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);\n\n\t(void)queue_insert(queue, NULL, data, false, false);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);\n}\n",
                {
                    "206": "void k_queue_prepend(struct k_queue *queue, void *data)",
                    "207": "{",
                    "208": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);",
                    "209": "",
                    "210": "\t(void)queue_insert(queue, NULL, data, false, false);",
                    "211": "",
                    "212": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);",
                    "213": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_queue_append": {
            "name": "k_queue_append",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 197,
            "function_content": [
                "/* Only need to actually allocate if no threads are pending */\nvoid k_queue_append(struct k_queue *queue, void *data)\n{\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);\n\n\t(void)queue_insert(queue, NULL, data, false, true);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);\n}\n",
                {
                    "197": "void k_queue_append(struct k_queue *queue, void *data)",
                    "198": "{",
                    "199": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);",
                    "200": "",
                    "201": "\t(void)queue_insert(queue, NULL, data, false, true);",
                    "202": "",
                    "203": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);",
                    "204": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "k_thread_state_str": {
            "name": "k_thread_state_str",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/thread.c",
            "location_line": 226,
            "function_content": [
                "#endif /* CONFIG_THREAD_NAME */\nconst char *k_thread_state_str(k_tid_t thread_id, char *buf, size_t buf_size)\n{\n\tsize_t      off = 0;\n\tuint8_t     bit;\n\tuint8_t     thread_state = thread_id->base.thread_state;\n#define SS_ENT(s) { Z_STATE_STR_##s, _THREAD_##s, sizeof(Z_STATE_STR_##s) - 1 }\n\tstatic const struct {\n\t\tconst char *str;\n\t\tuint16_t    bit;\n\t\tuint16_t    len;\n\t} state_string[] = {\n\t\tSS_ENT(DUMMY),\n\t\tSS_ENT(PENDING),\n\t\tSS_ENT(SLEEPING),\n\t\tSS_ENT(DEAD),\n\t\tSS_ENT(SUSPENDED),\n\t\tSS_ENT(ABORTING),\n\t\tSS_ENT(SUSPENDING),\n\t\tSS_ENT(QUEUED),\n\t};\n#undef SS_ENT\n\n\tif ((buf == NULL) || (buf_size == 0)) {\n\t\treturn \"\";\n\t}\n\n\tbuf_size--;   /* Reserve 1 byte for end-of-string character */\n\n\t/*\n\t * Loop through each bit in the thread_state. Stop once all have\n\t * been processed. If more than one thread_state bit is set, then\n\t * separate the descriptive strings with a '+'.\n\t */\n\n\n\tfor (unsigned int index = 0; thread_state != 0; index++) {\n\t\tbit = state_string[index].bit;\n\t\tif ((thread_state & bit) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\toff += copy_bytes(buf + off, buf_size - off,\n\t\t\t\t  state_string[index].str,\n\t\t\t\t  state_string[index].len);\n\n\t\tthread_state &= ~bit;\n\n\t\tif (thread_state != 0) {\n\t\t\toff += copy_bytes(buf + off, buf_size - off, \"+\", 1);\n\t\t}\n\t}\n\n\tbuf[off] = '\\0';\n\n\treturn (const char *)buf;\n}\n",
                {
                    "226": "const char *k_thread_state_str(k_tid_t thread_id, char *buf, size_t buf_size)",
                    "227": "{",
                    "228": "\tsize_t      off = 0;",
                    "229": "\tuint8_t     bit;",
                    "230": "\tuint8_t     thread_state = thread_id->base.thread_state;",
                    "231": "#define SS_ENT(s) { Z_STATE_STR_##s, _THREAD_##s, sizeof(Z_STATE_STR_##s) - 1 }",
                    "232": "\tstatic const struct {",
                    "233": "\t\tconst char *str;",
                    "234": "\t\tuint16_t    bit;",
                    "235": "\t\tuint16_t    len;",
                    "236": "\t} state_string[] = {",
                    "237": "\t\tSS_ENT(DUMMY),",
                    "238": "\t\tSS_ENT(PENDING),",
                    "239": "\t\tSS_ENT(SLEEPING),",
                    "240": "\t\tSS_ENT(DEAD),",
                    "241": "\t\tSS_ENT(SUSPENDED),",
                    "242": "\t\tSS_ENT(ABORTING),",
                    "243": "\t\tSS_ENT(SUSPENDING),",
                    "244": "\t\tSS_ENT(QUEUED),",
                    "245": "\t};",
                    "246": "#undef SS_ENT",
                    "247": "",
                    "248": "\tif ((buf == NULL) || (buf_size == 0)) {",
                    "249": "\t\treturn \"\";",
                    "250": "\t}",
                    "251": "",
                    "252": "\tbuf_size--;   /* Reserve 1 byte for end-of-string character */",
                    "253": "",
                    "254": "\t/*",
                    "255": "\t * Loop through each bit in the thread_state. Stop once all have",
                    "256": "\t * been processed. If more than one thread_state bit is set, then",
                    "257": "\t * separate the descriptive strings with a '+'.",
                    "258": "\t */",
                    "259": "",
                    "260": "",
                    "261": "\tfor (unsigned int index = 0; thread_state != 0; index++) {",
                    "262": "\t\tbit = state_string[index].bit;",
                    "263": "\t\tif ((thread_state & bit) == 0) {",
                    "264": "\t\t\tcontinue;",
                    "265": "\t\t}",
                    "266": "",
                    "267": "\t\toff += copy_bytes(buf + off, buf_size - off,",
                    "268": "\t\t\t\t  state_string[index].str,",
                    "269": "\t\t\t\t  state_string[index].len);",
                    "270": "",
                    "271": "\t\tthread_state &= ~bit;",
                    "272": "",
                    "273": "\t\tif (thread_state != 0) {",
                    "274": "\t\t\toff += copy_bytes(buf + off, buf_size - off, \"+\", 1);",
                    "275": "\t\t}",
                    "276": "\t}",
                    "277": "",
                    "278": "\tbuf[off] = '\\0';",
                    "279": "",
                    "280": "\treturn (const char *)buf;",
                    "281": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_timeout": {
            "name": "z_thread_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 655,
            "function_content": [
                "/* Timeout handler for *_thread_timeout() APIs */\nvoid z_thread_timeout(struct _timeout *timeout)\n{\n\tstruct k_thread *thread = CONTAINER_OF(timeout,\n\t\t\t\t\t       struct k_thread, base.timeout);\n\n\tz_sched_wake_thread(thread, true);\n}\n",
                {
                    "655": "void z_thread_timeout(struct _timeout *timeout)",
                    "656": "{",
                    "657": "\tstruct k_thread *thread = CONTAINER_OF(timeout,",
                    "658": "\t\t\t\t\t       struct k_thread, base.timeout);",
                    "659": "",
                    "660": "\tz_sched_wake_thread(thread, true);",
                    "661": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_malloc": {
            "name": "z_thread_malloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 201,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE */\nvoid *z_thread_malloc(size_t size)\n{\n\treturn z_thread_alloc_helper(0, size, sys_heap_noalign_alloc);\n}\n",
                {
                    "201": "void *z_thread_malloc(size_t size)",
                    "202": "{",
                    "203": "\treturn z_thread_alloc_helper(0, size, sys_heap_noalign_alloc);",
                    "204": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_waitq_walk": {
            "name": "z_sched_waitq_walk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1562,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nint z_sched_waitq_walk(_wait_q_t  *wait_q,\n\t\t       int (*func)(struct k_thread *, void *), void *data)\n{\n\tstruct k_thread *thread;\n\tint  status = 0;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {\n\n\t\t\t/*\n\t\t\t * Invoke the callback function on each waiting thread\n\t\t\t * for as long as there are both waiting threads AND\n\t\t\t * it returns 0.\n\t\t\t */\n\n\t\t\tstatus = func(thread, data);\n\t\t\tif (status != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n",
                {
                    "1562": "int z_sched_waitq_walk(_wait_q_t  *wait_q,",
                    "1563": "\t\t       int (*func)(struct k_thread *, void *), void *data)",
                    "1564": "{",
                    "1565": "\tstruct k_thread *thread;",
                    "1566": "\tint  status = 0;",
                    "1567": "",
                    "1568": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1569": "\t\t_WAIT_Q_FOR_EACH(wait_q, thread) {",
                    "1570": "",
                    "1571": "\t\t\t/*",
                    "1572": "\t\t\t * Invoke the callback function on each waiting thread",
                    "1573": "\t\t\t * for as long as there are both waiting threads AND",
                    "1574": "\t\t\t * it returns 0.",
                    "1575": "\t\t\t */",
                    "1576": "",
                    "1577": "\t\t\tstatus = func(thread, data);",
                    "1578": "\t\t\tif (status != 0) {",
                    "1579": "\t\t\t\tbreak;",
                    "1580": "\t\t\t}",
                    "1581": "\t\t}",
                    "1582": "\t}",
                    "1583": "",
                    "1584": "\treturn status;",
                    "1585": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wait": {
            "name": "z_sched_wait",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1551,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nint z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,\n\t\t _wait_q_t *wait_q, k_timeout_t timeout, void **data)\n{\n\tint ret = z_pend_curr(lock, key, wait_q, timeout);\n\n\tif (data != NULL) {\n\t\t*data = _current->base.swap_data;\n\t}\n\treturn ret;\n}\n",
                {
                    "1551": "int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,",
                    "1552": "\t\t _wait_q_t *wait_q, k_timeout_t timeout, void **data)",
                    "1553": "{",
                    "1554": "\tint ret = z_pend_curr(lock, key, wait_q, timeout);",
                    "1555": "",
                    "1556": "\tif (data != NULL) {",
                    "1557": "\t\t*data = _current->base.swap_data;",
                    "1558": "\t}",
                    "1559": "\treturn ret;",
                    "1560": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_sched_wake": {
            "name": "z_sched_wake",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/sched.c",
            "location_line": 1529,
            "function_content": [
                "/*\n* future scheduler.h API implementations\n*/\nbool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)\n{\n\tstruct k_thread *thread;\n\tbool ret = false;\n\n\tK_SPINLOCK(&_sched_spinlock) {\n\t\tthread = _priq_wait_best(&wait_q->waitq);\n\n\t\tif (thread != NULL) {\n\t\t\tz_thread_return_value_set_with_data(thread,\n\t\t\t\t\t\t\t    swap_retval,\n\t\t\t\t\t\t\t    swap_data);\n\t\t\tunpend_thread_no_timeout(thread);\n\t\t\tz_abort_thread_timeout(thread);\n\t\t\tready_thread(thread);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
                {
                    "1529": "bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)",
                    "1530": "{",
                    "1531": "\tstruct k_thread *thread;",
                    "1532": "\tbool ret = false;",
                    "1533": "",
                    "1534": "\tK_SPINLOCK(&_sched_spinlock) {",
                    "1535": "\t\tthread = _priq_wait_best(&wait_q->waitq);",
                    "1536": "",
                    "1537": "\t\tif (thread != NULL) {",
                    "1538": "\t\t\tz_thread_return_value_set_with_data(thread,",
                    "1539": "\t\t\t\t\t\t\t    swap_retval,",
                    "1540": "\t\t\t\t\t\t\t    swap_data);",
                    "1541": "\t\t\tunpend_thread_no_timeout(thread);",
                    "1542": "\t\t\tz_abort_thread_timeout(thread);",
                    "1543": "\t\t\tready_thread(thread);",
                    "1544": "\t\t\tret = true;",
                    "1545": "\t\t}",
                    "1546": "\t}",
                    "1547": "",
                    "1548": "\treturn ret;",
                    "1549": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "nsi_register_extra_args": {
            "name": "nsi_register_extra_args",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/scripts/native_simulator/native/src/nsi_cmdline.c",
            "location_line": 146,
            "function_content": [
                "/**\n* Handle possible command line arguments.\n*\n* We also store them for later use by possible test applications\n*/\nvoid nsi_register_extra_args(int argc, char *argv[])\n{\n\tint new_size = extra_argc + argc;\n\n\textra_argv = realloc(extra_argv, new_size*sizeof(char *));\n\tfor (int i = 0; i < argc; i++) {\n\t\tmemcpy(&extra_argv[extra_argc], argv, argc*sizeof(char *));\n\t}\n\textra_argc += argc;\n}\n",
                {
                    "146": "void nsi_register_extra_args(int argc, char *argv[])",
                    "147": "{",
                    "148": "\tint new_size = extra_argc + argc;",
                    "149": "",
                    "150": "\textra_argv = realloc(extra_argv, new_size*sizeof(char *));",
                    "151": "\tfor (int i = 0; i < argc; i++) {",
                    "152": "\t\tmemcpy(&extra_argv[extra_argc], argv, argc*sizeof(char *));",
                    "153": "\t}",
                    "154": "\textra_argc += argc;",
                    "155": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "nsi_add_command_line_opts": {
            "name": "nsi_add_command_line_opts",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/scripts/native_simulator/native/src/nsi_cmdline.c",
            "location_line": 46,
            "function_content": [
                "/**\n* Add a set of command line options to the program.\n*\n* Each option to be added is described in one entry of the input <args>\n* This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.\n*/\nvoid nsi_add_command_line_opts(struct args_struct_t *args)\n{\n\tint count = 0;\n\n\twhile (args[count].option != NULL) {\n\t\tcount++;\n\t}\n\tcount++; /*for the end marker*/\n\n\tif (used_args + count >= args_aval) {\n\t\tint growby = count;\n\t\t/* reallocs are expensive let's do them only in big chunks */\n\t\tif (growby < ARGS_ALLOC_CHUNK_SIZE) {\n\t\t\tgrowby = ARGS_ALLOC_CHUNK_SIZE;\n\t\t}\n\n\t\tstruct args_struct_t *new_args_struct = realloc(args_struct,\n\t\t\t\t      (args_aval + growby)*\n\t\t\t\t      sizeof(struct args_struct_t));\n\t\targs_aval += growby;\n\t\t/* LCOV_EXCL_START */\n\t\tif (new_args_struct == NULL) {\n\t\t\tnsi_print_error_and_exit(\"Could not allocate memory\");\n\t\t} else {\n\t\t\targs_struct = new_args_struct;\n\t\t}\n\t\t/* LCOV_EXCL_STOP */\n\t}\n\n\tmemcpy(&args_struct[used_args], args,\n\t\tcount*sizeof(struct args_struct_t));\n\n\tused_args += count - 1;\n\t/*\n\t * -1 as the end marker should be overwritten next time something\n\t * is added\n\t */\n}\n",
                {
                    "46": "void nsi_add_command_line_opts(struct args_struct_t *args)",
                    "47": "{",
                    "48": "\tint count = 0;",
                    "49": "",
                    "50": "\twhile (args[count].option != NULL) {",
                    "51": "\t\tcount++;",
                    "52": "\t}",
                    "53": "\tcount++; /*for the end marker*/",
                    "54": "",
                    "55": "\tif (used_args + count >= args_aval) {",
                    "56": "\t\tint growby = count;",
                    "57": "\t\t/* reallocs are expensive let's do them only in big chunks */",
                    "58": "\t\tif (growby < ARGS_ALLOC_CHUNK_SIZE) {",
                    "59": "\t\t\tgrowby = ARGS_ALLOC_CHUNK_SIZE;",
                    "60": "\t\t}",
                    "61": "",
                    "62": "\t\tstruct args_struct_t *new_args_struct = realloc(args_struct,",
                    "63": "\t\t\t\t      (args_aval + growby)*",
                    "64": "\t\t\t\t      sizeof(struct args_struct_t));",
                    "65": "\t\targs_aval += growby;",
                    "66": "\t\t/* LCOV_EXCL_START */",
                    "67": "\t\tif (new_args_struct == NULL) {",
                    "68": "\t\t\tnsi_print_error_and_exit(\"Could not allocate memory\");",
                    "69": "\t\t} else {",
                    "70": "\t\t\targs_struct = new_args_struct;",
                    "71": "\t\t}",
                    "72": "\t\t/* LCOV_EXCL_STOP */",
                    "73": "\t}",
                    "74": "",
                    "75": "\tmemcpy(&args_struct[used_args], args,",
                    "76": "\t\tcount*sizeof(struct args_struct_t));",
                    "77": "",
                    "78": "\tused_args += count - 1;",
                    "79": "\t/*",
                    "80": "\t * -1 as the end marker should be overwritten next time something",
                    "81": "\t * is added",
                    "82": "\t */",
                    "83": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "nsi_hws_find_next_event": {
            "name": "nsi_hws_find_next_event",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/scripts/native_simulator/common/src/nsi_hw_scheduler.c",
            "location_line": 101,
            "function_content": [
                "/**\n* Find in between all events timers which is the next one.\n* (and update the internal next_timer_* accordingly)\n*/\nvoid nsi_hws_find_next_event(void)\n{\n\tnext_timer_index = 0;\n\tnext_timer_time  = *__nsi_hw_events_start[0].timer;\n\n\tfor (unsigned int i = 1; i < number_of_events ; i++) {\n\t\tif (next_timer_time > *__nsi_hw_events_start[i].timer) {\n\t\t\tnext_timer_index = i;\n\t\t\tnext_timer_time = *__nsi_hw_events_start[i].timer;\n\t\t}\n\t}\n}\n",
                {
                    "101": "void nsi_hws_find_next_event(void)",
                    "102": "{",
                    "103": "\tnext_timer_index = 0;",
                    "104": "\tnext_timer_time  = *__nsi_hw_events_start[0].timer;",
                    "105": "",
                    "106": "\tfor (unsigned int i = 1; i < number_of_events ; i++) {",
                    "107": "\t\tif (next_timer_time > *__nsi_hw_events_start[i].timer) {",
                    "108": "\t\t\tnext_timer_index = i;",
                    "109": "\t\t\tnext_timer_time = *__nsi_hw_events_start[i].timer;",
                    "110": "\t\t}",
                    "111": "\t}",
                    "112": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "entropy_native_sim_get_entropy_isr": {
            "name": "entropy_native_sim_get_entropy_isr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/drivers/entropy/fake_entropy_native_sim.c",
            "location_line": 58,
            "function_content": [
                "/* The host random() provides a number between 0 and 2**31-1. Bit 32 is always 0.\n* So let's just use the lower 3 bytes discarding the upper 7 bits\n*/\nstatic int entropy_native_sim_get_entropy_isr(const struct device *dev,\n\t\t\t\t\t\tuint8_t *buf,\n\t\t\t\t\t\tuint16_t len, uint32_t flags)\n{\n\tARG_UNUSED(flags);\n\n\t/*\n\t * entropy_native_sim_get_entropy() is also safe for ISRs\n\t * and always produces data.\n\t */\n\tentropy_native_sim_get_entropy(dev, buf, len);\n\n\treturn len;\n}\n",
                {
                    "58": "static int entropy_native_sim_get_entropy_isr(const struct device *dev,",
                    "59": "\t\t\t\t\t\tuint8_t *buf,",
                    "60": "\t\t\t\t\t\tuint16_t len, uint32_t flags)",
                    "61": "{",
                    "62": "\tARG_UNUSED(flags);",
                    "63": "",
                    "64": "\t/*",
                    "65": "\t * entropy_native_sim_get_entropy() is also safe for ISRs",
                    "66": "\t * and always produces data.",
                    "67": "\t */",
                    "68": "\tentropy_native_sim_get_entropy(dev, buf, len);",
                    "69": "",
                    "70": "\treturn len;",
                    "71": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "entropy_native_sim_get_entropy": {
            "name": "entropy_native_sim_get_entropy",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/drivers/entropy/fake_entropy_native_sim.c",
            "location_line": 32,
            "function_content": [
                "#include \"cmdline.h\" /* native_sim command line options header */\nstatic int entropy_native_sim_get_entropy(const struct device *dev,\n\t\t\t\t\t    uint8_t *buffer,\n\t\t\t\t\t    uint16_t length)\n{\n\tARG_UNUSED(dev);\n\n\twhile (length) {\n\t\t/*\n\t\t * Note that only 1 thread (Zephyr thread or HW models), runs at\n\t\t * a time, therefore there is no need to use random_r()\n\t\t */\n\t\tlong value = nsi_host_random();\n\n\t\t/* The host random() provides a number between 0 and 2**31-1. Bit 32 is always 0.\n\t\t * So let's just use the lower 3 bytes discarding the upper 7 bits\n\t\t */\n\t\tsize_t to_copy = MIN(length, 3);\n\n\t\tmemcpy(buffer, &value, to_copy);\n\t\tbuffer += to_copy;\n\t\tlength -= to_copy;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "32": "static int entropy_native_sim_get_entropy(const struct device *dev,",
                    "33": "\t\t\t\t\t    uint8_t *buffer,",
                    "34": "\t\t\t\t\t    uint16_t length)",
                    "35": "{",
                    "36": "\tARG_UNUSED(dev);",
                    "37": "",
                    "38": "\twhile (length) {",
                    "39": "\t\t/*",
                    "40": "\t\t * Note that only 1 thread (Zephyr thread or HW models), runs at",
                    "41": "\t\t * a time, therefore there is no need to use random_r()",
                    "42": "\t\t */",
                    "43": "\t\tlong value = nsi_host_random();",
                    "44": "",
                    "45": "\t\t/* The host random() provides a number between 0 and 2**31-1. Bit 32 is always 0.",
                    "46": "\t\t * So let's just use the lower 3 bytes discarding the upper 7 bits",
                    "47": "\t\t */",
                    "48": "\t\tsize_t to_copy = MIN(length, 3);",
                    "49": "",
                    "50": "\t\tmemcpy(buffer, &value, to_copy);",
                    "51": "\t\tbuffer += to_copy;",
                    "52": "\t\tlength -= to_copy;",
                    "53": "\t}",
                    "54": "",
                    "55": "\treturn 0;",
                    "56": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_data_match": {
            "name": "net_buf_data_match",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 713,
            "function_content": [
                "/* Unreachable */\nsize_t net_buf_data_match(const struct net_buf *buf, size_t offset, const void *data, size_t len)\n{\n\tconst uint8_t *dptr = data;\n\tconst uint8_t *bptr;\n\tsize_t compared = 0;\n\tsize_t to_compare;\n\n\tif (!buf || !data) {\n\t\treturn compared;\n\t}\n\n\t/* find the right fragment to start comparison */\n\twhile (buf && offset >= buf->len) {\n\t\toffset -= buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\twhile (buf && len > 0) {\n\t\tbptr = buf->data + offset;\n\t\tto_compare = min(len, buf->len - offset);\n\n\t\tfor (size_t i = 0; i < to_compare; ++i) {\n\t\t\tif (dptr[compared] != bptr[i]) {\n\t\t\t\treturn compared;\n\t\t\t}\n\t\t\tcompared++;\n\t\t}\n\n\t\tlen -= to_compare;\n\t\tbuf = buf->frags;\n\t\toffset = 0;\n\t}\n\n\treturn compared;\n}\n",
                {
                    "713": "size_t net_buf_data_match(const struct net_buf *buf, size_t offset, const void *data, size_t len)",
                    "714": "{",
                    "715": "\tconst uint8_t *dptr = data;",
                    "716": "\tconst uint8_t *bptr;",
                    "717": "\tsize_t compared = 0;",
                    "718": "\tsize_t to_compare;",
                    "719": "",
                    "720": "\tif (!buf || !data) {",
                    "721": "\t\treturn compared;",
                    "722": "\t}",
                    "723": "",
                    "724": "\t/* find the right fragment to start comparison */",
                    "725": "\twhile (buf && offset >= buf->len) {",
                    "726": "\t\toffset -= buf->len;",
                    "727": "\t\tbuf = buf->frags;",
                    "728": "\t}",
                    "729": "",
                    "730": "\twhile (buf && len > 0) {",
                    "731": "\t\tbptr = buf->data + offset;",
                    "732": "\t\tto_compare = min(len, buf->len - offset);",
                    "733": "",
                    "734": "\t\tfor (size_t i = 0; i < to_compare; ++i) {",
                    "735": "\t\t\tif (dptr[compared] != bptr[i]) {",
                    "736": "\t\t\t\treturn compared;",
                    "737": "\t\t\t}",
                    "738": "\t\t\tcompared++;",
                    "739": "\t\t}",
                    "740": "",
                    "741": "\t\tlen -= to_compare;",
                    "742": "\t\tbuf = buf->frags;",
                    "743": "\t\toffset = 0;",
                    "744": "\t}",
                    "745": "",
                    "746": "\treturn compared;",
                    "747": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_append_bytes": {
            "name": "net_buf_append_bytes",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 666,
            "function_content": [
                "/* This helper routine will append multiple bytes, if there is no place for\n* the data in current fragment then create new fragment and add it to\n* the buffer. It assumes that the buffer has at least one fragment.\n*/\nsize_t net_buf_append_bytes(struct net_buf *buf, size_t len,\n\t\t\t    const void *value, k_timeout_t timeout,\n\t\t\t    net_buf_allocator_cb allocate_cb, void *user_data)\n{\n\tstruct net_buf *frag = net_buf_frag_last(buf);\n\tsize_t added_len = 0;\n\tconst uint8_t *value8 = value;\n\tsize_t max_size;\n\n\tdo {\n\t\tuint16_t count = min(len, net_buf_tailroom(frag));\n\n\t\tnet_buf_add_mem(frag, value8, count);\n\t\tlen -= count;\n\t\tadded_len += count;\n\t\tvalue8 += count;\n\n\t\tif (len == 0) {\n\t\t\treturn added_len;\n\t\t}\n\n\t\tif (allocate_cb) {\n\t\t\tfrag = allocate_cb(timeout, user_data);\n\t\t} else {\n\t\t\tstruct net_buf_pool *pool;\n\n\t\t\t/* Allocate from the original pool if no callback has\n\t\t\t * been provided.\n\t\t\t */\n\t\t\tpool = net_buf_pool_get(buf->pool_id);\n\t\t\tmax_size = pool->alloc->max_alloc_size;\n\t\t\tfrag = net_buf_alloc_len(pool,\n\t\t\t\t\t\t max_size ? min(len, max_size) : len,\n\t\t\t\t\t\t timeout);\n\t\t}\n\n\t\tif (!frag) {\n\t\t\treturn added_len;\n\t\t}\n\n\t\tnet_buf_frag_add(buf, frag);\n\t} while (1);\n\n\t/* Unreachable */\n\treturn 0;\n}\n",
                {
                    "666": "size_t net_buf_append_bytes(struct net_buf *buf, size_t len,",
                    "667": "\t\t\t    const void *value, k_timeout_t timeout,",
                    "668": "\t\t\t    net_buf_allocator_cb allocate_cb, void *user_data)",
                    "669": "{",
                    "670": "\tstruct net_buf *frag = net_buf_frag_last(buf);",
                    "671": "\tsize_t added_len = 0;",
                    "672": "\tconst uint8_t *value8 = value;",
                    "673": "\tsize_t max_size;",
                    "674": "",
                    "675": "\tdo {",
                    "676": "\t\tuint16_t count = min(len, net_buf_tailroom(frag));",
                    "677": "",
                    "678": "\t\tnet_buf_add_mem(frag, value8, count);",
                    "679": "\t\tlen -= count;",
                    "680": "\t\tadded_len += count;",
                    "681": "\t\tvalue8 += count;",
                    "682": "",
                    "683": "\t\tif (len == 0) {",
                    "684": "\t\t\treturn added_len;",
                    "685": "\t\t}",
                    "686": "",
                    "687": "\t\tif (allocate_cb) {",
                    "688": "\t\t\tfrag = allocate_cb(timeout, user_data);",
                    "689": "\t\t} else {",
                    "690": "\t\t\tstruct net_buf_pool *pool;",
                    "691": "",
                    "692": "\t\t\t/* Allocate from the original pool if no callback has",
                    "693": "\t\t\t * been provided.",
                    "694": "\t\t\t */",
                    "695": "\t\t\tpool = net_buf_pool_get(buf->pool_id);",
                    "696": "\t\t\tmax_size = pool->alloc->max_alloc_size;",
                    "697": "\t\t\tfrag = net_buf_alloc_len(pool,",
                    "698": "\t\t\t\t\t\t max_size ? min(len, max_size) : len,",
                    "699": "\t\t\t\t\t\t timeout);",
                    "700": "\t\t}",
                    "701": "",
                    "702": "\t\tif (!frag) {",
                    "703": "\t\t\treturn added_len;",
                    "704": "\t\t}",
                    "705": "",
                    "706": "\t\tnet_buf_frag_add(buf, frag);",
                    "707": "\t} while (1);",
                    "708": "",
                    "709": "\t/* Unreachable */",
                    "710": "\treturn 0;",
                    "711": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_linearize": {
            "name": "net_buf_linearize",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 626,
            "function_content": [
                "/* Take ownership of the fragment reference */\nsize_t net_buf_linearize(void *dst, size_t dst_len, const struct net_buf *src,\n\t\t\t size_t offset, size_t len)\n{\n\tconst struct net_buf *frag;\n\tsize_t to_copy;\n\tsize_t copied;\n\n\tlen = min(len, dst_len);\n\n\tfrag = src;\n\n\t/* find the right fragment to start copying from */\n\twhile (frag && offset >= frag->len) {\n\t\toffset -= frag->len;\n\t\tfrag = frag->frags;\n\t}\n\n\t/* traverse the fragment chain until len bytes are copied */\n\tcopied = 0;\n\twhile (frag && len > 0) {\n\t\tto_copy = min(len, frag->len - offset);\n\t\tmemcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);\n\n\t\tcopied += to_copy;\n\n\t\t/* to_copy is always <= len */\n\t\tlen -= to_copy;\n\t\tfrag = frag->frags;\n\n\t\t/* after the first iteration, this value will be 0 */\n\t\toffset = 0;\n\t}\n\n\treturn copied;\n}\n",
                {
                    "626": "size_t net_buf_linearize(void *dst, size_t dst_len, const struct net_buf *src,",
                    "627": "\t\t\t size_t offset, size_t len)",
                    "628": "{",
                    "629": "\tconst struct net_buf *frag;",
                    "630": "\tsize_t to_copy;",
                    "631": "\tsize_t copied;",
                    "632": "",
                    "633": "\tlen = min(len, dst_len);",
                    "634": "",
                    "635": "\tfrag = src;",
                    "636": "",
                    "637": "\t/* find the right fragment to start copying from */",
                    "638": "\twhile (frag && offset >= frag->len) {",
                    "639": "\t\toffset -= frag->len;",
                    "640": "\t\tfrag = frag->frags;",
                    "641": "\t}",
                    "642": "",
                    "643": "\t/* traverse the fragment chain until len bytes are copied */",
                    "644": "\tcopied = 0;",
                    "645": "\twhile (frag && len > 0) {",
                    "646": "\t\tto_copy = min(len, frag->len - offset);",
                    "647": "\t\tmemcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);",
                    "648": "",
                    "649": "\t\tcopied += to_copy;",
                    "650": "",
                    "651": "\t\t/* to_copy is always <= len */",
                    "652": "\t\tlen -= to_copy;",
                    "653": "\t\tfrag = frag->frags;",
                    "654": "",
                    "655": "\t\t/* after the first iteration, this value will be 0 */",
                    "656": "\t\toffset = 0;",
                    "657": "\t}",
                    "658": "",
                    "659": "\treturn copied;",
                    "660": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_clone": {
            "name": "net_buf_clone",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 494,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nstruct net_buf *net_buf_clone(struct net_buf *buf, k_timeout_t timeout)\n{\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tstruct net_buf_pool *pool;\n\tstruct net_buf *clone;\n\n\t__ASSERT_NO_MSG(buf);\n\n\tpool = net_buf_pool_get(buf->pool_id);\n\n\tclone = net_buf_alloc_len(pool, 0, timeout);\n\tif (!clone) {\n\t\treturn NULL;\n\t}\n\n\t/* If the pool supports data referencing use that. Otherwise\n\t * we need to allocate new data and make a copy.\n\t */\n\tif (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {\n\t\tclone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;\n\t\tclone->data = buf->data;\n\t\tclone->len = buf->len;\n\t\tclone->size = buf->size;\n\t} else {\n\t\tsize_t size = buf->size;\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\n\t\tclone->__buf = data_alloc(clone, &size, timeout);\n\t\tif (!clone->__buf || size < buf->size) {\n\t\t\tnet_buf_destroy(clone);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tclone->size = size;\n\t\tclone->data = clone->__buf + net_buf_headroom(buf);\n\t\tnet_buf_add_mem(clone, buf->data, buf->len);\n\t}\n\n\t/* user_data_size should be the same for buffers from the same pool */\n\t__ASSERT(buf->user_data_size == clone->user_data_size, \"Unexpected user data size\");\n\n\tmemcpy(clone->user_data, buf->user_data, clone->user_data_size);\n\n\treturn clone;\n}\n",
                {
                    "494": "struct net_buf *net_buf_clone(struct net_buf *buf, k_timeout_t timeout)",
                    "495": "{",
                    "496": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "497": "\tstruct net_buf_pool *pool;",
                    "498": "\tstruct net_buf *clone;",
                    "499": "",
                    "500": "\t__ASSERT_NO_MSG(buf);",
                    "501": "",
                    "502": "\tpool = net_buf_pool_get(buf->pool_id);",
                    "503": "",
                    "504": "\tclone = net_buf_alloc_len(pool, 0, timeout);",
                    "505": "\tif (!clone) {",
                    "506": "\t\treturn NULL;",
                    "507": "\t}",
                    "508": "",
                    "509": "\t/* If the pool supports data referencing use that. Otherwise",
                    "510": "\t * we need to allocate new data and make a copy.",
                    "511": "\t */",
                    "512": "\tif (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {",
                    "513": "\t\tclone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;",
                    "514": "\t\tclone->data = buf->data;",
                    "515": "\t\tclone->len = buf->len;",
                    "516": "\t\tclone->size = buf->size;",
                    "517": "\t} else {",
                    "518": "\t\tsize_t size = buf->size;",
                    "519": "",
                    "520": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "521": "",
                    "522": "\t\tclone->__buf = data_alloc(clone, &size, timeout);",
                    "523": "\t\tif (!clone->__buf || size < buf->size) {",
                    "524": "\t\t\tnet_buf_destroy(clone);",
                    "525": "\t\t\treturn NULL;",
                    "526": "\t\t}",
                    "527": "",
                    "528": "\t\tclone->size = size;",
                    "529": "\t\tclone->data = clone->__buf + net_buf_headroom(buf);",
                    "530": "\t\tnet_buf_add_mem(clone, buf->data, buf->len);",
                    "531": "\t}",
                    "532": "",
                    "533": "\t/* user_data_size should be the same for buffers from the same pool */",
                    "534": "\t__ASSERT(buf->user_data_size == clone->user_data_size, \"Unexpected user data size\");",
                    "535": "",
                    "536": "\tmemcpy(clone->user_data, buf->user_data, clone->user_data_size);",
                    "537": "",
                    "538": "\treturn clone;",
                    "539": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_unref": {
            "name": "net_buf_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 440,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nvoid net_buf_unref(struct net_buf *buf)\n#endif\n{\n\t__ASSERT_NO_MSG(buf);\n\n\twhile (buf) {\n\t\tstruct net_buf *frags = buf->frags;\n\t\tstruct net_buf_pool *pool;\n\n\t\t__ASSERT(buf->ref, \"buf %p double free\", buf);\n\t\tif (!buf->ref) {\n#if defined(CONFIG_NET_BUF_LOG)\n\t\t\tNET_BUF_ERR(\"%s():%d: buf %p double free\", func, line,\n\t\t\t\t    buf);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tNET_BUF_DBG(\"buf %p ref %u pool_id %u frags %p\", buf, buf->ref,\n\t\t\t    buf->pool_id, buf->frags);\n\n\t\tif (--buf->ref > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tbuf->data = NULL;\n\t\tbuf->frags = NULL;\n\n\t\tpool = net_buf_pool_get(buf->pool_id);\n\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\tatomic_inc(&pool->avail_count);\n\t\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);\n#endif\n\n\t\tif (pool->destroy) {\n\t\t\tpool->destroy(buf);\n\t\t} else {\n\t\t\tnet_buf_destroy(buf);\n\t\t}\n\n\t\tbuf = frags;\n\t}\n}\n",
                {
                    "440": "void net_buf_unref(struct net_buf *buf)",
                    "441": "#endif",
                    "442": "{",
                    "443": "\t__ASSERT_NO_MSG(buf);",
                    "444": "",
                    "445": "\twhile (buf) {",
                    "446": "\t\tstruct net_buf *frags = buf->frags;",
                    "447": "\t\tstruct net_buf_pool *pool;",
                    "448": "",
                    "449": "\t\t__ASSERT(buf->ref, \"buf %p double free\", buf);",
                    "450": "\t\tif (!buf->ref) {",
                    "451": "#if defined(CONFIG_NET_BUF_LOG)",
                    "452": "\t\t\tNET_BUF_ERR(\"%s():%d: buf %p double free\", func, line,",
                    "453": "\t\t\t\t    buf);",
                    "454": "#endif",
                    "455": "\t\t\treturn;",
                    "456": "\t\t}",
                    "457": "\t\tNET_BUF_DBG(\"buf %p ref %u pool_id %u frags %p\", buf, buf->ref,",
                    "458": "\t\t\t    buf->pool_id, buf->frags);",
                    "459": "",
                    "460": "\t\tif (--buf->ref > 0) {",
                    "461": "\t\t\treturn;",
                    "462": "\t\t}",
                    "463": "",
                    "464": "\t\tbuf->data = NULL;",
                    "465": "\t\tbuf->frags = NULL;",
                    "466": "",
                    "467": "\t\tpool = net_buf_pool_get(buf->pool_id);",
                    "468": "",
                    "469": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "470": "\t\tatomic_inc(&pool->avail_count);",
                    "471": "\t\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);",
                    "472": "#endif",
                    "473": "",
                    "474": "\t\tif (pool->destroy) {",
                    "475": "\t\t\tpool->destroy(buf);",
                    "476": "\t\t} else {",
                    "477": "\t\t\tnet_buf_destroy(buf);",
                    "478": "\t\t}",
                    "479": "",
                    "480": "\t\tbuf = frags;",
                    "481": "\t}",
                    "482": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_reserve": {
            "name": "net_buf_simple_reserve",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 41,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid net_buf_simple_reserve(struct net_buf_simple *buf, size_t reserve)\n{\n\t__ASSERT_NO_MSG(buf);\n\t__ASSERT_NO_MSG(buf->len == 0U);\n\tNET_BUF_SIMPLE_DBG(\"buf %p reserve %zu\", buf, reserve);\n\n\tbuf->data = buf->__buf + reserve;\n}\n",
                {
                    "41": "void net_buf_simple_reserve(struct net_buf_simple *buf, size_t reserve)",
                    "42": "{",
                    "43": "\t__ASSERT_NO_MSG(buf);",
                    "44": "\t__ASSERT_NO_MSG(buf->len == 0U);",
                    "45": "\tNET_BUF_SIMPLE_DBG(\"buf %p reserve %zu\", buf, reserve);",
                    "46": "",
                    "47": "\tbuf->data = buf->__buf + reserve;",
                    "48": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_alloc_with_data": {
            "name": "net_buf_alloc_with_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 385,
            "function_content": [
                "/* If this is not the first access to the pool, we can\n* be opportunistic and try to fetch a previously used\n* buffer from the LIFO with K_NO_WAIT.\n*/\nstruct net_buf *net_buf_alloc_with_data(struct net_buf_pool *pool,\n\t\t\t\t\tvoid *data, size_t size,\n\t\t\t\t\tk_timeout_t timeout)\n#endif\n{\n\tstruct net_buf *buf;\n\n#if defined(CONFIG_NET_BUF_LOG)\n\tbuf = net_buf_alloc_len_debug(pool, 0, timeout, func, line);\n#else\n\tbuf = net_buf_alloc_len(pool, 0, timeout);\n#endif\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tnet_buf_simple_init_with_data(&buf->b, data, size);\n\tbuf->flags = NET_BUF_EXTERNAL_DATA;\n\n\treturn buf;\n}\n",
                {
                    "385": "struct net_buf *net_buf_alloc_with_data(struct net_buf_pool *pool,",
                    "386": "\t\t\t\t\tvoid *data, size_t size,",
                    "387": "\t\t\t\t\tk_timeout_t timeout)",
                    "388": "#endif",
                    "389": "{",
                    "390": "\tstruct net_buf *buf;",
                    "391": "",
                    "392": "#if defined(CONFIG_NET_BUF_LOG)",
                    "393": "\tbuf = net_buf_alloc_len_debug(pool, 0, timeout, func, line);",
                    "394": "#else",
                    "395": "\tbuf = net_buf_alloc_len(pool, 0, timeout);",
                    "396": "#endif",
                    "397": "\tif (!buf) {",
                    "398": "\t\treturn NULL;",
                    "399": "\t}",
                    "400": "",
                    "401": "\tnet_buf_simple_init_with_data(&buf->b, data, size);",
                    "402": "\tbuf->flags = NET_BUF_EXTERNAL_DATA;",
                    "403": "",
                    "404": "\treturn buf;",
                    "405": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_alloc_len": {
            "name": "net_buf_alloc_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 249,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE > 0 */\nstruct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,\n\t\t\t\t  k_timeout_t timeout)\n#endif\n{\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\tstruct net_buf *buf;\n\tk_spinlock_key_t key;\n\n\t__ASSERT_NO_MSG(pool);\n\n\tNET_BUF_DBG(\"%s():%d: pool %p size %zu\", func, line, pool, size);\n\n\t/* We need to prevent race conditions\n\t * when accessing pool->uninit_count.\n\t */\n\tkey = k_spin_lock(&pool->lock);\n\n\t/* If there are uninitialized buffers we're guaranteed to succeed\n\t * with the allocation one way or another.\n\t */\n\tif (pool->uninit_count) {\n\t\tuint16_t uninit_count;\n\n\t\t/* If this is not the first access to the pool, we can\n\t\t * be opportunistic and try to fetch a previously used\n\t\t * buffer from the LIFO with K_NO_WAIT.\n\t\t */\n\t\tif (pool->uninit_count < pool->buf_count) {\n\t\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);\n\t\t\tif (buf) {\n\t\t\t\tk_spin_unlock(&pool->lock, key);\n\t\t\t\tgoto success;\n\t\t\t}\n\t\t}\n\n\t\tuninit_count = pool->uninit_count--;\n\t\tk_spin_unlock(&pool->lock, key);\n\n\t\tbuf = pool_get_uninit(pool, uninit_count);\n\t\tgoto success;\n\t}\n\n\tk_spin_unlock(&pool->lock, key);\n\n#if defined(CONFIG_NET_BUF_LOG) && (CONFIG_NET_BUF_LOG_LEVEL >= LOG_LEVEL_WRN)\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\tuint32_t ref = k_uptime_get_32();\n\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);\n\t\twhile (!buf) {\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s low on buffers.\",\n\t\t\t\t     func, line, pool->name);\n#else\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p low on buffers.\",\n\t\t\t\t     func, line, pool);\n#endif\n\t\t\tbuf = k_lifo_get(&pool->free, WARN_ALLOC_INTERVAL);\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s blocked for %u secs\",\n\t\t\t\t     func, line, pool->name,\n\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);\n#else\n\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p blocked for %u secs\",\n\t\t\t\t     func, line, pool,\n\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);\n#endif\n\t\t}\n\t} else {\n\t\tbuf = k_lifo_get(&pool->free, timeout);\n\t}\n#else\n\tbuf = k_lifo_get(&pool->free, timeout);\n#endif\n\tif (!buf) {\n\t\tNET_BUF_ERR(\"%s():%d: Failed to get free buffer\", func, line);\n\t\treturn NULL;\n\t}\n\nsuccess:\n\tNET_BUF_DBG(\"allocated buf %p\", buf);\n\n\tif (size) {\n\t\t__maybe_unused size_t req_size = size;\n\n\t\ttimeout = sys_timepoint_timeout(end);\n\t\tbuf->__buf = data_alloc(buf, &size, timeout);\n\t\tif (!buf->__buf) {\n\t\t\tNET_BUF_ERR(\"%s():%d: Failed to allocate data\",\n\t\t\t\t    func, line);\n\t\t\tnet_buf_destroy(buf);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t__ASSERT_NO_MSG(req_size <= size);\n\t} else {\n\t\tbuf->__buf = NULL;\n\t}\n\n\tbuf->ref   = 1U;\n\tbuf->flags = 0U;\n\tbuf->frags = NULL;\n\tbuf->size  = size;\n\tmemset(buf->user_data, 0, buf->user_data_size);\n\tnet_buf_reset(buf);\n\n#if defined(CONFIG_NET_BUF_POOL_USAGE)\n\tatomic_dec(&pool->avail_count);\n\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);\n\tpool->max_used = max(pool->max_used,\n\t\t\t     pool->buf_count - atomic_get(&pool->avail_count));\n#endif\n\treturn buf;\n}\n",
                {
                    "249": "struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,",
                    "250": "\t\t\t\t  k_timeout_t timeout)",
                    "251": "#endif",
                    "252": "{",
                    "253": "\tk_timepoint_t end = sys_timepoint_calc(timeout);",
                    "254": "\tstruct net_buf *buf;",
                    "255": "\tk_spinlock_key_t key;",
                    "256": "",
                    "257": "\t__ASSERT_NO_MSG(pool);",
                    "258": "",
                    "259": "\tNET_BUF_DBG(\"%s():%d: pool %p size %zu\", func, line, pool, size);",
                    "260": "",
                    "261": "\t/* We need to prevent race conditions",
                    "262": "\t * when accessing pool->uninit_count.",
                    "263": "\t */",
                    "264": "\tkey = k_spin_lock(&pool->lock);",
                    "265": "",
                    "266": "\t/* If there are uninitialized buffers we're guaranteed to succeed",
                    "267": "\t * with the allocation one way or another.",
                    "268": "\t */",
                    "269": "\tif (pool->uninit_count) {",
                    "270": "\t\tuint16_t uninit_count;",
                    "271": "",
                    "272": "\t\t/* If this is not the first access to the pool, we can",
                    "273": "\t\t * be opportunistic and try to fetch a previously used",
                    "274": "\t\t * buffer from the LIFO with K_NO_WAIT.",
                    "275": "\t\t */",
                    "276": "\t\tif (pool->uninit_count < pool->buf_count) {",
                    "277": "\t\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);",
                    "278": "\t\t\tif (buf) {",
                    "279": "\t\t\t\tk_spin_unlock(&pool->lock, key);",
                    "280": "\t\t\t\tgoto success;",
                    "281": "\t\t\t}",
                    "282": "\t\t}",
                    "283": "",
                    "284": "\t\tuninit_count = pool->uninit_count--;",
                    "285": "\t\tk_spin_unlock(&pool->lock, key);",
                    "286": "",
                    "287": "\t\tbuf = pool_get_uninit(pool, uninit_count);",
                    "288": "\t\tgoto success;",
                    "289": "\t}",
                    "290": "",
                    "291": "\tk_spin_unlock(&pool->lock, key);",
                    "292": "",
                    "293": "#if defined(CONFIG_NET_BUF_LOG) && (CONFIG_NET_BUF_LOG_LEVEL >= LOG_LEVEL_WRN)",
                    "294": "\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {",
                    "295": "\t\tuint32_t ref = k_uptime_get_32();",
                    "296": "\t\tbuf = k_lifo_get(&pool->free, K_NO_WAIT);",
                    "297": "\t\twhile (!buf) {",
                    "298": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "299": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s low on buffers.\",",
                    "300": "\t\t\t\t     func, line, pool->name);",
                    "301": "#else",
                    "302": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p low on buffers.\",",
                    "303": "\t\t\t\t     func, line, pool);",
                    "304": "#endif",
                    "305": "\t\t\tbuf = k_lifo_get(&pool->free, WARN_ALLOC_INTERVAL);",
                    "306": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "307": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %s blocked for %u secs\",",
                    "308": "\t\t\t\t     func, line, pool->name,",
                    "309": "\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);",
                    "310": "#else",
                    "311": "\t\t\tNET_BUF_WARN(\"%s():%d: Pool %p blocked for %u secs\",",
                    "312": "\t\t\t\t     func, line, pool,",
                    "313": "\t\t\t\t     (k_uptime_get_32() - ref) / MSEC_PER_SEC);",
                    "314": "#endif",
                    "315": "\t\t}",
                    "316": "\t} else {",
                    "317": "\t\tbuf = k_lifo_get(&pool->free, timeout);",
                    "318": "\t}",
                    "319": "#else",
                    "320": "\tbuf = k_lifo_get(&pool->free, timeout);",
                    "321": "#endif",
                    "322": "\tif (!buf) {",
                    "323": "\t\tNET_BUF_ERR(\"%s():%d: Failed to get free buffer\", func, line);",
                    "324": "\t\treturn NULL;",
                    "325": "\t}",
                    "326": "",
                    "327": "success:",
                    "328": "\tNET_BUF_DBG(\"allocated buf %p\", buf);",
                    "329": "",
                    "330": "\tif (size) {",
                    "331": "\t\t__maybe_unused size_t req_size = size;",
                    "332": "",
                    "333": "\t\ttimeout = sys_timepoint_timeout(end);",
                    "334": "\t\tbuf->__buf = data_alloc(buf, &size, timeout);",
                    "335": "\t\tif (!buf->__buf) {",
                    "336": "\t\t\tNET_BUF_ERR(\"%s():%d: Failed to allocate data\",",
                    "337": "\t\t\t\t    func, line);",
                    "338": "\t\t\tnet_buf_destroy(buf);",
                    "339": "\t\t\treturn NULL;",
                    "340": "\t\t}",
                    "341": "",
                    "342": "\t\t__ASSERT_NO_MSG(req_size <= size);",
                    "343": "\t} else {",
                    "344": "\t\tbuf->__buf = NULL;",
                    "345": "\t}",
                    "346": "",
                    "347": "\tbuf->ref   = 1U;",
                    "348": "\tbuf->flags = 0U;",
                    "349": "\tbuf->frags = NULL;",
                    "350": "\tbuf->size  = size;",
                    "351": "\tmemset(buf->user_data, 0, buf->user_data_size);",
                    "352": "\tnet_buf_reset(buf);",
                    "353": "",
                    "354": "#if defined(CONFIG_NET_BUF_POOL_USAGE)",
                    "355": "\tatomic_dec(&pool->avail_count);",
                    "356": "\t__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);",
                    "357": "\tpool->max_used = max(pool->max_used,",
                    "358": "\t\t\t     pool->buf_count - atomic_get(&pool->avail_count));",
                    "359": "#endif",
                    "360": "\treturn buf;",
                    "361": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_headroom": {
            "name": "net_buf_simple_headroom",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 613,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nsize_t net_buf_simple_headroom(const struct net_buf_simple *buf)\n{\n\treturn buf->data - buf->__buf;\n}\n",
                {
                    "613": "size_t net_buf_simple_headroom(const struct net_buf_simple *buf)",
                    "614": "{",
                    "615": "\treturn buf->data - buf->__buf;",
                    "616": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be64": {
            "name": "net_buf_simple_pull_be64",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 603,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_be64(struct net_buf_simple *buf)\n{\n\tuint64_t val;\n\n\tval = UNALIGNED_GET((uint64_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be64_to_cpu(val);\n}\n",
                {
                    "603": "uint64_t net_buf_simple_pull_be64(struct net_buf_simple *buf)",
                    "604": "{",
                    "605": "\tuint64_t val;",
                    "606": "",
                    "607": "\tval = UNALIGNED_GET((uint64_t *)buf->data);",
                    "608": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "609": "",
                    "610": "\treturn sys_be64_to_cpu(val);",
                    "611": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le64": {
            "name": "net_buf_simple_pull_le64",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 593,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_le64(struct net_buf_simple *buf)\n{\n\tuint64_t val;\n\n\tval = UNALIGNED_GET((uint64_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le64_to_cpu(val);\n}\n",
                {
                    "593": "uint64_t net_buf_simple_pull_le64(struct net_buf_simple *buf)",
                    "594": "{",
                    "595": "\tuint64_t val;",
                    "596": "",
                    "597": "\tval = UNALIGNED_GET((uint64_t *)buf->data);",
                    "598": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "599": "",
                    "600": "\treturn sys_le64_to_cpu(val);",
                    "601": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be48": {
            "name": "net_buf_simple_pull_be48",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 581,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_be48(struct net_buf_simple *buf)\n{\n\tstruct uint48 {\n\t\tuint64_t u48:48;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint48 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be48_to_cpu(val.u48);\n}\n",
                {
                    "581": "uint64_t net_buf_simple_pull_be48(struct net_buf_simple *buf)",
                    "582": "{",
                    "583": "\tstruct uint48 {",
                    "584": "\t\tuint64_t u48:48;",
                    "585": "\t} __packed val;",
                    "586": "",
                    "587": "\tval = UNALIGNED_GET((struct uint48 *)buf->data);",
                    "588": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "589": "",
                    "590": "\treturn sys_be48_to_cpu(val.u48);",
                    "591": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le48": {
            "name": "net_buf_simple_pull_le48",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 569,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_le48(struct net_buf_simple *buf)\n{\n\tstruct uint48 {\n\t\tuint64_t u48:48;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint48 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le48_to_cpu(val.u48);\n}\n",
                {
                    "569": "uint64_t net_buf_simple_pull_le48(struct net_buf_simple *buf)",
                    "570": "{",
                    "571": "\tstruct uint48 {",
                    "572": "\t\tuint64_t u48:48;",
                    "573": "\t} __packed val;",
                    "574": "",
                    "575": "\tval = UNALIGNED_GET((struct uint48 *)buf->data);",
                    "576": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "577": "",
                    "578": "\treturn sys_le48_to_cpu(val.u48);",
                    "579": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be40": {
            "name": "net_buf_simple_pull_be40",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 557,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_be40(struct net_buf_simple *buf)\n{\n\tstruct uint40 {\n\t\tuint64_t u40: 40;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint40 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be40_to_cpu(val.u40);\n}\n",
                {
                    "557": "uint64_t net_buf_simple_pull_be40(struct net_buf_simple *buf)",
                    "558": "{",
                    "559": "\tstruct uint40 {",
                    "560": "\t\tuint64_t u40: 40;",
                    "561": "\t} __packed val;",
                    "562": "",
                    "563": "\tval = UNALIGNED_GET((struct uint40 *)buf->data);",
                    "564": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "565": "",
                    "566": "\treturn sys_be40_to_cpu(val.u40);",
                    "567": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le40": {
            "name": "net_buf_simple_pull_le40",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 545,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint64_t net_buf_simple_pull_le40(struct net_buf_simple *buf)\n{\n\tstruct uint40 {\n\t\tuint64_t u40: 40;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint40 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le40_to_cpu(val.u40);\n}\n",
                {
                    "545": "uint64_t net_buf_simple_pull_le40(struct net_buf_simple *buf)",
                    "546": "{",
                    "547": "\tstruct uint40 {",
                    "548": "\t\tuint64_t u40: 40;",
                    "549": "\t} __packed val;",
                    "550": "",
                    "551": "\tval = UNALIGNED_GET((struct uint40 *)buf->data);",
                    "552": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "553": "",
                    "554": "\treturn sys_le40_to_cpu(val.u40);",
                    "555": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be32": {
            "name": "net_buf_simple_pull_be32",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 535,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint32_t net_buf_simple_pull_be32(struct net_buf_simple *buf)\n{\n\tuint32_t val;\n\n\tval = UNALIGNED_GET((uint32_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be32_to_cpu(val);\n}\n",
                {
                    "535": "uint32_t net_buf_simple_pull_be32(struct net_buf_simple *buf)",
                    "536": "{",
                    "537": "\tuint32_t val;",
                    "538": "",
                    "539": "\tval = UNALIGNED_GET((uint32_t *)buf->data);",
                    "540": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "541": "",
                    "542": "\treturn sys_be32_to_cpu(val);",
                    "543": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le32": {
            "name": "net_buf_simple_pull_le32",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 525,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint32_t net_buf_simple_pull_le32(struct net_buf_simple *buf)\n{\n\tuint32_t val;\n\n\tval = UNALIGNED_GET((uint32_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le32_to_cpu(val);\n}\n",
                {
                    "525": "uint32_t net_buf_simple_pull_le32(struct net_buf_simple *buf)",
                    "526": "{",
                    "527": "\tuint32_t val;",
                    "528": "",
                    "529": "\tval = UNALIGNED_GET((uint32_t *)buf->data);",
                    "530": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "531": "",
                    "532": "\treturn sys_le32_to_cpu(val);",
                    "533": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be24": {
            "name": "net_buf_simple_pull_be24",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 513,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint32_t net_buf_simple_pull_be24(struct net_buf_simple *buf)\n{\n\tstruct uint24 {\n\t\tuint32_t u24:24;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint24 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be24_to_cpu(val.u24);\n}\n",
                {
                    "513": "uint32_t net_buf_simple_pull_be24(struct net_buf_simple *buf)",
                    "514": "{",
                    "515": "\tstruct uint24 {",
                    "516": "\t\tuint32_t u24:24;",
                    "517": "\t} __packed val;",
                    "518": "",
                    "519": "\tval = UNALIGNED_GET((struct uint24 *)buf->data);",
                    "520": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "521": "",
                    "522": "\treturn sys_be24_to_cpu(val.u24);",
                    "523": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le24": {
            "name": "net_buf_simple_pull_le24",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 501,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint32_t net_buf_simple_pull_le24(struct net_buf_simple *buf)\n{\n\tstruct uint24 {\n\t\tuint32_t u24:24;\n\t} __packed val;\n\n\tval = UNALIGNED_GET((struct uint24 *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le24_to_cpu(val.u24);\n}\n",
                {
                    "501": "uint32_t net_buf_simple_pull_le24(struct net_buf_simple *buf)",
                    "502": "{",
                    "503": "\tstruct uint24 {",
                    "504": "\t\tuint32_t u24:24;",
                    "505": "\t} __packed val;",
                    "506": "",
                    "507": "\tval = UNALIGNED_GET((struct uint24 *)buf->data);",
                    "508": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "509": "",
                    "510": "\treturn sys_le24_to_cpu(val.u24);",
                    "511": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_be16": {
            "name": "net_buf_simple_pull_be16",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 491,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint16_t net_buf_simple_pull_be16(struct net_buf_simple *buf)\n{\n\tuint16_t val;\n\n\tval = UNALIGNED_GET((uint16_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_be16_to_cpu(val);\n}\n",
                {
                    "491": "uint16_t net_buf_simple_pull_be16(struct net_buf_simple *buf)",
                    "492": "{",
                    "493": "\tuint16_t val;",
                    "494": "",
                    "495": "\tval = UNALIGNED_GET((uint16_t *)buf->data);",
                    "496": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "497": "",
                    "498": "\treturn sys_be16_to_cpu(val);",
                    "499": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_le16": {
            "name": "net_buf_simple_pull_le16",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 481,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)\n{\n\tuint16_t val;\n\n\tval = UNALIGNED_GET((uint16_t *)buf->data);\n\tnet_buf_simple_pull(buf, sizeof(val));\n\n\treturn sys_le16_to_cpu(val);\n}\n",
                {
                    "481": "uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)",
                    "482": "{",
                    "483": "\tuint16_t val;",
                    "484": "",
                    "485": "\tval = UNALIGNED_GET((uint16_t *)buf->data);",
                    "486": "\tnet_buf_simple_pull(buf, sizeof(val));",
                    "487": "",
                    "488": "\treturn sys_le16_to_cpu(val);",
                    "489": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_u8": {
            "name": "net_buf_simple_pull_u8",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 471,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nuint8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)\n{\n\tuint8_t val;\n\n\tval = buf->data[0];\n\tnet_buf_simple_pull(buf, 1);\n\n\treturn val;\n}\n",
                {
                    "471": "uint8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)",
                    "472": "{",
                    "473": "\tuint8_t val;",
                    "474": "",
                    "475": "\tval = buf->data[0];",
                    "476": "\tnet_buf_simple_pull(buf, 1);",
                    "477": "",
                    "478": "\treturn val;",
                    "479": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull_mem": {
            "name": "net_buf_simple_pull_mem",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 457,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)\n{\n\tvoid *data = buf->data;\n\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\t__ASSERT_NO_MSG(buf->len >= len);\n\n\tbuf->len -= len;\n\tbuf->data += len;\n\n\treturn data;\n}\n",
                {
                    "457": "void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)",
                    "458": "{",
                    "459": "\tvoid *data = buf->data;",
                    "460": "",
                    "461": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "462": "",
                    "463": "\t__ASSERT_NO_MSG(buf->len >= len);",
                    "464": "",
                    "465": "\tbuf->len -= len;",
                    "466": "\tbuf->data += len;",
                    "467": "",
                    "468": "\treturn data;",
                    "469": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_pull": {
            "name": "net_buf_simple_pull",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 447,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)\n{\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\t__ASSERT_NO_MSG(buf->len >= len);\n\n\tbuf->len -= len;\n\treturn buf->data += len;\n}\n",
                {
                    "447": "void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)",
                    "448": "{",
                    "449": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "450": "",
                    "451": "\t__ASSERT_NO_MSG(buf->len >= len);",
                    "452": "",
                    "453": "\tbuf->len -= len;",
                    "454": "\treturn buf->data += len;",
                    "455": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_push_mem": {
            "name": "net_buf_simple_push_mem",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 348,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_push_mem(struct net_buf_simple *buf, const void *mem,\n\t\t\t      size_t len)\n{\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\treturn memcpy(net_buf_simple_push(buf, len), mem, len);\n}\n",
                {
                    "348": "void *net_buf_simple_push_mem(struct net_buf_simple *buf, const void *mem,",
                    "349": "\t\t\t      size_t len)",
                    "350": "{",
                    "351": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "352": "",
                    "353": "\treturn memcpy(net_buf_simple_push(buf, len), mem, len);",
                    "354": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_push": {
            "name": "net_buf_simple_push",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 337,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_push(struct net_buf_simple *buf, size_t len)\n{\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\t__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);\n\n\tbuf->data -= len;\n\tbuf->len += len;\n\treturn buf->data;\n}\n",
                {
                    "337": "void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)",
                    "338": "{",
                    "339": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "340": "",
                    "341": "\t__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);",
                    "342": "",
                    "343": "\tbuf->data -= len;",
                    "344": "\tbuf->len += len;",
                    "345": "\treturn buf->data;",
                    "346": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_remove_mem": {
            "name": "net_buf_simple_remove_mem",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 172,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_remove_mem(struct net_buf_simple *buf, size_t len)\n{\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\t__ASSERT_NO_MSG(buf->len >= len);\n\n\tbuf->len -= len;\n\treturn buf->data + buf->len;\n}\n",
                {
                    "172": "void *net_buf_simple_remove_mem(struct net_buf_simple *buf, size_t len)",
                    "173": "{",
                    "174": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "175": "",
                    "176": "\t__ASSERT_NO_MSG(buf->len >= len);",
                    "177": "",
                    "178": "\tbuf->len -= len;",
                    "179": "\treturn buf->data + buf->len;",
                    "180": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_add_mem": {
            "name": "net_buf_simple_add_mem",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 68,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,\n\t\t\t     size_t len)\n{\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\treturn memcpy(net_buf_simple_add(buf, len), mem, len);\n}\n",
                {
                    "68": "void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,",
                    "69": "\t\t\t     size_t len)",
                    "70": "{",
                    "71": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "72": "",
                    "73": "\treturn memcpy(net_buf_simple_add(buf, len), mem, len);",
                    "74": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_add": {
            "name": "net_buf_simple_add",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 56,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid *net_buf_simple_add(struct net_buf_simple *buf, size_t len)\n{\n\tuint8_t *tail = net_buf_simple_tail(buf);\n\n\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);\n\n\t__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);\n\n\tbuf->len += len;\n\treturn tail;\n}\n",
                {
                    "56": "void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)",
                    "57": "{",
                    "58": "\tuint8_t *tail = net_buf_simple_tail(buf);",
                    "59": "",
                    "60": "\tNET_BUF_SIMPLE_DBG(\"buf %p len %zu\", buf, len);",
                    "61": "",
                    "62": "\t__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);",
                    "63": "",
                    "64": "\tbuf->len += len;",
                    "65": "\treturn tail;",
                    "66": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_buf_simple_init_with_data": {
            "name": "net_buf_simple_init_with_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf_simple.c",
            "location_line": 32,
            "function_content": [
                "#endif /* CONFIG_NET_BUF_SIMPLE_LOG */\nvoid net_buf_simple_init_with_data(struct net_buf_simple *buf,\n\t\t\t\t   void *data, size_t size)\n{\n\tbuf->__buf = data;\n\tbuf->data  = data;\n\tbuf->size  = size;\n\tbuf->len   = size;\n}\n",
                {
                    "32": "void net_buf_simple_init_with_data(struct net_buf_simple *buf,",
                    "33": "\t\t\t\t   void *data, size_t size)",
                    "34": "{",
                    "35": "\tbuf->__buf = data;",
                    "36": "\tbuf->data  = data;",
                    "37": "\tbuf->size  = size;",
                    "38": "\tbuf->len   = size;",
                    "39": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_net_addr_ntop": {
            "name": "z_impl_net_addr_ntop",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 160,
            "function_content": [
                "/*\n* Copyright (c) 2016 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nchar *z_impl_net_addr_ntop(net_sa_family_t family, const void *src,\n\t\t\t   char *dst, size_t size)\n{\n\tstruct net_in_addr addr = { 0 };\n\tstruct net_in6_addr addr6 = { 0 };\n\tuint16_t *w = NULL;\n\tint i;\n\tuint8_t longest = 1U;\n\tint pos = -1;\n\tchar delim = ':';\n\tuint8_t zeros[8] = { 0 };\n\tchar *ptr = dst;\n\tint len = -1;\n\tuint16_t value;\n\tbool needcolon = false;\n\tbool mapped = false;\n\n\tswitch (family) {\n\tcase NET_AF_INET6:\n\t\tif (size < NET_INET6_ADDRSTRLEN) {\n\t\t\t/* POSIX definition is the size - includes nil */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnet_ipv6_addr_copy_raw(addr6.s6_addr, src);\n\t\tw = (uint16_t *)addr6.s6_addr16;\n\t\tlen = 8;\n\n\t\tif (net_ipv6_addr_is_v4_mapped(&addr6)) {\n\t\t\tmapped = true;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tfor (int j = i; j < 8; j++) {\n\t\t\t\tif (w[j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tzeros[i]++;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (zeros[i] > longest) {\n\t\t\t\tlongest = zeros[i];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\n\t\tif (longest == 1U) {\n\t\t\tpos = -1;\n\t\t}\n\t\tbreak;\n\n\tcase NET_AF_INET:\n\t\tif (size < NET_INET_ADDRSTRLEN) {\n\t\t\t/* POSIX definition is the size - includes nil */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnet_ipv4_addr_copy_raw(addr.s4_addr, src);\n\t\tlen = 4;\n\t\tdelim = '.';\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\nprint_mapped:\n\tfor (i = 0; i < len; i++) {\n\t\t/* IPv4 address a.b.c.d */\n\t\tif (len == 4) {\n\t\t\tuint8_t l;\n\n\t\t\tvalue = (uint16_t)addr.s4_addr[i];\n\n\t\t\t/* net_byte_to_udec() eats 0 */\n\t\t\tif (value == 0U) {\n\t\t\t\t*ptr++ = '0';\n\t\t\t\t*ptr++ = delim;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tl = net_value_to_udec(ptr, value, 0);\n\n\t\t\tptr += l;\n\t\t\t*ptr++ = delim;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mapped && (i > 5)) {\n\t\t\tdelim = '.';\n\t\t\tlen = 4;\n\t\t\taddr.s_addr = addr6.s6_addr32[3];\n\t\t\t*ptr++ = ':';\n\t\t\tfamily = NET_AF_INET;\n\t\t\tgoto print_mapped;\n\t\t}\n\n\t\t/* IPv6 address */\n\t\tif (i == pos) {\n\t\t\tif (needcolon || i == 0U) {\n\t\t\t\t*ptr++ = ':';\n\t\t\t}\n\n\t\t\t*ptr++ = ':';\n\t\t\tneedcolon = false;\n\t\t\ti += (int)longest - 1;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (needcolon) {\n\t\t\t*ptr++ = ':';\n\t\t}\n\n\t\tvalue = sys_be16_to_cpu(UNALIGNED_GET(&w[i]));\n\t\tuint8_t bh = value >> 8;\n\t\tuint8_t bl = value & 0xff;\n\n\t\tif (bh) {\n\t\t\t/* Convert high byte to hex without padding */\n\t\t\tptr = net_byte_to_hex(ptr, bh, 'a', false);\n\n\t\t\t/* Always pad the low byte, since high byte is non - zero */\n\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', true);\n\t\t} else {\n\t\t\t/* For the case where the high byte is zero, only process the low byte\n\t\t\t * Do not pad the low byte, since high byte is zero\n\t\t\t */\n\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', false);\n\t\t}\n\n\t\tneedcolon = true;\n\t}\n\n\tif (family == NET_AF_INET) {\n\t\t*(ptr - 1) = '\\0';\n\t} else {\n\t\t*ptr = '\\0';\n\t}\n\n\treturn dst;\n}\n",
                {
                    "160": "char *z_impl_net_addr_ntop(net_sa_family_t family, const void *src,",
                    "161": "\t\t\t   char *dst, size_t size)",
                    "162": "{",
                    "163": "\tstruct net_in_addr addr = { 0 };",
                    "164": "\tstruct net_in6_addr addr6 = { 0 };",
                    "165": "\tuint16_t *w = NULL;",
                    "166": "\tint i;",
                    "167": "\tuint8_t longest = 1U;",
                    "168": "\tint pos = -1;",
                    "169": "\tchar delim = ':';",
                    "170": "\tuint8_t zeros[8] = { 0 };",
                    "171": "\tchar *ptr = dst;",
                    "172": "\tint len = -1;",
                    "173": "\tuint16_t value;",
                    "174": "\tbool needcolon = false;",
                    "175": "\tbool mapped = false;",
                    "176": "",
                    "177": "\tswitch (family) {",
                    "178": "\tcase NET_AF_INET6:",
                    "179": "\t\tif (size < NET_INET6_ADDRSTRLEN) {",
                    "180": "\t\t\t/* POSIX definition is the size - includes nil */",
                    "181": "\t\t\treturn NULL;",
                    "182": "\t\t}",
                    "183": "",
                    "184": "\t\tnet_ipv6_addr_copy_raw(addr6.s6_addr, src);",
                    "185": "\t\tw = (uint16_t *)addr6.s6_addr16;",
                    "186": "\t\tlen = 8;",
                    "187": "",
                    "188": "\t\tif (net_ipv6_addr_is_v4_mapped(&addr6)) {",
                    "189": "\t\t\tmapped = true;",
                    "190": "\t\t}",
                    "191": "",
                    "192": "\t\tfor (i = 0; i < 8; i++) {",
                    "193": "\t\t\tfor (int j = i; j < 8; j++) {",
                    "194": "\t\t\t\tif (w[j] != 0) {",
                    "195": "\t\t\t\t\tbreak;",
                    "196": "\t\t\t\t}",
                    "197": "",
                    "198": "\t\t\t\tzeros[i]++;",
                    "199": "\t\t\t}",
                    "200": "\t\t}",
                    "201": "",
                    "202": "\t\tfor (i = 0; i < 8; i++) {",
                    "203": "\t\t\tif (zeros[i] > longest) {",
                    "204": "\t\t\t\tlongest = zeros[i];",
                    "205": "\t\t\t\tpos = i;",
                    "206": "\t\t\t}",
                    "207": "\t\t}",
                    "208": "",
                    "209": "\t\tif (longest == 1U) {",
                    "210": "\t\t\tpos = -1;",
                    "211": "\t\t}",
                    "212": "\t\tbreak;",
                    "213": "",
                    "214": "\tcase NET_AF_INET:",
                    "215": "\t\tif (size < NET_INET_ADDRSTRLEN) {",
                    "216": "\t\t\t/* POSIX definition is the size - includes nil */",
                    "217": "\t\t\treturn NULL;",
                    "218": "\t\t}",
                    "219": "",
                    "220": "\t\tnet_ipv4_addr_copy_raw(addr.s4_addr, src);",
                    "221": "\t\tlen = 4;",
                    "222": "\t\tdelim = '.';",
                    "223": "\t\tbreak;",
                    "224": "",
                    "225": "\tdefault:",
                    "226": "\t\treturn NULL;",
                    "227": "\t}",
                    "228": "",
                    "229": "print_mapped:",
                    "230": "\tfor (i = 0; i < len; i++) {",
                    "231": "\t\t/* IPv4 address a.b.c.d */",
                    "232": "\t\tif (len == 4) {",
                    "233": "\t\t\tuint8_t l;",
                    "234": "",
                    "235": "\t\t\tvalue = (uint16_t)addr.s4_addr[i];",
                    "236": "",
                    "237": "\t\t\t/* net_byte_to_udec() eats 0 */",
                    "238": "\t\t\tif (value == 0U) {",
                    "239": "\t\t\t\t*ptr++ = '0';",
                    "240": "\t\t\t\t*ptr++ = delim;",
                    "241": "\t\t\t\tcontinue;",
                    "242": "\t\t\t}",
                    "243": "",
                    "244": "\t\t\tl = net_value_to_udec(ptr, value, 0);",
                    "245": "",
                    "246": "\t\t\tptr += l;",
                    "247": "\t\t\t*ptr++ = delim;",
                    "248": "",
                    "249": "\t\t\tcontinue;",
                    "250": "\t\t}",
                    "251": "",
                    "252": "\t\tif (mapped && (i > 5)) {",
                    "253": "\t\t\tdelim = '.';",
                    "254": "\t\t\tlen = 4;",
                    "255": "\t\t\taddr.s_addr = addr6.s6_addr32[3];",
                    "256": "\t\t\t*ptr++ = ':';",
                    "257": "\t\t\tfamily = NET_AF_INET;",
                    "258": "\t\t\tgoto print_mapped;",
                    "259": "\t\t}",
                    "260": "",
                    "261": "\t\t/* IPv6 address */",
                    "262": "\t\tif (i == pos) {",
                    "263": "\t\t\tif (needcolon || i == 0U) {",
                    "264": "\t\t\t\t*ptr++ = ':';",
                    "265": "\t\t\t}",
                    "266": "",
                    "267": "\t\t\t*ptr++ = ':';",
                    "268": "\t\t\tneedcolon = false;",
                    "269": "\t\t\ti += (int)longest - 1;",
                    "270": "",
                    "271": "\t\t\tcontinue;",
                    "272": "\t\t}",
                    "273": "",
                    "274": "\t\tif (needcolon) {",
                    "275": "\t\t\t*ptr++ = ':';",
                    "276": "\t\t}",
                    "277": "",
                    "278": "\t\tvalue = sys_be16_to_cpu(UNALIGNED_GET(&w[i]));",
                    "279": "\t\tuint8_t bh = value >> 8;",
                    "280": "\t\tuint8_t bl = value & 0xff;",
                    "281": "",
                    "282": "\t\tif (bh) {",
                    "283": "\t\t\t/* Convert high byte to hex without padding */",
                    "284": "\t\t\tptr = net_byte_to_hex(ptr, bh, 'a', false);",
                    "285": "",
                    "286": "\t\t\t/* Always pad the low byte, since high byte is non - zero */",
                    "287": "\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', true);",
                    "288": "\t\t} else {",
                    "289": "\t\t\t/* For the case where the high byte is zero, only process the low byte",
                    "290": "\t\t\t * Do not pad the low byte, since high byte is zero",
                    "291": "\t\t\t */",
                    "292": "\t\t\tptr = net_byte_to_hex(ptr, bl, 'a', false);",
                    "293": "\t\t}",
                    "294": "",
                    "295": "\t\tneedcolon = true;",
                    "296": "\t}",
                    "297": "",
                    "298": "\tif (family == NET_AF_INET) {",
                    "299": "\t\t*(ptr - 1) = '\\0';",
                    "300": "\t} else {",
                    "301": "\t\t*ptr = '\\0';",
                    "302": "\t}",
                    "303": "",
                    "304": "\treturn dst;",
                    "305": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_net_addr_pton": {
            "name": "z_impl_net_addr_pton",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 343,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nint z_impl_net_addr_pton(net_sa_family_t family, const char *src,\n\t\t\t void *dst)\n{\n\tif (family == NET_AF_INET) {\n\t\tstruct net_in_addr *addr = (struct net_in_addr *)dst;\n\t\tuint8_t index = 0, digits = 0;\n\t\tuint16_t value = 0, count = 0;\n\n\t\t(void)memset(addr, 0, sizeof(struct net_in_addr));\n\n\t\t/* A valid IPv4 address that can be used with inet_pton\n\t\t * must be in the standard dotted-decimal notation:\n\t\t *\n\t\t *    - Four octets, each ranging from 0 to 255\n\t\t *    - Separated by dots (.)\n\t\t *    - No leading zeros in each octet\n\t\t */\n\n\t\twhile (index < sizeof(struct net_in_addr)) {\n\t\t\tif (*src == '\\0' || *src == '.') {\n\t\t\t\tif (*src == '.') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tif ((digits > 1 && value < 10) ||\n\t\t\t\t    (digits > 2 && value < 100)) {\n\t\t\t\t\t/* Preceding zeroes */\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (digits == 0 || value > UINT8_MAX) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\taddr->s4_addr[index] = value;\n\n\t\t\t\tif (*src == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t\tdigits = 0;\n\t\t\t\tvalue = 0;\n\t\t\t} else if ('0' <= *src && *src <= '9') {\n\t\t\t\tif (++digits > 3) {\n\t\t\t\t\t/* Number too large */\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tvalue *= 10;\n\t\t\t\tvalue += *src - '0';\n\t\t\t} else {\n\t\t\t\t/* Invalid character */\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsrc++;\n\t\t}\n\n\t\tif (count != 3) {\n\t\t\t/* Three dots needed */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else if (family == NET_AF_INET6) {\n\t\t/* If the string contains a '.', it means it's of the form\n\t\t * X:X:X:X:X:X:x.x.x.x, and contains only 6 16-bit pieces\n\t\t */\n\t\tint expected_groups = strchr(src, '.') ? 6 : 8;\n\t\tstruct net_in6_addr *addr = (struct net_in6_addr *)dst;\n\t\tint i, len;\n\n\t\tif (*src == ':') {\n\t\t\t/* Ignore a leading colon, makes parsing neater */\n\t\t\tsrc++;\n\t\t}\n\n\t\tlen = strlen(src);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!(src[i] >= '0' && src[i] <= '9') &&\n\t\t\t    !(src[i] >= 'A' && src[i] <= 'F') &&\n\t\t\t    !(src[i] >= 'a' && src[i] <= 'f') &&\n\t\t\t    src[i] != '.' && src[i] != ':') {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < expected_groups; i++) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!src || *src == '\\0') {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (*src != ':') {\n\t\t\t\t/* Normal IPv6 16-bit piece */\n\t\t\t\tUNALIGNED_PUT(net_htons(strtol(src, NULL, 16)),\n\t\t\t\t\t      &addr->s6_addr16[i]);\n\t\t\t\tsrc = strchr(src, ':');\n\t\t\t\tif (src) {\n\t\t\t\t\tsrc++;\n\t\t\t\t} else {\n\t\t\t\t\tif (i < expected_groups - 1) {\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Two colons in a row */\n\n\t\t\tfor (; i < expected_groups; i++) {\n\t\t\t\tUNALIGNED_PUT(0, &addr->s6_addr16[i]);\n\t\t\t}\n\n\t\t\ttmp = strrchr(src, ':');\n\t\t\tif (src == tmp && (expected_groups == 6 || !src[1])) {\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (expected_groups == 6) {\n\t\t\t\t/* we need to drop the trailing\n\t\t\t\t * colon since it's between the\n\t\t\t\t * ipv6 and ipv4 addresses, rather than being\n\t\t\t\t * a part of the ipv6 address\n\t\t\t\t */\n\t\t\t\ttmp--;\n\t\t\t}\n\n\t\t\t/* Calculate the amount of skipped zeros */\n\t\t\ti = expected_groups - 1;\n\t\t\tdo {\n\t\t\t\tif (*tmp == ':') {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\tif (i < 0) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} while (tmp-- != src);\n\n\t\t\tsrc++;\n\t\t}\n\n\t\tif (expected_groups == 6) {\n\t\t\t/* Parse the IPv4 part */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tif (!src || !*src) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\taddr->s6_addr[12 + i] = strtol(src, NULL, 10);\n\n\t\t\t\tsrc = strchr(src, '.');\n\t\t\t\tif (src) {\n\t\t\t\t\tsrc++;\n\t\t\t\t} else {\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "343": "int z_impl_net_addr_pton(net_sa_family_t family, const char *src,",
                    "344": "\t\t\t void *dst)",
                    "345": "{",
                    "346": "\tif (family == NET_AF_INET) {",
                    "347": "\t\tstruct net_in_addr *addr = (struct net_in_addr *)dst;",
                    "348": "\t\tuint8_t index = 0, digits = 0;",
                    "349": "\t\tuint16_t value = 0, count = 0;",
                    "350": "",
                    "351": "\t\t(void)memset(addr, 0, sizeof(struct net_in_addr));",
                    "352": "",
                    "353": "\t\t/* A valid IPv4 address that can be used with inet_pton",
                    "354": "\t\t * must be in the standard dotted-decimal notation:",
                    "355": "\t\t *",
                    "356": "\t\t *    - Four octets, each ranging from 0 to 255",
                    "357": "\t\t *    - Separated by dots (.)",
                    "358": "\t\t *    - No leading zeros in each octet",
                    "359": "\t\t */",
                    "360": "",
                    "361": "\t\twhile (index < sizeof(struct net_in_addr)) {",
                    "362": "\t\t\tif (*src == '\\0' || *src == '.') {",
                    "363": "\t\t\t\tif (*src == '.') {",
                    "364": "\t\t\t\t\tcount++;",
                    "365": "\t\t\t\t}",
                    "366": "",
                    "367": "\t\t\t\tif ((digits > 1 && value < 10) ||",
                    "368": "\t\t\t\t    (digits > 2 && value < 100)) {",
                    "369": "\t\t\t\t\t/* Preceding zeroes */",
                    "370": "\t\t\t\t\treturn -EINVAL;",
                    "371": "\t\t\t\t}",
                    "372": "",
                    "373": "\t\t\t\tif (digits == 0 || value > UINT8_MAX) {",
                    "374": "\t\t\t\t\treturn -EINVAL;",
                    "375": "\t\t\t\t}",
                    "376": "",
                    "377": "\t\t\t\taddr->s4_addr[index] = value;",
                    "378": "",
                    "379": "\t\t\t\tif (*src == '\\0') {",
                    "380": "\t\t\t\t\tbreak;",
                    "381": "\t\t\t\t}",
                    "382": "",
                    "383": "\t\t\t\tindex++;",
                    "384": "\t\t\t\tdigits = 0;",
                    "385": "\t\t\t\tvalue = 0;",
                    "386": "\t\t\t} else if ('0' <= *src && *src <= '9') {",
                    "387": "\t\t\t\tif (++digits > 3) {",
                    "388": "\t\t\t\t\t/* Number too large */",
                    "389": "\t\t\t\t\treturn -EINVAL;",
                    "390": "\t\t\t\t}",
                    "391": "",
                    "392": "\t\t\t\tvalue *= 10;",
                    "393": "\t\t\t\tvalue += *src - '0';",
                    "394": "\t\t\t} else {",
                    "395": "\t\t\t\t/* Invalid character */",
                    "396": "\t\t\t\treturn -EINVAL;",
                    "397": "\t\t\t}",
                    "398": "",
                    "399": "\t\t\tsrc++;",
                    "400": "\t\t}",
                    "401": "",
                    "402": "\t\tif (count != 3) {",
                    "403": "\t\t\t/* Three dots needed */",
                    "404": "\t\t\treturn -EINVAL;",
                    "405": "\t\t}",
                    "406": "",
                    "407": "\t} else if (family == NET_AF_INET6) {",
                    "408": "\t\t/* If the string contains a '.', it means it's of the form",
                    "409": "\t\t * X:X:X:X:X:X:x.x.x.x, and contains only 6 16-bit pieces",
                    "410": "\t\t */",
                    "411": "\t\tint expected_groups = strchr(src, '.') ? 6 : 8;",
                    "412": "\t\tstruct net_in6_addr *addr = (struct net_in6_addr *)dst;",
                    "413": "\t\tint i, len;",
                    "414": "",
                    "415": "\t\tif (*src == ':') {",
                    "416": "\t\t\t/* Ignore a leading colon, makes parsing neater */",
                    "417": "\t\t\tsrc++;",
                    "418": "\t\t}",
                    "419": "",
                    "420": "\t\tlen = strlen(src);",
                    "421": "\t\tfor (i = 0; i < len; i++) {",
                    "422": "\t\t\tif (!(src[i] >= '0' && src[i] <= '9') &&",
                    "423": "\t\t\t    !(src[i] >= 'A' && src[i] <= 'F') &&",
                    "424": "\t\t\t    !(src[i] >= 'a' && src[i] <= 'f') &&",
                    "425": "\t\t\t    src[i] != '.' && src[i] != ':') {",
                    "426": "\t\t\t\treturn -EINVAL;",
                    "427": "\t\t\t}",
                    "428": "\t\t}",
                    "429": "",
                    "430": "\t\tfor (i = 0; i < expected_groups; i++) {",
                    "431": "\t\t\tchar *tmp;",
                    "432": "",
                    "433": "\t\t\tif (!src || *src == '\\0') {",
                    "434": "\t\t\t\treturn -EINVAL;",
                    "435": "\t\t\t}",
                    "436": "",
                    "437": "\t\t\tif (*src != ':') {",
                    "438": "\t\t\t\t/* Normal IPv6 16-bit piece */",
                    "439": "\t\t\t\tUNALIGNED_PUT(net_htons(strtol(src, NULL, 16)),",
                    "440": "\t\t\t\t\t      &addr->s6_addr16[i]);",
                    "441": "\t\t\t\tsrc = strchr(src, ':');",
                    "442": "\t\t\t\tif (src) {",
                    "443": "\t\t\t\t\tsrc++;",
                    "444": "\t\t\t\t} else {",
                    "445": "\t\t\t\t\tif (i < expected_groups - 1) {",
                    "446": "\t\t\t\t\t\treturn -EINVAL;",
                    "447": "\t\t\t\t\t}",
                    "448": "\t\t\t\t}",
                    "449": "",
                    "450": "\t\t\t\tcontinue;",
                    "451": "\t\t\t}",
                    "452": "",
                    "453": "\t\t\t/* Two colons in a row */",
                    "454": "",
                    "455": "\t\t\tfor (; i < expected_groups; i++) {",
                    "456": "\t\t\t\tUNALIGNED_PUT(0, &addr->s6_addr16[i]);",
                    "457": "\t\t\t}",
                    "458": "",
                    "459": "\t\t\ttmp = strrchr(src, ':');",
                    "460": "\t\t\tif (src == tmp && (expected_groups == 6 || !src[1])) {",
                    "461": "\t\t\t\tsrc++;",
                    "462": "\t\t\t\tbreak;",
                    "463": "\t\t\t}",
                    "464": "",
                    "465": "\t\t\tif (expected_groups == 6) {",
                    "466": "\t\t\t\t/* we need to drop the trailing",
                    "467": "\t\t\t\t * colon since it's between the",
                    "468": "\t\t\t\t * ipv6 and ipv4 addresses, rather than being",
                    "469": "\t\t\t\t * a part of the ipv6 address",
                    "470": "\t\t\t\t */",
                    "471": "\t\t\t\ttmp--;",
                    "472": "\t\t\t}",
                    "473": "",
                    "474": "\t\t\t/* Calculate the amount of skipped zeros */",
                    "475": "\t\t\ti = expected_groups - 1;",
                    "476": "\t\t\tdo {",
                    "477": "\t\t\t\tif (*tmp == ':') {",
                    "478": "\t\t\t\t\ti--;",
                    "479": "\t\t\t\t}",
                    "480": "",
                    "481": "\t\t\t\tif (i < 0) {",
                    "482": "\t\t\t\t\treturn -EINVAL;",
                    "483": "\t\t\t\t}",
                    "484": "\t\t\t} while (tmp-- != src);",
                    "485": "",
                    "486": "\t\t\tsrc++;",
                    "487": "\t\t}",
                    "488": "",
                    "489": "\t\tif (expected_groups == 6) {",
                    "490": "\t\t\t/* Parse the IPv4 part */",
                    "491": "\t\t\tfor (i = 0; i < 4; i++) {",
                    "492": "\t\t\t\tif (!src || !*src) {",
                    "493": "\t\t\t\t\treturn -EINVAL;",
                    "494": "\t\t\t\t}",
                    "495": "",
                    "496": "\t\t\t\taddr->s6_addr[12 + i] = strtol(src, NULL, 10);",
                    "497": "",
                    "498": "\t\t\t\tsrc = strchr(src, '.');",
                    "499": "\t\t\t\tif (src) {",
                    "500": "\t\t\t\t\tsrc++;",
                    "501": "\t\t\t\t} else {",
                    "502": "\t\t\t\t\tif (i < 3) {",
                    "503": "\t\t\t\t\t\treturn -EINVAL;",
                    "504": "\t\t\t\t\t}",
                    "505": "\t\t\t\t}",
                    "506": "\t\t\t}",
                    "507": "\t\t}",
                    "508": "\t} else {",
                    "509": "\t\treturn -EINVAL;",
                    "510": "\t}",
                    "511": "",
                    "512": "\treturn 0;",
                    "513": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipaddr_parse_mask": {
            "name": "net_ipaddr_parse_mask",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 984,
            "function_content": [
                "/* We cannot accept empty string here */\nconst char *net_ipaddr_parse_mask(const char *str, size_t str_len,\n\t\t\t\t  struct net_sockaddr *addr, uint8_t *mask_len)\n{\n\tconst char *next = NULL, *mask_ptr = NULL;\n\tint parsed_mask_len = -1;\n\tbool ret = false;\n\n\tif (str == NULL || str_len == 0 || addr == NULL || mask_len == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (*str == '\\0') {\n\t\treturn NULL;\n\t}\n\n\tfor (int i = 0; i < str_len; i++) {\n\t\tif (str[i] == ',' || str[i] == ' ') {\n\t\t\tnext = str + i + 1;\n\t\t\tstr_len = next - str - 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (str[i] == '/') {\n\t\t\tmask_ptr = str + i;\n\t\t}\n\t}\n\n\tif (mask_ptr != NULL) {\n\t\tchar *endptr;\n\n\t\tparsed_mask_len = strtoul(mask_ptr + 1, &endptr, 10);\n\t\tif (*endptr != '\\0') {\n\t\t\tif (next == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tstr_len = mask_ptr - str;\n\t\t*mask_len = (uint8_t)parsed_mask_len;\n\t}\n\n#if defined(CONFIG_NET_IPV4) && defined(CONFIG_NET_IPV6)\n\tret = parse_ipv4(str, str_len, addr, false);\n\tif (!ret) {\n\t\tret = parse_ipv6(str, str_len, addr, false);\n\t}\n#elif defined(CONFIG_NET_IPV4) && !defined(CONFIG_NET_IPV6)\n\tret = parse_ipv4(str, str_len, addr, false);\n\n#elif defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)\n\tret = parse_ipv6(str, str_len, addr, false);\n#endif\n\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif (parsed_mask_len < 0) {\n\t\tif (addr->sa_family == NET_AF_INET) {\n\t\t\t*mask_len = 32;\n\t\t} else if (addr->sa_family == NET_AF_INET6) {\n\t\t\t*mask_len = 128;\n\t\t}\n\t}\n\n\tif (next != NULL) {\n\t\treturn next;\n\t}\n\n\treturn \"\";\n}\n",
                {
                    "984": "const char *net_ipaddr_parse_mask(const char *str, size_t str_len,",
                    "985": "\t\t\t\t  struct net_sockaddr *addr, uint8_t *mask_len)",
                    "986": "{",
                    "987": "\tconst char *next = NULL, *mask_ptr = NULL;",
                    "988": "\tint parsed_mask_len = -1;",
                    "989": "\tbool ret = false;",
                    "990": "",
                    "991": "\tif (str == NULL || str_len == 0 || addr == NULL || mask_len == NULL) {",
                    "992": "\t\treturn NULL;",
                    "993": "\t}",
                    "994": "",
                    "995": "\tif (*str == '\\0') {",
                    "996": "\t\treturn NULL;",
                    "997": "\t}",
                    "998": "",
                    "999": "\tfor (int i = 0; i < str_len; i++) {",
                    "1000": "\t\tif (str[i] == ',' || str[i] == ' ') {",
                    "1001": "\t\t\tnext = str + i + 1;",
                    "1002": "\t\t\tstr_len = next - str - 1;",
                    "1003": "\t\t\tbreak;",
                    "1004": "\t\t}",
                    "1005": "",
                    "1006": "\t\tif (str[i] == '/') {",
                    "1007": "\t\t\tmask_ptr = str + i;",
                    "1008": "\t\t}",
                    "1009": "\t}",
                    "1010": "",
                    "1011": "\tif (mask_ptr != NULL) {",
                    "1012": "\t\tchar *endptr;",
                    "1013": "",
                    "1014": "\t\tparsed_mask_len = strtoul(mask_ptr + 1, &endptr, 10);",
                    "1015": "\t\tif (*endptr != '\\0') {",
                    "1016": "\t\t\tif (next == NULL) {",
                    "1017": "\t\t\t\treturn NULL;",
                    "1018": "\t\t\t}",
                    "1019": "\t\t}",
                    "1020": "",
                    "1021": "\t\tstr_len = mask_ptr - str;",
                    "1022": "\t\t*mask_len = (uint8_t)parsed_mask_len;",
                    "1023": "\t}",
                    "1024": "",
                    "1025": "#if defined(CONFIG_NET_IPV4) && defined(CONFIG_NET_IPV6)",
                    "1026": "\tret = parse_ipv4(str, str_len, addr, false);",
                    "1027": "\tif (!ret) {",
                    "1028": "\t\tret = parse_ipv6(str, str_len, addr, false);",
                    "1029": "\t}",
                    "1030": "#elif defined(CONFIG_NET_IPV4) && !defined(CONFIG_NET_IPV6)",
                    "1031": "\tret = parse_ipv4(str, str_len, addr, false);",
                    "1032": "",
                    "1033": "#elif defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)",
                    "1034": "\tret = parse_ipv6(str, str_len, addr, false);",
                    "1035": "#endif",
                    "1036": "",
                    "1037": "\tif (!ret) {",
                    "1038": "\t\treturn NULL;",
                    "1039": "\t}",
                    "1040": "",
                    "1041": "\tif (parsed_mask_len < 0) {",
                    "1042": "\t\tif (addr->sa_family == NET_AF_INET) {",
                    "1043": "\t\t\t*mask_len = 32;",
                    "1044": "\t\t} else if (addr->sa_family == NET_AF_INET6) {",
                    "1045": "\t\t\t*mask_len = 128;",
                    "1046": "\t\t}",
                    "1047": "\t}",
                    "1048": "",
                    "1049": "\tif (next != NULL) {",
                    "1050": "\t\treturn next;",
                    "1051": "\t}",
                    "1052": "",
                    "1053": "\treturn \"\";",
                    "1054": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipaddr_parse": {
            "name": "net_ipaddr_parse",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 939,
            "function_content": [
                "#endif /* CONFIG_NET_IPV4 */\nbool net_ipaddr_parse(const char *str, size_t str_len, struct net_sockaddr *addr)\n{\n\tint i, count;\n\n\tif (!str || str_len == 0) {\n\t\treturn false;\n\t}\n\n\t/* We cannot accept empty string here */\n\tif (*str == '\\0') {\n\t\treturn false;\n\t}\n\n\tif (*str == '[') {\n\t\treturn parse_ipv6(str, str_len, addr, true);\n\t}\n\n\tfor (count = i = 0; i < str_len && str[i]; i++) {\n\t\tif (str[i] == ':') {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 1) {\n\t\treturn parse_ipv4(str, str_len, addr, true);\n\t}\n\n#if defined(CONFIG_NET_IPV4) && defined(CONFIG_NET_IPV6)\n\tif (!parse_ipv4(str, str_len, addr, false)) {\n\t\treturn parse_ipv6(str, str_len, addr, false);\n\t}\n\n\treturn true;\n#endif\n\n#if defined(CONFIG_NET_IPV4) && !defined(CONFIG_NET_IPV6)\n\treturn parse_ipv4(str, str_len, addr, false);\n#endif\n\n#if defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)\n\treturn parse_ipv6(str, str_len, addr, false);\n#endif\n\treturn false;\n}\n",
                {
                    "939": "bool net_ipaddr_parse(const char *str, size_t str_len, struct net_sockaddr *addr)",
                    "940": "{",
                    "941": "\tint i, count;",
                    "942": "",
                    "943": "\tif (!str || str_len == 0) {",
                    "944": "\t\treturn false;",
                    "945": "\t}",
                    "946": "",
                    "947": "\t/* We cannot accept empty string here */",
                    "948": "\tif (*str == '\\0') {",
                    "949": "\t\treturn false;",
                    "950": "\t}",
                    "951": "",
                    "952": "\tif (*str == '[') {",
                    "953": "\t\treturn parse_ipv6(str, str_len, addr, true);",
                    "954": "\t}",
                    "955": "",
                    "956": "\tfor (count = i = 0; i < str_len && str[i]; i++) {",
                    "957": "\t\tif (str[i] == ':') {",
                    "958": "\t\t\tcount++;",
                    "959": "\t\t}",
                    "960": "\t}",
                    "961": "",
                    "962": "\tif (count == 1) {",
                    "963": "\t\treturn parse_ipv4(str, str_len, addr, true);",
                    "964": "\t}",
                    "965": "",
                    "966": "#if defined(CONFIG_NET_IPV4) && defined(CONFIG_NET_IPV6)",
                    "967": "\tif (!parse_ipv4(str, str_len, addr, false)) {",
                    "968": "\t\treturn parse_ipv6(str, str_len, addr, false);",
                    "969": "\t}",
                    "970": "",
                    "971": "\treturn true;",
                    "972": "#endif",
                    "973": "",
                    "974": "#if defined(CONFIG_NET_IPV4) && !defined(CONFIG_NET_IPV6)",
                    "975": "\treturn parse_ipv4(str, str_len, addr, false);",
                    "976": "#endif",
                    "977": "",
                    "978": "#if defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)",
                    "979": "\treturn parse_ipv6(str, str_len, addr, false);",
                    "980": "#endif",
                    "981": "\treturn false;",
                    "982": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_mask_len_to_netmask": {
            "name": "net_mask_len_to_netmask",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 1056,
            "function_content": [
                "/* We cannot accept empty string here */\nint net_mask_len_to_netmask(net_sa_family_t family, uint8_t mask_len, struct net_sockaddr *mask)\n{\n\tif (family == NET_AF_INET) {\n\t\tstruct net_in_addr *addr4 = &net_sin(mask)->sin_addr;\n\t\tstruct net_sockaddr_in *mask4 = (struct net_sockaddr_in *)mask;\n\n\t\tif (mask_len > 32) {\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tmemset(mask4, 0, sizeof(struct net_sockaddr_in));\n\n\t\tmask4->sin_family = NET_AF_INET;\n\t\tmask4->sin_port = 0;\n\t\taddr4->s_addr = net_htonl(UINT32_MAX << (32 - mask_len));\n\n\t} else if (family == NET_AF_INET6) {\n\t\tstruct net_in6_addr *addr6 = &net_sin6(mask)->sin6_addr;\n\t\tstruct net_sockaddr_in6 *mask6 = (struct net_sockaddr_in6 *)mask;\n\t\tuint32_t mask_val[4] = { 0 };\n\n\t\tif (mask_len > 128) {\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tmemset(mask6, 0, sizeof(struct net_sockaddr_in6));\n\n\t\tmask6->sin6_family = NET_AF_INET6;\n\t\tmask6->sin6_port = 0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint bits = mask_len - i * 32;\n\n\t\t\tif (bits >= 32) {\n\t\t\t\tmask_val[i] = UINT32_MAX;\n\t\t\t} else if (bits > 0) {\n\t\t\t\tmask_val[i] = net_htonl(UINT32_MAX << (32 - bits));\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(addr6->s6_addr32, mask_val, sizeof(mask_val));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1056": "int net_mask_len_to_netmask(net_sa_family_t family, uint8_t mask_len, struct net_sockaddr *mask)",
                    "1057": "{",
                    "1058": "\tif (family == NET_AF_INET) {",
                    "1059": "\t\tstruct net_in_addr *addr4 = &net_sin(mask)->sin_addr;",
                    "1060": "\t\tstruct net_sockaddr_in *mask4 = (struct net_sockaddr_in *)mask;",
                    "1061": "",
                    "1062": "\t\tif (mask_len > 32) {",
                    "1063": "\t\t\treturn -ERANGE;",
                    "1064": "\t\t}",
                    "1065": "",
                    "1066": "\t\tmemset(mask4, 0, sizeof(struct net_sockaddr_in));",
                    "1067": "",
                    "1068": "\t\tmask4->sin_family = NET_AF_INET;",
                    "1069": "\t\tmask4->sin_port = 0;",
                    "1070": "\t\taddr4->s_addr = net_htonl(UINT32_MAX << (32 - mask_len));",
                    "1071": "",
                    "1072": "\t} else if (family == NET_AF_INET6) {",
                    "1073": "\t\tstruct net_in6_addr *addr6 = &net_sin6(mask)->sin6_addr;",
                    "1074": "\t\tstruct net_sockaddr_in6 *mask6 = (struct net_sockaddr_in6 *)mask;",
                    "1075": "\t\tuint32_t mask_val[4] = { 0 };",
                    "1076": "",
                    "1077": "\t\tif (mask_len > 128) {",
                    "1078": "\t\t\treturn -ERANGE;",
                    "1079": "\t\t}",
                    "1080": "",
                    "1081": "\t\tmemset(mask6, 0, sizeof(struct net_sockaddr_in6));",
                    "1082": "",
                    "1083": "\t\tmask6->sin6_family = NET_AF_INET6;",
                    "1084": "\t\tmask6->sin6_port = 0;",
                    "1085": "",
                    "1086": "\t\tfor (int i = 0; i < 4; i++) {",
                    "1087": "\t\t\tint bits = mask_len - i * 32;",
                    "1088": "",
                    "1089": "\t\t\tif (bits >= 32) {",
                    "1090": "\t\t\t\tmask_val[i] = UINT32_MAX;",
                    "1091": "\t\t\t} else if (bits > 0) {",
                    "1092": "\t\t\t\tmask_val[i] = net_htonl(UINT32_MAX << (32 - bits));",
                    "1093": "\t\t\t}",
                    "1094": "\t\t}",
                    "1095": "",
                    "1096": "\t\tmemcpy(addr6->s6_addr32, mask_val, sizeof(mask_val));",
                    "1097": "\t} else {",
                    "1098": "\t\treturn -EINVAL;",
                    "1099": "\t}",
                    "1100": "",
                    "1101": "\treturn 0;",
                    "1102": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_addr_generate_iid": {
            "name": "net_ipv6_addr_generate_iid",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 960,
            "function_content": [
                "/* Check reserved addresses, RFC 5453 ch 3 */\nint net_ipv6_addr_generate_iid(struct net_if *iface,\n\t\t\t       const struct net_in6_addr *prefix,\n\t\t\t       uint8_t *network_id,\n\t\t\t       size_t network_id_len,\n\t\t\t       uint8_t dad_counter,\n\t\t\t       struct net_in6_addr *addr,\n\t\t\t       struct net_linkaddr *lladdr)\n{\n\tstruct net_in6_addr tmp_addr;\n\tuint8_t if_index;\n\n\tif_index = (iface == NULL) ? net_if_get_by_iface(net_if_get_default())\n\t\t: net_if_get_by_iface(iface);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE)) {\n\t\tstruct net_in6_addr tmp_prefix = { 0 };\n\t\tint ret;\n\n\t\tif (prefix == NULL) {\n\t\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_prefix.s6_addr32[0]);\n\t\t} else {\n\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]),\n\t\t\t\t      &tmp_prefix.s6_addr32[0]);\n\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]),\n\t\t\t\t      &tmp_prefix.s6_addr32[1]);\n\t\t}\n\n\t\tret = gen_stable_iid(if_index, &tmp_prefix, network_id, network_id_len,\n\t\t\t\t     dad_counter, (uint8_t *)&tmp_addr + 8,\n\t\t\t\t     sizeof(tmp_addr) / 2);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (prefix == NULL) {\n\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_addr.s6_addr32[0]);\n\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[1]);\n\t} else {\n\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]), &tmp_addr.s6_addr32[0]);\n\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]), &tmp_addr.s6_addr32[1]);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_EUI_64)) {\n\t\tswitch (lladdr->len) {\n\t\tcase 2:\n\t\t\t/* The generated IPv6 shall not toggle the\n\t\t\t * Universal/Local bit. RFC 6282 ch 3.2.2\n\t\t\t */\n\t\t\tif (lladdr->type == NET_LINK_IEEE802154) {\n\t\t\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[2]);\n\t\t\t\ttmp_addr.s6_addr[11] = 0xff;\n\t\t\t\ttmp_addr.s6_addr[12] = 0xfe;\n\t\t\t\ttmp_addr.s6_addr[13] = 0U;\n\t\t\t\ttmp_addr.s6_addr[14] = lladdr->addr[0];\n\t\t\t\ttmp_addr.s6_addr[15] = lladdr->addr[1];\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t/* We do not toggle the Universal/Local bit\n\t\t\t * in Bluetooth. See RFC 7668 ch 3.2.2\n\t\t\t */\n\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, 3);\n\t\t\ttmp_addr.s6_addr[11] = 0xff;\n\t\t\ttmp_addr.s6_addr[12] = 0xfe;\n\t\t\tmemcpy(&tmp_addr.s6_addr[13], lladdr->addr + 3, 3);\n\n\t\t\tif (lladdr->type == NET_LINK_ETHERNET) {\n\t\t\t\ttmp_addr.s6_addr[8] ^= 0x02;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (sizeof(lladdr->addr) < 8) {\n\t\t\t\tNET_ERR(\"Invalid link layer address length %zu, expecting 8\",\n\t\t\t\t\tsizeof(lladdr->addr));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, lladdr->len);\n\t\t\ttmp_addr.s6_addr[8] ^= 0x02;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tNET_DBG(\"%s IID for iface %d %s\",\n\t\tIS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) ? \"Stable\" : \"EUI-64\",\n\t\tif_index, net_sprint_ipv6_addr(&tmp_addr));\n\n\tmemcpy(addr, &tmp_addr, sizeof(*addr));\n\treturn 0;\n}\n",
                {
                    "960": "int net_ipv6_addr_generate_iid(struct net_if *iface,",
                    "961": "\t\t\t       const struct net_in6_addr *prefix,",
                    "962": "\t\t\t       uint8_t *network_id,",
                    "963": "\t\t\t       size_t network_id_len,",
                    "964": "\t\t\t       uint8_t dad_counter,",
                    "965": "\t\t\t       struct net_in6_addr *addr,",
                    "966": "\t\t\t       struct net_linkaddr *lladdr)",
                    "967": "{",
                    "968": "\tstruct net_in6_addr tmp_addr;",
                    "969": "\tuint8_t if_index;",
                    "970": "",
                    "971": "\tif_index = (iface == NULL) ? net_if_get_by_iface(net_if_get_default())",
                    "972": "\t\t: net_if_get_by_iface(iface);",
                    "973": "",
                    "974": "\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_STABLE)) {",
                    "975": "\t\tstruct net_in6_addr tmp_prefix = { 0 };",
                    "976": "\t\tint ret;",
                    "977": "",
                    "978": "\t\tif (prefix == NULL) {",
                    "979": "\t\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_prefix.s6_addr32[0]);",
                    "980": "\t\t} else {",
                    "981": "\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]),",
                    "982": "\t\t\t\t      &tmp_prefix.s6_addr32[0]);",
                    "983": "\t\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]),",
                    "984": "\t\t\t\t      &tmp_prefix.s6_addr32[1]);",
                    "985": "\t\t}",
                    "986": "",
                    "987": "\t\tret = gen_stable_iid(if_index, &tmp_prefix, network_id, network_id_len,",
                    "988": "\t\t\t\t     dad_counter, (uint8_t *)&tmp_addr + 8,",
                    "989": "\t\t\t\t     sizeof(tmp_addr) / 2);",
                    "990": "\t\tif (ret < 0) {",
                    "991": "\t\t\treturn ret;",
                    "992": "\t\t}",
                    "993": "\t}",
                    "994": "",
                    "995": "\tif (prefix == NULL) {",
                    "996": "\t\tUNALIGNED_PUT(net_htonl(0xfe800000), &tmp_addr.s6_addr32[0]);",
                    "997": "\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[1]);",
                    "998": "\t} else {",
                    "999": "\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[0]), &tmp_addr.s6_addr32[0]);",
                    "1000": "\t\tUNALIGNED_PUT(UNALIGNED_GET(&prefix->s6_addr32[1]), &tmp_addr.s6_addr32[1]);",
                    "1001": "\t}",
                    "1002": "",
                    "1003": "\tif (IS_ENABLED(CONFIG_NET_IPV6_IID_EUI_64)) {",
                    "1004": "\t\tswitch (lladdr->len) {",
                    "1005": "\t\tcase 2:",
                    "1006": "\t\t\t/* The generated IPv6 shall not toggle the",
                    "1007": "\t\t\t * Universal/Local bit. RFC 6282 ch 3.2.2",
                    "1008": "\t\t\t */",
                    "1009": "\t\t\tif (lladdr->type == NET_LINK_IEEE802154) {",
                    "1010": "\t\t\t\tUNALIGNED_PUT(0, &tmp_addr.s6_addr32[2]);",
                    "1011": "\t\t\t\ttmp_addr.s6_addr[11] = 0xff;",
                    "1012": "\t\t\t\ttmp_addr.s6_addr[12] = 0xfe;",
                    "1013": "\t\t\t\ttmp_addr.s6_addr[13] = 0U;",
                    "1014": "\t\t\t\ttmp_addr.s6_addr[14] = lladdr->addr[0];",
                    "1015": "\t\t\t\ttmp_addr.s6_addr[15] = lladdr->addr[1];",
                    "1016": "\t\t\t}",
                    "1017": "",
                    "1018": "\t\t\tbreak;",
                    "1019": "\t\tcase 6:",
                    "1020": "\t\t\t/* We do not toggle the Universal/Local bit",
                    "1021": "\t\t\t * in Bluetooth. See RFC 7668 ch 3.2.2",
                    "1022": "\t\t\t */",
                    "1023": "\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, 3);",
                    "1024": "\t\t\ttmp_addr.s6_addr[11] = 0xff;",
                    "1025": "\t\t\ttmp_addr.s6_addr[12] = 0xfe;",
                    "1026": "\t\t\tmemcpy(&tmp_addr.s6_addr[13], lladdr->addr + 3, 3);",
                    "1027": "",
                    "1028": "\t\t\tif (lladdr->type == NET_LINK_ETHERNET) {",
                    "1029": "\t\t\t\ttmp_addr.s6_addr[8] ^= 0x02;",
                    "1030": "\t\t\t}",
                    "1031": "",
                    "1032": "\t\t\tbreak;",
                    "1033": "\t\tcase 8:",
                    "1034": "\t\t\tif (sizeof(lladdr->addr) < 8) {",
                    "1035": "\t\t\t\tNET_ERR(\"Invalid link layer address length %zu, expecting 8\",",
                    "1036": "\t\t\t\t\tsizeof(lladdr->addr));",
                    "1037": "\t\t\t\treturn -EINVAL;",
                    "1038": "\t\t\t}",
                    "1039": "",
                    "1040": "\t\t\tmemcpy(&tmp_addr.s6_addr[8], lladdr->addr, lladdr->len);",
                    "1041": "\t\t\ttmp_addr.s6_addr[8] ^= 0x02;",
                    "1042": "\t\t\tbreak;",
                    "1043": "\t\t}",
                    "1044": "\t}",
                    "1045": "",
                    "1046": "\tNET_DBG(\"%s IID for iface %d %s\",",
                    "1047": "\t\tIS_ENABLED(CONFIG_NET_IPV6_IID_STABLE) ? \"Stable\" : \"EUI-64\",",
                    "1048": "\t\tif_index, net_sprint_ipv6_addr(&tmp_addr));",
                    "1049": "",
                    "1050": "\tmemcpy(addr, &tmp_addr, sizeof(*addr));",
                    "1051": "\treturn 0;",
                    "1052": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_get_name": {
            "name": "net_if_get_name",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 6304,
            "function_content": [
                "/* If no STA interface is found, return the first WiFi interface */\nint net_if_get_name(struct net_if *iface, char *buf, int len)\n{\n#if defined(CONFIG_NET_INTERFACE_NAME)\n\tint name_len;\n\n\tif (iface == NULL || buf == NULL || len <= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tname_len = strlen(net_if_get_config(iface)->name);\n\tif (name_len >= len) {\n\t\treturn -ERANGE;\n\t}\n\n\t/* Copy string and null terminator */\n\tmemcpy(buf, net_if_get_config(iface)->name, name_len + 1);\n\n\treturn name_len;\n#else\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "6304": "int net_if_get_name(struct net_if *iface, char *buf, int len)",
                    "6305": "{",
                    "6306": "#if defined(CONFIG_NET_INTERFACE_NAME)",
                    "6307": "\tint name_len;",
                    "6308": "",
                    "6309": "\tif (iface == NULL || buf == NULL || len <= 0) {",
                    "6310": "\t\treturn -EINVAL;",
                    "6311": "\t}",
                    "6312": "",
                    "6313": "\tname_len = strlen(net_if_get_config(iface)->name);",
                    "6314": "\tif (name_len >= len) {",
                    "6315": "\t\treturn -ERANGE;",
                    "6316": "\t}",
                    "6317": "",
                    "6318": "\t/* Copy string and null terminator */",
                    "6319": "\tmemcpy(buf, net_if_get_config(iface)->name, name_len + 1);",
                    "6320": "",
                    "6321": "\treturn name_len;",
                    "6322": "#else",
                    "6323": "\treturn -ENOTSUP;",
                    "6324": "#endif",
                    "6325": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_ipv6_addr_lookup_by_iface_raw": {
            "name": "net_if_ipv6_addr_lookup_by_iface_raw",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 1877,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE_IPV6 */\nstruct net_if_addr *net_if_ipv6_addr_lookup_by_iface_raw(struct net_if *iface,\n\t\t\t\t\t\t\t const uint8_t *addr)\n{\n\tstruct net_if_addr *ifaddr = NULL;\n\tstruct net_if_ipv6 *ipv6;\n\n\tnet_if_lock(iface);\n\n\tipv6 = iface->config.ip.ipv6;\n\tif (!ipv6) {\n\t\tgoto out;\n\t}\n\n\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\tif (!ipv6->unicast[i].is_used ||\n\t\t    ipv6->unicast[i].address.family != NET_AF_INET6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ipv6_is_prefix(\n\t\t\t    addr,\n\t\t\t    ipv6->unicast[i].address.in6_addr.s6_addr,\n\t\t\t    128)) {\n\t\t\tifaddr = &ipv6->unicast[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn ifaddr;\n}\n",
                {
                    "1877": "struct net_if_addr *net_if_ipv6_addr_lookup_by_iface_raw(struct net_if *iface,",
                    "1878": "\t\t\t\t\t\t\t const uint8_t *addr)",
                    "1879": "{",
                    "1880": "\tstruct net_if_addr *ifaddr = NULL;",
                    "1881": "\tstruct net_if_ipv6 *ipv6;",
                    "1882": "",
                    "1883": "\tnet_if_lock(iface);",
                    "1884": "",
                    "1885": "\tipv6 = iface->config.ip.ipv6;",
                    "1886": "\tif (!ipv6) {",
                    "1887": "\t\tgoto out;",
                    "1888": "\t}",
                    "1889": "",
                    "1890": "\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "1891": "\t\tif (!ipv6->unicast[i].is_used ||",
                    "1892": "\t\t    ipv6->unicast[i].address.family != NET_AF_INET6) {",
                    "1893": "\t\t\tcontinue;",
                    "1894": "\t\t}",
                    "1895": "",
                    "1896": "\t\tif (net_ipv6_is_prefix(",
                    "1897": "\t\t\t    addr,",
                    "1898": "\t\t\t    ipv6->unicast[i].address.in6_addr.s6_addr,",
                    "1899": "\t\t\t    128)) {",
                    "1900": "\t\t\tifaddr = &ipv6->unicast[i];",
                    "1901": "\t\t\tgoto out;",
                    "1902": "\t\t}",
                    "1903": "\t}",
                    "1904": "",
                    "1905": "out:",
                    "1906": "\tnet_if_unlock(iface);",
                    "1907": "",
                    "1908": "\treturn ifaddr;",
                    "1909": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_addr_ref": {
            "name": "net_if_addr_ref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 5447,
            "function_content": [
                "/* Using the IPv6 address pointer here can give false\n* info if someone adds a new IP address into this position\n* in the address array. This is quite unlikely thou.\n*/\nstruct net_if_addr *net_if_addr_ref(struct net_if *iface,\n\t\t\t\t    net_sa_family_t family,\n\t\t\t\t    const void *addr)\n#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\n{\n\tstruct net_if_addr *ifaddr;\n\tatomic_val_t ref;\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tchar addr_str[IS_ENABLED(CONFIG_NET_IPV6) ?\n\t\t      NET_INET6_ADDRSTRLEN : NET_INET_ADDRSTRLEN];\n\n\t__ASSERT(iface, \"iface is NULL (%s():%d)\", caller, line);\n#endif\n\n\tifaddr = get_ifaddr(iface, family, addr, NULL);\n\n\tdo {\n\t\tref = ifaddr ? atomic_get(&ifaddr->atomic_ref) : 0;\n\t\tif (!ref) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\t\tNET_ERR(\"iface %d addr %s (%s():%d)\",\n\t\t\t\tnet_if_get_by_iface(iface),\n\t\t\t\tnet_addr_ntop(family,\n\t\t\t\t\t      addr,\n\t\t\t\t\t      addr_str, sizeof(addr_str)),\n\t\t\t\tcaller, line);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t} while (!atomic_cas(&ifaddr->atomic_ref, ref, ref + 1));\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"[%d] ifaddr %s state %d ref %ld (%s():%d)\",\n\t\tnet_if_get_by_iface(iface),\n\t\tnet_addr_ntop(ifaddr->address.family,\n\t\t\t      (void *)&ifaddr->address.in_addr,\n\t\t\t      addr_str, sizeof(addr_str)),\n\t\tifaddr->addr_state,\n\t\tref + 1,\n\t\tcaller, line);\n#endif\n\n\treturn ifaddr;\n}\n",
                {
                    "5447": "struct net_if_addr *net_if_addr_ref(struct net_if *iface,",
                    "5448": "\t\t\t\t    net_sa_family_t family,",
                    "5449": "\t\t\t\t    const void *addr)",
                    "5450": "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */",
                    "5451": "{",
                    "5452": "\tstruct net_if_addr *ifaddr;",
                    "5453": "\tatomic_val_t ref;",
                    "5454": "",
                    "5455": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5456": "\tchar addr_str[IS_ENABLED(CONFIG_NET_IPV6) ?",
                    "5457": "\t\t      NET_INET6_ADDRSTRLEN : NET_INET_ADDRSTRLEN];",
                    "5458": "",
                    "5459": "\t__ASSERT(iface, \"iface is NULL (%s():%d)\", caller, line);",
                    "5460": "#endif",
                    "5461": "",
                    "5462": "\tifaddr = get_ifaddr(iface, family, addr, NULL);",
                    "5463": "",
                    "5464": "\tdo {",
                    "5465": "\t\tref = ifaddr ? atomic_get(&ifaddr->atomic_ref) : 0;",
                    "5466": "\t\tif (!ref) {",
                    "5467": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5468": "\t\t\tNET_ERR(\"iface %d addr %s (%s():%d)\",",
                    "5469": "\t\t\t\tnet_if_get_by_iface(iface),",
                    "5470": "\t\t\t\tnet_addr_ntop(family,",
                    "5471": "\t\t\t\t\t      addr,",
                    "5472": "\t\t\t\t\t      addr_str, sizeof(addr_str)),",
                    "5473": "\t\t\t\tcaller, line);",
                    "5474": "#endif",
                    "5475": "\t\t\treturn NULL;",
                    "5476": "\t\t}",
                    "5477": "\t} while (!atomic_cas(&ifaddr->atomic_ref, ref, ref + 1));",
                    "5478": "",
                    "5479": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5480": "\tNET_DBG(\"[%d] ifaddr %s state %d ref %ld (%s():%d)\",",
                    "5481": "\t\tnet_if_get_by_iface(iface),",
                    "5482": "\t\tnet_addr_ntop(ifaddr->address.family,",
                    "5483": "\t\t\t      (void *)&ifaddr->address.in_addr,",
                    "5484": "\t\t\t      addr_str, sizeof(addr_str)),",
                    "5485": "\t\tifaddr->addr_state,",
                    "5486": "\t\tref + 1,",
                    "5487": "\t\tcaller, line);",
                    "5488": "#endif",
                    "5489": "",
                    "5490": "\treturn ifaddr;",
                    "5491": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_addr_unref": {
            "name": "net_if_addr_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 5500,
            "function_content": [
                "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\nint net_if_addr_unref(struct net_if *iface,\n\t\t      net_sa_family_t family,\n\t\t      const void *addr,\n\t\t      struct net_if_addr **ret_ifaddr)\n#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */\n{\n\tstruct net_if_addr *ifaddr;\n\tunsigned int maddr_count = 0;\n\tatomic_val_t ref;\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tchar addr_str[IS_ENABLED(CONFIG_NET_IPV6) ?\n\t\t      NET_INET6_ADDRSTRLEN : NET_INET_ADDRSTRLEN];\n\n\t__ASSERT(iface, \"iface is NULL (%s():%d)\", caller, line);\n#endif\n\n\tifaddr = get_ifaddr(iface, family, addr, &maddr_count);\n\n\tif (!ifaddr) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\tNET_ERR(\"iface %d addr %s (%s():%d)\",\n\t\t\tnet_if_get_by_iface(iface),\n\t\t\tnet_addr_ntop(family,\n\t\t\t\t      addr,\n\t\t\t\t      addr_str, sizeof(addr_str)),\n\t\t\tcaller, line);\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tref = atomic_get(&ifaddr->atomic_ref);\n\t\tif (!ref) {\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\t\t\tNET_ERR(\"*** ERROR *** iface %d ifaddr %p \"\n\t\t\t\t\"is freed already (%s():%d)\",\n\t\t\t\tnet_if_get_by_iface(iface),\n\t\t\t\tifaddr,\n\t\t\t\tcaller, line);\n#endif\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} while (!atomic_cas(&ifaddr->atomic_ref, ref, ref - 1));\n\n#if NET_LOG_LEVEL >= LOG_LEVEL_DBG\n\tNET_DBG(\"[%d] ifaddr %s state %d ref %ld (%s():%d)\",\n\t\tnet_if_get_by_iface(iface),\n\t\tnet_addr_ntop(ifaddr->address.family,\n\t\t\t      (void *)&ifaddr->address.in_addr,\n\t\t\t      addr_str, sizeof(addr_str)),\n\t\tifaddr->addr_state,\n\t\tref - 1, caller, line);\n#endif\n\n\tif (ref > 1) {\n\t\tif (ret_ifaddr) {\n\t\t\t*ret_ifaddr = ifaddr;\n\t\t}\n\n\t\treturn ref - 1;\n\t}\n\n\tifaddr->is_used = false;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 && addr != NULL) {\n\t\tremove_ipv6_ifaddr(iface, ifaddr, maddr_count);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET && addr != NULL) {\n\t\tremove_ipv4_ifaddr(iface, ifaddr);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "5500": "int net_if_addr_unref(struct net_if *iface,",
                    "5501": "\t\t      net_sa_family_t family,",
                    "5502": "\t\t      const void *addr,",
                    "5503": "\t\t      struct net_if_addr **ret_ifaddr)",
                    "5504": "#endif /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */",
                    "5505": "{",
                    "5506": "\tstruct net_if_addr *ifaddr;",
                    "5507": "\tunsigned int maddr_count = 0;",
                    "5508": "\tatomic_val_t ref;",
                    "5509": "",
                    "5510": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5511": "\tchar addr_str[IS_ENABLED(CONFIG_NET_IPV6) ?",
                    "5512": "\t\t      NET_INET6_ADDRSTRLEN : NET_INET_ADDRSTRLEN];",
                    "5513": "",
                    "5514": "\t__ASSERT(iface, \"iface is NULL (%s():%d)\", caller, line);",
                    "5515": "#endif",
                    "5516": "",
                    "5517": "\tifaddr = get_ifaddr(iface, family, addr, &maddr_count);",
                    "5518": "",
                    "5519": "\tif (!ifaddr) {",
                    "5520": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5521": "\t\tNET_ERR(\"iface %d addr %s (%s():%d)\",",
                    "5522": "\t\t\tnet_if_get_by_iface(iface),",
                    "5523": "\t\t\tnet_addr_ntop(family,",
                    "5524": "\t\t\t\t      addr,",
                    "5525": "\t\t\t\t      addr_str, sizeof(addr_str)),",
                    "5526": "\t\t\tcaller, line);",
                    "5527": "#endif",
                    "5528": "\t\treturn -EINVAL;",
                    "5529": "\t}",
                    "5530": "",
                    "5531": "\tdo {",
                    "5532": "\t\tref = atomic_get(&ifaddr->atomic_ref);",
                    "5533": "\t\tif (!ref) {",
                    "5534": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5535": "\t\t\tNET_ERR(\"*** ERROR *** iface %d ifaddr %p \"",
                    "5536": "\t\t\t\t\"is freed already (%s():%d)\",",
                    "5537": "\t\t\t\tnet_if_get_by_iface(iface),",
                    "5538": "\t\t\t\tifaddr,",
                    "5539": "\t\t\t\tcaller, line);",
                    "5540": "#endif",
                    "5541": "\t\t\treturn -EINVAL;",
                    "5542": "\t\t}",
                    "5543": "",
                    "5544": "\t} while (!atomic_cas(&ifaddr->atomic_ref, ref, ref - 1));",
                    "5545": "",
                    "5546": "#if NET_LOG_LEVEL >= LOG_LEVEL_DBG",
                    "5547": "\tNET_DBG(\"[%d] ifaddr %s state %d ref %ld (%s():%d)\",",
                    "5548": "\t\tnet_if_get_by_iface(iface),",
                    "5549": "\t\tnet_addr_ntop(ifaddr->address.family,",
                    "5550": "\t\t\t      (void *)&ifaddr->address.in_addr,",
                    "5551": "\t\t\t      addr_str, sizeof(addr_str)),",
                    "5552": "\t\tifaddr->addr_state,",
                    "5553": "\t\tref - 1, caller, line);",
                    "5554": "#endif",
                    "5555": "",
                    "5556": "\tif (ref > 1) {",
                    "5557": "\t\tif (ret_ifaddr) {",
                    "5558": "\t\t\t*ret_ifaddr = ifaddr;",
                    "5559": "\t\t}",
                    "5560": "",
                    "5561": "\t\treturn ref - 1;",
                    "5562": "\t}",
                    "5563": "",
                    "5564": "\tifaddr->is_used = false;",
                    "5565": "",
                    "5566": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 && addr != NULL) {",
                    "5567": "\t\tremove_ipv6_ifaddr(iface, ifaddr, maddr_count);",
                    "5568": "\t}",
                    "5569": "",
                    "5570": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET && addr != NULL) {",
                    "5571": "\t\tremove_ipv4_ifaddr(iface, ifaddr);",
                    "5572": "\t}",
                    "5573": "",
                    "5574": "\treturn 0;",
                    "5575": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_if_set_link_addr_locked": {
            "name": "net_if_set_link_addr_locked",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 563,
            "function_content": [
                "#endif /* CONFIG_NET_NATIVE */\nint net_if_set_link_addr_locked(struct net_if *iface,\n\t\t\t\tuint8_t *addr, uint8_t len,\n\t\t\t\tenum net_link_type type)\n{\n\tint ret;\n\n\tnet_if_lock(iface);\n\n\tret = net_if_set_link_addr_unlocked(iface, addr, len, type);\n\n\tnet_if_unlock(iface);\n\n\treturn ret;\n}\n",
                {
                    "563": "int net_if_set_link_addr_locked(struct net_if *iface,",
                    "564": "\t\t\t\tuint8_t *addr, uint8_t len,",
                    "565": "\t\t\t\tenum net_link_type type)",
                    "566": "{",
                    "567": "\tint ret;",
                    "568": "",
                    "569": "\tnet_if_lock(iface);",
                    "570": "",
                    "571": "\tret = net_if_set_link_addr_unlocked(iface, addr, len, type);",
                    "572": "",
                    "573": "\tnet_if_unlock(iface);",
                    "574": "",
                    "575": "\treturn ret;",
                    "576": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_get_option": {
            "name": "net_context_get_option",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 4031,
            "function_content": [
                "/* IPv4 only supports getting the MTU */\nint net_context_get_option(struct net_context *context,\n\t\t\t    enum net_context_option option,\n\t\t\t    void *value, uint32_t *len)\n{\n\tint ret = 0;\n\n\tNET_ASSERT(context);\n\n\tif (!PART_OF_ARRAY(contexts, context)) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\tswitch (option) {\n\tcase NET_OPT_PRIORITY:\n\t\tret = get_context_priority(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TXTIME:\n\t\tret = get_context_txtime(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SOCKS5:\n\t\tret = get_context_proxy(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RCVTIMEO:\n\t\tret = get_context_rcvtimeo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SNDTIMEO:\n\t\tret = get_context_sndtimeo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RCVBUF:\n\t\tret = get_context_rcvbuf(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SNDBUF:\n\t\tret = get_context_sndbuf(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_DSCP_ECN:\n\t\tret = get_context_dscp_ecn(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TTL:\n\t\tret = get_context_ttl(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MCAST_TTL:\n\t\tret = get_context_mcast_ttl(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MCAST_HOP_LIMIT:\n\t\tret = get_context_mcast_hop_limit(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_UNICAST_HOP_LIMIT:\n\t\tret = get_context_unicast_hop_limit(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_REUSEADDR:\n\t\tret = get_context_reuseaddr(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_REUSEPORT:\n\t\tret = get_context_reuseport(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV6_V6ONLY:\n\t\tret = get_context_ipv6_v6only(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RECV_PKTINFO:\n\t\tret = get_context_recv_pktinfo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_ADDR_PREFERENCES:\n\t\tret = get_context_addr_preferences(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TIMESTAMPING:\n\t\tret = get_context_timestamping(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MTU:\n\t\tret = get_context_mtu(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MCAST_IFINDEX:\n\t\tret = get_context_mcast_ifindex(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_LOCAL_PORT_RANGE:\n\t\tret = get_context_local_port_range(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV6_MCAST_LOOP:\n\t\tret = get_context_ipv6_mcast_loop(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV4_MCAST_LOOP:\n\t\tret = get_context_ipv4_mcast_loop(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RECV_HOPLIMIT:\n\t\tret = get_context_recv_hoplimit(context, value, len);\n\t\tbreak;\n\t}\n\n\tk_mutex_unlock(&context->lock);\n\n\treturn ret;\n}\n",
                {
                    "4031": "int net_context_get_option(struct net_context *context,",
                    "4032": "\t\t\t    enum net_context_option option,",
                    "4033": "\t\t\t    void *value, uint32_t *len)",
                    "4034": "{",
                    "4035": "\tint ret = 0;",
                    "4036": "",
                    "4037": "\tNET_ASSERT(context);",
                    "4038": "",
                    "4039": "\tif (!PART_OF_ARRAY(contexts, context)) {",
                    "4040": "\t\treturn -EINVAL;",
                    "4041": "\t}",
                    "4042": "",
                    "4043": "\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "4044": "",
                    "4045": "\tswitch (option) {",
                    "4046": "\tcase NET_OPT_PRIORITY:",
                    "4047": "\t\tret = get_context_priority(context, value, len);",
                    "4048": "\t\tbreak;",
                    "4049": "\tcase NET_OPT_TXTIME:",
                    "4050": "\t\tret = get_context_txtime(context, value, len);",
                    "4051": "\t\tbreak;",
                    "4052": "\tcase NET_OPT_SOCKS5:",
                    "4053": "\t\tret = get_context_proxy(context, value, len);",
                    "4054": "\t\tbreak;",
                    "4055": "\tcase NET_OPT_RCVTIMEO:",
                    "4056": "\t\tret = get_context_rcvtimeo(context, value, len);",
                    "4057": "\t\tbreak;",
                    "4058": "\tcase NET_OPT_SNDTIMEO:",
                    "4059": "\t\tret = get_context_sndtimeo(context, value, len);",
                    "4060": "\t\tbreak;",
                    "4061": "\tcase NET_OPT_RCVBUF:",
                    "4062": "\t\tret = get_context_rcvbuf(context, value, len);",
                    "4063": "\t\tbreak;",
                    "4064": "\tcase NET_OPT_SNDBUF:",
                    "4065": "\t\tret = get_context_sndbuf(context, value, len);",
                    "4066": "\t\tbreak;",
                    "4067": "\tcase NET_OPT_DSCP_ECN:",
                    "4068": "\t\tret = get_context_dscp_ecn(context, value, len);",
                    "4069": "\t\tbreak;",
                    "4070": "\tcase NET_OPT_TTL:",
                    "4071": "\t\tret = get_context_ttl(context, value, len);",
                    "4072": "\t\tbreak;",
                    "4073": "\tcase NET_OPT_MCAST_TTL:",
                    "4074": "\t\tret = get_context_mcast_ttl(context, value, len);",
                    "4075": "\t\tbreak;",
                    "4076": "\tcase NET_OPT_MCAST_HOP_LIMIT:",
                    "4077": "\t\tret = get_context_mcast_hop_limit(context, value, len);",
                    "4078": "\t\tbreak;",
                    "4079": "\tcase NET_OPT_UNICAST_HOP_LIMIT:",
                    "4080": "\t\tret = get_context_unicast_hop_limit(context, value, len);",
                    "4081": "\t\tbreak;",
                    "4082": "\tcase NET_OPT_REUSEADDR:",
                    "4083": "\t\tret = get_context_reuseaddr(context, value, len);",
                    "4084": "\t\tbreak;",
                    "4085": "\tcase NET_OPT_REUSEPORT:",
                    "4086": "\t\tret = get_context_reuseport(context, value, len);",
                    "4087": "\t\tbreak;",
                    "4088": "\tcase NET_OPT_IPV6_V6ONLY:",
                    "4089": "\t\tret = get_context_ipv6_v6only(context, value, len);",
                    "4090": "\t\tbreak;",
                    "4091": "\tcase NET_OPT_RECV_PKTINFO:",
                    "4092": "\t\tret = get_context_recv_pktinfo(context, value, len);",
                    "4093": "\t\tbreak;",
                    "4094": "\tcase NET_OPT_ADDR_PREFERENCES:",
                    "4095": "\t\tret = get_context_addr_preferences(context, value, len);",
                    "4096": "\t\tbreak;",
                    "4097": "\tcase NET_OPT_TIMESTAMPING:",
                    "4098": "\t\tret = get_context_timestamping(context, value, len);",
                    "4099": "\t\tbreak;",
                    "4100": "\tcase NET_OPT_MTU:",
                    "4101": "\t\tret = get_context_mtu(context, value, len);",
                    "4102": "\t\tbreak;",
                    "4103": "\tcase NET_OPT_MCAST_IFINDEX:",
                    "4104": "\t\tret = get_context_mcast_ifindex(context, value, len);",
                    "4105": "\t\tbreak;",
                    "4106": "\tcase NET_OPT_LOCAL_PORT_RANGE:",
                    "4107": "\t\tret = get_context_local_port_range(context, value, len);",
                    "4108": "\t\tbreak;",
                    "4109": "\tcase NET_OPT_IPV6_MCAST_LOOP:",
                    "4110": "\t\tret = get_context_ipv6_mcast_loop(context, value, len);",
                    "4111": "\t\tbreak;",
                    "4112": "\tcase NET_OPT_IPV4_MCAST_LOOP:",
                    "4113": "\t\tret = get_context_ipv4_mcast_loop(context, value, len);",
                    "4114": "\t\tbreak;",
                    "4115": "\tcase NET_OPT_RECV_HOPLIMIT:",
                    "4116": "\t\tret = get_context_recv_hoplimit(context, value, len);",
                    "4117": "\t\tbreak;",
                    "4118": "\t}",
                    "4119": "",
                    "4120": "\tk_mutex_unlock(&context->lock);",
                    "4121": "",
                    "4122": "\treturn ret;",
                    "4123": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_set_option": {
            "name": "net_context_set_option",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3929,
            "function_content": [
                "/* If either of the range is 0, then that bound has no effect.\n* This is checked when the emphemeral port is selected.\n*/\nint net_context_set_option(struct net_context *context,\n\t\t\t   enum net_context_option option,\n\t\t\t   const void *value, uint32_t len)\n{\n\tint ret = 0;\n\n\tNET_ASSERT(context);\n\n\tif (!PART_OF_ARRAY(contexts, context)) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\tswitch (option) {\n\tcase NET_OPT_PRIORITY:\n\t\tret = set_context_priority(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TXTIME:\n\t\tret = set_context_txtime(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SOCKS5:\n\t\tret = set_context_proxy(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RCVTIMEO:\n\t\tret = set_context_rcvtimeo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SNDTIMEO:\n\t\tret = set_context_sndtimeo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RCVBUF:\n\t\tret = set_context_rcvbuf(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_SNDBUF:\n\t\tret = set_context_sndbuf(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_DSCP_ECN:\n\t\tret = set_context_dscp_ecn(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TTL:\n\t\tret = set_context_ttl(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MCAST_TTL:\n\t\tret = set_context_mcast_ttl(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MCAST_HOP_LIMIT:\n\t\tret = set_context_mcast_hop_limit(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_UNICAST_HOP_LIMIT:\n\t\tret = set_context_unicast_hop_limit(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_REUSEADDR:\n\t\tret = set_context_reuseaddr(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_REUSEPORT:\n\t\tret = set_context_reuseport(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV6_V6ONLY:\n\t\tret = set_context_ipv6_v6only(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RECV_PKTINFO:\n\t\tret = set_context_recv_pktinfo(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_ADDR_PREFERENCES:\n\t\tret = set_context_addr_preferences(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_TIMESTAMPING:\n\t\tret = set_context_timestamping(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_MTU:\n\t\t/* IPv4 only supports getting the MTU */\n\t\tif (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t    net_context_get_family(context) == NET_AF_INET) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t\t   net_context_get_family(context) == NET_AF_INET6) {\n\t\t\tret = set_context_ipv6_mtu(context, value, len);\n\t\t}\n\n\t\tbreak;\n\tcase NET_OPT_MCAST_IFINDEX:\n\t\tret = set_context_mcast_ifindex(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_LOCAL_PORT_RANGE:\n\t\tret = set_context_local_port_range(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV6_MCAST_LOOP:\n\t\tret = set_context_ipv6_mcast_loop(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_IPV4_MCAST_LOOP:\n\t\tret = set_context_ipv4_mcast_loop(context, value, len);\n\t\tbreak;\n\tcase NET_OPT_RECV_HOPLIMIT:\n\t\tret = set_context_recv_hoplimit(context, value, len);\n\t\tbreak;\n\t}\n\n\tk_mutex_unlock(&context->lock);\n\n\treturn ret;\n}\n",
                {
                    "3929": "int net_context_set_option(struct net_context *context,",
                    "3930": "\t\t\t   enum net_context_option option,",
                    "3931": "\t\t\t   const void *value, uint32_t len)",
                    "3932": "{",
                    "3933": "\tint ret = 0;",
                    "3934": "",
                    "3935": "\tNET_ASSERT(context);",
                    "3936": "",
                    "3937": "\tif (!PART_OF_ARRAY(contexts, context)) {",
                    "3938": "\t\treturn -EINVAL;",
                    "3939": "\t}",
                    "3940": "",
                    "3941": "\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "3942": "",
                    "3943": "\tswitch (option) {",
                    "3944": "\tcase NET_OPT_PRIORITY:",
                    "3945": "\t\tret = set_context_priority(context, value, len);",
                    "3946": "\t\tbreak;",
                    "3947": "\tcase NET_OPT_TXTIME:",
                    "3948": "\t\tret = set_context_txtime(context, value, len);",
                    "3949": "\t\tbreak;",
                    "3950": "\tcase NET_OPT_SOCKS5:",
                    "3951": "\t\tret = set_context_proxy(context, value, len);",
                    "3952": "\t\tbreak;",
                    "3953": "\tcase NET_OPT_RCVTIMEO:",
                    "3954": "\t\tret = set_context_rcvtimeo(context, value, len);",
                    "3955": "\t\tbreak;",
                    "3956": "\tcase NET_OPT_SNDTIMEO:",
                    "3957": "\t\tret = set_context_sndtimeo(context, value, len);",
                    "3958": "\t\tbreak;",
                    "3959": "\tcase NET_OPT_RCVBUF:",
                    "3960": "\t\tret = set_context_rcvbuf(context, value, len);",
                    "3961": "\t\tbreak;",
                    "3962": "\tcase NET_OPT_SNDBUF:",
                    "3963": "\t\tret = set_context_sndbuf(context, value, len);",
                    "3964": "\t\tbreak;",
                    "3965": "\tcase NET_OPT_DSCP_ECN:",
                    "3966": "\t\tret = set_context_dscp_ecn(context, value, len);",
                    "3967": "\t\tbreak;",
                    "3968": "\tcase NET_OPT_TTL:",
                    "3969": "\t\tret = set_context_ttl(context, value, len);",
                    "3970": "\t\tbreak;",
                    "3971": "\tcase NET_OPT_MCAST_TTL:",
                    "3972": "\t\tret = set_context_mcast_ttl(context, value, len);",
                    "3973": "\t\tbreak;",
                    "3974": "\tcase NET_OPT_MCAST_HOP_LIMIT:",
                    "3975": "\t\tret = set_context_mcast_hop_limit(context, value, len);",
                    "3976": "\t\tbreak;",
                    "3977": "\tcase NET_OPT_UNICAST_HOP_LIMIT:",
                    "3978": "\t\tret = set_context_unicast_hop_limit(context, value, len);",
                    "3979": "\t\tbreak;",
                    "3980": "\tcase NET_OPT_REUSEADDR:",
                    "3981": "\t\tret = set_context_reuseaddr(context, value, len);",
                    "3982": "\t\tbreak;",
                    "3983": "\tcase NET_OPT_REUSEPORT:",
                    "3984": "\t\tret = set_context_reuseport(context, value, len);",
                    "3985": "\t\tbreak;",
                    "3986": "\tcase NET_OPT_IPV6_V6ONLY:",
                    "3987": "\t\tret = set_context_ipv6_v6only(context, value, len);",
                    "3988": "\t\tbreak;",
                    "3989": "\tcase NET_OPT_RECV_PKTINFO:",
                    "3990": "\t\tret = set_context_recv_pktinfo(context, value, len);",
                    "3991": "\t\tbreak;",
                    "3992": "\tcase NET_OPT_ADDR_PREFERENCES:",
                    "3993": "\t\tret = set_context_addr_preferences(context, value, len);",
                    "3994": "\t\tbreak;",
                    "3995": "\tcase NET_OPT_TIMESTAMPING:",
                    "3996": "\t\tret = set_context_timestamping(context, value, len);",
                    "3997": "\t\tbreak;",
                    "3998": "\tcase NET_OPT_MTU:",
                    "3999": "\t\t/* IPv4 only supports getting the MTU */",
                    "4000": "\t\tif (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "4001": "\t\t    net_context_get_family(context) == NET_AF_INET) {",
                    "4002": "\t\t\tret = -EOPNOTSUPP;",
                    "4003": "\t\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "4004": "\t\t\t   net_context_get_family(context) == NET_AF_INET6) {",
                    "4005": "\t\t\tret = set_context_ipv6_mtu(context, value, len);",
                    "4006": "\t\t}",
                    "4007": "",
                    "4008": "\t\tbreak;",
                    "4009": "\tcase NET_OPT_MCAST_IFINDEX:",
                    "4010": "\t\tret = set_context_mcast_ifindex(context, value, len);",
                    "4011": "\t\tbreak;",
                    "4012": "\tcase NET_OPT_LOCAL_PORT_RANGE:",
                    "4013": "\t\tret = set_context_local_port_range(context, value, len);",
                    "4014": "\t\tbreak;",
                    "4015": "\tcase NET_OPT_IPV6_MCAST_LOOP:",
                    "4016": "\t\tret = set_context_ipv6_mcast_loop(context, value, len);",
                    "4017": "\t\tbreak;",
                    "4018": "\tcase NET_OPT_IPV4_MCAST_LOOP:",
                    "4019": "\t\tret = set_context_ipv4_mcast_loop(context, value, len);",
                    "4020": "\t\tbreak;",
                    "4021": "\tcase NET_OPT_RECV_HOPLIMIT:",
                    "4022": "\t\tret = set_context_recv_hoplimit(context, value, len);",
                    "4023": "\t\tbreak;",
                    "4024": "\t}",
                    "4025": "",
                    "4026": "\tk_mutex_unlock(&context->lock);",
                    "4027": "",
                    "4028": "\treturn ret;",
                    "4029": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_sendto": {
            "name": "net_context_sendto",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2984,
            "function_content": [
                "/* The destination address is set in remote for this\n* socket type.\n*/\nint net_context_sendto(struct net_context *context,\n\t\t       const void *buf,\n\t\t       size_t len,\n\t\t       const struct net_sockaddr *dst_addr,\n\t\t       net_socklen_t addrlen,\n\t\t       net_context_send_cb_t cb,\n\t\t       k_timeout_t timeout,\n\t\t       void *user_data)\n{\n\tint ret;\n\n\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\tret = context_sendto(context, buf, len, dst_addr, addrlen,\n\t\t\t     cb, timeout, user_data, true);\n\n\tk_mutex_unlock(&context->lock);\n\n\treturn ret;\n}\n",
                {
                    "2984": "int net_context_sendto(struct net_context *context,",
                    "2985": "\t\t       const void *buf,",
                    "2986": "\t\t       size_t len,",
                    "2987": "\t\t       const struct net_sockaddr *dst_addr,",
                    "2988": "\t\t       net_socklen_t addrlen,",
                    "2989": "\t\t       net_context_send_cb_t cb,",
                    "2990": "\t\t       k_timeout_t timeout,",
                    "2991": "\t\t       void *user_data)",
                    "2992": "{",
                    "2993": "\tint ret;",
                    "2994": "",
                    "2995": "\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "2996": "",
                    "2997": "\tret = context_sendto(context, buf, len, dst_addr, addrlen,",
                    "2998": "\t\t\t     cb, timeout, user_data, true);",
                    "2999": "",
                    "3000": "\tk_mutex_unlock(&context->lock);",
                    "3001": "",
                    "3002": "\treturn ret;",
                    "3003": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_context_send": {
            "name": "net_context_send",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2909,
            "function_content": [
                "/* The destination address is set in remote for this\n* socket type.\n*/\nint net_context_send(struct net_context *context,\n\t\t     const void *buf,\n\t\t     size_t len,\n\t\t     net_context_send_cb_t cb,\n\t\t     k_timeout_t timeout,\n\t\t     void *user_data)\n{\n\tbool dst_check = true;\n\tnet_socklen_t addrlen;\n\tint ret = 0;\n\n\tk_mutex_lock(&context->lock, K_FOREVER);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_context_get_family(context) == NET_AF_INET6) {\n\t\taddrlen = sizeof(struct net_sockaddr_in6);\n\t\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&\n\t\t    net_context_get_type(context) == NET_SOCK_RAW) {\n\t\t\traw_inet_set_remote(context, buf, len);\n\t\t\tdst_check = false;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t   net_context_get_family(context) == NET_AF_INET) {\n\t\taddrlen = sizeof(struct net_sockaddr_in);\n\t\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&\n\t\t    net_context_get_type(context) == NET_SOCK_RAW) {\n\t\t\traw_inet_set_remote(context, buf, len);\n\t\t\tdst_check = false;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&\n\t\t   net_context_get_family(context) == NET_AF_PACKET) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&\n\t\t   net_context_get_family(context) == NET_AF_CAN) {\n\t\taddrlen = sizeof(struct net_sockaddr_can);\n\t} else {\n\t\taddrlen = 0;\n\t}\n\n\tif (dst_check) {\n\t\tif (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||\n\t\t    net_sin(&context->remote)->sin_port == 0) {\n\t\t\tret = -EDESTADDRREQ;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = context_sendto(context, buf, len, &context->remote,\n\t\t\t     addrlen, cb, timeout, user_data, false);\nunlock:\n\tk_mutex_unlock(&context->lock);\n\n\treturn ret;\n}\n",
                {
                    "2909": "int net_context_send(struct net_context *context,",
                    "2910": "\t\t     const void *buf,",
                    "2911": "\t\t     size_t len,",
                    "2912": "\t\t     net_context_send_cb_t cb,",
                    "2913": "\t\t     k_timeout_t timeout,",
                    "2914": "\t\t     void *user_data)",
                    "2915": "{",
                    "2916": "\tbool dst_check = true;",
                    "2917": "\tnet_socklen_t addrlen;",
                    "2918": "\tint ret = 0;",
                    "2919": "",
                    "2920": "\tk_mutex_lock(&context->lock, K_FOREVER);",
                    "2921": "",
                    "2922": "\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "2923": "\t    net_context_get_family(context) == NET_AF_INET6) {",
                    "2924": "\t\taddrlen = sizeof(struct net_sockaddr_in6);",
                    "2925": "\t\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&",
                    "2926": "\t\t    net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2927": "\t\t\traw_inet_set_remote(context, buf, len);",
                    "2928": "\t\t\tdst_check = false;",
                    "2929": "\t\t}",
                    "2930": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "2931": "\t\t   net_context_get_family(context) == NET_AF_INET) {",
                    "2932": "\t\taddrlen = sizeof(struct net_sockaddr_in);",
                    "2933": "\t\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&",
                    "2934": "\t\t    net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2935": "\t\t\traw_inet_set_remote(context, buf, len);",
                    "2936": "\t\t\tdst_check = false;",
                    "2937": "\t\t}",
                    "2938": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&",
                    "2939": "\t\t   net_context_get_family(context) == NET_AF_PACKET) {",
                    "2940": "\t\tret = -EOPNOTSUPP;",
                    "2941": "\t\tgoto unlock;",
                    "2942": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&",
                    "2943": "\t\t   net_context_get_family(context) == NET_AF_CAN) {",
                    "2944": "\t\taddrlen = sizeof(struct net_sockaddr_can);",
                    "2945": "\t} else {",
                    "2946": "\t\taddrlen = 0;",
                    "2947": "\t}",
                    "2948": "",
                    "2949": "\tif (dst_check) {",
                    "2950": "\t\tif (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||",
                    "2951": "\t\t    net_sin(&context->remote)->sin_port == 0) {",
                    "2952": "\t\t\tret = -EDESTADDRREQ;",
                    "2953": "\t\t\tgoto unlock;",
                    "2954": "\t\t}",
                    "2955": "\t}",
                    "2956": "",
                    "2957": "\tret = context_sendto(context, buf, len, &context->remote,",
                    "2958": "\t\t\t     addrlen, cb, timeout, user_data, false);",
                    "2959": "unlock:",
                    "2960": "\tk_mutex_unlock(&context->lock);",
                    "2961": "",
                    "2962": "\treturn ret;",
                    "2963": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_set_data": {
            "name": "net_pkt_set_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2351,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_set_data(struct net_pkt *pkt,\n\t\t     struct net_pkt_data_access *access)\n{\n\tif (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {\n\t\treturn net_pkt_skip(pkt, access->size);\n\t}\n\n\treturn net_pkt_write(pkt, access->data, access->size);\n}\n",
                {
                    "2351": "int net_pkt_set_data(struct net_pkt *pkt,",
                    "2352": "\t\t     struct net_pkt_data_access *access)",
                    "2353": "{",
                    "2354": "\tif (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {",
                    "2355": "\t\treturn net_pkt_skip(pkt, access->size);",
                    "2356": "\t}",
                    "2357": "",
                    "2358": "\treturn net_pkt_write(pkt, access->data, access->size);",
                    "2359": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_get_data": {
            "name": "net_pkt_get_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2314,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nvoid *net_pkt_get_data(struct net_pkt *pkt,\n\t\t       struct net_pkt_data_access *access)\n{\n\tif (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {\n\t\tif (!net_pkt_is_contiguous(pkt, access->size)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn pkt->cursor.pos;\n\t} else {\n\t\tif (net_pkt_is_contiguous(pkt, access->size)) {\n\t\t\taccess->data = pkt->cursor.pos;\n\t\t} else if (net_pkt_is_being_overwritten(pkt)) {\n\t\t\tstruct net_pkt_cursor backup;\n\n\t\t\tif (!access->data) {\n\t\t\t\tNET_ERR(\"Uncontiguous data\"\n\t\t\t\t\t\" cannot be linearized\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tnet_pkt_cursor_backup(pkt, &backup);\n\n\t\t\tif (net_pkt_read(pkt, access->data, access->size)) {\n\t\t\t\tnet_pkt_cursor_restore(pkt, &backup);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tnet_pkt_cursor_restore(pkt, &backup);\n\t\t}\n\n\t\treturn access->data;\n\t}\n\n\treturn NULL;\n}\n",
                {
                    "2314": "void *net_pkt_get_data(struct net_pkt *pkt,",
                    "2315": "\t\t       struct net_pkt_data_access *access)",
                    "2316": "{",
                    "2317": "\tif (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {",
                    "2318": "\t\tif (!net_pkt_is_contiguous(pkt, access->size)) {",
                    "2319": "\t\t\treturn NULL;",
                    "2320": "\t\t}",
                    "2321": "",
                    "2322": "\t\treturn pkt->cursor.pos;",
                    "2323": "\t} else {",
                    "2324": "\t\tif (net_pkt_is_contiguous(pkt, access->size)) {",
                    "2325": "\t\t\taccess->data = pkt->cursor.pos;",
                    "2326": "\t\t} else if (net_pkt_is_being_overwritten(pkt)) {",
                    "2327": "\t\t\tstruct net_pkt_cursor backup;",
                    "2328": "",
                    "2329": "\t\t\tif (!access->data) {",
                    "2330": "\t\t\t\tNET_ERR(\"Uncontiguous data\"",
                    "2331": "\t\t\t\t\t\" cannot be linearized\");",
                    "2332": "\t\t\t\treturn NULL;",
                    "2333": "\t\t\t}",
                    "2334": "",
                    "2335": "\t\t\tnet_pkt_cursor_backup(pkt, &backup);",
                    "2336": "",
                    "2337": "\t\t\tif (net_pkt_read(pkt, access->data, access->size)) {",
                    "2338": "\t\t\t\tnet_pkt_cursor_restore(pkt, &backup);",
                    "2339": "\t\t\t\treturn NULL;",
                    "2340": "\t\t\t}",
                    "2341": "",
                    "2342": "\t\t\tnet_pkt_cursor_restore(pkt, &backup);",
                    "2343": "\t\t}",
                    "2344": "",
                    "2345": "\t\treturn access->data;",
                    "2346": "\t}",
                    "2347": "",
                    "2348": "\treturn NULL;",
                    "2349": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_get_contiguous_len": {
            "name": "net_pkt_get_contiguous_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2297,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nsize_t net_pkt_get_contiguous_len(struct net_pkt *pkt)\n{\n\tpkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));\n\n\tif (pkt->cursor.buf && pkt->cursor.pos) {\n\t\tsize_t len;\n\n\t\tlen = net_pkt_is_being_overwritten(pkt) ?\n\t\t\tpkt->cursor.buf->len : net_buf_max_len(pkt->cursor.buf);\n\t\tlen -= pkt->cursor.pos - pkt->cursor.buf->data;\n\n\t\treturn len;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "2297": "size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)",
                    "2298": "{",
                    "2299": "\tpkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));",
                    "2300": "",
                    "2301": "\tif (pkt->cursor.buf && pkt->cursor.pos) {",
                    "2302": "\t\tsize_t len;",
                    "2303": "",
                    "2304": "\t\tlen = net_pkt_is_being_overwritten(pkt) ?",
                    "2305": "\t\t\tpkt->cursor.buf->len : net_buf_max_len(pkt->cursor.buf);",
                    "2306": "\t\tlen -= pkt->cursor.pos - pkt->cursor.buf->data;",
                    "2307": "",
                    "2308": "\t\treturn len;",
                    "2309": "\t}",
                    "2310": "",
                    "2311": "\treturn 0;",
                    "2312": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_get_current_offset": {
            "name": "net_pkt_get_current_offset",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2269,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nuint16_t net_pkt_get_current_offset(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf = pkt->buffer;\n\tuint16_t offset;\n\n\tif (!pkt->cursor.buf || !pkt->cursor.pos) {\n\t\treturn 0;\n\t}\n\n\toffset = 0U;\n\n\twhile (buf != pkt->cursor.buf) {\n\t\toffset += buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\toffset += pkt->cursor.pos - buf->data;\n\n\treturn offset;\n}\n",
                {
                    "2269": "uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)",
                    "2270": "{",
                    "2271": "\tstruct net_buf *buf = pkt->buffer;",
                    "2272": "\tuint16_t offset;",
                    "2273": "",
                    "2274": "\tif (!pkt->cursor.buf || !pkt->cursor.pos) {",
                    "2275": "\t\treturn 0;",
                    "2276": "\t}",
                    "2277": "",
                    "2278": "\toffset = 0U;",
                    "2279": "",
                    "2280": "\twhile (buf != pkt->cursor.buf) {",
                    "2281": "\t\toffset += buf->len;",
                    "2282": "\t\tbuf = buf->frags;",
                    "2283": "\t}",
                    "2284": "",
                    "2285": "\toffset += pkt->cursor.pos - buf->data;",
                    "2286": "",
                    "2287": "\treturn offset;",
                    "2288": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_pull": {
            "name": "net_pkt_pull",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2217,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_pull(struct net_pkt *pkt, size_t length)\n{\n\tstruct net_pkt_cursor *c_op = &pkt->cursor;\n\n\twhile (length) {\n\t\tsize_t left, rem;\n\n\t\tpkt_cursor_advance(pkt, false);\n\n\t\tif (!c_op->buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tleft = c_op->buf->len - (c_op->pos - c_op->buf->data);\n\t\tif (!left) {\n\t\t\tbreak;\n\t\t}\n\n\t\trem = left;\n\t\tif (rem > length) {\n\t\t\trem = length;\n\t\t}\n\n\t\tc_op->buf->len -= rem;\n\t\tleft -= rem;\n\t\tif (left) {\n\t\t\tmemmove(c_op->pos, c_op->pos+rem, left);\n\t\t} else {\n\t\t\tstruct net_buf *buf = pkt->buffer;\n\n\t\t\tif (buf) {\n\t\t\t\tpkt->buffer = buf->frags;\n\t\t\t\tbuf->frags = NULL;\n\t\t\t\tnet_buf_unref(buf);\n\t\t\t}\n\n\t\t\tnet_pkt_cursor_init(pkt);\n\t\t}\n\n\t\tlength -= rem;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "2217": "int net_pkt_pull(struct net_pkt *pkt, size_t length)",
                    "2218": "{",
                    "2219": "\tstruct net_pkt_cursor *c_op = &pkt->cursor;",
                    "2220": "",
                    "2221": "\twhile (length) {",
                    "2222": "\t\tsize_t left, rem;",
                    "2223": "",
                    "2224": "\t\tpkt_cursor_advance(pkt, false);",
                    "2225": "",
                    "2226": "\t\tif (!c_op->buf) {",
                    "2227": "\t\t\tbreak;",
                    "2228": "\t\t}",
                    "2229": "",
                    "2230": "\t\tleft = c_op->buf->len - (c_op->pos - c_op->buf->data);",
                    "2231": "\t\tif (!left) {",
                    "2232": "\t\t\tbreak;",
                    "2233": "\t\t}",
                    "2234": "",
                    "2235": "\t\trem = left;",
                    "2236": "\t\tif (rem > length) {",
                    "2237": "\t\t\trem = length;",
                    "2238": "\t\t}",
                    "2239": "",
                    "2240": "\t\tc_op->buf->len -= rem;",
                    "2241": "\t\tleft -= rem;",
                    "2242": "\t\tif (left) {",
                    "2243": "\t\t\tmemmove(c_op->pos, c_op->pos+rem, left);",
                    "2244": "\t\t} else {",
                    "2245": "\t\t\tstruct net_buf *buf = pkt->buffer;",
                    "2246": "",
                    "2247": "\t\t\tif (buf) {",
                    "2248": "\t\t\t\tpkt->buffer = buf->frags;",
                    "2249": "\t\t\t\tbuf->frags = NULL;",
                    "2250": "\t\t\t\tnet_buf_unref(buf);",
                    "2251": "\t\t\t}",
                    "2252": "",
                    "2253": "\t\t\tnet_pkt_cursor_init(pkt);",
                    "2254": "\t\t}",
                    "2255": "",
                    "2256": "\t\tlength -= rem;",
                    "2257": "\t}",
                    "2258": "",
                    "2259": "\tnet_pkt_cursor_init(pkt);",
                    "2260": "",
                    "2261": "\tif (length) {",
                    "2262": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "2263": "\t\treturn -ENOBUFS;",
                    "2264": "\t}",
                    "2265": "",
                    "2266": "\treturn 0;",
                    "2267": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_remaining_data": {
            "name": "net_pkt_remaining_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 2180,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nsize_t net_pkt_remaining_data(struct net_pkt *pkt)\n{\n\tstruct net_buf *buf;\n\tsize_t data_length;\n\n\tif (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {\n\t\treturn 0;\n\t}\n\n\tbuf = pkt->cursor.buf;\n\tdata_length = buf->len - (pkt->cursor.pos - buf->data);\n\n\tbuf = buf->frags;\n\twhile (buf) {\n\t\tdata_length += buf->len;\n\t\tbuf = buf->frags;\n\t}\n\n\treturn data_length;\n}\n",
                {
                    "2180": "size_t net_pkt_remaining_data(struct net_pkt *pkt)",
                    "2181": "{",
                    "2182": "\tstruct net_buf *buf;",
                    "2183": "\tsize_t data_length;",
                    "2184": "",
                    "2185": "\tif (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {",
                    "2186": "\t\treturn 0;",
                    "2187": "\t}",
                    "2188": "",
                    "2189": "\tbuf = pkt->cursor.buf;",
                    "2190": "\tdata_length = buf->len - (pkt->cursor.pos - buf->data);",
                    "2191": "",
                    "2192": "\tbuf = buf->frags;",
                    "2193": "\twhile (buf) {",
                    "2194": "\t\tdata_length += buf->len;",
                    "2195": "\t\tbuf = buf->frags;",
                    "2196": "\t}",
                    "2197": "",
                    "2198": "\treturn data_length;",
                    "2199": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_write": {
            "name": "net_pkt_write",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1955,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_write(struct net_pkt *pkt, const void *data, size_t length)\n{\n\tNET_DBG(\"pkt %p data %p length %zu\", pkt, data, length);\n\n\tif (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {\n\t\treturn net_pkt_skip(pkt, length);\n\t}\n\n\treturn net_pkt_cursor_operate(pkt, (void *)data, length, true, true);\n}\n",
                {
                    "1955": "int net_pkt_write(struct net_pkt *pkt, const void *data, size_t length)",
                    "1956": "{",
                    "1957": "\tNET_DBG(\"pkt %p data %p length %zu\", pkt, data, length);",
                    "1958": "",
                    "1959": "\tif (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {",
                    "1960": "\t\treturn net_pkt_skip(pkt, length);",
                    "1961": "\t}",
                    "1962": "",
                    "1963": "\treturn net_pkt_cursor_operate(pkt, (void *)data, length, true, true);",
                    "1964": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_read_be32": {
            "name": "net_pkt_read_be32",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1942,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_read_be32(struct net_pkt *pkt, uint32_t *data)\n{\n\tuint8_t d32[4];\n\tint ret;\n\n\tret = net_pkt_read(pkt, d32, sizeof(uint32_t));\n\n\t*data = (uint32_t)d32[0] << 24 | (uint32_t)d32[1] << 16 |\n\t\t(uint32_t)d32[2] << 8 | (uint32_t)d32[3];\n\n\treturn ret;\n}\n",
                {
                    "1942": "int net_pkt_read_be32(struct net_pkt *pkt, uint32_t *data)",
                    "1943": "{",
                    "1944": "\tuint8_t d32[4];",
                    "1945": "\tint ret;",
                    "1946": "",
                    "1947": "\tret = net_pkt_read(pkt, d32, sizeof(uint32_t));",
                    "1948": "",
                    "1949": "\t*data = (uint32_t)d32[0] << 24 | (uint32_t)d32[1] << 16 |",
                    "1950": "\t\t(uint32_t)d32[2] << 8 | (uint32_t)d32[3];",
                    "1951": "",
                    "1952": "\treturn ret;",
                    "1953": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_read_le16": {
            "name": "net_pkt_read_le16",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1930,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_read_le16(struct net_pkt *pkt, uint16_t *data)\n{\n\tuint8_t d16[2];\n\tint ret;\n\n\tret = net_pkt_read(pkt, d16, sizeof(uint16_t));\n\n\t*data = d16[1] << 8 | d16[0];\n\n\treturn ret;\n}\n",
                {
                    "1930": "int net_pkt_read_le16(struct net_pkt *pkt, uint16_t *data)",
                    "1931": "{",
                    "1932": "\tuint8_t d16[2];",
                    "1933": "\tint ret;",
                    "1934": "",
                    "1935": "\tret = net_pkt_read(pkt, d16, sizeof(uint16_t));",
                    "1936": "",
                    "1937": "\t*data = d16[1] << 8 | d16[0];",
                    "1938": "",
                    "1939": "\treturn ret;",
                    "1940": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_read_be16": {
            "name": "net_pkt_read_be16",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1918,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_read_be16(struct net_pkt *pkt, uint16_t *data)\n{\n\tuint8_t d16[2];\n\tint ret;\n\n\tret = net_pkt_read(pkt, d16, sizeof(uint16_t));\n\n\t*data = d16[0] << 8 | d16[1];\n\n\treturn ret;\n}\n",
                {
                    "1918": "int net_pkt_read_be16(struct net_pkt *pkt, uint16_t *data)",
                    "1919": "{",
                    "1920": "\tuint8_t d16[2];",
                    "1921": "\tint ret;",
                    "1922": "",
                    "1923": "\tret = net_pkt_read(pkt, d16, sizeof(uint16_t));",
                    "1924": "",
                    "1925": "\t*data = d16[0] << 8 | d16[1];",
                    "1926": "",
                    "1927": "\treturn ret;",
                    "1928": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_read": {
            "name": "net_pkt_read",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1911,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_read(struct net_pkt *pkt, void *data, size_t length)\n{\n\tNET_DBG(\"pkt %p data %p length %zu\", pkt, data, length);\n\n\treturn net_pkt_cursor_operate(pkt, data, length, true, false);\n}\n",
                {
                    "1911": "int net_pkt_read(struct net_pkt *pkt, void *data, size_t length)",
                    "1912": "{",
                    "1913": "\tNET_DBG(\"pkt %p data %p length %zu\", pkt, data, length);",
                    "1914": "",
                    "1915": "\treturn net_pkt_cursor_operate(pkt, data, length, true, false);",
                    "1916": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_copy": {
            "name": "net_pkt_copy",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1966,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_copy(struct net_pkt *pkt_dst,\n\t\t struct net_pkt *pkt_src,\n\t\t size_t length)\n{\n\tstruct net_pkt_cursor *c_dst = &pkt_dst->cursor;\n\tstruct net_pkt_cursor *c_src = &pkt_src->cursor;\n\n\twhile (c_dst->buf && c_src->buf && length) {\n\t\tsize_t s_len, d_len, len;\n\n\t\tpkt_cursor_advance(pkt_dst, true);\n\t\tpkt_cursor_advance(pkt_src, false);\n\n\t\tif (!c_dst->buf || !c_src->buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\ts_len = c_src->buf->len - (c_src->pos - c_src->buf->data);\n\t\td_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);\n\t\tif (length < s_len && length < d_len) {\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tif (d_len < s_len) {\n\t\t\t\tlen = d_len;\n\t\t\t} else {\n\t\t\t\tlen = s_len;\n\t\t\t}\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(c_dst->pos, c_src->pos, len);\n\n\t\tif (!net_pkt_is_being_overwritten(pkt_dst)) {\n\t\t\tnet_buf_add(c_dst->buf, len);\n\t\t}\n\n\t\tpkt_cursor_update(pkt_dst, len, true);\n\t\tpkt_cursor_update(pkt_src, len, false);\n\n\t\tlength -= len;\n\t}\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1966": "int net_pkt_copy(struct net_pkt *pkt_dst,",
                    "1967": "\t\t struct net_pkt *pkt_src,",
                    "1968": "\t\t size_t length)",
                    "1969": "{",
                    "1970": "\tstruct net_pkt_cursor *c_dst = &pkt_dst->cursor;",
                    "1971": "\tstruct net_pkt_cursor *c_src = &pkt_src->cursor;",
                    "1972": "",
                    "1973": "\twhile (c_dst->buf && c_src->buf && length) {",
                    "1974": "\t\tsize_t s_len, d_len, len;",
                    "1975": "",
                    "1976": "\t\tpkt_cursor_advance(pkt_dst, true);",
                    "1977": "\t\tpkt_cursor_advance(pkt_src, false);",
                    "1978": "",
                    "1979": "\t\tif (!c_dst->buf || !c_src->buf) {",
                    "1980": "\t\t\tbreak;",
                    "1981": "\t\t}",
                    "1982": "",
                    "1983": "\t\ts_len = c_src->buf->len - (c_src->pos - c_src->buf->data);",
                    "1984": "\t\td_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);",
                    "1985": "\t\tif (length < s_len && length < d_len) {",
                    "1986": "\t\t\tlen = length;",
                    "1987": "\t\t} else {",
                    "1988": "\t\t\tif (d_len < s_len) {",
                    "1989": "\t\t\t\tlen = d_len;",
                    "1990": "\t\t\t} else {",
                    "1991": "\t\t\t\tlen = s_len;",
                    "1992": "\t\t\t}",
                    "1993": "\t\t}",
                    "1994": "",
                    "1995": "\t\tif (!len) {",
                    "1996": "\t\t\tbreak;",
                    "1997": "\t\t}",
                    "1998": "",
                    "1999": "\t\tmemcpy(c_dst->pos, c_src->pos, len);",
                    "2000": "",
                    "2001": "\t\tif (!net_pkt_is_being_overwritten(pkt_dst)) {",
                    "2002": "\t\t\tnet_buf_add(c_dst->buf, len);",
                    "2003": "\t\t}",
                    "2004": "",
                    "2005": "\t\tpkt_cursor_update(pkt_dst, len, true);",
                    "2006": "\t\tpkt_cursor_update(pkt_src, len, false);",
                    "2007": "",
                    "2008": "\t\tlength -= len;",
                    "2009": "\t}",
                    "2010": "",
                    "2011": "\tif (length) {",
                    "2012": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "2013": "\t\treturn -ENOBUFS;",
                    "2014": "\t}",
                    "2015": "",
                    "2016": "\treturn 0;",
                    "2017": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_memset": {
            "name": "net_pkt_memset",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1904,
            "function_content": [
                "/* We use such variable to avoid lengthy lines */\nint net_pkt_memset(struct net_pkt *pkt, int byte, size_t amount)\n{\n\tNET_DBG(\"pkt %p byte %d amount %zu\", pkt, byte, amount);\n\n\treturn net_pkt_cursor_operate(pkt, &byte, amount, false, true);\n}\n",
                {
                    "1904": "int net_pkt_memset(struct net_pkt *pkt, int byte, size_t amount)",
                    "1905": "{",
                    "1906": "\tNET_DBG(\"pkt %p byte %d amount %zu\", pkt, byte, amount);",
                    "1907": "",
                    "1908": "\treturn net_pkt_cursor_operate(pkt, &byte, amount, false, true);",
                    "1909": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_cursor_init": {
            "name": "net_pkt_cursor_init",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1766,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nvoid net_pkt_cursor_init(struct net_pkt *pkt)\n{\n\tpkt->cursor.buf = pkt->buffer;\n\tif (pkt->cursor.buf) {\n\t\tpkt->cursor.pos = pkt->cursor.buf->data;\n\t} else {\n\t\tpkt->cursor.pos = NULL;\n\t}\n}\n",
                {
                    "1766": "void net_pkt_cursor_init(struct net_pkt *pkt)",
                    "1767": "{",
                    "1768": "\tpkt->cursor.buf = pkt->buffer;",
                    "1769": "\tif (pkt->cursor.buf) {",
                    "1770": "\t\tpkt->cursor.pos = pkt->cursor.buf->data;",
                    "1771": "\t} else {",
                    "1772": "\t\tpkt->cursor.pos = NULL;",
                    "1773": "\t}",
                    "1774": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_compact": {
            "name": "net_pkt_compact",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 780,
            "function_content": [
                "/* We do not use net_buf_frag_add() as this one will refcount\n* the frag once more if !pkt->frags\n*/\nvoid net_pkt_compact(struct net_pkt *pkt)\n{\n\tstruct net_buf *frag, *prev;\n\n\tNET_DBG(\"Compacting data in pkt %p\", pkt);\n\n\tfrag = pkt->frags;\n\tprev = NULL;\n\n\twhile (frag) {\n\t\tif (frag->frags) {\n\t\t\t/* Copy amount of data from next fragment to this\n\t\t\t * fragment.\n\t\t\t */\n\t\t\tsize_t copy_len;\n\n\t\t\tcopy_len = frag->frags->len;\n\t\t\tif (copy_len > net_buf_tailroom(frag)) {\n\t\t\t\tcopy_len = net_buf_tailroom(frag);\n\t\t\t}\n\n\t\t\tmemcpy(net_buf_tail(frag), frag->frags->data, copy_len);\n\t\t\tnet_buf_add(frag, copy_len);\n\n\t\t\tmemmove(frag->frags->data,\n\t\t\t\tfrag->frags->data + copy_len,\n\t\t\t\tfrag->frags->len - copy_len);\n\n\t\t\tfrag->frags->len -= copy_len;\n\n\t\t\t/* Is there any more space in this fragment */\n\t\t\tif (net_buf_tailroom(frag)) {\n\t\t\t\t/* There is. This also means that the next\n\t\t\t\t * fragment is empty as otherwise we could\n\t\t\t\t * not have copied all data. Remove next\n\t\t\t\t * fragment as there is no data in it any more.\n\t\t\t\t */\n\t\t\t\tnet_pkt_frag_del(pkt, frag, frag->frags);\n\n\t\t\t\t/* Then check next fragment */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!frag->len) {\n\t\t\t\t/* Remove the last fragment because there is no\n\t\t\t\t * data in it.\n\t\t\t\t */\n\t\t\t\tnet_pkt_frag_del(pkt, prev, frag);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprev = frag;\n\t\tfrag = frag->frags;\n\t}\n}\n",
                {
                    "780": "void net_pkt_compact(struct net_pkt *pkt)",
                    "781": "{",
                    "782": "\tstruct net_buf *frag, *prev;",
                    "783": "",
                    "784": "\tNET_DBG(\"Compacting data in pkt %p\", pkt);",
                    "785": "",
                    "786": "\tfrag = pkt->frags;",
                    "787": "\tprev = NULL;",
                    "788": "",
                    "789": "\twhile (frag) {",
                    "790": "\t\tif (frag->frags) {",
                    "791": "\t\t\t/* Copy amount of data from next fragment to this",
                    "792": "\t\t\t * fragment.",
                    "793": "\t\t\t */",
                    "794": "\t\t\tsize_t copy_len;",
                    "795": "",
                    "796": "\t\t\tcopy_len = frag->frags->len;",
                    "797": "\t\t\tif (copy_len > net_buf_tailroom(frag)) {",
                    "798": "\t\t\t\tcopy_len = net_buf_tailroom(frag);",
                    "799": "\t\t\t}",
                    "800": "",
                    "801": "\t\t\tmemcpy(net_buf_tail(frag), frag->frags->data, copy_len);",
                    "802": "\t\t\tnet_buf_add(frag, copy_len);",
                    "803": "",
                    "804": "\t\t\tmemmove(frag->frags->data,",
                    "805": "\t\t\t\tfrag->frags->data + copy_len,",
                    "806": "\t\t\t\tfrag->frags->len - copy_len);",
                    "807": "",
                    "808": "\t\t\tfrag->frags->len -= copy_len;",
                    "809": "",
                    "810": "\t\t\t/* Is there any more space in this fragment */",
                    "811": "\t\t\tif (net_buf_tailroom(frag)) {",
                    "812": "\t\t\t\t/* There is. This also means that the next",
                    "813": "\t\t\t\t * fragment is empty as otherwise we could",
                    "814": "\t\t\t\t * not have copied all data. Remove next",
                    "815": "\t\t\t\t * fragment as there is no data in it any more.",
                    "816": "\t\t\t\t */",
                    "817": "\t\t\t\tnet_pkt_frag_del(pkt, frag, frag->frags);",
                    "818": "",
                    "819": "\t\t\t\t/* Then check next fragment */",
                    "820": "\t\t\t\tcontinue;",
                    "821": "\t\t\t}",
                    "822": "\t\t} else {",
                    "823": "\t\t\tif (!frag->len) {",
                    "824": "\t\t\t\t/* Remove the last fragment because there is no",
                    "825": "\t\t\t\t * data in it.",
                    "826": "\t\t\t\t */",
                    "827": "\t\t\t\tnet_pkt_frag_del(pkt, prev, frag);",
                    "828": "",
                    "829": "\t\t\t\tbreak;",
                    "830": "\t\t\t}",
                    "831": "\t\t}",
                    "832": "",
                    "833": "\t\tprev = frag;",
                    "834": "\t\tfrag = frag->frags;",
                    "835": "\t}",
                    "836": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_eth_ipv6_mcast_to_mac_addr": {
            "name": "net_eth_ipv6_mcast_to_mac_addr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 72,
            "function_content": [
                "/* RFC 1112 6.4. Extensions to an Ethernet Local Network Module\n* \"An IP host group address is mapped to an Ethernet multicast\n* address by placing the low-order 23-bits of the IP address into\n* the low-order 23 bits of the Ethernet multicast address\n* 01-00-5E-00-00-00 (hex).\"\n*/\nvoid net_eth_ipv6_mcast_to_mac_addr(const struct net_in6_addr *ipv6_addr,\n\t\t\t\t    struct net_eth_addr *mac_addr)\n{\n\t/* RFC 2464 7. Address Mapping -- Multicast\n\t * \"An IPv6 packet with a multicast destination address DST,\n\t * consisting of the sixteen octets DST[1] through DST[16],\n\t * is transmitted to the Ethernet multicast address whose\n\t * first two octets are the value 3333 hexadecimal and whose\n\t * last four octets are the last four octets of DST.\"\n\t */\n\tmac_addr->addr[0] = mac_addr->addr[1] = 0x33;\n\tmemcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);\n}\n",
                {
                    "72": "void net_eth_ipv6_mcast_to_mac_addr(const struct net_in6_addr *ipv6_addr,",
                    "73": "\t\t\t\t    struct net_eth_addr *mac_addr)",
                    "74": "{",
                    "75": "\t/* RFC 2464 7. Address Mapping -- Multicast",
                    "76": "\t * \"An IPv6 packet with a multicast destination address DST,",
                    "77": "\t * consisting of the sixteen octets DST[1] through DST[16],",
                    "78": "\t * is transmitted to the Ethernet multicast address whose",
                    "79": "\t * first two octets are the value 3333 hexadecimal and whose",
                    "80": "\t * last four octets are the last four octets of DST.\"",
                    "81": "\t */",
                    "82": "\tmac_addr->addr[0] = mac_addr->addr[1] = 0x33;",
                    "83": "\tmemcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);",
                    "84": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_z_log_msg_static_create": {
            "name": "z_impl_z_log_msg_static_create",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_msg.c",
            "location_line": 280,
            "function_content": [
                "/* fmt string located at index 1 */\nvoid z_impl_z_log_msg_static_create(const void *source,\n\t\t\t      const struct log_msg_desc desc,\n\t\t\t      uint8_t *package, const void *data)\n{\n\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) && frontend_runtime_filtering(source, desc.level)) {\n\t\tlog_frontend_msg(source, desc, package, data);\n\t}\n\n\tif (!BACKENDS_IN_USE()) {\n\t\treturn;\n\t}\n\n\tstruct log_msg_desc out_desc = desc;\n\tint inlen = desc.package_len;\n\tstruct log_msg *msg;\n\n\tif (inlen > 0) {\n\t\tuint32_t flags = CBPRINTF_PACKAGE_CONVERT_RW_STR |\n\t\t\t\t (IS_ENABLED(CONFIG_LOG_MSG_APPEND_RO_STRING_LOC) ?\n\t\t\t\t CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR : 0) |\n\t\t\t\t (IS_ENABLED(CONFIG_LOG_FMT_SECTION_STRIP) ?\n\t\t\t\t 0 : CBPRINTF_PACKAGE_CONVERT_PTR_CHECK);\n\t\tuint16_t strl[4];\n\t\tint len;\n\n\t\tlen = cbprintf_package_copy(package, inlen,\n\t\t\t\t\t    NULL, 0, flags,\n\t\t\t\t\t    strl, ARRAY_SIZE(strl));\n\n\t\tif (len > Z_LOG_MSG_MAX_PACKAGE) {\n\t\t\tstruct cbprintf_package_hdr_ext *pkg =\n\t\t\t\t(struct cbprintf_package_hdr_ext *)package;\n\n\t\t\tLOG_WRN(\"Message (\\\"%s\\\") dropped because it exceeds size limitation (%u)\",\n\t\t\t\tpkg->fmt, (uint32_t)Z_LOG_MSG_MAX_PACKAGE);\n\t\t\treturn;\n\t\t}\n\t\t/* Update package length with calculated value (which may be extended\n\t\t * when strings are copied into the package.\n\t\t */\n\t\tout_desc.package_len = len;\n\t\tmsg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));\n\t\tif (msg) {\n\t\t\tlen = cbprintf_package_copy(package, inlen,\n\t\t\t\t\t\t    msg->data, out_desc.package_len,\n\t\t\t\t\t\t    flags, strl, ARRAY_SIZE(strl));\n\t\t\t__ASSERT_NO_MSG(len >= 0);\n\t\t}\n\t} else {\n\t\tmsg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));\n\t}\n\n\tz_log_msg_finalize(msg, source, out_desc, data);\n}\n",
                {
                    "280": "void z_impl_z_log_msg_static_create(const void *source,",
                    "281": "\t\t\t      const struct log_msg_desc desc,",
                    "282": "\t\t\t      uint8_t *package, const void *data)",
                    "283": "{",
                    "284": "\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) && frontend_runtime_filtering(source, desc.level)) {",
                    "285": "\t\tlog_frontend_msg(source, desc, package, data);",
                    "286": "\t}",
                    "287": "",
                    "288": "\tif (!BACKENDS_IN_USE()) {",
                    "289": "\t\treturn;",
                    "290": "\t}",
                    "291": "",
                    "292": "\tstruct log_msg_desc out_desc = desc;",
                    "293": "\tint inlen = desc.package_len;",
                    "294": "\tstruct log_msg *msg;",
                    "295": "",
                    "296": "\tif (inlen > 0) {",
                    "297": "\t\tuint32_t flags = CBPRINTF_PACKAGE_CONVERT_RW_STR |",
                    "298": "\t\t\t\t (IS_ENABLED(CONFIG_LOG_MSG_APPEND_RO_STRING_LOC) ?",
                    "299": "\t\t\t\t CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR : 0) |",
                    "300": "\t\t\t\t (IS_ENABLED(CONFIG_LOG_FMT_SECTION_STRIP) ?",
                    "301": "\t\t\t\t 0 : CBPRINTF_PACKAGE_CONVERT_PTR_CHECK);",
                    "302": "\t\tuint16_t strl[4];",
                    "303": "\t\tint len;",
                    "304": "",
                    "305": "\t\tlen = cbprintf_package_copy(package, inlen,",
                    "306": "\t\t\t\t\t    NULL, 0, flags,",
                    "307": "\t\t\t\t\t    strl, ARRAY_SIZE(strl));",
                    "308": "",
                    "309": "\t\tif (len > Z_LOG_MSG_MAX_PACKAGE) {",
                    "310": "\t\t\tstruct cbprintf_package_hdr_ext *pkg =",
                    "311": "\t\t\t\t(struct cbprintf_package_hdr_ext *)package;",
                    "312": "",
                    "313": "\t\t\tLOG_WRN(\"Message (\\\"%s\\\") dropped because it exceeds size limitation (%u)\",",
                    "314": "\t\t\t\tpkg->fmt, (uint32_t)Z_LOG_MSG_MAX_PACKAGE);",
                    "315": "\t\t\treturn;",
                    "316": "\t\t}",
                    "317": "\t\t/* Update package length with calculated value (which may be extended",
                    "318": "\t\t * when strings are copied into the package.",
                    "319": "\t\t */",
                    "320": "\t\tout_desc.package_len = len;",
                    "321": "\t\tmsg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));",
                    "322": "\t\tif (msg) {",
                    "323": "\t\t\tlen = cbprintf_package_copy(package, inlen,",
                    "324": "\t\t\t\t\t\t    msg->data, out_desc.package_len,",
                    "325": "\t\t\t\t\t\t    flags, strl, ARRAY_SIZE(strl));",
                    "326": "\t\t\t__ASSERT_NO_MSG(len >= 0);",
                    "327": "\t\t}",
                    "328": "\t} else {",
                    "329": "\t\tmsg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));",
                    "330": "\t}",
                    "331": "",
                    "332": "\tz_log_msg_finalize(msg, source, out_desc, data);",
                    "333": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_log_msg_runtime_vcreate": {
            "name": "z_log_msg_runtime_vcreate",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_msg.c",
            "location_line": 345,
            "function_content": [
                "/* Update package length with calculated value (which may be extended\n* when strings are copied into the package.\n*/\nvoid z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,\n\t\t\t\tuint8_t level, const void *data, size_t dlen,\n\t\t\t\tuint32_t package_flags, const char *fmt, va_list ap)\n{\n\tint plen;\n\n\tif (fmt) {\n\t\tva_list ap2;\n\n\t\tva_copy(ap2, ap);\n\t\tplen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,\n\t\t\t\t\t package_flags, fmt, ap2);\n\t\t__ASSERT_NO_MSG(plen >= 0);\n\t\tva_end(ap2);\n\t} else {\n\t\tplen = 0;\n\t}\n\n\tif (plen > Z_LOG_MSG_MAX_PACKAGE) {\n\t\tLOG_WRN(\"Message dropped because it exceeds size limitation (%u)\",\n\t\t\t(uint32_t)Z_LOG_MSG_MAX_PACKAGE);\n\t\treturn;\n\t}\n\n\tsize_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);\n\tstruct log_msg *msg;\n\tuint8_t *pkg;\n\tstruct log_msg_desc desc =\n\t\tZ_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);\n\n\tif (IS_ENABLED(CONFIG_USERSPACE) && k_is_user_context()) {\n\t\tpkg = alloca(plen);\n\t\tmsg = NULL;\n\t} else if (IS_ENABLED(CONFIG_LOG_MODE_DEFERRED) && BACKENDS_IN_USE()) {\n\t\tmsg = z_log_msg_alloc(msg_wlen);\n\t\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) && msg == NULL) {\n\t\t\tpkg = alloca(plen);\n\t\t} else {\n\t\t\tpkg = msg ? msg->data : NULL;\n\t\t}\n\t} else {\n\t\tmsg = alloca(msg_wlen * sizeof(int));\n\t\tpkg = msg->data;\n\t}\n\n\tif (pkg && fmt) {\n\t\tplen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);\n\t\t__ASSERT_NO_MSG(plen >= 0);\n\t}\n\n\tif (IS_ENABLED(CONFIG_USERSPACE) && k_is_user_context()) {\n\t\tz_log_msg_static_create(source, desc, pkg, data);\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) &&\n\t\t    frontend_runtime_filtering(source, desc.level)) {\n\t\t\tlog_frontend_msg(source, desc, pkg, data);\n\t\t}\n\n\t\tif (BACKENDS_IN_USE()) {\n\t\t\tz_log_msg_finalize(msg, source, desc, data);\n\t\t}\n\t}\n}\n",
                {
                    "345": "void z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,",
                    "346": "\t\t\t\tuint8_t level, const void *data, size_t dlen,",
                    "347": "\t\t\t\tuint32_t package_flags, const char *fmt, va_list ap)",
                    "348": "{",
                    "349": "\tint plen;",
                    "350": "",
                    "351": "\tif (fmt) {",
                    "352": "\t\tva_list ap2;",
                    "353": "",
                    "354": "\t\tva_copy(ap2, ap);",
                    "355": "\t\tplen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,",
                    "356": "\t\t\t\t\t package_flags, fmt, ap2);",
                    "357": "\t\t__ASSERT_NO_MSG(plen >= 0);",
                    "358": "\t\tva_end(ap2);",
                    "359": "\t} else {",
                    "360": "\t\tplen = 0;",
                    "361": "\t}",
                    "362": "",
                    "363": "\tif (plen > Z_LOG_MSG_MAX_PACKAGE) {",
                    "364": "\t\tLOG_WRN(\"Message dropped because it exceeds size limitation (%u)\",",
                    "365": "\t\t\t(uint32_t)Z_LOG_MSG_MAX_PACKAGE);",
                    "366": "\t\treturn;",
                    "367": "\t}",
                    "368": "",
                    "369": "\tsize_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);",
                    "370": "\tstruct log_msg *msg;",
                    "371": "\tuint8_t *pkg;",
                    "372": "\tstruct log_msg_desc desc =",
                    "373": "\t\tZ_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);",
                    "374": "",
                    "375": "\tif (IS_ENABLED(CONFIG_USERSPACE) && k_is_user_context()) {",
                    "376": "\t\tpkg = alloca(plen);",
                    "377": "\t\tmsg = NULL;",
                    "378": "\t} else if (IS_ENABLED(CONFIG_LOG_MODE_DEFERRED) && BACKENDS_IN_USE()) {",
                    "379": "\t\tmsg = z_log_msg_alloc(msg_wlen);",
                    "380": "\t\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) && msg == NULL) {",
                    "381": "\t\t\tpkg = alloca(plen);",
                    "382": "\t\t} else {",
                    "383": "\t\t\tpkg = msg ? msg->data : NULL;",
                    "384": "\t\t}",
                    "385": "\t} else {",
                    "386": "\t\tmsg = alloca(msg_wlen * sizeof(int));",
                    "387": "\t\tpkg = msg->data;",
                    "388": "\t}",
                    "389": "",
                    "390": "\tif (pkg && fmt) {",
                    "391": "\t\tplen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);",
                    "392": "\t\t__ASSERT_NO_MSG(plen >= 0);",
                    "393": "\t}",
                    "394": "",
                    "395": "\tif (IS_ENABLED(CONFIG_USERSPACE) && k_is_user_context()) {",
                    "396": "\t\tz_log_msg_static_create(source, desc, pkg, data);",
                    "397": "\t} else {",
                    "398": "\t\tif (IS_ENABLED(CONFIG_LOG_FRONTEND) &&",
                    "399": "\t\t    frontend_runtime_filtering(source, desc.level)) {",
                    "400": "\t\t\tlog_frontend_msg(source, desc, pkg, data);",
                    "401": "\t\t}",
                    "402": "",
                    "403": "\t\tif (BACKENDS_IN_USE()) {",
                    "404": "\t\t\tz_log_msg_finalize(msg, source, desc, data);",
                    "405": "\t\t}",
                    "406": "\t}",
                    "407": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_log_msg_finalize": {
            "name": "z_log_msg_finalize",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_msg.c",
            "location_line": 31,
            "function_content": [
                "/* For simplified message handling cprintf package must have only 1 word. */\nvoid z_log_msg_finalize(struct log_msg *msg, const void *source,\n\t\t\t const struct log_msg_desc desc, const void *data)\n{\n\tif (!msg) {\n\t\tz_log_dropped(false);\n\n\t\treturn;\n\t}\n\n\tif (data) {\n\t\tuint8_t *d = msg->data + desc.package_len;\n\n\t\tmemcpy(d, data, desc.data_len);\n\t}\n\n\tmsg->hdr.desc = desc;\n\tmsg->hdr.source = source;\n#if CONFIG_LOG_THREAD_ID_PREFIX\n\tmsg->hdr.tid = k_is_in_isr() ? NULL : k_current_get();\n#endif\n\tz_log_msg_commit(msg);\n}\n",
                {
                    "31": "void z_log_msg_finalize(struct log_msg *msg, const void *source,",
                    "32": "\t\t\t const struct log_msg_desc desc, const void *data)",
                    "33": "{",
                    "34": "\tif (!msg) {",
                    "35": "\t\tz_log_dropped(false);",
                    "36": "",
                    "37": "\t\treturn;",
                    "38": "\t}",
                    "39": "",
                    "40": "\tif (data) {",
                    "41": "\t\tuint8_t *d = msg->data + desc.package_len;",
                    "42": "",
                    "43": "\t\tmemcpy(d, data, desc.data_len);",
                    "44": "\t}",
                    "45": "",
                    "46": "\tmsg->hdr.desc = desc;",
                    "47": "\tmsg->hdr.source = source;",
                    "48": "#if CONFIG_LOG_THREAD_ID_PREFIX",
                    "49": "\tmsg->hdr.tid = k_is_in_isr() ? NULL : k_current_get();",
                    "50": "#endif",
                    "51": "\tz_log_msg_commit(msg);",
                    "52": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_log_vprintk": {
            "name": "z_log_vprintk",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_core.c",
            "location_line": 219,
            "function_content": [
                "/* No action needed. Message processing will be triggered by the\n* timeout or when number of upcoming messages exceeds the\n* threshold.\n*/\nvoid z_log_vprintk(const char *fmt, va_list ap)\n{\n\tif (!IS_ENABLED(CONFIG_LOG_PRINTK)) {\n\t\treturn;\n\t}\n\n\tz_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,\n\t\t\t\t   LOG_LEVEL_INTERNAL_RAW_STRING, NULL, 0,\n\t\t\t\t   Z_LOG_MSG_CBPRINTF_FLAGS(0),\n\t\t\t\t   fmt, ap);\n}\n",
                {
                    "219": "void z_log_vprintk(const char *fmt, va_list ap)",
                    "220": "{",
                    "221": "\tif (!IS_ENABLED(CONFIG_LOG_PRINTK)) {",
                    "222": "\t\treturn;",
                    "223": "\t}",
                    "224": "",
                    "225": "\tz_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,",
                    "226": "\t\t\t\t   LOG_LEVEL_INTERNAL_RAW_STRING, NULL, 0,",
                    "227": "\t\t\t\t   Z_LOG_MSG_CBPRINTF_FLAGS(0),",
                    "228": "\t\t\t\t   fmt, ap);",
                    "229": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_data_check": {
            "name": "mbox_message_data_check",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 367,
            "function_content": [
                "/**\n* @brief Handle immediate consumption of received mailbox message data.\n*\n* Checks to see if received message data should be kept for later retrieval,\n* or if the data should consumed immediately and the message disposed of.\n*\n* The data is consumed immediately in either of the following cases:\n*     1) The receiver requested immediate retrieval by supplying a buffer\n*        to receive the data.\n*     2) There is no data to be retrieved. (i.e. Data size is 0 bytes.)\n*\n* @param rx_msg Pointer to receive message descriptor.\n* @param buffer Pointer to buffer to receive data.\n*\n* @return 0\n*/\nstatic int mbox_message_data_check(struct k_mbox_msg *rx_msg, void *buffer)\n{\n\tif (buffer != NULL) {\n\t\t/* retrieve data now, then dispose of message */\n\t\tk_mbox_data_get(rx_msg, buffer);\n\t} else if (rx_msg->size == 0U) {\n\t\t/* there is no data to get, so just dispose of message */\n\t\tmbox_message_dispose(rx_msg);\n\t} else {\n\t\t/* keep message around for later data retrieval */\n\t}\n\n\treturn 0;\n}\n",
                {
                    "367": "static int mbox_message_data_check(struct k_mbox_msg *rx_msg, void *buffer)",
                    "368": "{",
                    "369": "\tif (buffer != NULL) {",
                    "370": "\t\t/* retrieve data now, then dispose of message */",
                    "371": "\t\tk_mbox_data_get(rx_msg, buffer);",
                    "372": "\t} else if (rx_msg->size == 0U) {",
                    "373": "\t\t/* there is no data to get, so just dispose of message */",
                    "374": "\t\tmbox_message_dispose(rx_msg);",
                    "375": "\t} else {",
                    "376": "\t\t/* keep message around for later data retrieval */",
                    "377": "\t}",
                    "378": "",
                    "379": "\treturn 0;",
                    "380": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_put": {
            "name": "mbox_message_put",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 210,
            "function_content": [
                "/**\n* @brief Send a mailbox message.\n*\n* Helper routine that handles both synchronous and asynchronous sends.\n*\n* @param mbox Pointer to the mailbox object.\n* @param tx_msg Pointer to transmit message descriptor.\n* @param timeout Maximum time (milliseconds) to wait for the message to be\n*        received (although not necessarily completely processed).\n*        Use K_NO_WAIT to return immediately, or K_FOREVER to wait as long\n*        as necessary.\n*\n* @return 0 if successful, -ENOMSG if failed immediately, -EAGAIN if timed out\n*/\nstatic int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     k_timeout_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_thread *receiving_thread;\n\tstruct k_mbox_msg *rx_msg;\n\tk_spinlock_key_t key;\n\n\t/* save sender id so it can be used during message matching */\n\ttx_msg->rx_source_thread = _current;\n\n\t/* finish readying sending thread (actual or dummy) for send */\n\tsending_thread = tx_msg->_syncing_thread;\n\tsending_thread->base.swap_data = tx_msg;\n\n\t/* search mailbox's rx queue for a compatible receiver */\n\tkey = k_spin_lock(&mbox->lock);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);\n\n\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {\n\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take receiver out of rx queue */\n\t\t\tz_unpend_thread(receiving_thread);\n\n\t\t\t/* ready receiver for execution */\n\t\t\tarch_thread_return_value_set(receiving_thread, 0);\n\t\t\tz_ready_thread(receiving_thread);\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t\t\t/*\n\t\t\t * asynchronous send: swap out current thread\n\t\t\t * if receiver has priority, otherwise let it continue\n\t\t\t *\n\t\t\t * note: dummy sending thread sits (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)\n\t\t\t    != 0U) {\n\t\t\t\tz_reschedule(&mbox->lock, key);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t\t\t/*\n\t\t\t * synchronous send: pend current thread (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);\n\n\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* didn't find a matching receiver: don't wait for one */\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);\n\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/* asynchronous send: dummy thread waits on tx queue for receiver */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn 0;\n\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);\n\n\t/* synchronous send: sender waits on tx queue for receiver or timeout */\n\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);\n\n\treturn ret;\n}\n",
                {
                    "210": "static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,",
                    "211": "\t\t\t     k_timeout_t timeout)",
                    "212": "{",
                    "213": "\tstruct k_thread *sending_thread;",
                    "214": "\tstruct k_thread *receiving_thread;",
                    "215": "\tstruct k_mbox_msg *rx_msg;",
                    "216": "\tk_spinlock_key_t key;",
                    "217": "",
                    "218": "\t/* save sender id so it can be used during message matching */",
                    "219": "\ttx_msg->rx_source_thread = _current;",
                    "220": "",
                    "221": "\t/* finish readying sending thread (actual or dummy) for send */",
                    "222": "\tsending_thread = tx_msg->_syncing_thread;",
                    "223": "\tsending_thread->base.swap_data = tx_msg;",
                    "224": "",
                    "225": "\t/* search mailbox's rx queue for a compatible receiver */",
                    "226": "\tkey = k_spin_lock(&mbox->lock);",
                    "227": "",
                    "228": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mbox, message_put, mbox, timeout);",
                    "229": "",
                    "230": "\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {",
                    "231": "\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;",
                    "232": "",
                    "233": "\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {",
                    "234": "\t\t\t/* take receiver out of rx queue */",
                    "235": "\t\t\tz_unpend_thread(receiving_thread);",
                    "236": "",
                    "237": "\t\t\t/* ready receiver for execution */",
                    "238": "\t\t\tarch_thread_return_value_set(receiving_thread, 0);",
                    "239": "\t\t\tz_ready_thread(receiving_thread);",
                    "240": "",
                    "241": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "242": "\t\t\t/*",
                    "243": "\t\t\t * asynchronous send: swap out current thread",
                    "244": "\t\t\t * if receiver has priority, otherwise let it continue",
                    "245": "\t\t\t *",
                    "246": "\t\t\t * note: dummy sending thread sits (unqueued)",
                    "247": "\t\t\t * until the receiver consumes the message",
                    "248": "\t\t\t */",
                    "249": "\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)",
                    "250": "\t\t\t    != 0U) {",
                    "251": "\t\t\t\tz_reschedule(&mbox->lock, key);",
                    "252": "\t\t\t\treturn 0;",
                    "253": "\t\t\t}",
                    "254": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "255": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "256": "",
                    "257": "\t\t\t/*",
                    "258": "\t\t\t * synchronous send: pend current thread (unqueued)",
                    "259": "\t\t\t * until the receiver consumes the message",
                    "260": "\t\t\t */",
                    "261": "\t\t\tint ret = z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);",
                    "262": "",
                    "263": "\t\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "264": "",
                    "265": "\t\t\treturn ret;",
                    "266": "\t\t}",
                    "267": "\t}",
                    "268": "",
                    "269": "\t/* didn't find a matching receiver: don't wait for one */",
                    "270": "\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {",
                    "271": "\t\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, -ENOMSG);",
                    "272": "",
                    "273": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "274": "\t\treturn -ENOMSG;",
                    "275": "\t}",
                    "276": "",
                    "277": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "278": "\t/* asynchronous send: dummy thread waits on tx queue for receiver */",
                    "279": "\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {",
                    "280": "\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);",
                    "281": "\t\tk_spin_unlock(&mbox->lock, key);",
                    "282": "\t\treturn 0;",
                    "283": "\t}",
                    "284": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "285": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mbox, message_put, mbox, timeout);",
                    "286": "",
                    "287": "\t/* synchronous send: sender waits on tx queue for receiver or timeout */",
                    "288": "\tint ret = z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);",
                    "289": "",
                    "290": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mbox, message_put, mbox, timeout, ret);",
                    "291": "",
                    "292": "\treturn ret;",
                    "293": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_dispose": {
            "name": "mbox_message_dispose",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 155,
            "function_content": [
                "/**\n* @brief Dispose of received message.\n*\n* Notifies the sender that message processing is complete.\n*\n* @param rx_msg Pointer to receive message descriptor.\n*/\nstatic void mbox_message_dispose(struct k_mbox_msg *rx_msg)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_mbox_msg *tx_msg;\n\n\t/* do nothing if message was disposed of when it was received */\n\tif (rx_msg->_syncing_thread == NULL) {\n\t\treturn;\n\t}\n\n\t/* recover sender info */\n\tsending_thread = rx_msg->_syncing_thread;\n\trx_msg->_syncing_thread = NULL;\n\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;\n\n\t/* update data size field for sender */\n\ttx_msg->size = rx_msg->size;\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/*\n\t * asynchronous send: free asynchronous message descriptor +\n\t * dummy thread pair, then give semaphore (if needed)\n\t */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tstruct k_sem *async_sem = tx_msg->_async_sem;\n\n\t\tmbox_async_free((struct k_mbox_async *)sending_thread);\n\t\tif (async_sem != NULL) {\n\t\t\tk_sem_give(async_sem);\n\t\t}\n\t\treturn;\n\t}\n#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */\n\n\t/* synchronous send: wake up sending thread */\n\tarch_thread_return_value_set(sending_thread, 0);\n\tz_mark_thread_as_not_pending(sending_thread);\n\tz_ready_thread(sending_thread);\n\tz_reschedule_unlocked();\n}\n",
                {
                    "155": "static void mbox_message_dispose(struct k_mbox_msg *rx_msg)",
                    "156": "{",
                    "157": "\tstruct k_thread *sending_thread;",
                    "158": "\tstruct k_mbox_msg *tx_msg;",
                    "159": "",
                    "160": "\t/* do nothing if message was disposed of when it was received */",
                    "161": "\tif (rx_msg->_syncing_thread == NULL) {",
                    "162": "\t\treturn;",
                    "163": "\t}",
                    "164": "",
                    "165": "\t/* recover sender info */",
                    "166": "\tsending_thread = rx_msg->_syncing_thread;",
                    "167": "\trx_msg->_syncing_thread = NULL;",
                    "168": "\ttx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;",
                    "169": "",
                    "170": "\t/* update data size field for sender */",
                    "171": "\ttx_msg->size = rx_msg->size;",
                    "172": "",
                    "173": "#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)",
                    "174": "\t/*",
                    "175": "\t * asynchronous send: free asynchronous message descriptor +",
                    "176": "\t * dummy thread pair, then give semaphore (if needed)",
                    "177": "\t */",
                    "178": "\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {",
                    "179": "\t\tstruct k_sem *async_sem = tx_msg->_async_sem;",
                    "180": "",
                    "181": "\t\tmbox_async_free((struct k_mbox_async *)sending_thread);",
                    "182": "\t\tif (async_sem != NULL) {",
                    "183": "\t\t\tk_sem_give(async_sem);",
                    "184": "\t\t}",
                    "185": "\t\treturn;",
                    "186": "\t}",
                    "187": "#endif /* CONFIG_NUM_MBOX_ASYNC_MSGS */",
                    "188": "",
                    "189": "\t/* synchronous send: wake up sending thread */",
                    "190": "\tarch_thread_return_value_set(sending_thread, 0);",
                    "191": "\tz_mark_thread_as_not_pending(sending_thread);",
                    "192": "\tz_ready_thread(sending_thread);",
                    "193": "\tz_reschedule_unlocked();",
                    "194": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mbox_message_match": {
            "name": "mbox_message_match",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mailbox.c",
            "location_line": 112,
            "function_content": [
                "/**\n* @brief Check compatibility of sender's and receiver's message descriptors.\n*\n* Compares sender's and receiver's message descriptors to see if they are\n* compatible. If so, the descriptor fields are updated to reflect that a\n* match has occurred.\n*\n* @param tx_msg Pointer to transmit message descriptor.\n* @param rx_msg Pointer to receive message descriptor.\n*\n* @return 0 if successfully matched, otherwise -1.\n*/\nstatic int mbox_message_match(struct k_mbox_msg *tx_msg,\n\t\t\t       struct k_mbox_msg *rx_msg)\n{\n\tuint32_t temp_info;\n\n\tif (((tx_msg->tx_target_thread == (k_tid_t)K_ANY) ||\n\t     (tx_msg->tx_target_thread == rx_msg->tx_target_thread)) &&\n\t    ((rx_msg->rx_source_thread == (k_tid_t)K_ANY) ||\n\t     (rx_msg->rx_source_thread == tx_msg->rx_source_thread))) {\n\n\t\t/* update thread identifier fields for both descriptors */\n\t\trx_msg->rx_source_thread = tx_msg->rx_source_thread;\n\t\ttx_msg->tx_target_thread = rx_msg->tx_target_thread;\n\n\t\t/* update application info fields for both descriptors */\n\t\ttemp_info = rx_msg->info;\n\t\trx_msg->info = tx_msg->info;\n\t\ttx_msg->info = temp_info;\n\n\t\t/* update data size field for receiver only */\n\t\tif (rx_msg->size > tx_msg->size) {\n\t\t\trx_msg->size = tx_msg->size;\n\t\t}\n\n\t\t/* update data location fields for receiver only */\n\t\trx_msg->tx_data = tx_msg->tx_data;\n\n\t\t/* update syncing thread field for receiver only */\n\t\trx_msg->_syncing_thread = tx_msg->_syncing_thread;\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n",
                {
                    "112": "static int mbox_message_match(struct k_mbox_msg *tx_msg,",
                    "113": "\t\t\t       struct k_mbox_msg *rx_msg)",
                    "114": "{",
                    "115": "\tuint32_t temp_info;",
                    "116": "",
                    "117": "\tif (((tx_msg->tx_target_thread == (k_tid_t)K_ANY) ||",
                    "118": "\t     (tx_msg->tx_target_thread == rx_msg->tx_target_thread)) &&",
                    "119": "\t    ((rx_msg->rx_source_thread == (k_tid_t)K_ANY) ||",
                    "120": "\t     (rx_msg->rx_source_thread == tx_msg->rx_source_thread))) {",
                    "121": "",
                    "122": "\t\t/* update thread identifier fields for both descriptors */",
                    "123": "\t\trx_msg->rx_source_thread = tx_msg->rx_source_thread;",
                    "124": "\t\ttx_msg->tx_target_thread = rx_msg->tx_target_thread;",
                    "125": "",
                    "126": "\t\t/* update application info fields for both descriptors */",
                    "127": "\t\ttemp_info = rx_msg->info;",
                    "128": "\t\trx_msg->info = tx_msg->info;",
                    "129": "\t\ttx_msg->info = temp_info;",
                    "130": "",
                    "131": "\t\t/* update data size field for receiver only */",
                    "132": "\t\tif (rx_msg->size > tx_msg->size) {",
                    "133": "\t\t\trx_msg->size = tx_msg->size;",
                    "134": "\t\t}",
                    "135": "",
                    "136": "\t\t/* update data location fields for receiver only */",
                    "137": "\t\trx_msg->tx_data = tx_msg->tx_data;",
                    "138": "",
                    "139": "\t\t/* update syncing thread field for receiver only */",
                    "140": "\t\trx_msg->_syncing_thread = tx_msg->_syncing_thread;",
                    "141": "",
                    "142": "\t\treturn 0;",
                    "143": "\t}",
                    "144": "",
                    "145": "\treturn -1;",
                    "146": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "create_free_list": {
            "name": "create_free_list",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mem_slab.c",
            "location_line": 104,
            "function_content": [
                "/**\n* @brief Initialize kernel memory slab subsystem.\n*\n* Perform any initialization of memory slabs that wasn't done at build time.\n* Currently this just involves creating the list of free blocks for each slab.\n*\n* @retval 0 on success.\n* @retval -EINVAL if @p slab contains invalid configuration and/or values.\n*/\nstatic int create_free_list(struct k_mem_slab *slab)\n{\n\tchar *p;\n\n\t/* blocks must be word aligned */\n\tCHECKIF(((slab->info.block_size | (uintptr_t)slab->buffer) &\n\t\t\t\t(sizeof(void *) - 1)) != 0U) {\n\t\treturn -EINVAL;\n\t}\n\n\tslab->free_list = NULL;\n\tp = slab->buffer + slab->info.block_size * (slab->info.num_blocks - 1);\n\n\tfor (int i = slab->info.num_blocks - 1; i >= 0; i--) {\n\t\t*(char **)p = slab->free_list;\n\t\tslab->free_list = p;\n\t\tp -= slab->info.block_size;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "104": "static int create_free_list(struct k_mem_slab *slab)",
                    "105": "{",
                    "106": "\tchar *p;",
                    "107": "",
                    "108": "\t/* blocks must be word aligned */",
                    "109": "\tCHECKIF(((slab->info.block_size | (uintptr_t)slab->buffer) &",
                    "110": "\t\t\t\t(sizeof(void *) - 1)) != 0U) {",
                    "111": "\t\treturn -EINVAL;",
                    "112": "\t}",
                    "113": "",
                    "114": "\tslab->free_list = NULL;",
                    "115": "\tp = slab->buffer + slab->info.block_size * (slab->info.num_blocks - 1);",
                    "116": "",
                    "117": "\tfor (int i = slab->info.num_blocks - 1; i >= 0; i--) {",
                    "118": "\t\t*(char **)p = slab->free_list;",
                    "119": "\t\tslab->free_list = p;",
                    "120": "\t\tp -= slab->info.block_size;",
                    "121": "\t}",
                    "122": "",
                    "123": "\treturn 0;",
                    "124": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_thread_alloc_helper": {
            "name": "z_thread_alloc_helper",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 175,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE */\nstatic void *z_thread_alloc_helper(size_t align, size_t size,\n\t\t\t\t   sys_heap_allocator_t sys_heap_allocator)\n{\n\tvoid *ret;\n\tstruct k_heap *heap;\n\n\tif (k_is_in_isr()) {\n\t\theap = _SYSTEM_HEAP;\n\t} else {\n\t\theap = _current->resource_pool;\n\t}\n\n\tif (heap != NULL) {\n\t\tret = z_alloc_helper(heap, align, size, sys_heap_allocator);\n\t} else {\n\t\tret = NULL;\n\t}\n\n\treturn ret;\n}\n",
                {
                    "175": "static void *z_thread_alloc_helper(size_t align, size_t size,",
                    "176": "\t\t\t\t   sys_heap_allocator_t sys_heap_allocator)",
                    "177": "{",
                    "178": "\tvoid *ret;",
                    "179": "\tstruct k_heap *heap;",
                    "180": "",
                    "181": "\tif (k_is_in_isr()) {",
                    "182": "\t\theap = _SYSTEM_HEAP;",
                    "183": "\t} else {",
                    "184": "\t\theap = _current->resource_pool;",
                    "185": "\t}",
                    "186": "",
                    "187": "\tif (heap != NULL) {",
                    "188": "\t\tret = z_alloc_helper(heap, align, size, sys_heap_allocator);",
                    "189": "\t} else {",
                    "190": "\t\tret = NULL;",
                    "191": "\t}",
                    "192": "",
                    "193": "\treturn ret;",
                    "194": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_alloc_helper": {
            "name": "z_alloc_helper",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/mempool.c",
            "location_line": 14,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstatic void *z_alloc_helper(struct k_heap *heap, size_t align, size_t size,\n\t\t\t    sys_heap_allocator_t sys_heap_allocator)\n{\n\tvoid *mem;\n\tstruct k_heap **heap_ref;\n\tsize_t __align;\n\tk_spinlock_key_t key;\n\n\t/* A power of 2 as well as 0 is OK */\n\t__ASSERT((align & (align - 1)) == 0,\n\t\t\"align must be a power of 2\");\n\n\t/*\n\t * Adjust the size to make room for our heap reference.\n\t * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).\n\t * This allows for storing the heap pointer right below the aligned\n\t * boundary without wasting any memory.\n\t */\n\tif (size_add_overflow(size, sizeof(heap_ref), &size)) {\n\t\treturn NULL;\n\t}\n\t__align = align | sizeof(heap_ref);\n\n\t/*\n\t * No point calling k_heap_malloc/k_heap_aligned_alloc with K_NO_WAIT.\n\t * Better bypass them and go directly to sys_heap_*() instead.\n\t */\n\tkey = k_spin_lock(&heap->lock);\n\tmem = sys_heap_allocator(&heap->heap, __align, size);\n\tk_spin_unlock(&heap->lock, key);\n\n\tif (mem == NULL) {\n\t\treturn NULL;\n\t}\n\n\theap_ref = mem;\n\t*heap_ref = heap;\n\tmem = ++heap_ref;\n\t__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,\n\t\t \"misaligned memory at %p (align = %zu)\", mem, align);\n\n\treturn mem;\n}\n",
                {
                    "14": "static void *z_alloc_helper(struct k_heap *heap, size_t align, size_t size,",
                    "15": "\t\t\t    sys_heap_allocator_t sys_heap_allocator)",
                    "16": "{",
                    "17": "\tvoid *mem;",
                    "18": "\tstruct k_heap **heap_ref;",
                    "19": "\tsize_t __align;",
                    "20": "\tk_spinlock_key_t key;",
                    "21": "",
                    "22": "\t/* A power of 2 as well as 0 is OK */",
                    "23": "\t__ASSERT((align & (align - 1)) == 0,",
                    "24": "\t\t\"align must be a power of 2\");",
                    "25": "",
                    "26": "\t/*",
                    "27": "\t * Adjust the size to make room for our heap reference.",
                    "28": "\t * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).",
                    "29": "\t * This allows for storing the heap pointer right below the aligned",
                    "30": "\t * boundary without wasting any memory.",
                    "31": "\t */",
                    "32": "\tif (size_add_overflow(size, sizeof(heap_ref), &size)) {",
                    "33": "\t\treturn NULL;",
                    "34": "\t}",
                    "35": "\t__align = align | sizeof(heap_ref);",
                    "36": "",
                    "37": "\t/*",
                    "38": "\t * No point calling k_heap_malloc/k_heap_aligned_alloc with K_NO_WAIT.",
                    "39": "\t * Better bypass them and go directly to sys_heap_*() instead.",
                    "40": "\t */",
                    "41": "\tkey = k_spin_lock(&heap->lock);",
                    "42": "\tmem = sys_heap_allocator(&heap->heap, __align, size);",
                    "43": "\tk_spin_unlock(&heap->lock, key);",
                    "44": "",
                    "45": "\tif (mem == NULL) {",
                    "46": "\t\treturn NULL;",
                    "47": "\t}",
                    "48": "",
                    "49": "\theap_ref = mem;",
                    "50": "\t*heap_ref = heap;",
                    "51": "\tmem = ++heap_ref;",
                    "52": "\t__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,",
                    "53": "\t\t \"misaligned memory at %p (align = %zu)\", mem, align);",
                    "54": "",
                    "55": "\treturn mem;",
                    "56": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "copy_to_pending_readers": {
            "name": "copy_to_pending_readers",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/pipe.c",
            "location_line": 93,
            "function_content": [
                "#endif /* CONFIG_OBJ_CORE_PIPE */\nstatic size_t copy_to_pending_readers(struct k_pipe *pipe, bool *need_resched,\n\t\t\t\t      const uint8_t *data, size_t len)\n{\n\tstruct k_thread *reader = NULL;\n\tstruct pipe_buf_spec *reader_buf;\n\tsize_t copy_size, written = 0;\n\n\t/*\n\t * Attempt a direct data copy to waiting readers if any.\n\t * The copy has to be done under the scheduler lock to ensure all the\n\t * needed data is copied to the target thread whose buffer spec lives\n\t * on that thread's stack, and then the thread unpended only if it\n\t * received all the data it wanted, without racing with a potential\n\t * thread timeout/cancellation event.\n\t */\n\tdo {\n\t\tLOCK_SCHED_SPINLOCK {\n\t\t\treader = _priq_wait_best(&pipe->data.waitq);\n\t\t\tif (reader == NULL) {\n\t\t\t\tK_SPINLOCK_BREAK;\n\t\t\t}\n\n\t\t\treader_buf = reader->base.swap_data;\n\t\t\tcopy_size = min(len - written,\n\t\t\t\t\treader_buf->len - reader_buf->used);\n\t\t\tmemcpy(&reader_buf->data[reader_buf->used],\n\t\t\t       &data[written], copy_size);\n\t\t\twritten += copy_size;\n\t\t\treader_buf->used += copy_size;\n\n\t\t\tif (reader_buf->used < reader_buf->len) {\n\t\t\t\t/* This reader wants more: don't unpend. */\n\t\t\t\treader = NULL;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This reader has received all the data\n\t\t\t\t * it was waiting for: wake it up with\n\t\t\t\t * the scheduler lock still held.\n\t\t\t\t */\n\t\t\t\tunpend_thread_no_timeout(reader);\n\t\t\t\tz_abort_thread_timeout(reader);\n\t\t\t}\n\t\t}\n\t\tif (reader != NULL) {\n\t\t\t/* rest of thread wake-up outside the scheduler lock */\n\t\t\tz_thread_return_value_set_with_data(reader, 0, NULL);\n\t\t\tz_ready_thread(reader);\n\t\t\t*need_resched = true;\n\t\t}\n\t} while (reader != NULL && written < len);\n\n\treturn written;\n}\n",
                {
                    "93": "static size_t copy_to_pending_readers(struct k_pipe *pipe, bool *need_resched,",
                    "94": "\t\t\t\t      const uint8_t *data, size_t len)",
                    "95": "{",
                    "96": "\tstruct k_thread *reader = NULL;",
                    "97": "\tstruct pipe_buf_spec *reader_buf;",
                    "98": "\tsize_t copy_size, written = 0;",
                    "99": "",
                    "100": "\t/*",
                    "101": "\t * Attempt a direct data copy to waiting readers if any.",
                    "102": "\t * The copy has to be done under the scheduler lock to ensure all the",
                    "103": "\t * needed data is copied to the target thread whose buffer spec lives",
                    "104": "\t * on that thread's stack, and then the thread unpended only if it",
                    "105": "\t * received all the data it wanted, without racing with a potential",
                    "106": "\t * thread timeout/cancellation event.",
                    "107": "\t */",
                    "108": "\tdo {",
                    "109": "\t\tLOCK_SCHED_SPINLOCK {",
                    "110": "\t\t\treader = _priq_wait_best(&pipe->data.waitq);",
                    "111": "\t\t\tif (reader == NULL) {",
                    "112": "\t\t\t\tK_SPINLOCK_BREAK;",
                    "113": "\t\t\t}",
                    "114": "",
                    "115": "\t\t\treader_buf = reader->base.swap_data;",
                    "116": "\t\t\tcopy_size = min(len - written,",
                    "117": "\t\t\t\t\treader_buf->len - reader_buf->used);",
                    "118": "\t\t\tmemcpy(&reader_buf->data[reader_buf->used],",
                    "119": "\t\t\t       &data[written], copy_size);",
                    "120": "\t\t\twritten += copy_size;",
                    "121": "\t\t\treader_buf->used += copy_size;",
                    "122": "",
                    "123": "\t\t\tif (reader_buf->used < reader_buf->len) {",
                    "124": "\t\t\t\t/* This reader wants more: don't unpend. */",
                    "125": "\t\t\t\treader = NULL;",
                    "126": "\t\t\t} else {",
                    "127": "\t\t\t\t/*",
                    "128": "\t\t\t\t * This reader has received all the data",
                    "129": "\t\t\t\t * it was waiting for: wake it up with",
                    "130": "\t\t\t\t * the scheduler lock still held.",
                    "131": "\t\t\t\t */",
                    "132": "\t\t\t\tunpend_thread_no_timeout(reader);",
                    "133": "\t\t\t\tz_abort_thread_timeout(reader);",
                    "134": "\t\t\t}",
                    "135": "\t\t}",
                    "136": "\t\tif (reader != NULL) {",
                    "137": "\t\t\t/* rest of thread wake-up outside the scheduler lock */",
                    "138": "\t\t\tz_thread_return_value_set_with_data(reader, 0, NULL);",
                    "139": "\t\t\tz_ready_thread(reader);",
                    "140": "\t\t\t*need_resched = true;",
                    "141": "\t\t}",
                    "142": "\t} while (reader != NULL && written < len);",
                    "143": "",
                    "144": "\treturn written;",
                    "145": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "poller_thread": {
            "name": "poller_thread",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/poll.c",
            "location_line": 106,
            "function_content": [
                "/* must be called with interrupts locked */\nstatic struct k_thread *poller_thread(struct z_poller *p)\n{\n\treturn p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;\n}\n",
                {
                    "106": "static struct k_thread *poller_thread(struct z_poller *p)",
                    "107": "{",
                    "108": "\treturn p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;",
                    "109": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "queue_insert": {
            "name": "queue_insert",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 132,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic int32_t queue_insert(struct k_queue *queue, void *prev, void *data,\n\t\t\t    bool alloc, bool is_append)\n{\n\tstruct k_thread *first_pending_thread;\n\tk_spinlock_key_t key = k_spin_lock(&queue->lock);\n\tint32_t result = 0;\n\tbool resched = false;\n\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);\n\n\tif (is_append) {\n\t\tprev = sys_sflist_peek_tail(&queue->data_q);\n\t}\n\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);\n\n\tif (unlikely(first_pending_thread != NULL)) {\n\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);\n\n\t\tprepare_thread_to_run(first_pending_thread, data);\n\t\tresched = true;\n\t\tgoto out;\n\t}\n\n\t/* Only need to actually allocate if no threads are pending */\n\tif (alloc) {\n\t\tstruct alloc_node *anode;\n\n\t\tanode = z_thread_malloc(sizeof(*anode));\n\t\tif (anode == NULL) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tanode->data = data;\n\t\tsys_sfnode_init(&anode->node, 0x1);\n\t\tdata = anode;\n\t} else {\n\t\tsys_sfnode_init(data, 0x0);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);\n\n\tsys_sflist_insert(&queue->data_q, prev, data);\n\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);\n\nout:\n\tif (resched) {\n\t\tz_reschedule(&queue->lock, key);\n\t} else {\n\t\tk_spin_unlock(&queue->lock, key);\n\t}\n\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, result);\n\n\treturn result;\n}\n",
                {
                    "132": "static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,",
                    "133": "\t\t\t    bool alloc, bool is_append)",
                    "134": "{",
                    "135": "\tstruct k_thread *first_pending_thread;",
                    "136": "\tk_spinlock_key_t key = k_spin_lock(&queue->lock);",
                    "137": "\tint32_t result = 0;",
                    "138": "\tbool resched = false;",
                    "139": "",
                    "140": "\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);",
                    "141": "",
                    "142": "\tif (is_append) {",
                    "143": "\t\tprev = sys_sflist_peek_tail(&queue->data_q);",
                    "144": "\t}",
                    "145": "\tfirst_pending_thread = z_unpend_first_thread(&queue->wait_q);",
                    "146": "",
                    "147": "\tif (unlikely(first_pending_thread != NULL)) {",
                    "148": "\t\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);",
                    "149": "",
                    "150": "\t\tprepare_thread_to_run(first_pending_thread, data);",
                    "151": "\t\tresched = true;",
                    "152": "\t\tgoto out;",
                    "153": "\t}",
                    "154": "",
                    "155": "\t/* Only need to actually allocate if no threads are pending */",
                    "156": "\tif (alloc) {",
                    "157": "\t\tstruct alloc_node *anode;",
                    "158": "",
                    "159": "\t\tanode = z_thread_malloc(sizeof(*anode));",
                    "160": "\t\tif (anode == NULL) {",
                    "161": "\t\t\tresult = -ENOMEM;",
                    "162": "\t\t\tgoto out;",
                    "163": "\t\t}",
                    "164": "\t\tanode->data = data;",
                    "165": "\t\tsys_sfnode_init(&anode->node, 0x1);",
                    "166": "\t\tdata = anode;",
                    "167": "\t} else {",
                    "168": "\t\tsys_sfnode_init(data, 0x0);",
                    "169": "\t}",
                    "170": "",
                    "171": "\tSYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);",
                    "172": "",
                    "173": "\tsys_sflist_insert(&queue->data_q, prev, data);",
                    "174": "\tresched = handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);",
                    "175": "",
                    "176": "out:",
                    "177": "\tif (resched) {",
                    "178": "\t\tz_reschedule(&queue->lock, key);",
                    "179": "\t} else {",
                    "180": "\t\tk_spin_unlock(&queue->lock, key);",
                    "181": "\t}",
                    "182": "",
                    "183": "\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, result);",
                    "184": "",
                    "185": "\treturn result;",
                    "186": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "prepare_thread_to_run": {
            "name": "prepare_thread_to_run",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 81,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic void prepare_thread_to_run(struct k_thread *thread, void *data)\n{\n\tz_thread_return_value_set_with_data(thread, 0, data);\n\tz_ready_thread(thread);\n}\n",
                {
                    "81": "static void prepare_thread_to_run(struct k_thread *thread, void *data)",
                    "82": "{",
                    "83": "\tz_thread_return_value_set_with_data(thread, 0, data);",
                    "84": "\tz_ready_thread(thread);",
                    "85": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_queue_node_peek": {
            "name": "z_queue_node_peek",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/queue.c",
            "location_line": 30,
            "function_content": [
                "/**\n* @file\n*\n* @brief dynamic-size QUEUE object.\n*/\nvoid *z_queue_node_peek(sys_sfnode_t *node, bool needs_free)\n{\n\tvoid *ret;\n\n\tif ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {\n\t\t/* If the flag is set, then the enqueue operation for this item\n\t\t * did a behind-the scenes memory allocation of an alloc_node\n\t\t * struct, which is what got put in the queue. Free it and pass\n\t\t * back the data pointer.\n\t\t */\n\t\tstruct alloc_node *anode;\n\n\t\tanode = CONTAINER_OF(node, struct alloc_node, node);\n\t\tret = anode->data;\n\t\tif (needs_free) {\n\t\t\tk_free(anode);\n\t\t}\n\t} else {\n\t\t/* Data was directly placed in the queue, the first word\n\t\t * reserved for the linked list. User mode isn't allowed to\n\t\t * do this, although it can get data sent this way.\n\t\t */\n\t\tret = (void *)node;\n\t}\n\n\treturn ret;\n}\n",
                {
                    "30": "void *z_queue_node_peek(sys_sfnode_t *node, bool needs_free)",
                    "31": "{",
                    "32": "\tvoid *ret;",
                    "33": "",
                    "34": "\tif ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {",
                    "35": "\t\t/* If the flag is set, then the enqueue operation for this item",
                    "36": "\t\t * did a behind-the scenes memory allocation of an alloc_node",
                    "37": "\t\t * struct, which is what got put in the queue. Free it and pass",
                    "38": "\t\t * back the data pointer.",
                    "39": "\t\t */",
                    "40": "\t\tstruct alloc_node *anode;",
                    "41": "",
                    "42": "\t\tanode = CONTAINER_OF(node, struct alloc_node, node);",
                    "43": "\t\tret = anode->data;",
                    "44": "\t\tif (needs_free) {",
                    "45": "\t\t\tk_free(anode);",
                    "46": "\t\t}",
                    "47": "\t} else {",
                    "48": "\t\t/* Data was directly placed in the queue, the first word",
                    "49": "\t\t * reserved for the linked list. User mode isn't allowed to",
                    "50": "\t\t * do this, although it can get data sent this way.",
                    "51": "\t\t */",
                    "52": "\t\tret = (void *)node;",
                    "53": "\t}",
                    "54": "",
                    "55": "\treturn ret;",
                    "56": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_sys_csrand_get": {
            "name": "z_impl_sys_csrand_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/random/random_entropy_device.c",
            "location_line": 69,
            "function_content": [
                "#endif /* CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR */\nint z_impl_sys_csrand_get(void *dst, size_t outlen)\n{\n\tif (rand_get(dst, outlen, true) != 0) {\n\t\t/* Is it the only error it should return ? entropy_sam\n\t\t * can return -ETIMEDOUT for example\n\t\t */\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "69": "int z_impl_sys_csrand_get(void *dst, size_t outlen)",
                    "70": "{",
                    "71": "\tif (rand_get(dst, outlen, true) != 0) {",
                    "72": "\t\t/* Is it the only error it should return ? entropy_sam",
                    "73": "\t\t * can return -ETIMEDOUT for example",
                    "74": "\t\t */",
                    "75": "\t\treturn -EIO;",
                    "76": "\t}",
                    "77": "",
                    "78": "\treturn 0;",
                    "79": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_impl_sys_rand_get": {
            "name": "z_impl_sys_rand_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/random/random_entropy_device.c",
            "location_line": 61,
            "function_content": [
                "/* Use system timer in case the entropy device couldn't deliver\n* 32-bit of data.  There's not much that can be done in this\n* situation.  An __ASSERT() isn't used here as the HWRNG might\n* still be gathering entropy during early boot situations.\n*/\nvoid z_impl_sys_rand_get(void *dst, size_t outlen)\n{\n\trand_get(dst, outlen, false);\n}\n",
                {
                    "61": "void z_impl_sys_rand_get(void *dst, size_t outlen)",
                    "62": "{",
                    "63": "\trand_get(dst, outlen, false);",
                    "64": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "copy_bytes": {
            "name": "copy_bytes",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/thread.c",
            "location_line": 216,
            "function_content": [
                "#endif /* CONFIG_THREAD_NAME */\nstatic size_t copy_bytes(char *dest, size_t dest_size, const char *src, size_t src_size)\n{\n\tsize_t  bytes_to_copy;\n\n\tbytes_to_copy = min(dest_size, src_size);\n\tmemcpy(dest, src, bytes_to_copy);\n\n\treturn bytes_to_copy;\n}\n",
                {
                    "216": "static size_t copy_bytes(char *dest, size_t dest_size, const char *src, size_t src_size)",
                    "217": "{",
                    "218": "\tsize_t  bytes_to_copy;",
                    "219": "",
                    "220": "\tbytes_to_copy = min(dest_size, src_size);",
                    "221": "\tmemcpy(dest, src, bytes_to_copy);",
                    "222": "",
                    "223": "\treturn bytes_to_copy;",
                    "224": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "first": {
            "name": "first",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/kernel/timeout.c",
            "location_line": 41,
            "function_content": [
                "#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */\nstatic struct _timeout *first(void)\n{\n\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);\n\n\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);\n}\n",
                {
                    "41": "static struct _timeout *first(void)",
                    "42": "{",
                    "43": "\tsys_dnode_t *t = sys_dlist_peek_head(&timeout_list);",
                    "44": "",
                    "45": "\treturn (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);",
                    "46": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "inplace_realloc": {
            "name": "inplace_realloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 387,
            "function_content": [
                "/* Split and free unused suffix */\nstatic bool inplace_realloc(struct sys_heap *heap, void *ptr, size_t bytes)\n{\n\tstruct z_heap *h = heap->heap;\n\n\tchunkid_t c = mem_to_chunkid(h, ptr);\n\tsize_t align_gap = (uint8_t *)ptr - (uint8_t *)chunk_mem(h, c);\n\n\tchunksz_t chunks_need = bytes_to_chunksz(h, bytes, align_gap);\n\n\tif (chunk_size(h, c) == chunks_need) {\n\t\t/* We're good already */\n\t\treturn true;\n\t}\n\n\tif (chunk_size(h, c) > chunks_need) {\n\t\t/* Shrink in place, split off and free unused suffix */\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\t\tsize_t bytes_freed = chunksz_to_bytes(h, chunk_size(h, c));\n#endif\n\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\t\th->allocated_bytes -=\n\t\t\t(chunk_size(h, c) - chunks_need) * CHUNK_UNIT;\n#endif\n\n\t\tsplit_chunks(h, c, c + chunks_need);\n\t\tset_chunk_used(h, c, true);\n\t\tfree_chunk(h, c + chunks_need);\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\t\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), ptr,\n\t\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));\n\t\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), ptr,\n\t\t\t\t\t  bytes_freed);\n#endif\n\n\t\treturn true;\n\t}\n\n\tchunkid_t rc = right_chunk(h, c);\n\n\tif (!chunk_used(h, rc) &&\n\t    (chunk_size(h, c) + chunk_size(h, rc) >= chunks_need)) {\n\t\t/* Expand: split the right chunk and append */\n\t\tchunksz_t split_size = chunks_need - chunk_size(h, c);\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\t\tsize_t bytes_freed = chunksz_to_bytes(h, chunk_size(h, c));\n#endif\n\n#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS\n\t\tincrease_allocated_bytes(h, split_size * CHUNK_UNIT);\n#endif\n\n\t\tfree_list_remove(h, rc);\n\n\t\tif (split_size < chunk_size(h, rc)) {\n\t\t\tsplit_chunks(h, rc, rc + split_size);\n\t\t\tfree_list_add(h, rc + split_size);\n\t\t}\n\n\t\tmerge_chunks(h, c, rc);\n\t\tset_chunk_used(h, c, true);\n\n#ifdef CONFIG_SYS_HEAP_LISTENER\n\t\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), ptr,\n\t\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));\n\t\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), ptr,\n\t\t\t\t\t  bytes_freed);\n#endif\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
                {
                    "387": "static bool inplace_realloc(struct sys_heap *heap, void *ptr, size_t bytes)",
                    "388": "{",
                    "389": "\tstruct z_heap *h = heap->heap;",
                    "390": "",
                    "391": "\tchunkid_t c = mem_to_chunkid(h, ptr);",
                    "392": "\tsize_t align_gap = (uint8_t *)ptr - (uint8_t *)chunk_mem(h, c);",
                    "393": "",
                    "394": "\tchunksz_t chunks_need = bytes_to_chunksz(h, bytes, align_gap);",
                    "395": "",
                    "396": "\tif (chunk_size(h, c) == chunks_need) {",
                    "397": "\t\t/* We're good already */",
                    "398": "\t\treturn true;",
                    "399": "\t}",
                    "400": "",
                    "401": "\tif (chunk_size(h, c) > chunks_need) {",
                    "402": "\t\t/* Shrink in place, split off and free unused suffix */",
                    "403": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "404": "\t\tsize_t bytes_freed = chunksz_to_bytes(h, chunk_size(h, c));",
                    "405": "#endif",
                    "406": "",
                    "407": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "408": "\t\th->allocated_bytes -=",
                    "409": "\t\t\t(chunk_size(h, c) - chunks_need) * CHUNK_UNIT;",
                    "410": "#endif",
                    "411": "",
                    "412": "\t\tsplit_chunks(h, c, c + chunks_need);",
                    "413": "\t\tset_chunk_used(h, c, true);",
                    "414": "\t\tfree_chunk(h, c + chunks_need);",
                    "415": "",
                    "416": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "417": "\t\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), ptr,",
                    "418": "\t\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));",
                    "419": "\t\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), ptr,",
                    "420": "\t\t\t\t\t  bytes_freed);",
                    "421": "#endif",
                    "422": "",
                    "423": "\t\treturn true;",
                    "424": "\t}",
                    "425": "",
                    "426": "\tchunkid_t rc = right_chunk(h, c);",
                    "427": "",
                    "428": "\tif (!chunk_used(h, rc) &&",
                    "429": "\t    (chunk_size(h, c) + chunk_size(h, rc) >= chunks_need)) {",
                    "430": "\t\t/* Expand: split the right chunk and append */",
                    "431": "\t\tchunksz_t split_size = chunks_need - chunk_size(h, c);",
                    "432": "",
                    "433": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "434": "\t\tsize_t bytes_freed = chunksz_to_bytes(h, chunk_size(h, c));",
                    "435": "#endif",
                    "436": "",
                    "437": "#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS",
                    "438": "\t\tincrease_allocated_bytes(h, split_size * CHUNK_UNIT);",
                    "439": "#endif",
                    "440": "",
                    "441": "\t\tfree_list_remove(h, rc);",
                    "442": "",
                    "443": "\t\tif (split_size < chunk_size(h, rc)) {",
                    "444": "\t\t\tsplit_chunks(h, rc, rc + split_size);",
                    "445": "\t\t\tfree_list_add(h, rc + split_size);",
                    "446": "\t\t}",
                    "447": "",
                    "448": "\t\tmerge_chunks(h, c, rc);",
                    "449": "\t\tset_chunk_used(h, c, true);",
                    "450": "",
                    "451": "#ifdef CONFIG_SYS_HEAP_LISTENER",
                    "452": "\t\theap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), ptr,",
                    "453": "\t\t\t\t\t   chunksz_to_bytes(h, chunk_size(h, c)));",
                    "454": "\t\theap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), ptr,",
                    "455": "\t\t\t\t\t  bytes_freed);",
                    "456": "#endif",
                    "457": "",
                    "458": "\t\treturn true;",
                    "459": "\t}",
                    "460": "",
                    "461": "\treturn false;",
                    "462": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mem_to_chunkid": {
            "name": "mem_to_chunkid",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 157,
            "function_content": [
                "/*\n* Return the closest chunk ID corresponding to given memory pointer.\n* Here \"closest\" is only meaningful in the context of sys_heap_aligned_alloc()\n* where wanted alignment might not always correspond to a chunk header\n* boundary.\n*/\nstatic chunkid_t mem_to_chunkid(struct z_heap *h, void *p)\n{\n\tuint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);\n\treturn (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;\n}\n",
                {
                    "157": "static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)",
                    "158": "{",
                    "159": "\tuint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);",
                    "160": "\treturn (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;",
                    "161": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "chunk_mem": {
            "name": "chunk_mem",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/heap/heap.c",
            "location_line": 24,
            "function_content": [
                "/*\n* Copyright (c) 2019 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstatic void *chunk_mem(struct z_heap *h, chunkid_t c)\n{\n\tchunk_unit_t *buf = chunk_buf(h);\n\tuint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);\n\n\tCHECK(!(((uintptr_t)ret) & (big_heap(h) ? 7 : 3)));\n\n\treturn ret;\n}\n",
                {
                    "24": "static void *chunk_mem(struct z_heap *h, chunkid_t c)",
                    "25": "{",
                    "26": "\tchunk_unit_t *buf = chunk_buf(h);",
                    "27": "\tuint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);",
                    "28": "",
                    "29": "\tCHECK(!(((uintptr_t)ret) & (big_heap(h) ? 7 : 3)));",
                    "30": "",
                    "31": "\treturn ret;",
                    "32": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "data_ref": {
            "name": "data_ref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 237,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE > 0 */\nstatic uint8_t *data_ref(struct net_buf *buf, uint8_t *data)\n{\n\tstruct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);\n\n\treturn pool->alloc->cb->ref(buf, data);\n}\n",
                {
                    "237": "static uint8_t *data_ref(struct net_buf *buf, uint8_t *data)",
                    "238": "{",
                    "239": "\tstruct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);",
                    "240": "",
                    "241": "\treturn pool->alloc->cb->ref(buf, data);",
                    "242": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "data_alloc": {
            "name": "data_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 230,
            "function_content": [
                "#endif /* K_HEAP_MEM_POOL_SIZE > 0 */\nstatic uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)\n{\n\tstruct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);\n\n\treturn pool->alloc->cb->alloc(buf, size, timeout);\n}\n",
                {
                    "230": "static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)",
                    "231": "{",
                    "232": "\tstruct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);",
                    "233": "",
                    "234": "\treturn pool->alloc->cb->alloc(buf, size, timeout);",
                    "235": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "heap_data_unref": {
            "name": "heap_data_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 204,
            "function_content": [
                "/* Nothing needed for fixed-size data pools */\nstatic void heap_data_unref(struct net_buf *buf, uint8_t *data)\n{\n\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);\n\tuint8_t *ref_count;\n\n\tref_count = data - GET_ALIGN(buf_pool);\n\tif (--(*ref_count)) {\n\t\treturn;\n\t}\n\n\tk_free(ref_count);\n}\n",
                {
                    "204": "static void heap_data_unref(struct net_buf *buf, uint8_t *data)",
                    "205": "{",
                    "206": "\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);",
                    "207": "\tuint8_t *ref_count;",
                    "208": "",
                    "209": "\tref_count = data - GET_ALIGN(buf_pool);",
                    "210": "\tif (--(*ref_count)) {",
                    "211": "\t\treturn;",
                    "212": "\t}",
                    "213": "",
                    "214": "\tk_free(ref_count);",
                    "215": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "heap_data_alloc": {
            "name": "heap_data_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 188,
            "function_content": [
                "/* Nothing needed for fixed-size data pools */\nstatic uint8_t *heap_data_alloc(struct net_buf *buf, size_t *size,\n\t\t\t     k_timeout_t timeout)\n{\n\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);\n\tuint8_t *ref_count;\n\n\tref_count = k_malloc(GET_ALIGN(buf_pool) + *size);\n\tif (!ref_count) {\n\t\treturn NULL;\n\t}\n\n\t*ref_count = 1U;\n\n\treturn ref_count + GET_ALIGN(buf_pool);\n}\n",
                {
                    "188": "static uint8_t *heap_data_alloc(struct net_buf *buf, size_t *size,",
                    "189": "\t\t\t     k_timeout_t timeout)",
                    "190": "{",
                    "191": "\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);",
                    "192": "\tuint8_t *ref_count;",
                    "193": "",
                    "194": "\tref_count = k_malloc(GET_ALIGN(buf_pool) + *size);",
                    "195": "\tif (!ref_count) {",
                    "196": "\t\treturn NULL;",
                    "197": "\t}",
                    "198": "",
                    "199": "\t*ref_count = 1U;",
                    "200": "",
                    "201": "\treturn ref_count + GET_ALIGN(buf_pool);",
                    "202": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mem_pool_data_unref": {
            "name": "mem_pool_data_unref",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 144,
            "function_content": [
                "/* Return pointer to the byte following the ref count */\nstatic void mem_pool_data_unref(struct net_buf *buf, uint8_t *data)\n{\n\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);\n\tstruct k_heap *pool = buf_pool->alloc->alloc_data;\n\tuint8_t *ref_count;\n\n\tref_count = data - GET_ALIGN(buf_pool);\n\tif (--(*ref_count)) {\n\t\treturn;\n\t}\n\n\t/* Need to copy to local variable due to alignment */\n\tk_heap_free(pool, ref_count);\n}\n",
                {
                    "144": "static void mem_pool_data_unref(struct net_buf *buf, uint8_t *data)",
                    "145": "{",
                    "146": "\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);",
                    "147": "\tstruct k_heap *pool = buf_pool->alloc->alloc_data;",
                    "148": "\tuint8_t *ref_count;",
                    "149": "",
                    "150": "\tref_count = data - GET_ALIGN(buf_pool);",
                    "151": "\tif (--(*ref_count)) {",
                    "152": "\t\treturn;",
                    "153": "\t}",
                    "154": "",
                    "155": "\t/* Need to copy to local variable due to alignment */",
                    "156": "\tk_heap_free(pool, ref_count);",
                    "157": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "mem_pool_data_alloc": {
            "name": "mem_pool_data_alloc",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/net_buf/buf.c",
            "location_line": 106,
            "function_content": [
                "/* Linker-defined symbol bound to the static pool structs */\nstatic uint8_t *mem_pool_data_alloc(struct net_buf *buf, size_t *size,\n\t\t\t\t k_timeout_t timeout)\n{\n\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);\n\tstruct k_heap *pool = buf_pool->alloc->alloc_data;\n\tuint8_t *ref_count;\n\tvoid *b;\n\n\tif (buf_pool->alloc->alignment == 0) {\n\t\t/* Reserve extra space for a ref-count (uint8_t) */\n\t\tb = k_heap_alloc(pool, sizeof(void *) + *size, timeout);\n\n\t} else {\n\t\tif (*size < buf_pool->alloc->alignment) {\n\t\t\tNET_BUF_DBG(\"Requested size %zu is smaller than alignment %zu\",\n\t\t\t\t    *size, buf_pool->alloc->alignment);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reserve extra space for a ref-count (uint8_t) */\n\t\tb = k_heap_aligned_alloc(pool,\n\t\t\t\t\t buf_pool->alloc->alignment,\n\t\t\t\t\t GET_ALIGN(buf_pool) +\n\t\t\t\t\t ROUND_UP(*size, buf_pool->alloc->alignment),\n\t\t\t\t\t timeout);\n\t}\n\n\tif (b == NULL) {\n\t\treturn NULL;\n\t}\n\n\tref_count = (uint8_t *)b;\n\t*ref_count = 1U;\n\n\t/* Return pointer to the byte following the ref count */\n\treturn ref_count + GET_ALIGN(buf_pool);\n}\n",
                {
                    "106": "static uint8_t *mem_pool_data_alloc(struct net_buf *buf, size_t *size,",
                    "107": "\t\t\t\t k_timeout_t timeout)",
                    "108": "{",
                    "109": "\tstruct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);",
                    "110": "\tstruct k_heap *pool = buf_pool->alloc->alloc_data;",
                    "111": "\tuint8_t *ref_count;",
                    "112": "\tvoid *b;",
                    "113": "",
                    "114": "\tif (buf_pool->alloc->alignment == 0) {",
                    "115": "\t\t/* Reserve extra space for a ref-count (uint8_t) */",
                    "116": "\t\tb = k_heap_alloc(pool, sizeof(void *) + *size, timeout);",
                    "117": "",
                    "118": "\t} else {",
                    "119": "\t\tif (*size < buf_pool->alloc->alignment) {",
                    "120": "\t\t\tNET_BUF_DBG(\"Requested size %zu is smaller than alignment %zu\",",
                    "121": "\t\t\t\t    *size, buf_pool->alloc->alignment);",
                    "122": "\t\t\treturn NULL;",
                    "123": "\t\t}",
                    "124": "",
                    "125": "\t\t/* Reserve extra space for a ref-count (uint8_t) */",
                    "126": "\t\tb = k_heap_aligned_alloc(pool,",
                    "127": "\t\t\t\t\t buf_pool->alloc->alignment,",
                    "128": "\t\t\t\t\t GET_ALIGN(buf_pool) +",
                    "129": "\t\t\t\t\t ROUND_UP(*size, buf_pool->alloc->alignment),",
                    "130": "\t\t\t\t\t timeout);",
                    "131": "\t}",
                    "132": "",
                    "133": "\tif (b == NULL) {",
                    "134": "\t\treturn NULL;",
                    "135": "\t}",
                    "136": "",
                    "137": "\tref_count = (uint8_t *)b;",
                    "138": "\t*ref_count = 1U;",
                    "139": "",
                    "140": "\t/* Return pointer to the byte following the ref count */",
                    "141": "\treturn ref_count + GET_ALIGN(buf_pool);",
                    "142": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_cbvprintf_impl": {
            "name": "z_cbvprintf_impl",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_complete.c",
            "location_line": 1370,
            "function_content": [
                "/* Outline function to emit all characters in [sp, ep). */\nint z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,\n\t\t     va_list ap, uint32_t flags)\n{\n\tchar buf[CONVERTED_BUFLEN];\n\tsize_t count = 0;\n\tsint_value_type sint;\n\tcbprintf_cb_local out = __out;\n\n\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)\n\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;\n\n/* Output character, returning EOF if output failed, otherwise\n * updating count.\n *\n * NB: c is evaluated exactly once: side-effects are OK\n */\n#define OUTC(c) do { \\\n\tint rc = (*out)((int)(c), ctx); \\\n\t\\\n\tif (rc < 0) { \\\n\t\treturn rc; \\\n\t} \\\n\t++count; \\\n} while (false)\n\n/* Output sequence of characters, returning a negative error if output\n * failed.\n */\n\n#define OUTS(_sp, _ep) do { \\\n\tint rc = outs(out, ctx, (_sp), (_ep)); \\\n\t\\\n\tif (rc < 0) {\t    \\\n\t\treturn rc; \\\n\t} \\\n\tcount += rc; \\\n} while (false)\n\n\twhile (*fp != 0) {\n\t\tif (*fp != '%') {\n\t\t\tOUTC(*fp);\n\t\t\t++fp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Force union into RAM with conversion state to\n\t\t * mitigate LLVM code generation bug.\n\t\t */\n\t\tstruct {\n\t\t\tunion argument_value value;\n\t\t\tstruct conversion conv;\n\t\t} state = {\n\t\t\t.value = {\n\t\t\t\t.uint = 0,\n\t\t\t},\n\t\t};\n\t\tstruct conversion *const conv = &state.conv;\n\t\tunion argument_value *const value = &state.value;\n\t\tconst char *sp = fp;\n\t\tint width = -1;\n\t\tint precision = -1;\n\t\tconst char *bps = NULL;\n\t\tconst char *bpe = buf + sizeof(buf);\n\t\tchar sign = 0;\n\n\t\tfp = extract_conversion(conv, sp);\n\n\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\t\t\t    && tagged_ap) {\n\t\t\t\t/* Skip over the argument tag as it is not being\n\t\t\t\t * used here.\n\t\t\t\t */\n\t\t\t\t(void)va_arg(ap, int);\n\t\t\t}\n\t\t}\n\n\t\t/* If dynamic width is specified, process it,\n\t\t * otherwise set width if present.\n\t\t */\n\t\tif (conv->width_star) {\n\t\t\twidth = va_arg(ap, int);\n\n\t\t\tif (width < 0) {\n\t\t\t\tconv->flag_dash = true;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t} else if (conv->width_present) {\n\t\t\twidth = conv->width_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* If dynamic precision is specified, process it, otherwise\n\t\t * set precision if present.  For floating point where\n\t\t * precision is not present use 6.\n\t\t */\n\t\tif (conv->prec_star) {\n\t\t\tint arg = va_arg(ap, int);\n\n\t\t\tif (arg < 0) {\n\t\t\t\tconv->prec_present = false;\n\t\t\t} else {\n\t\t\t\tprecision = arg;\n\t\t\t}\n\t\t} else if (conv->prec_present) {\n\t\t\tprecision = conv->prec_value;\n\t\t} else {\n\t\t\t;\n\t\t}\n\n\t\t/* Reuse width and precision memory in conv for value\n\t\t * padding counts.\n\t\t */\n\t\tconv->pad0_value = 0;\n\t\tconv->pad0_pre_exp = 0;\n\n\t\t/* FP conversion requires knowing the precision. */\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)\n\t\t    && (conv->specifier_cat == SPECIFIER_FP)\n\t\t    && !conv->prec_present) {\n\t\t\tif (conv->specifier_a) {\n\t\t\t\tprecision = FRACTION_HEX;\n\t\t\t} else {\n\t\t\t\tprecision = 6;\n\t\t\t}\n\t\t}\n\n\t\t/* Get the value to be converted from the args.\n\t\t *\n\t\t * This can't be extracted to a helper function because\n\t\t * passing a pointer to va_list doesn't work on x86_64.  See\n\t\t * https://stackoverflow.com/a/8048892.\n\t\t */\n\t\tenum specifier_cat_enum specifier_cat\n\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;\n\t\tenum length_mod_enum length_mod\n\t\t\t= (enum length_mod_enum)conv->length_mod;\n\n\t\t/* Extract the value based on the argument category and length.\n\t\t *\n\t\t * Note that the length modifier doesn't affect the value of a\n\t\t * pointer argument.\n\t\t */\n\t\tif (specifier_cat == SPECIFIER_SINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->sint = va_arg(ap, int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif (WCHAR_IS_SIGNED\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->sint = va_arg(ap, long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\t/* Though ssize_t is the signed equivalent of\n\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.\n\t\t\t\t * Assume that size_t and ptrdiff_t are the\n\t\t\t\t * unsigned and signed equivalents of each\n\t\t\t\t * other.  This can be checked in a platform\n\t\t\t\t * test.\n\t\t\t\t */\n\t\t\t\tvalue->sint =\n\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->sint = (signed char)value->sint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->sint = (short)value->sint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_UINT) {\n\t\t\tswitch (length_mod) {\n\t\t\tdefault:\n\t\t\tcase LENGTH_NONE:\n\t\t\tcase LENGTH_HH:\n\t\t\tcase LENGTH_H:\n\t\t\t\tvalue->uint = va_arg(ap, unsigned int);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_L:\n\t\t\t\tif ((!WCHAR_IS_SIGNED)\n\t\t\t\t    && (conv->specifier == 'c')) {\n\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,\n\t\t\t\t\t\t\t      WINT_TYPE);\n\t\t\t\t} else {\n\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_LL:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\tunsigned long long);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_J:\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap,\n\t\t\t\t\t\t\t\tuintmax_t);\n\t\t\t\tbreak;\n\t\t\tcase LENGTH_Z:\t\t/* size_t */\n\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */\n\t\t\t\tvalue->uint =\n\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (length_mod == LENGTH_HH) {\n\t\t\t\tvalue->uint = (unsigned char)value->uint;\n\t\t\t} else if (length_mod == LENGTH_H) {\n\t\t\t\tvalue->uint = (unsigned short)value->uint;\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_FP) {\n\t\t\tif (length_mod == LENGTH_UPPER_L) {\n\t\t\t\tvalue->ldbl = va_arg(ap, long double);\n\t\t\t} else {\n\t\t\t\tvalue->dbl = va_arg(ap, double);\n\t\t\t}\n\t\t} else if (specifier_cat == SPECIFIER_PTR) {\n\t\t\tvalue->ptr = va_arg(ap, void *);\n\t\t}\n\n\t\t/* We've now consumed all arguments related to this\n\t\t * specification.  If the conversion is invalid, or is\n\t\t * something we don't support, then output the original\n\t\t * specification and move on.\n\t\t */\n\t\tif (conv->invalid || conv->unsupported) {\n\t\t\tOUTS(sp, fp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do formatting, either into the buffer or\n\t\t * referencing external data.\n\t\t */\n\t\tswitch (conv->specifier) {\n\t\tcase '%':\n\t\t\tOUTC('%');\n\t\t\tbreak;\n\t\tcase 's': {\n\t\t\tbps = (const char *)value->ptr;\n\n\t\t\tsize_t len;\n\n\t\t\tif (precision >= 0) {\n\t\t\t\tlen = strnlen(bps, precision);\n\t\t\t} else {\n\t\t\t\tlen = strlen(bps);\n\t\t\t}\n\n\t\t\tbpe = bps + len;\n\t\t\tprecision = -1;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 'p':\n\t\t\t/* Implementation-defined: null is \"(nil)\", non-null\n\t\t\t * has 0x prefix followed by significant address hex\n\t\t\t * digits, no leading zeros.\n\t\t\t */\n\t\t\tif (value->ptr != NULL) {\n\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,\n\t\t\t\t\t\t  buf, bpe);\n\n\t\t\t\t/* Use 0x prefix */\n\t\t\t\tconv->altform_0c = true;\n\t\t\t\tconv->specifier = 'x';\n\n\t\t\t\tgoto prec_int_pad0;\n\t\t\t}\n\n\t\t\tbps = \"(nil)\";\n\t\t\tbpe = bps + 5;\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tbps = buf;\n\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;\n\t\t\tbpe = buf + 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tif (conv->flag_plus) {\n\t\t\t\tsign = '+';\n\t\t\t} else if (conv->flag_space) {\n\t\t\t\tsign = ' ';\n\t\t\t}\n\n\t\t\t/* sint/uint overlay in the union, and so\n\t\t\t * can't appear in read and write operations\n\t\t\t * in the same statement.\n\t\t\t */\n\t\t\tsint = value->sint;\n\t\t\tif (sint < 0) {\n\t\t\t\tsign = '-';\n\t\t\t\tvalue->uint = (uint_value_type)-sint;\n\t\t\t} else {\n\t\t\t\tvalue->uint = (uint_value_type)sint;\n\t\t\t}\n\n\t\t\t__fallthrough;\n\t\tcase 'o':\n\t\tcase 'u':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);\n\n\t\tprec_int_pad0:\n\t\t\t/* Update pad0 values based on precision and converted\n\t\t\t * length.  Note that a non-empty sign is not in the\n\t\t\t * converted sequence, but it does not affect the\n\t\t\t * padding size.\n\t\t\t */\n\t\t\tif (precision >= 0) {\n\t\t\t\tsize_t len = bpe - bps;\n\n\t\t\t\t/* Zero-padding flag is ignored for integer\n\t\t\t\t * conversions with precision.\n\t\t\t\t */\n\t\t\t\tconv->flag_zero = false;\n\n\t\t\t\t/* Set pad0_value to satisfy precision */\n\t\t\t\tif (len < (size_t)precision) {\n\t\t\t\t\tconv->pad0_value = precision - (int)len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {\n\t\t\t\tstore_count(conv, value->ptr, count);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FP_CONV_CASES:\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {\n\t\t\t\tbps = encode_float(value->dbl, conv, precision,\n\t\t\t\t\t\t   &sign, buf, &bpe);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Add an empty default with break, this is a defensive\n\t\t\t * programming. Static analysis tool won't raise a violation\n\t\t\t * if default is empty, but has that comment.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If we don't have a converted value to emit, move\n\t\t * on.\n\t\t */\n\t\tif (bps == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The converted value is now stored in [bps, bpe), excluding\n\t\t * any required zero padding.\n\t\t *\n\t\t * The unjustified output will be:\n\t\t *\n\t\t * * any sign character (sint-only)\n\t\t * * any altform prefix\n\t\t * * for FP:\n\t\t *   * any pre-decimal content from the converted value\n\t\t *   * any pad0_value padding (!postdp)\n\t\t *   * any decimal point in the converted value\n\t\t *   * any pad0_value padding (postdp)\n\t\t *   * any pre-exponent content from the converted value\n\t\t *   * any pad0_pre_exp padding\n\t\t *   * any exponent content from the converted value\n\t\t * * for non-FP:\n\t\t *   * any pad0_prefix\n\t\t *   * the converted value\n\t\t */\n\t\tsize_t nj_len = (bpe - bps);\n\t\tint pad_len = 0;\n\n\t\tif (sign != 0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tif (conv->altform_0c) {\n\t\t\tnj_len += 2U;\n\t\t} else if (conv->altform_0) {\n\t\t\tnj_len += 1U;\n\t\t}\n\n\t\tnj_len += conv->pad0_value;\n\t\tif (conv->pad_fp) {\n\t\t\tnj_len += conv->pad0_pre_exp;\n\t\t}\n\n\t\t/* If we have a width update width to hold the padding we need\n\t\t * for justification.  The result may be negative, which will\n\t\t * result in no padding.\n\t\t *\n\t\t * If a non-negative padding width is present and we're doing\n\t\t * right-justification, emit the padding now.\n\t\t */\n\t\tif (width > 0) {\n\t\t\twidth -= (int)nj_len;\n\n\t\t\tif (!conv->flag_dash) {\n\t\t\t\tchar pad = ' ';\n\n\t\t\t\t/* If we're zero-padding we have to emit the\n\t\t\t\t * sign first.\n\t\t\t\t */\n\t\t\t\tif (conv->flag_zero) {\n\t\t\t\t\tif (sign != 0) {\n\t\t\t\t\t\tOUTC(sign);\n\t\t\t\t\t\tsign = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpad = '0';\n\t\t\t\t}\n\n\t\t\t\twhile (width-- > 0) {\n\t\t\t\t\tOUTC(pad);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have a sign that hasn't been emitted, now's the\n\t\t * time....\n\t\t */\n\t\tif (sign != 0) {\n\t\t\tOUTC(sign);\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {\n\t\t\tconst char *cp = bps;\n\n\t\t\tif (conv->specifier_a) {\n\t\t\t\t/* Only padding is pre_exp */\n\t\t\t\twhile (*cp != 'p') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\n\t\t\t\tpad_len = conv->pad0_value;\n\t\t\t\tif (!conv->pad_postdp) {\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*cp == '.') {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t\t/* Remaining padding is\n\t\t\t\t\t * post-dp.\n\t\t\t\t\t */\n\t\t\t\t\twhile (pad_len-- > 0) {\n\t\t\t\t\t\tOUTC('0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {\n\t\t\t\t\tOUTC(*cp);\n\t\t\t\t\t++cp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_pre_exp;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(cp, bpe);\n\t\t} else {\n\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tif (conv->altform_0c) {\n\t\t\t\tOUTC(conv->specifier);\n\t\t\t}\n\n\t\t\tpad_len = conv->pad0_value;\n\t\t\twhile (pad_len-- > 0) {\n\t\t\t\tOUTC('0');\n\t\t\t}\n\n\t\t\tOUTS(bps, bpe);\n\t\t}\n\n\t\t/* Finish left justification */\n\t\twhile (width > 0) {\n\t\t\tOUTC(' ');\n\t\t\t--width;\n\t\t}\n\t}\n\n\treturn count;\n#undef OUTS\n#undef OUTC\n}\n",
                {
                    "1370": "int z_cbvprintf_impl(cbprintf_cb __out, void *ctx, const char *fp,",
                    "1371": "\t\t     va_list ap, uint32_t flags)",
                    "1372": "{",
                    "1373": "\tchar buf[CONVERTED_BUFLEN];",
                    "1374": "\tsize_t count = 0;",
                    "1375": "\tsint_value_type sint;",
                    "1376": "\tcbprintf_cb_local out = __out;",
                    "1377": "",
                    "1378": "\tconst bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)",
                    "1379": "\t\t\t       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;",
                    "1380": "",
                    "1381": "/* Output character, returning EOF if output failed, otherwise",
                    "1382": " * updating count.",
                    "1383": " *",
                    "1384": " * NB: c is evaluated exactly once: side-effects are OK",
                    "1385": " */",
                    "1386": "#define OUTC(c) do { \\",
                    "1387": "\tint rc = (*out)((int)(c), ctx); \\",
                    "1388": "\t\\",
                    "1389": "\tif (rc < 0) { \\",
                    "1390": "\t\treturn rc; \\",
                    "1391": "\t} \\",
                    "1392": "\t++count; \\",
                    "1393": "} while (false)",
                    "1394": "",
                    "1395": "/* Output sequence of characters, returning a negative error if output",
                    "1396": " * failed.",
                    "1397": " */",
                    "1398": "",
                    "1399": "#define OUTS(_sp, _ep) do { \\",
                    "1400": "\tint rc = outs(out, ctx, (_sp), (_ep)); \\",
                    "1401": "\t\\",
                    "1402": "\tif (rc < 0) {\t    \\",
                    "1403": "\t\treturn rc; \\",
                    "1404": "\t} \\",
                    "1405": "\tcount += rc; \\",
                    "1406": "} while (false)",
                    "1407": "",
                    "1408": "\twhile (*fp != 0) {",
                    "1409": "\t\tif (*fp != '%') {",
                    "1410": "\t\t\tOUTC(*fp);",
                    "1411": "\t\t\t++fp;",
                    "1412": "\t\t\tcontinue;",
                    "1413": "\t\t}",
                    "1414": "",
                    "1415": "\t\t/* Force union into RAM with conversion state to",
                    "1416": "\t\t * mitigate LLVM code generation bug.",
                    "1417": "\t\t */",
                    "1418": "\t\tstruct {",
                    "1419": "\t\t\tunion argument_value value;",
                    "1420": "\t\t\tstruct conversion conv;",
                    "1421": "\t\t} state = {",
                    "1422": "\t\t\t.value = {",
                    "1423": "\t\t\t\t.uint = 0,",
                    "1424": "\t\t\t},",
                    "1425": "\t\t};",
                    "1426": "\t\tstruct conversion *const conv = &state.conv;",
                    "1427": "\t\tunion argument_value *const value = &state.value;",
                    "1428": "\t\tconst char *sp = fp;",
                    "1429": "\t\tint width = -1;",
                    "1430": "\t\tint precision = -1;",
                    "1431": "\t\tconst char *bps = NULL;",
                    "1432": "\t\tconst char *bpe = buf + sizeof(buf);",
                    "1433": "\t\tchar sign = 0;",
                    "1434": "",
                    "1435": "\t\tfp = extract_conversion(conv, sp);",
                    "1436": "",
                    "1437": "\t\tif (conv->specifier_cat != SPECIFIER_INVALID) {",
                    "1438": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)",
                    "1439": "\t\t\t    && tagged_ap) {",
                    "1440": "\t\t\t\t/* Skip over the argument tag as it is not being",
                    "1441": "\t\t\t\t * used here.",
                    "1442": "\t\t\t\t */",
                    "1443": "\t\t\t\t(void)va_arg(ap, int);",
                    "1444": "\t\t\t}",
                    "1445": "\t\t}",
                    "1446": "",
                    "1447": "\t\t/* If dynamic width is specified, process it,",
                    "1448": "\t\t * otherwise set width if present.",
                    "1449": "\t\t */",
                    "1450": "\t\tif (conv->width_star) {",
                    "1451": "\t\t\twidth = va_arg(ap, int);",
                    "1452": "",
                    "1453": "\t\t\tif (width < 0) {",
                    "1454": "\t\t\t\tconv->flag_dash = true;",
                    "1455": "\t\t\t\twidth = -width;",
                    "1456": "\t\t\t}",
                    "1457": "\t\t} else if (conv->width_present) {",
                    "1458": "\t\t\twidth = conv->width_value;",
                    "1459": "\t\t} else {",
                    "1460": "\t\t\t;",
                    "1461": "\t\t}",
                    "1462": "",
                    "1463": "\t\t/* If dynamic precision is specified, process it, otherwise",
                    "1464": "\t\t * set precision if present.  For floating point where",
                    "1465": "\t\t * precision is not present use 6.",
                    "1466": "\t\t */",
                    "1467": "\t\tif (conv->prec_star) {",
                    "1468": "\t\t\tint arg = va_arg(ap, int);",
                    "1469": "",
                    "1470": "\t\t\tif (arg < 0) {",
                    "1471": "\t\t\t\tconv->prec_present = false;",
                    "1472": "\t\t\t} else {",
                    "1473": "\t\t\t\tprecision = arg;",
                    "1474": "\t\t\t}",
                    "1475": "\t\t} else if (conv->prec_present) {",
                    "1476": "\t\t\tprecision = conv->prec_value;",
                    "1477": "\t\t} else {",
                    "1478": "\t\t\t;",
                    "1479": "\t\t}",
                    "1480": "",
                    "1481": "\t\t/* Reuse width and precision memory in conv for value",
                    "1482": "\t\t * padding counts.",
                    "1483": "\t\t */",
                    "1484": "\t\tconv->pad0_value = 0;",
                    "1485": "\t\tconv->pad0_pre_exp = 0;",
                    "1486": "",
                    "1487": "\t\t/* FP conversion requires knowing the precision. */",
                    "1488": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)",
                    "1489": "\t\t    && (conv->specifier_cat == SPECIFIER_FP)",
                    "1490": "\t\t    && !conv->prec_present) {",
                    "1491": "\t\t\tif (conv->specifier_a) {",
                    "1492": "\t\t\t\tprecision = FRACTION_HEX;",
                    "1493": "\t\t\t} else {",
                    "1494": "\t\t\t\tprecision = 6;",
                    "1495": "\t\t\t}",
                    "1496": "\t\t}",
                    "1497": "",
                    "1498": "\t\t/* Get the value to be converted from the args.",
                    "1499": "\t\t *",
                    "1500": "\t\t * This can't be extracted to a helper function because",
                    "1501": "\t\t * passing a pointer to va_list doesn't work on x86_64.  See",
                    "1502": "\t\t * https://stackoverflow.com/a/8048892.",
                    "1503": "\t\t */",
                    "1504": "\t\tenum specifier_cat_enum specifier_cat",
                    "1505": "\t\t\t= (enum specifier_cat_enum)conv->specifier_cat;",
                    "1506": "\t\tenum length_mod_enum length_mod",
                    "1507": "\t\t\t= (enum length_mod_enum)conv->length_mod;",
                    "1508": "",
                    "1509": "\t\t/* Extract the value based on the argument category and length.",
                    "1510": "\t\t *",
                    "1511": "\t\t * Note that the length modifier doesn't affect the value of a",
                    "1512": "\t\t * pointer argument.",
                    "1513": "\t\t */",
                    "1514": "\t\tif (specifier_cat == SPECIFIER_SINT) {",
                    "1515": "\t\t\tswitch (length_mod) {",
                    "1516": "\t\t\tdefault:",
                    "1517": "\t\t\tcase LENGTH_NONE:",
                    "1518": "\t\t\tcase LENGTH_HH:",
                    "1519": "\t\t\tcase LENGTH_H:",
                    "1520": "\t\t\t\tvalue->sint = va_arg(ap, int);",
                    "1521": "\t\t\t\tbreak;",
                    "1522": "\t\t\tcase LENGTH_L:",
                    "1523": "\t\t\t\tif (WCHAR_IS_SIGNED",
                    "1524": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1525": "\t\t\t\t\tvalue->sint = (wchar_t)va_arg(ap,",
                    "1526": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1527": "\t\t\t\t} else {",
                    "1528": "\t\t\t\t\tvalue->sint = va_arg(ap, long);",
                    "1529": "\t\t\t\t}",
                    "1530": "\t\t\t\tbreak;",
                    "1531": "\t\t\tcase LENGTH_LL:",
                    "1532": "\t\t\t\tvalue->sint =",
                    "1533": "\t\t\t\t\t(sint_value_type)va_arg(ap, long long);",
                    "1534": "\t\t\t\tbreak;",
                    "1535": "\t\t\tcase LENGTH_J:",
                    "1536": "\t\t\t\tvalue->sint =",
                    "1537": "\t\t\t\t\t(sint_value_type)va_arg(ap, intmax_t);",
                    "1538": "\t\t\t\tbreak;",
                    "1539": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1540": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1541": "\t\t\t\t/* Though ssize_t is the signed equivalent of",
                    "1542": "\t\t\t\t * size_t for POSIX, there is no uptrdiff_t.",
                    "1543": "\t\t\t\t * Assume that size_t and ptrdiff_t are the",
                    "1544": "\t\t\t\t * unsigned and signed equivalents of each",
                    "1545": "\t\t\t\t * other.  This can be checked in a platform",
                    "1546": "\t\t\t\t * test.",
                    "1547": "\t\t\t\t */",
                    "1548": "\t\t\t\tvalue->sint =",
                    "1549": "\t\t\t\t\t(sint_value_type)va_arg(ap, ptrdiff_t);",
                    "1550": "\t\t\t\tbreak;",
                    "1551": "\t\t\t}",
                    "1552": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1553": "\t\t\t\tvalue->sint = (signed char)value->sint;",
                    "1554": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1555": "\t\t\t\tvalue->sint = (short)value->sint;",
                    "1556": "\t\t\t}",
                    "1557": "\t\t} else if (specifier_cat == SPECIFIER_UINT) {",
                    "1558": "\t\t\tswitch (length_mod) {",
                    "1559": "\t\t\tdefault:",
                    "1560": "\t\t\tcase LENGTH_NONE:",
                    "1561": "\t\t\tcase LENGTH_HH:",
                    "1562": "\t\t\tcase LENGTH_H:",
                    "1563": "\t\t\t\tvalue->uint = va_arg(ap, unsigned int);",
                    "1564": "\t\t\t\tbreak;",
                    "1565": "\t\t\tcase LENGTH_L:",
                    "1566": "\t\t\t\tif ((!WCHAR_IS_SIGNED)",
                    "1567": "\t\t\t\t    && (conv->specifier == 'c')) {",
                    "1568": "\t\t\t\t\tvalue->uint = (wchar_t)va_arg(ap,",
                    "1569": "\t\t\t\t\t\t\t      WINT_TYPE);",
                    "1570": "\t\t\t\t} else {",
                    "1571": "\t\t\t\t\tvalue->uint = va_arg(ap, unsigned long);",
                    "1572": "\t\t\t\t}",
                    "1573": "\t\t\t\tbreak;",
                    "1574": "\t\t\tcase LENGTH_LL:",
                    "1575": "\t\t\t\tvalue->uint =",
                    "1576": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1577": "\t\t\t\t\t\tunsigned long long);",
                    "1578": "\t\t\t\tbreak;",
                    "1579": "\t\t\tcase LENGTH_J:",
                    "1580": "\t\t\t\tvalue->uint =",
                    "1581": "\t\t\t\t\t(uint_value_type)va_arg(ap,",
                    "1582": "\t\t\t\t\t\t\t\tuintmax_t);",
                    "1583": "\t\t\t\tbreak;",
                    "1584": "\t\t\tcase LENGTH_Z:\t\t/* size_t */",
                    "1585": "\t\t\tcase LENGTH_T:\t\t/* ptrdiff_t */",
                    "1586": "\t\t\t\tvalue->uint =",
                    "1587": "\t\t\t\t\t(uint_value_type)va_arg(ap, size_t);",
                    "1588": "\t\t\t\tbreak;",
                    "1589": "\t\t\t}",
                    "1590": "\t\t\tif (length_mod == LENGTH_HH) {",
                    "1591": "\t\t\t\tvalue->uint = (unsigned char)value->uint;",
                    "1592": "\t\t\t} else if (length_mod == LENGTH_H) {",
                    "1593": "\t\t\t\tvalue->uint = (unsigned short)value->uint;",
                    "1594": "\t\t\t}",
                    "1595": "\t\t} else if (specifier_cat == SPECIFIER_FP) {",
                    "1596": "\t\t\tif (length_mod == LENGTH_UPPER_L) {",
                    "1597": "\t\t\t\tvalue->ldbl = va_arg(ap, long double);",
                    "1598": "\t\t\t} else {",
                    "1599": "\t\t\t\tvalue->dbl = va_arg(ap, double);",
                    "1600": "\t\t\t}",
                    "1601": "\t\t} else if (specifier_cat == SPECIFIER_PTR) {",
                    "1602": "\t\t\tvalue->ptr = va_arg(ap, void *);",
                    "1603": "\t\t}",
                    "1604": "",
                    "1605": "\t\t/* We've now consumed all arguments related to this",
                    "1606": "\t\t * specification.  If the conversion is invalid, or is",
                    "1607": "\t\t * something we don't support, then output the original",
                    "1608": "\t\t * specification and move on.",
                    "1609": "\t\t */",
                    "1610": "\t\tif (conv->invalid || conv->unsupported) {",
                    "1611": "\t\t\tOUTS(sp, fp);",
                    "1612": "\t\t\tcontinue;",
                    "1613": "\t\t}",
                    "1614": "",
                    "1615": "\t\t/* Do formatting, either into the buffer or",
                    "1616": "\t\t * referencing external data.",
                    "1617": "\t\t */",
                    "1618": "\t\tswitch (conv->specifier) {",
                    "1619": "\t\tcase '%':",
                    "1620": "\t\t\tOUTC('%');",
                    "1621": "\t\t\tbreak;",
                    "1622": "\t\tcase 's': {",
                    "1623": "\t\t\tbps = (const char *)value->ptr;",
                    "1624": "",
                    "1625": "\t\t\tsize_t len;",
                    "1626": "",
                    "1627": "\t\t\tif (precision >= 0) {",
                    "1628": "\t\t\t\tlen = strnlen(bps, precision);",
                    "1629": "\t\t\t} else {",
                    "1630": "\t\t\t\tlen = strlen(bps);",
                    "1631": "\t\t\t}",
                    "1632": "",
                    "1633": "\t\t\tbpe = bps + len;",
                    "1634": "\t\t\tprecision = -1;",
                    "1635": "",
                    "1636": "\t\t\tbreak;",
                    "1637": "\t\t}",
                    "1638": "\t\tcase 'p':",
                    "1639": "\t\t\t/* Implementation-defined: null is \"(nil)\", non-null",
                    "1640": "\t\t\t * has 0x prefix followed by significant address hex",
                    "1641": "\t\t\t * digits, no leading zeros.",
                    "1642": "\t\t\t */",
                    "1643": "\t\t\tif (value->ptr != NULL) {",
                    "1644": "\t\t\t\tbps = encode_uint((uintptr_t)value->ptr, conv,",
                    "1645": "\t\t\t\t\t\t  buf, bpe);",
                    "1646": "",
                    "1647": "\t\t\t\t/* Use 0x prefix */",
                    "1648": "\t\t\t\tconv->altform_0c = true;",
                    "1649": "\t\t\t\tconv->specifier = 'x';",
                    "1650": "",
                    "1651": "\t\t\t\tgoto prec_int_pad0;",
                    "1652": "\t\t\t}",
                    "1653": "",
                    "1654": "\t\t\tbps = \"(nil)\";",
                    "1655": "\t\t\tbpe = bps + 5;",
                    "1656": "",
                    "1657": "\t\t\tbreak;",
                    "1658": "\t\tcase 'c':",
                    "1659": "\t\t\tbps = buf;",
                    "1660": "\t\t\tbuf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;",
                    "1661": "\t\t\tbpe = buf + 1;",
                    "1662": "\t\t\tbreak;",
                    "1663": "\t\tcase 'd':",
                    "1664": "\t\tcase 'i':",
                    "1665": "\t\t\tif (conv->flag_plus) {",
                    "1666": "\t\t\t\tsign = '+';",
                    "1667": "\t\t\t} else if (conv->flag_space) {",
                    "1668": "\t\t\t\tsign = ' ';",
                    "1669": "\t\t\t}",
                    "1670": "",
                    "1671": "\t\t\t/* sint/uint overlay in the union, and so",
                    "1672": "\t\t\t * can't appear in read and write operations",
                    "1673": "\t\t\t * in the same statement.",
                    "1674": "\t\t\t */",
                    "1675": "\t\t\tsint = value->sint;",
                    "1676": "\t\t\tif (sint < 0) {",
                    "1677": "\t\t\t\tsign = '-';",
                    "1678": "\t\t\t\tvalue->uint = (uint_value_type)-sint;",
                    "1679": "\t\t\t} else {",
                    "1680": "\t\t\t\tvalue->uint = (uint_value_type)sint;",
                    "1681": "\t\t\t}",
                    "1682": "",
                    "1683": "\t\t\t__fallthrough;",
                    "1684": "\t\tcase 'o':",
                    "1685": "\t\tcase 'u':",
                    "1686": "\t\tcase 'x':",
                    "1687": "\t\tcase 'X':",
                    "1688": "\t\t\tbps = encode_uint(value->uint, conv, buf, bpe);",
                    "1689": "",
                    "1690": "\t\tprec_int_pad0:",
                    "1691": "\t\t\t/* Update pad0 values based on precision and converted",
                    "1692": "\t\t\t * length.  Note that a non-empty sign is not in the",
                    "1693": "\t\t\t * converted sequence, but it does not affect the",
                    "1694": "\t\t\t * padding size.",
                    "1695": "\t\t\t */",
                    "1696": "\t\t\tif (precision >= 0) {",
                    "1697": "\t\t\t\tsize_t len = bpe - bps;",
                    "1698": "",
                    "1699": "\t\t\t\t/* Zero-padding flag is ignored for integer",
                    "1700": "\t\t\t\t * conversions with precision.",
                    "1701": "\t\t\t\t */",
                    "1702": "\t\t\t\tconv->flag_zero = false;",
                    "1703": "",
                    "1704": "\t\t\t\t/* Set pad0_value to satisfy precision */",
                    "1705": "\t\t\t\tif (len < (size_t)precision) {",
                    "1706": "\t\t\t\t\tconv->pad0_value = precision - (int)len;",
                    "1707": "\t\t\t\t}",
                    "1708": "\t\t\t}",
                    "1709": "",
                    "1710": "\t\t\tbreak;",
                    "1711": "\t\tcase 'n':",
                    "1712": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {",
                    "1713": "\t\t\t\tstore_count(conv, value->ptr, count);",
                    "1714": "\t\t\t}",
                    "1715": "",
                    "1716": "\t\t\tbreak;",
                    "1717": "",
                    "1718": "\t\tcase FP_CONV_CASES:",
                    "1719": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {",
                    "1720": "\t\t\t\tbps = encode_float(value->dbl, conv, precision,",
                    "1721": "\t\t\t\t\t\t   &sign, buf, &bpe);",
                    "1722": "\t\t\t}",
                    "1723": "\t\t\tbreak;",
                    "1724": "\t\tdefault:",
                    "1725": "\t\t\t/* Add an empty default with break, this is a defensive",
                    "1726": "\t\t\t * programming. Static analysis tool won't raise a violation",
                    "1727": "\t\t\t * if default is empty, but has that comment.",
                    "1728": "\t\t\t */",
                    "1729": "\t\t\tbreak;",
                    "1730": "\t\t}",
                    "1731": "",
                    "1732": "\t\t/* If we don't have a converted value to emit, move",
                    "1733": "\t\t * on.",
                    "1734": "\t\t */",
                    "1735": "\t\tif (bps == NULL) {",
                    "1736": "\t\t\tcontinue;",
                    "1737": "\t\t}",
                    "1738": "",
                    "1739": "\t\t/* The converted value is now stored in [bps, bpe), excluding",
                    "1740": "\t\t * any required zero padding.",
                    "1741": "\t\t *",
                    "1742": "\t\t * The unjustified output will be:",
                    "1743": "\t\t *",
                    "1744": "\t\t * * any sign character (sint-only)",
                    "1745": "\t\t * * any altform prefix",
                    "1746": "\t\t * * for FP:",
                    "1747": "\t\t *   * any pre-decimal content from the converted value",
                    "1748": "\t\t *   * any pad0_value padding (!postdp)",
                    "1749": "\t\t *   * any decimal point in the converted value",
                    "1750": "\t\t *   * any pad0_value padding (postdp)",
                    "1751": "\t\t *   * any pre-exponent content from the converted value",
                    "1752": "\t\t *   * any pad0_pre_exp padding",
                    "1753": "\t\t *   * any exponent content from the converted value",
                    "1754": "\t\t * * for non-FP:",
                    "1755": "\t\t *   * any pad0_prefix",
                    "1756": "\t\t *   * the converted value",
                    "1757": "\t\t */",
                    "1758": "\t\tsize_t nj_len = (bpe - bps);",
                    "1759": "\t\tint pad_len = 0;",
                    "1760": "",
                    "1761": "\t\tif (sign != 0) {",
                    "1762": "\t\t\tnj_len += 1U;",
                    "1763": "\t\t}",
                    "1764": "",
                    "1765": "\t\tif (conv->altform_0c) {",
                    "1766": "\t\t\tnj_len += 2U;",
                    "1767": "\t\t} else if (conv->altform_0) {",
                    "1768": "\t\t\tnj_len += 1U;",
                    "1769": "\t\t}",
                    "1770": "",
                    "1771": "\t\tnj_len += conv->pad0_value;",
                    "1772": "\t\tif (conv->pad_fp) {",
                    "1773": "\t\t\tnj_len += conv->pad0_pre_exp;",
                    "1774": "\t\t}",
                    "1775": "",
                    "1776": "\t\t/* If we have a width update width to hold the padding we need",
                    "1777": "\t\t * for justification.  The result may be negative, which will",
                    "1778": "\t\t * result in no padding.",
                    "1779": "\t\t *",
                    "1780": "\t\t * If a non-negative padding width is present and we're doing",
                    "1781": "\t\t * right-justification, emit the padding now.",
                    "1782": "\t\t */",
                    "1783": "\t\tif (width > 0) {",
                    "1784": "\t\t\twidth -= (int)nj_len;",
                    "1785": "",
                    "1786": "\t\t\tif (!conv->flag_dash) {",
                    "1787": "\t\t\t\tchar pad = ' ';",
                    "1788": "",
                    "1789": "\t\t\t\t/* If we're zero-padding we have to emit the",
                    "1790": "\t\t\t\t * sign first.",
                    "1791": "\t\t\t\t */",
                    "1792": "\t\t\t\tif (conv->flag_zero) {",
                    "1793": "\t\t\t\t\tif (sign != 0) {",
                    "1794": "\t\t\t\t\t\tOUTC(sign);",
                    "1795": "\t\t\t\t\t\tsign = 0;",
                    "1796": "\t\t\t\t\t}",
                    "1797": "\t\t\t\t\tpad = '0';",
                    "1798": "\t\t\t\t}",
                    "1799": "",
                    "1800": "\t\t\t\twhile (width-- > 0) {",
                    "1801": "\t\t\t\t\tOUTC(pad);",
                    "1802": "\t\t\t\t}",
                    "1803": "\t\t\t}",
                    "1804": "\t\t}",
                    "1805": "",
                    "1806": "\t\t/* If we have a sign that hasn't been emitted, now's the",
                    "1807": "\t\t * time....",
                    "1808": "\t\t */",
                    "1809": "\t\tif (sign != 0) {",
                    "1810": "\t\t\tOUTC(sign);",
                    "1811": "\t\t}",
                    "1812": "",
                    "1813": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {",
                    "1814": "\t\t\tconst char *cp = bps;",
                    "1815": "",
                    "1816": "\t\t\tif (conv->specifier_a) {",
                    "1817": "\t\t\t\t/* Only padding is pre_exp */",
                    "1818": "\t\t\t\twhile (*cp != 'p') {",
                    "1819": "\t\t\t\t\tOUTC(*cp);",
                    "1820": "\t\t\t\t\t++cp;",
                    "1821": "\t\t\t\t}",
                    "1822": "\t\t\t} else {",
                    "1823": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1824": "\t\t\t\t\tOUTC(*cp);",
                    "1825": "\t\t\t\t\t++cp;",
                    "1826": "\t\t\t\t}",
                    "1827": "",
                    "1828": "\t\t\t\tpad_len = conv->pad0_value;",
                    "1829": "\t\t\t\tif (!conv->pad_postdp) {",
                    "1830": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1831": "\t\t\t\t\t\tOUTC('0');",
                    "1832": "\t\t\t\t\t}",
                    "1833": "\t\t\t\t}",
                    "1834": "",
                    "1835": "\t\t\t\tif (*cp == '.') {",
                    "1836": "\t\t\t\t\tOUTC(*cp);",
                    "1837": "\t\t\t\t\t++cp;",
                    "1838": "\t\t\t\t\t/* Remaining padding is",
                    "1839": "\t\t\t\t\t * post-dp.",
                    "1840": "\t\t\t\t\t */",
                    "1841": "\t\t\t\t\twhile (pad_len-- > 0) {",
                    "1842": "\t\t\t\t\t\tOUTC('0');",
                    "1843": "\t\t\t\t\t}",
                    "1844": "\t\t\t\t}",
                    "1845": "\t\t\t\twhile (isdigit((unsigned char)*cp) != 0) {",
                    "1846": "\t\t\t\t\tOUTC(*cp);",
                    "1847": "\t\t\t\t\t++cp;",
                    "1848": "\t\t\t\t}",
                    "1849": "\t\t\t}",
                    "1850": "",
                    "1851": "\t\t\tpad_len = conv->pad0_pre_exp;",
                    "1852": "\t\t\twhile (pad_len-- > 0) {",
                    "1853": "\t\t\t\tOUTC('0');",
                    "1854": "\t\t\t}",
                    "1855": "",
                    "1856": "\t\t\tOUTS(cp, bpe);",
                    "1857": "\t\t} else {",
                    "1858": "\t\t\tif ((conv->altform_0c | conv->altform_0) != 0) {",
                    "1859": "\t\t\t\tOUTC('0');",
                    "1860": "\t\t\t}",
                    "1861": "",
                    "1862": "\t\t\tif (conv->altform_0c) {",
                    "1863": "\t\t\t\tOUTC(conv->specifier);",
                    "1864": "\t\t\t}",
                    "1865": "",
                    "1866": "\t\t\tpad_len = conv->pad0_value;",
                    "1867": "\t\t\twhile (pad_len-- > 0) {",
                    "1868": "\t\t\t\tOUTC('0');",
                    "1869": "\t\t\t}",
                    "1870": "",
                    "1871": "\t\t\tOUTS(bps, bpe);",
                    "1872": "\t\t}",
                    "1873": "",
                    "1874": "\t\t/* Finish left justification */",
                    "1875": "\t\twhile (width > 0) {",
                    "1876": "\t\t\tOUTC(' ');",
                    "1877": "\t\t\t--width;",
                    "1878": "\t\t}",
                    "1879": "\t}",
                    "1880": "",
                    "1881": "\treturn count;",
                    "1882": "#undef OUTS",
                    "1883": "#undef OUTC",
                    "1884": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "cbprintf_package_convert": {
            "name": "cbprintf_package_convert",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 913,
            "function_content": [
                "/* Function checks if nth argument is a pointer (%p). Returns true is yes. Returns\n* false if not or if string does not have nth argument.\n*/\nint cbprintf_package_convert(void *in_packaged,\n\t\t\t     size_t in_len,\n\t\t\t     cbprintf_convert_cb cb,\n\t\t\t     void *ctx,\n\t\t\t     uint32_t flags,\n\t\t\t     uint16_t *strl,\n\t\t\t     size_t strl_len)\n{\n\t__ASSERT_NO_MSG(in_packaged != NULL);\n\n\tuint8_t *buf = in_packaged;\n\tuint32_t *buf32 = in_packaged;\n\tunsigned int args_size, ros_nbr, rws_nbr;\n\tbool fmt_present = flags & CBPRINTF_PACKAGE_CONVERT_PTR_CHECK ? true : false;\n\tbool rw_cpy;\n\tbool ro_cpy;\n\tstruct cbprintf_package_desc *in_desc = in_packaged;\n\n\tin_len = in_len != 0 ? in_len : get_package_len(in_packaged);\n\n\t/* Get number of RO string indexes in the package and check if copying\n\t * includes appending those strings.\n\t */\n\tros_nbr = in_desc->ro_str_cnt;\n\tro_cpy = ros_nbr &&\n\t\t(flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) == CBPRINTF_PACKAGE_CONVERT_RO_STR;\n\n\t/* Get number of RW string indexes in the package and check if copying\n\t * includes appending those strings.\n\t */\n\trws_nbr = in_desc->rw_str_cnt;\n\trw_cpy = rws_nbr > 0 &&\n\t\t (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) == CBPRINTF_PACKAGE_CONVERT_RW_STR;\n\n\t/* If flags are not set or appending request without rw string indexes\n\t * present is chosen, just do a simple copy (or length calculation).\n\t * Assuming that it is the most common case.\n\t */\n\tif (!rw_cpy && !ro_cpy) {\n\t\tif (cb) {\n\t\t\tcb(in_packaged, in_len, ctx);\n\t\t}\n\n\t\treturn in_len;\n\t}\n\n\t/* If we got here, it means that coping will be more complex and will be\n\t * done with strings appending.\n\t * Retrieve the size of the arg list.\n\t */\n\targs_size = in_desc->len * sizeof(int);\n\n\tint out_len;\n\n\t/* Pointer to array with string locations. Array starts with read-only\n\t * string locations.\n\t */\n\tconst char *fmt = *(const char **)(buf + sizeof(void *));\n\tuint8_t *str_pos = &buf[args_size];\n\tsize_t strl_cnt = 0;\n\n\t/* If null destination, just calculate output length. */\n\tif (cb == NULL) {\n\t\tout_len = (int)in_len;\n\t\tif (ro_cpy) {\n\t\t\tfor (unsigned int i = 0; i < ros_nbr; i++) {\n\t\t\t\tconst char *str = *(const char **)&buf32[*str_pos];\n\t\t\t\tint len = append_string(cb, NULL, str, 0);\n\n\t\t\t\t/* If possible store calculated string length. */\n\t\t\t\tif (strl && strl_cnt < strl_len) {\n\t\t\t\t\tstrl[strl_cnt++] = (uint16_t)len;\n\t\t\t\t}\n\t\t\t\tout_len += len;\n\t\t\t\tstr_pos++;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_pos += ros_nbr;\n\t\t}\n\n\t\tbool drop_ro_str_pos = !(flags &\n\t\t\t\t\t(CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR |\n\t\t\t\t\t CBPRINTF_PACKAGE_CONVERT_RO_STR));\n\n\t\t/* Handle RW strings. */\n\t\tfor (unsigned int i = 0; i < rws_nbr; i++) {\n\t\t\tuint8_t arg_idx = *str_pos++;\n\t\t\tuint8_t arg_pos = *str_pos++;\n\t\t\tconst char *str = *(const char **)&buf32[arg_pos];\n\t\t\tbool is_ro = ptr_in_rodata(str);\n\t\t\tint len;\n\n\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_CONVERT_CHECK_PTR) &&\n\t\t\t    fmt_present && is_ptr(fmt, arg_idx)) {\n\t\t\t\tLOG_WRN(\"(unsigned) char * used for %%p argument. \"\n\t\t\t\t\t\"It's recommended to cast it to void * because \"\n\t\t\t\t\t\"it may cause misbehavior in certain \"\n\t\t\t\t\t\"configurations. String:\\\"%s\\\" argument:%d\", fmt, arg_idx);\n\t\t\t\t/* Since location is being dropped, decrement\n\t\t\t\t * output length by 2 (argument index + position)\n\t\t\t\t */\n\t\t\t\tout_len -= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ro) {\n\t\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {\n\t\t\t\t\tgoto calculate_string_length;\n\t\t\t\t} else {\n\t\t\t\t\tout_len -= drop_ro_str_pos ? 2 : 1;\n\t\t\t\t}\n\t\t\t} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {\ncalculate_string_length:\n\t\t\t\tlen = append_string(cb, NULL, str, 0);\n\n\t\t\t\t/* If possible store calculated string length. */\n\t\t\t\tif (strl && strl_cnt < strl_len) {\n\t\t\t\t\tstrl[strl_cnt++] = (uint16_t)len;\n\t\t\t\t}\n\t\t\t\t/* string length decremented by 1 because argument\n\t\t\t\t * index is dropped.\n\t\t\t\t */\n\t\t\t\tout_len += (len - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn out_len;\n\t}\n\n\tstruct cbprintf_package_desc out_desc;\n\t/* At least one is copied in. */\n\tuint8_t cpy_str_pos[16];\n\t/* Up to one will be kept since if both types are kept it returns earlier. */\n\tuint8_t keep_str_pos[16];\n\tuint8_t scpy_cnt;\n\tuint8_t keep_cnt;\n\tuint8_t *dst;\n\tint rv;\n\n\t/* If read-only strings shall be appended to the output package copy\n\t * their indexes to the local array, otherwise indicate that indexes\n\t * shall remain in the output package.\n\t */\n\tif (ro_cpy) {\n\t\tscpy_cnt = ros_nbr;\n\t\tkeep_cnt = 0;\n\t\tdst = cpy_str_pos;\n\t} else if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {\n\t\tscpy_cnt = 0;\n\t\tkeep_cnt = ros_nbr;\n\t\tdst = keep_str_pos;\n\t} else {\n\t\tscpy_cnt = 0;\n\t\tkeep_cnt = 0;\n\t\tdst = NULL;\n\t}\n\tif (dst) {\n\t\tmemcpy(dst, str_pos, ros_nbr);\n\t}\n\tstr_pos += ros_nbr;\n\n\t/* Go through read-write strings and identify which shall be appended.\n\t * Note that there may be read-only strings there. Use address evaluation\n\t * to determine if strings is read-only.\n\t */\n\tfor (unsigned int i = 0; i < rws_nbr; i++) {\n\t\tuint8_t arg_idx = *str_pos++;\n\t\tuint8_t arg_pos = *str_pos++;\n\t\tconst char *str = *(const char **)&buf32[arg_pos];\n\t\tbool is_ro = ptr_in_rodata(str);\n\n\t\tif (IS_ENABLED(CONFIG_CBPRINTF_CONVERT_CHECK_PTR) &&\n\t\t    fmt_present && is_ptr(fmt, arg_idx)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_ro) {\n\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {\n\t\t\t\t__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));\n\t\t\t\tcpy_str_pos[scpy_cnt++] = arg_pos;\n\t\t\t} else if (flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {\n\t\t\t\t__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));\n\t\t\t\tkeep_str_pos[keep_cnt++] = arg_pos;\n\t\t\t} else {\n\t\t\t\t/* Drop information about ro_str location. */\n\t\t\t}\n\t\t} else {\n\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {\n\t\t\t\t__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));\n\t\t\t\tcpy_str_pos[scpy_cnt++] = arg_pos;\n\t\t\t} else {\n\t\t\t\t__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));\n\t\t\t\tkeep_str_pos[keep_cnt++] = arg_idx;\n\t\t\t\tkeep_str_pos[keep_cnt++] = arg_pos;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set amount of strings appended to the package. */\n\tout_desc.len = in_desc->len;\n\tout_desc.str_cnt = in_desc->str_cnt + scpy_cnt;\n\tout_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);\n\tout_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :\n\t\t\t((flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) ? keep_cnt : 0);\n\n\t/* Temporary overwrite input descriptor to allow bulk transfer */\n\tstruct cbprintf_package_desc in_desc_backup = *in_desc;\n\t*in_desc = out_desc;\n\n\t/* Copy package header and arguments. */\n\trv = cb(in_packaged, args_size, ctx);\n\tif (rv < 0) {\n\t\treturn rv;\n\t}\n\tout_len = rv;\n\t/* Restore input descriptor. */\n\t*in_desc = in_desc_backup;\n\n\t/* Copy string positions which are kept. */\n\trv = cb(keep_str_pos, keep_cnt, ctx);\n\tif (rv < 0) {\n\t\treturn rv;\n\t}\n\tout_len += rv;\n\n\t/* Copy appended strings from source package to destination. */\n\tsize_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);\n\n\trv = cb(str_pos, strs_len, ctx);\n\tif (rv < 0) {\n\t\treturn rv;\n\t}\n\tout_len += rv;\n\n\t/* Append strings */\n\tfor (unsigned int i = 0; i < scpy_cnt; i++) {\n\t\tuint8_t loc = cpy_str_pos[i];\n\t\tconst char *str = *(const char **)&buf32[loc];\n\t\tuint16_t str_len = (strl && (i < strl_len)) ? strl[i] : 0;\n\n\t\trv = cb(&loc, 1, ctx);\n\t\tif (rv < 0) {\n\t\t\treturn rv;\n\t\t}\n\t\tout_len += rv;\n\n\t\trv = append_string(cb, ctx, str, str_len);\n\t\tif (rv < 0) {\n\t\t\treturn rv;\n\t\t}\n\t\tout_len += rv;\n\t}\n\n\t/* Empty call (can be interpreted as flushing) */\n\t(void)cb(NULL, 0, ctx);\n\n\treturn out_len;\n}\n",
                {
                    "913": "int cbprintf_package_convert(void *in_packaged,",
                    "914": "\t\t\t     size_t in_len,",
                    "915": "\t\t\t     cbprintf_convert_cb cb,",
                    "916": "\t\t\t     void *ctx,",
                    "917": "\t\t\t     uint32_t flags,",
                    "918": "\t\t\t     uint16_t *strl,",
                    "919": "\t\t\t     size_t strl_len)",
                    "920": "{",
                    "921": "\t__ASSERT_NO_MSG(in_packaged != NULL);",
                    "922": "",
                    "923": "\tuint8_t *buf = in_packaged;",
                    "924": "\tuint32_t *buf32 = in_packaged;",
                    "925": "\tunsigned int args_size, ros_nbr, rws_nbr;",
                    "926": "\tbool fmt_present = flags & CBPRINTF_PACKAGE_CONVERT_PTR_CHECK ? true : false;",
                    "927": "\tbool rw_cpy;",
                    "928": "\tbool ro_cpy;",
                    "929": "\tstruct cbprintf_package_desc *in_desc = in_packaged;",
                    "930": "",
                    "931": "\tin_len = in_len != 0 ? in_len : get_package_len(in_packaged);",
                    "932": "",
                    "933": "\t/* Get number of RO string indexes in the package and check if copying",
                    "934": "\t * includes appending those strings.",
                    "935": "\t */",
                    "936": "\tros_nbr = in_desc->ro_str_cnt;",
                    "937": "\tro_cpy = ros_nbr &&",
                    "938": "\t\t(flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) == CBPRINTF_PACKAGE_CONVERT_RO_STR;",
                    "939": "",
                    "940": "\t/* Get number of RW string indexes in the package and check if copying",
                    "941": "\t * includes appending those strings.",
                    "942": "\t */",
                    "943": "\trws_nbr = in_desc->rw_str_cnt;",
                    "944": "\trw_cpy = rws_nbr > 0 &&",
                    "945": "\t\t (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) == CBPRINTF_PACKAGE_CONVERT_RW_STR;",
                    "946": "",
                    "947": "\t/* If flags are not set or appending request without rw string indexes",
                    "948": "\t * present is chosen, just do a simple copy (or length calculation).",
                    "949": "\t * Assuming that it is the most common case.",
                    "950": "\t */",
                    "951": "\tif (!rw_cpy && !ro_cpy) {",
                    "952": "\t\tif (cb) {",
                    "953": "\t\t\tcb(in_packaged, in_len, ctx);",
                    "954": "\t\t}",
                    "955": "",
                    "956": "\t\treturn in_len;",
                    "957": "\t}",
                    "958": "",
                    "959": "\t/* If we got here, it means that coping will be more complex and will be",
                    "960": "\t * done with strings appending.",
                    "961": "\t * Retrieve the size of the arg list.",
                    "962": "\t */",
                    "963": "\targs_size = in_desc->len * sizeof(int);",
                    "964": "",
                    "965": "\tint out_len;",
                    "966": "",
                    "967": "\t/* Pointer to array with string locations. Array starts with read-only",
                    "968": "\t * string locations.",
                    "969": "\t */",
                    "970": "\tconst char *fmt = *(const char **)(buf + sizeof(void *));",
                    "971": "\tuint8_t *str_pos = &buf[args_size];",
                    "972": "\tsize_t strl_cnt = 0;",
                    "973": "",
                    "974": "\t/* If null destination, just calculate output length. */",
                    "975": "\tif (cb == NULL) {",
                    "976": "\t\tout_len = (int)in_len;",
                    "977": "\t\tif (ro_cpy) {",
                    "978": "\t\t\tfor (unsigned int i = 0; i < ros_nbr; i++) {",
                    "979": "\t\t\t\tconst char *str = *(const char **)&buf32[*str_pos];",
                    "980": "\t\t\t\tint len = append_string(cb, NULL, str, 0);",
                    "981": "",
                    "982": "\t\t\t\t/* If possible store calculated string length. */",
                    "983": "\t\t\t\tif (strl && strl_cnt < strl_len) {",
                    "984": "\t\t\t\t\tstrl[strl_cnt++] = (uint16_t)len;",
                    "985": "\t\t\t\t}",
                    "986": "\t\t\t\tout_len += len;",
                    "987": "\t\t\t\tstr_pos++;",
                    "988": "\t\t\t}",
                    "989": "\t\t} else {",
                    "990": "\t\t\tstr_pos += ros_nbr;",
                    "991": "\t\t}",
                    "992": "",
                    "993": "\t\tbool drop_ro_str_pos = !(flags &",
                    "994": "\t\t\t\t\t(CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR |",
                    "995": "\t\t\t\t\t CBPRINTF_PACKAGE_CONVERT_RO_STR));",
                    "996": "",
                    "997": "\t\t/* Handle RW strings. */",
                    "998": "\t\tfor (unsigned int i = 0; i < rws_nbr; i++) {",
                    "999": "\t\t\tuint8_t arg_idx = *str_pos++;",
                    "1000": "\t\t\tuint8_t arg_pos = *str_pos++;",
                    "1001": "\t\t\tconst char *str = *(const char **)&buf32[arg_pos];",
                    "1002": "\t\t\tbool is_ro = ptr_in_rodata(str);",
                    "1003": "\t\t\tint len;",
                    "1004": "",
                    "1005": "\t\t\tif (IS_ENABLED(CONFIG_CBPRINTF_CONVERT_CHECK_PTR) &&",
                    "1006": "\t\t\t    fmt_present && is_ptr(fmt, arg_idx)) {",
                    "1007": "\t\t\t\tLOG_WRN(\"(unsigned) char * used for %%p argument. \"",
                    "1008": "\t\t\t\t\t\"It's recommended to cast it to void * because \"",
                    "1009": "\t\t\t\t\t\"it may cause misbehavior in certain \"",
                    "1010": "\t\t\t\t\t\"configurations. String:\\\"%s\\\" argument:%d\", fmt, arg_idx);",
                    "1011": "\t\t\t\t/* Since location is being dropped, decrement",
                    "1012": "\t\t\t\t * output length by 2 (argument index + position)",
                    "1013": "\t\t\t\t */",
                    "1014": "\t\t\t\tout_len -= 2;",
                    "1015": "\t\t\t\tcontinue;",
                    "1016": "\t\t\t}",
                    "1017": "",
                    "1018": "\t\t\tif (is_ro) {",
                    "1019": "\t\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {",
                    "1020": "\t\t\t\t\tgoto calculate_string_length;",
                    "1021": "\t\t\t\t} else {",
                    "1022": "\t\t\t\t\tout_len -= drop_ro_str_pos ? 2 : 1;",
                    "1023": "\t\t\t\t}",
                    "1024": "\t\t\t} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {",
                    "1025": "calculate_string_length:",
                    "1026": "\t\t\t\tlen = append_string(cb, NULL, str, 0);",
                    "1027": "",
                    "1028": "\t\t\t\t/* If possible store calculated string length. */",
                    "1029": "\t\t\t\tif (strl && strl_cnt < strl_len) {",
                    "1030": "\t\t\t\t\tstrl[strl_cnt++] = (uint16_t)len;",
                    "1031": "\t\t\t\t}",
                    "1032": "\t\t\t\t/* string length decremented by 1 because argument",
                    "1033": "\t\t\t\t * index is dropped.",
                    "1034": "\t\t\t\t */",
                    "1035": "\t\t\t\tout_len += (len - 1);",
                    "1036": "\t\t\t}",
                    "1037": "\t\t}",
                    "1038": "",
                    "1039": "\t\treturn out_len;",
                    "1040": "\t}",
                    "1041": "",
                    "1042": "\tstruct cbprintf_package_desc out_desc;",
                    "1043": "\t/* At least one is copied in. */",
                    "1044": "\tuint8_t cpy_str_pos[16];",
                    "1045": "\t/* Up to one will be kept since if both types are kept it returns earlier. */",
                    "1046": "\tuint8_t keep_str_pos[16];",
                    "1047": "\tuint8_t scpy_cnt;",
                    "1048": "\tuint8_t keep_cnt;",
                    "1049": "\tuint8_t *dst;",
                    "1050": "\tint rv;",
                    "1051": "",
                    "1052": "\t/* If read-only strings shall be appended to the output package copy",
                    "1053": "\t * their indexes to the local array, otherwise indicate that indexes",
                    "1054": "\t * shall remain in the output package.",
                    "1055": "\t */",
                    "1056": "\tif (ro_cpy) {",
                    "1057": "\t\tscpy_cnt = ros_nbr;",
                    "1058": "\t\tkeep_cnt = 0;",
                    "1059": "\t\tdst = cpy_str_pos;",
                    "1060": "\t} else if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {",
                    "1061": "\t\tscpy_cnt = 0;",
                    "1062": "\t\tkeep_cnt = ros_nbr;",
                    "1063": "\t\tdst = keep_str_pos;",
                    "1064": "\t} else {",
                    "1065": "\t\tscpy_cnt = 0;",
                    "1066": "\t\tkeep_cnt = 0;",
                    "1067": "\t\tdst = NULL;",
                    "1068": "\t}",
                    "1069": "\tif (dst) {",
                    "1070": "\t\tmemcpy(dst, str_pos, ros_nbr);",
                    "1071": "\t}",
                    "1072": "\tstr_pos += ros_nbr;",
                    "1073": "",
                    "1074": "\t/* Go through read-write strings and identify which shall be appended.",
                    "1075": "\t * Note that there may be read-only strings there. Use address evaluation",
                    "1076": "\t * to determine if strings is read-only.",
                    "1077": "\t */",
                    "1078": "\tfor (unsigned int i = 0; i < rws_nbr; i++) {",
                    "1079": "\t\tuint8_t arg_idx = *str_pos++;",
                    "1080": "\t\tuint8_t arg_pos = *str_pos++;",
                    "1081": "\t\tconst char *str = *(const char **)&buf32[arg_pos];",
                    "1082": "\t\tbool is_ro = ptr_in_rodata(str);",
                    "1083": "",
                    "1084": "\t\tif (IS_ENABLED(CONFIG_CBPRINTF_CONVERT_CHECK_PTR) &&",
                    "1085": "\t\t    fmt_present && is_ptr(fmt, arg_idx)) {",
                    "1086": "\t\t\tcontinue;",
                    "1087": "\t\t}",
                    "1088": "",
                    "1089": "\t\tif (is_ro) {",
                    "1090": "\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {",
                    "1091": "\t\t\t\t__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));",
                    "1092": "\t\t\t\tcpy_str_pos[scpy_cnt++] = arg_pos;",
                    "1093": "\t\t\t} else if (flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {",
                    "1094": "\t\t\t\t__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));",
                    "1095": "\t\t\t\tkeep_str_pos[keep_cnt++] = arg_pos;",
                    "1096": "\t\t\t} else {",
                    "1097": "\t\t\t\t/* Drop information about ro_str location. */",
                    "1098": "\t\t\t}",
                    "1099": "\t\t} else {",
                    "1100": "\t\t\tif (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {",
                    "1101": "\t\t\t\t__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));",
                    "1102": "\t\t\t\tcpy_str_pos[scpy_cnt++] = arg_pos;",
                    "1103": "\t\t\t} else {",
                    "1104": "\t\t\t\t__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));",
                    "1105": "\t\t\t\tkeep_str_pos[keep_cnt++] = arg_idx;",
                    "1106": "\t\t\t\tkeep_str_pos[keep_cnt++] = arg_pos;",
                    "1107": "\t\t\t}",
                    "1108": "\t\t}",
                    "1109": "\t}",
                    "1110": "",
                    "1111": "\t/* Set amount of strings appended to the package. */",
                    "1112": "\tout_desc.len = in_desc->len;",
                    "1113": "\tout_desc.str_cnt = in_desc->str_cnt + scpy_cnt;",
                    "1114": "\tout_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);",
                    "1115": "\tout_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :",
                    "1116": "\t\t\t((flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) ? keep_cnt : 0);",
                    "1117": "",
                    "1118": "\t/* Temporary overwrite input descriptor to allow bulk transfer */",
                    "1119": "\tstruct cbprintf_package_desc in_desc_backup = *in_desc;",
                    "1120": "\t*in_desc = out_desc;",
                    "1121": "",
                    "1122": "\t/* Copy package header and arguments. */",
                    "1123": "\trv = cb(in_packaged, args_size, ctx);",
                    "1124": "\tif (rv < 0) {",
                    "1125": "\t\treturn rv;",
                    "1126": "\t}",
                    "1127": "\tout_len = rv;",
                    "1128": "\t/* Restore input descriptor. */",
                    "1129": "\t*in_desc = in_desc_backup;",
                    "1130": "",
                    "1131": "\t/* Copy string positions which are kept. */",
                    "1132": "\trv = cb(keep_str_pos, keep_cnt, ctx);",
                    "1133": "\tif (rv < 0) {",
                    "1134": "\t\treturn rv;",
                    "1135": "\t}",
                    "1136": "\tout_len += rv;",
                    "1137": "",
                    "1138": "\t/* Copy appended strings from source package to destination. */",
                    "1139": "\tsize_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);",
                    "1140": "",
                    "1141": "\trv = cb(str_pos, strs_len, ctx);",
                    "1142": "\tif (rv < 0) {",
                    "1143": "\t\treturn rv;",
                    "1144": "\t}",
                    "1145": "\tout_len += rv;",
                    "1146": "",
                    "1147": "\t/* Append strings */",
                    "1148": "\tfor (unsigned int i = 0; i < scpy_cnt; i++) {",
                    "1149": "\t\tuint8_t loc = cpy_str_pos[i];",
                    "1150": "\t\tconst char *str = *(const char **)&buf32[loc];",
                    "1151": "\t\tuint16_t str_len = (strl && (i < strl_len)) ? strl[i] : 0;",
                    "1152": "",
                    "1153": "\t\trv = cb(&loc, 1, ctx);",
                    "1154": "\t\tif (rv < 0) {",
                    "1155": "\t\t\treturn rv;",
                    "1156": "\t\t}",
                    "1157": "\t\tout_len += rv;",
                    "1158": "",
                    "1159": "\t\trv = append_string(cb, ctx, str, str_len);",
                    "1160": "\t\tif (rv < 0) {",
                    "1161": "\t\t\treturn rv;",
                    "1162": "\t\t}",
                    "1163": "\t\tout_len += rv;",
                    "1164": "\t}",
                    "1165": "",
                    "1166": "\t/* Empty call (can be interpreted as flushing) */",
                    "1167": "\t(void)cb(NULL, 0, ctx);",
                    "1168": "",
                    "1169": "\treturn out_len;",
                    "1170": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "cbvprintf_package": {
            "name": "cbvprintf_package",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 233,
            "function_content": [
                "/* Move beyond strings appended to the package. */\nint cbvprintf_package(void *packaged, size_t len, uint32_t flags,\n\t\t      const char *fmt, va_list ap)\n{\n/*\n * Internally, a byte is used to store location of a string argument within a\n * package. MSB bit is set if string is read-only so effectively 7 bits are\n * used for index, which should be enough.\n */\n#define STR_POS_RO_FLAG BIT(7)\n#define STR_POS_MASK BIT_MASK(7)\n\n/* Buffer offset abstraction for better code clarity. */\n#define BUF_OFFSET (buf - (uintptr_t)buf0)\n\n\tuint8_t *buf0 = packaged;  /* buffer start (may be NULL) */\n\tuintptr_t buf = (uintptr_t)buf0; /* current buffer position */\n\tunsigned int size;         /* current argument's size */\n\tunsigned int align;        /* current argument's required alignment */\n\tuint8_t str_ptr_pos[16];   /* string pointer positions */\n\tuint8_t str_ptr_arg[16];   /* string pointer argument index */\n\tunsigned int s_idx = 0;    /* index into str_ptr_pos[] */\n\tunsigned int s_rw_cnt = 0; /* number of rw strings */\n\tunsigned int s_ro_cnt = 0; /* number of ro strings */\n\tint arg_idx\t      = -1; /* Argument index. Preincremented thus starting from -1.*/\n\tunsigned int i;\n\tconst char *s;\n\tbool parsing = false;\n\t/* Flag indicates that rw strings are stored as array with positions,\n\t * instead of appending them to the package.\n\t */\n\tbool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);\n\t/* Get number of first read only strings present in the string.\n\t * There is always at least 1 (fmt) but flags can indicate more, e.g\n\t * fixed prefix appended to all strings.\n\t */\n\tint fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);\n\tbool is_str_arg = false;\n\tunion cbprintf_package_hdr *pkg_hdr = packaged;\n\n\t/* Buffer must be aligned at least to size of a pointer. */\n\tif ((uintptr_t)packaged % sizeof(void *)) {\n\t\treturn -EFAULT;\n\t}\n\n#if defined(__xtensa__)\n\t/* Xtensa requires package to be 16 bytes aligned. */\n\tif ((uintptr_t)packaged % CBPRINTF_PACKAGE_ALIGNMENT) {\n\t\treturn -EFAULT;\n\t}\n#endif\n\n\t/*\n\t * Make room to store the arg list size, the number of\n\t * appended writable strings and the number of appended\n\t * read-only strings. They both occupy 1 byte each.\n\t * Skip a byte. Then a uint32_t to store flags used to\n\t * create the package.\n\t *\n\t * Given the next value to store is the format string pointer\n\t * which is guaranteed to be at least 4 bytes, we just reserve\n\t * multiple of pointer size for the above to preserve alignment.\n\t *\n\t * Refer to union cbprintf_package_hdr for more details.\n\t */\n\tbuf += sizeof(*pkg_hdr);\n\n\t/*\n\t * When buf0 is NULL we don't store anything.\n\t * Instead we count the needed space to store the data.\n\t * In this case, incoming len argument indicates the anticipated\n\t * buffer \"misalignment\" offset.\n\t */\n\tif (buf0 == NULL) {\n\t\tbuf += len % CBPRINTF_PACKAGE_ALIGNMENT;\n\t\t/*\n\t\t * The space to store the data is represented by both the\n\t\t * buffer offset as well as the extra string data to be\n\t\t * appended. When only figuring out the needed space, we\n\t\t * don't append anything. Instead, we reuse the len variable\n\t\t * to sum the size of that data.\n\t\t *\n\t\t * Also, we subtract any initial misalignment offset from\n\t\t * the total as this won't be part of the buffer. To avoid\n\t\t * going negative with an unsigned variable, we add an offset\n\t\t * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before\n\t\t * returning.\n\t\t */\n\t\tlen = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);\n\t}\n\n\t/*\n\t * Otherwise we must ensure we can store at least\n\t * the pointer to the format string itself.\n\t */\n\tif ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * Then process the format string itself.\n\t * Here we branch directly into the code processing strings\n\t * which is in the middle of the following while() loop. That's the\n\t * reason for the post-decrement on fmt as it will be incremented\n\t * prior to the next (actually first) round of that loop.\n\t */\n\ts = fmt;\n\t--fmt;\n\talign = VA_STACK_ALIGN(char *);\n\tsize = sizeof(char *);\n\tgoto process_string;\n\n\twhile (true) {\n\n#if defined(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\t\tif ((flags & CBPRINTF_PACKAGE_ARGS_ARE_TAGGED)\n\t\t    == CBPRINTF_PACKAGE_ARGS_ARE_TAGGED) {\n\t\t\tint arg_tag = va_arg(ap, int);\n\n\t\t\t/*\n\t\t\t * Here we copy the tag over to the package.\n\t\t\t */\n\t\t\talign = VA_STACK_ALIGN(int);\n\t\t\tsize = sizeof(int);\n\n\t\t\t/* align destination buffer location */\n\t\t\tbuf = ROUND_UP(buf, align);\n\n\t\t\t/* make sure the data fits */\n\t\t\tif (buf0 != NULL && BUF_OFFSET + size > len) {\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tif (buf0 != NULL) {\n\t\t\t\t*(int *)buf = arg_tag;\n\t\t\t}\n\n\t\t\tbuf += sizeof(int);\n\n\t\t\tif (arg_tag == CBPRINTF_PACKAGE_ARG_TYPE_END) {\n\t\t\t\t/* End of arguments */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * There are lots of __fallthrough here since\n\t\t\t * quite a few of the data types have the same\n\t\t\t * storage size.\n\t\t\t */\n\t\t\tswitch (arg_tag) {\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_CHAR:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_CHAR:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_SHORT:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_SHORT:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_INT:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_INT:\n\t\t\t\talign = VA_STACK_ALIGN(int);\n\t\t\t\tsize = sizeof(int);\n\t\t\t\tbreak;\n\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_LONG:\n\t\t\t\talign = VA_STACK_ALIGN(long);\n\t\t\t\tsize = sizeof(long);\n\t\t\t\tbreak;\n\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG_LONG:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_LONG_LONG:\n\t\t\t\talign = VA_STACK_ALIGN(long long);\n\t\t\t\tsize = sizeof(long long);\n\t\t\t\tbreak;\n\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_FLOAT:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_DOUBLE:\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG_DOUBLE: {\n\t\t\t\t/*\n\t\t\t\t * Handle floats separately as they may be\n\t\t\t\t * held in a different register set.\n\t\t\t\t */\n\t\t\t\tunion { double d; long double ld; } v;\n\n\t\t\t\tif (arg_tag == CBPRINTF_PACKAGE_ARG_TYPE_LONG_DOUBLE) {\n\t\t\t\t\tv.ld = va_arg(ap, long double);\n\t\t\t\t\talign = VA_STACK_ALIGN(long double);\n\t\t\t\t\tsize = sizeof(long double);\n\t\t\t\t} else {\n\t\t\t\t\tv.d = va_arg(ap, double);\n\t\t\t\t\talign = VA_STACK_ALIGN(double);\n\t\t\t\t\tsize = sizeof(double);\n\t\t\t\t}\n\n\t\t\t\t/* align destination buffer location */\n\t\t\t\tbuf = ROUND_UP(buf, align);\n\t\t\t\tif (buf0 != NULL) {\n\t\t\t\t\t/* make sure it fits */\n\t\t\t\t\tif ((BUF_OFFSET + size) > len) {\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {\n\t\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, size);\n\t\t\t\t\t} else if (fmt[-1] == 'L') {\n\t\t\t\t\t\t*(long double *)buf = v.ld;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*(double *)buf = v.d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf += size;\n\t\t\t\tparsing = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_PTR_CHAR:\n\t\t\t\tis_str_arg = true;\n\n\t\t\t\t__fallthrough;\n\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_PTR_VOID:\n\t\t\t\talign = VA_STACK_ALIGN(void *);\n\t\t\t\tsize = sizeof(void *);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else\n#endif /* CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS */\n\t\t{\n\t\t\t/* Scan the format string */\n\t\t\tif (*++fmt == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!parsing) {\n\t\t\t\tif (*fmt == '%') {\n\t\t\t\t\tparsing = true;\n\t\t\t\t\targ_idx++;\n\t\t\t\t\talign = VA_STACK_ALIGN(int);\n\t\t\t\t\tsize = sizeof(int);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (*fmt) {\n\t\t\tcase '%':\n\t\t\t\tparsing = false;\n\t\t\t\targ_idx--;\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\tcase '-':\n\t\t\tcase '+':\n\t\t\tcase ' ':\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '.':\n\t\t\tcase 'h':\n\t\t\tcase 'l':\n\t\t\tcase 'L':\n\t\t\t\tcontinue;\n\n\t\t\tcase '*':\n\t\t\t\tbreak;\n\n\t\t\tcase 'j':\n\t\t\t\talign = VA_STACK_ALIGN(intmax_t);\n\t\t\t\tsize = sizeof(intmax_t);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'z':\n\t\t\t\talign = VA_STACK_ALIGN(size_t);\n\t\t\t\tsize = sizeof(size_t);\n\t\t\t\tcontinue;\n\n\t\t\tcase 't':\n\t\t\t\talign = VA_STACK_ALIGN(ptrdiff_t);\n\t\t\t\tsize = sizeof(ptrdiff_t);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\tcase 'o':\n\t\t\tcase 'u':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\tif (fmt[-1] == 'l') {\n\t\t\t\t\tif (fmt[-2] == 'l') {\n\t\t\t\t\t\talign = VA_STACK_ALIGN(long long);\n\t\t\t\t\t\tsize = sizeof(long long);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talign = VA_STACK_ALIGN(long);\n\t\t\t\t\t\tsize = sizeof(long);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparsing = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tis_str_arg = true;\n\n\t\t\t\t__fallthrough;\n\t\t\tcase 'p':\n\t\t\tcase 'n':\n\t\t\t\talign = VA_STACK_ALIGN(void *);\n\t\t\t\tsize = sizeof(void *);\n\t\t\t\tparsing = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\tcase 'g':\n\t\t\tcase 'G': {\n\t\t\t\t/*\n\t\t\t\t * Handle floats separately as they may be\n\t\t\t\t * held in a different register set.\n\t\t\t\t */\n\t\t\t\tunion { double d; long double ld; } v;\n\n\t\t\t\tif (fmt[-1] == 'L') {\n\t\t\t\t\tv.ld = va_arg(ap, long double);\n\t\t\t\t\talign = VA_STACK_ALIGN(long double);\n\t\t\t\t\tsize = sizeof(long double);\n\t\t\t\t} else {\n\t\t\t\t\tv.d = va_arg(ap, double);\n\t\t\t\t\talign = VA_STACK_ALIGN(double);\n\t\t\t\t\tsize = sizeof(double);\n\t\t\t\t}\n\t\t\t\t/* align destination buffer location */\n\t\t\t\tbuf = ROUND_UP(buf, align);\n\t\t\t\tif (buf0 != NULL) {\n\t\t\t\t\t/* make sure it fits */\n\t\t\t\t\tif (BUF_OFFSET + size > len) {\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {\n\t\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, size);\n\t\t\t\t\t} else if (fmt[-1] == 'L') {\n\t\t\t\t\t\t*(long double *)buf = v.ld;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*(double *)buf = v.d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf += size;\n\t\t\t\tparsing = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tparsing = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* align destination buffer location */\n\t\tbuf = ROUND_UP(buf, align);\n\n\t\t/* make sure the data fits */\n\t\tif ((buf0 != NULL) && (BUF_OFFSET + size) > len) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* copy va_list data over to our buffer */\n\t\tif (is_str_arg) {\n\t\t\ts = va_arg(ap, char *);\nprocess_string:\n\t\t\tif (buf0 != NULL) {\n\t\t\t\t*(const char **)buf = s;\n\t\t\t}\n\n\t\t\tbool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);\n\t\t\tbool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);\n\n\t\t\tif (is_ro && !do_ro) {\n\t\t\t\t/* nothing to do */\n\t\t\t} else {\n\t\t\t\tuint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);\n\n\t\t\t\t/*\n\t\t\t\t * In the do_ro case we must consider\n\t\t\t\t * room for possible STR_POS_RO_FLAG.\n\t\t\t\t * Otherwise the index range is 8 bits\n\t\t\t\t * and any overflow is caught later.\n\t\t\t\t */\n\t\t\t\tif (do_ro && s_ptr_idx > STR_POS_MASK) {\n\t\t\t\t\t__ASSERT(false, \"String with too many arguments\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (s_idx >= ARRAY_SIZE(str_ptr_pos)) {\n\t\t\t\t\t__ASSERT(false, \"str_ptr_pos[] too small\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (buf0 != NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember string pointer location.\n\t\t\t\t\t * We will append non-ro strings later.\n\t\t\t\t\t */\n\t\t\t\t\tstr_ptr_pos[s_idx] = s_ptr_idx;\n\t\t\t\t\tstr_ptr_arg[s_idx] = arg_idx;\n\t\t\t\t\tif (is_ro) {\n\t\t\t\t\t\t/* flag read-only string. */\n\t\t\t\t\t\tstr_ptr_pos[s_idx] |= STR_POS_RO_FLAG;\n\t\t\t\t\t\ts_ro_cnt++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts_rw_cnt++;\n\t\t\t\t\t}\n\t\t\t\t} else if (is_ro) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Add only pointer position prefix\n\t\t\t\t\t * when counting strings.\n\t\t\t\t\t */\n\t\t\t\t\tlen += 1;\n\t\t\t\t} else if (rws_pos_en) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Add only pointer position prefix and\n\t\t\t\t\t * argument index when counting strings.\n\t\t\t\t\t */\n\t\t\t\t\tlen += 2;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Add the string length, the final '\\0'\n\t\t\t\t\t * and size of the pointer position prefix.\n\t\t\t\t\t */\n\t\t\t\t\tlen += strlen(s) + 1 + 1;\n\t\t\t\t}\n\n\t\t\t\ts_idx++;\n\t\t\t}\n\t\t\tbuf += sizeof(char *);\n\n\t\t\tis_str_arg = false;\n\t\t} else if (size == sizeof(int)) {\n\t\t\tint v = va_arg(ap, int);\n\n\t\t\tif (buf0 != NULL) {\n\t\t\t\t*(int *)buf = v;\n\t\t\t}\n\t\t\tbuf += sizeof(int);\n\t\t} else if (size == sizeof(long)) {\n\t\t\tlong v = va_arg(ap, long);\n\n\t\t\tif (buf0 != NULL) {\n\t\t\t\t*(long *)buf = v;\n\t\t\t}\n\t\t\tbuf += sizeof(long);\n\t\t} else if (size == sizeof(long long)) {\n\t\t\tlong long v = va_arg(ap, long long);\n\n\t\t\tif (buf0 != NULL) {\n\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {\n\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, sizeof(long long));\n\t\t\t\t} else {\n\t\t\t\t\t*(long long *)buf = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += sizeof(long long);\n\t\t} else {\n\t\t\t__ASSERT(false, \"unexpected size %u\", size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * We remember the size of the argument list as a multiple of\n\t * sizeof(int) and limit it to a 8-bit field. That means 1020 bytes\n\t * worth of va_list, or about 127 arguments on a 64-bit system\n\t * (twice that on 32-bit systems). That ought to be good enough.\n\t */\n\tif ((BUF_OFFSET / sizeof(int)) > 255) {\n\t\t__ASSERT(false, \"too many format args\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If all we wanted was to count required buffer size\n\t * then we have it now.\n\t */\n\tif (buf0 == NULL) {\n\t\treturn BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;\n\t}\n\n\t/* Clear our buffer header. We made room for it initially. */\n\t*(char **)buf0 = NULL;\n\n\t/* Record end of argument list. */\n\tpkg_hdr->desc.len = BUF_OFFSET / sizeof(int);\n\n\tif (rws_pos_en) {\n\t\t/* Strings are appended, update location counter. */\n\t\tpkg_hdr->desc.str_cnt = 0;\n\t\tpkg_hdr->desc.rw_str_cnt = s_rw_cnt;\n\t} else {\n\t\t/* Strings are appended, update append counter. */\n\t\tpkg_hdr->desc.str_cnt = s_rw_cnt;\n\t\tpkg_hdr->desc.rw_str_cnt = 0;\n\t}\n\n\tpkg_hdr->desc.ro_str_cnt = s_ro_cnt;\n\n#ifdef CONFIG_CBPRINTF_PACKAGE_HEADER_STORE_CREATION_FLAGS\n\tpkg_hdr->desc.pkg_flags = flags;\n#endif\n\n\t/* Store strings pointer locations of read only strings. */\n\tif (s_ro_cnt != 0U) {\n\t\tfor (i = 0; i < s_idx; i++) {\n\t\t\tif (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuint8_t pos = str_ptr_pos[i] & STR_POS_MASK;\n\n\t\t\t/* make sure it fits */\n\t\t\tif ((BUF_OFFSET + 1) > len) {\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\t/* store the pointer position prefix */\n\t\t\t*(uint8_t *)buf = pos;\n\t\t\t++buf;\n\t\t}\n\t}\n\n\t/* Store strings prefixed by their pointer location. */\n\tfor (i = 0; i < s_idx; i++) {\n\t\t/* Process only RW strings. */\n\t\tif (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rws_pos_en) {\n\t\t\tsize = 0;\n\t\t\t*(uint8_t *)buf = str_ptr_arg[i];\n\t\t\t++buf;\n\t\t} else {\n\t\t\t/* retrieve the string pointer */\n\t\t\ts = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));\n\t\t\t/* clear the in-buffer pointer (less entropy if compressed) */\n\t\t\t*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;\n\t\t\t/* find the string length including terminating '\\0' */\n\t\t\tsize = strlen(s) + 1;\n\t\t}\n\n\t\t/* make sure it fits */\n\t\tif ((BUF_OFFSET + 1 + size) > len) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/* store the pointer position prefix */\n\t\t*(uint8_t *)buf = str_ptr_pos[i];\n\t\t++buf;\n\t\t/* copy the string with its terminating '\\0' */\n\t\tmemcpy((void *)buf, (uint8_t *)s, size);\n\t\tbuf += size;\n\t}\n\n\t/*\n\t * TODO: remove pointers for appended strings since they're useless.\n\t * TODO: explore leveraging same mechanism to remove alignment padding\n\t */\n\n\treturn BUF_OFFSET;\n\n#undef BUF_OFFSET\n#undef STR_POS_RO_FLAG\n#undef STR_POS_MASK\n}\n",
                {
                    "233": "int cbvprintf_package(void *packaged, size_t len, uint32_t flags,",
                    "234": "\t\t      const char *fmt, va_list ap)",
                    "235": "{",
                    "236": "/*",
                    "237": " * Internally, a byte is used to store location of a string argument within a",
                    "238": " * package. MSB bit is set if string is read-only so effectively 7 bits are",
                    "239": " * used for index, which should be enough.",
                    "240": " */",
                    "241": "#define STR_POS_RO_FLAG BIT(7)",
                    "242": "#define STR_POS_MASK BIT_MASK(7)",
                    "243": "",
                    "244": "/* Buffer offset abstraction for better code clarity. */",
                    "245": "#define BUF_OFFSET (buf - (uintptr_t)buf0)",
                    "246": "",
                    "247": "\tuint8_t *buf0 = packaged;  /* buffer start (may be NULL) */",
                    "248": "\tuintptr_t buf = (uintptr_t)buf0; /* current buffer position */",
                    "249": "\tunsigned int size;         /* current argument's size */",
                    "250": "\tunsigned int align;        /* current argument's required alignment */",
                    "251": "\tuint8_t str_ptr_pos[16];   /* string pointer positions */",
                    "252": "\tuint8_t str_ptr_arg[16];   /* string pointer argument index */",
                    "253": "\tunsigned int s_idx = 0;    /* index into str_ptr_pos[] */",
                    "254": "\tunsigned int s_rw_cnt = 0; /* number of rw strings */",
                    "255": "\tunsigned int s_ro_cnt = 0; /* number of ro strings */",
                    "256": "\tint arg_idx\t      = -1; /* Argument index. Preincremented thus starting from -1.*/",
                    "257": "\tunsigned int i;",
                    "258": "\tconst char *s;",
                    "259": "\tbool parsing = false;",
                    "260": "\t/* Flag indicates that rw strings are stored as array with positions,",
                    "261": "\t * instead of appending them to the package.",
                    "262": "\t */",
                    "263": "\tbool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);",
                    "264": "\t/* Get number of first read only strings present in the string.",
                    "265": "\t * There is always at least 1 (fmt) but flags can indicate more, e.g",
                    "266": "\t * fixed prefix appended to all strings.",
                    "267": "\t */",
                    "268": "\tint fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);",
                    "269": "\tbool is_str_arg = false;",
                    "270": "\tunion cbprintf_package_hdr *pkg_hdr = packaged;",
                    "271": "",
                    "272": "\t/* Buffer must be aligned at least to size of a pointer. */",
                    "273": "\tif ((uintptr_t)packaged % sizeof(void *)) {",
                    "274": "\t\treturn -EFAULT;",
                    "275": "\t}",
                    "276": "",
                    "277": "#if defined(__xtensa__)",
                    "278": "\t/* Xtensa requires package to be 16 bytes aligned. */",
                    "279": "\tif ((uintptr_t)packaged % CBPRINTF_PACKAGE_ALIGNMENT) {",
                    "280": "\t\treturn -EFAULT;",
                    "281": "\t}",
                    "282": "#endif",
                    "283": "",
                    "284": "\t/*",
                    "285": "\t * Make room to store the arg list size, the number of",
                    "286": "\t * appended writable strings and the number of appended",
                    "287": "\t * read-only strings. They both occupy 1 byte each.",
                    "288": "\t * Skip a byte. Then a uint32_t to store flags used to",
                    "289": "\t * create the package.",
                    "290": "\t *",
                    "291": "\t * Given the next value to store is the format string pointer",
                    "292": "\t * which is guaranteed to be at least 4 bytes, we just reserve",
                    "293": "\t * multiple of pointer size for the above to preserve alignment.",
                    "294": "\t *",
                    "295": "\t * Refer to union cbprintf_package_hdr for more details.",
                    "296": "\t */",
                    "297": "\tbuf += sizeof(*pkg_hdr);",
                    "298": "",
                    "299": "\t/*",
                    "300": "\t * When buf0 is NULL we don't store anything.",
                    "301": "\t * Instead we count the needed space to store the data.",
                    "302": "\t * In this case, incoming len argument indicates the anticipated",
                    "303": "\t * buffer \"misalignment\" offset.",
                    "304": "\t */",
                    "305": "\tif (buf0 == NULL) {",
                    "306": "\t\tbuf += len % CBPRINTF_PACKAGE_ALIGNMENT;",
                    "307": "\t\t/*",
                    "308": "\t\t * The space to store the data is represented by both the",
                    "309": "\t\t * buffer offset as well as the extra string data to be",
                    "310": "\t\t * appended. When only figuring out the needed space, we",
                    "311": "\t\t * don't append anything. Instead, we reuse the len variable",
                    "312": "\t\t * to sum the size of that data.",
                    "313": "\t\t *",
                    "314": "\t\t * Also, we subtract any initial misalignment offset from",
                    "315": "\t\t * the total as this won't be part of the buffer. To avoid",
                    "316": "\t\t * going negative with an unsigned variable, we add an offset",
                    "317": "\t\t * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before",
                    "318": "\t\t * returning.",
                    "319": "\t\t */",
                    "320": "\t\tlen = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);",
                    "321": "\t}",
                    "322": "",
                    "323": "\t/*",
                    "324": "\t * Otherwise we must ensure we can store at least",
                    "325": "\t * the pointer to the format string itself.",
                    "326": "\t */",
                    "327": "\tif ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {",
                    "328": "\t\treturn -ENOSPC;",
                    "329": "\t}",
                    "330": "",
                    "331": "\t/*",
                    "332": "\t * Then process the format string itself.",
                    "333": "\t * Here we branch directly into the code processing strings",
                    "334": "\t * which is in the middle of the following while() loop. That's the",
                    "335": "\t * reason for the post-decrement on fmt as it will be incremented",
                    "336": "\t * prior to the next (actually first) round of that loop.",
                    "337": "\t */",
                    "338": "\ts = fmt;",
                    "339": "\t--fmt;",
                    "340": "\talign = VA_STACK_ALIGN(char *);",
                    "341": "\tsize = sizeof(char *);",
                    "342": "\tgoto process_string;",
                    "343": "",
                    "344": "\twhile (true) {",
                    "345": "",
                    "346": "#if defined(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)",
                    "347": "\t\tif ((flags & CBPRINTF_PACKAGE_ARGS_ARE_TAGGED)",
                    "348": "\t\t    == CBPRINTF_PACKAGE_ARGS_ARE_TAGGED) {",
                    "349": "\t\t\tint arg_tag = va_arg(ap, int);",
                    "350": "",
                    "351": "\t\t\t/*",
                    "352": "\t\t\t * Here we copy the tag over to the package.",
                    "353": "\t\t\t */",
                    "354": "\t\t\talign = VA_STACK_ALIGN(int);",
                    "355": "\t\t\tsize = sizeof(int);",
                    "356": "",
                    "357": "\t\t\t/* align destination buffer location */",
                    "358": "\t\t\tbuf = ROUND_UP(buf, align);",
                    "359": "",
                    "360": "\t\t\t/* make sure the data fits */",
                    "361": "\t\t\tif (buf0 != NULL && BUF_OFFSET + size > len) {",
                    "362": "\t\t\t\treturn -ENOSPC;",
                    "363": "\t\t\t}",
                    "364": "",
                    "365": "\t\t\tif (buf0 != NULL) {",
                    "366": "\t\t\t\t*(int *)buf = arg_tag;",
                    "367": "\t\t\t}",
                    "368": "",
                    "369": "\t\t\tbuf += sizeof(int);",
                    "370": "",
                    "371": "\t\t\tif (arg_tag == CBPRINTF_PACKAGE_ARG_TYPE_END) {",
                    "372": "\t\t\t\t/* End of arguments */",
                    "373": "\t\t\t\tbreak;",
                    "374": "\t\t\t}",
                    "375": "",
                    "376": "\t\t\t/*",
                    "377": "\t\t\t * There are lots of __fallthrough here since",
                    "378": "\t\t\t * quite a few of the data types have the same",
                    "379": "\t\t\t * storage size.",
                    "380": "\t\t\t */",
                    "381": "\t\t\tswitch (arg_tag) {",
                    "382": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_CHAR:",
                    "383": "\t\t\t\t__fallthrough;",
                    "384": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_CHAR:",
                    "385": "\t\t\t\t__fallthrough;",
                    "386": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_SHORT:",
                    "387": "\t\t\t\t__fallthrough;",
                    "388": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_SHORT:",
                    "389": "\t\t\t\t__fallthrough;",
                    "390": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_INT:",
                    "391": "\t\t\t\t__fallthrough;",
                    "392": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_INT:",
                    "393": "\t\t\t\talign = VA_STACK_ALIGN(int);",
                    "394": "\t\t\t\tsize = sizeof(int);",
                    "395": "\t\t\t\tbreak;",
                    "396": "",
                    "397": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG:",
                    "398": "\t\t\t\t__fallthrough;",
                    "399": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_LONG:",
                    "400": "\t\t\t\talign = VA_STACK_ALIGN(long);",
                    "401": "\t\t\t\tsize = sizeof(long);",
                    "402": "\t\t\t\tbreak;",
                    "403": "",
                    "404": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG_LONG:",
                    "405": "\t\t\t\t__fallthrough;",
                    "406": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_UNSIGNED_LONG_LONG:",
                    "407": "\t\t\t\talign = VA_STACK_ALIGN(long long);",
                    "408": "\t\t\t\tsize = sizeof(long long);",
                    "409": "\t\t\t\tbreak;",
                    "410": "",
                    "411": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_FLOAT:",
                    "412": "\t\t\t\t__fallthrough;",
                    "413": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_DOUBLE:",
                    "414": "\t\t\t\t__fallthrough;",
                    "415": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_LONG_DOUBLE: {",
                    "416": "\t\t\t\t/*",
                    "417": "\t\t\t\t * Handle floats separately as they may be",
                    "418": "\t\t\t\t * held in a different register set.",
                    "419": "\t\t\t\t */",
                    "420": "\t\t\t\tunion { double d; long double ld; } v;",
                    "421": "",
                    "422": "\t\t\t\tif (arg_tag == CBPRINTF_PACKAGE_ARG_TYPE_LONG_DOUBLE) {",
                    "423": "\t\t\t\t\tv.ld = va_arg(ap, long double);",
                    "424": "\t\t\t\t\talign = VA_STACK_ALIGN(long double);",
                    "425": "\t\t\t\t\tsize = sizeof(long double);",
                    "426": "\t\t\t\t} else {",
                    "427": "\t\t\t\t\tv.d = va_arg(ap, double);",
                    "428": "\t\t\t\t\talign = VA_STACK_ALIGN(double);",
                    "429": "\t\t\t\t\tsize = sizeof(double);",
                    "430": "\t\t\t\t}",
                    "431": "",
                    "432": "\t\t\t\t/* align destination buffer location */",
                    "433": "\t\t\t\tbuf = ROUND_UP(buf, align);",
                    "434": "\t\t\t\tif (buf0 != NULL) {",
                    "435": "\t\t\t\t\t/* make sure it fits */",
                    "436": "\t\t\t\t\tif ((BUF_OFFSET + size) > len) {",
                    "437": "\t\t\t\t\t\treturn -ENOSPC;",
                    "438": "\t\t\t\t\t}",
                    "439": "\t\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {",
                    "440": "\t\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, size);",
                    "441": "\t\t\t\t\t} else if (fmt[-1] == 'L') {",
                    "442": "\t\t\t\t\t\t*(long double *)buf = v.ld;",
                    "443": "\t\t\t\t\t} else {",
                    "444": "\t\t\t\t\t\t*(double *)buf = v.d;",
                    "445": "\t\t\t\t\t}",
                    "446": "\t\t\t\t}",
                    "447": "\t\t\t\tbuf += size;",
                    "448": "\t\t\t\tparsing = false;",
                    "449": "\t\t\t\tcontinue;",
                    "450": "\t\t\t}",
                    "451": "",
                    "452": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_PTR_CHAR:",
                    "453": "\t\t\t\tis_str_arg = true;",
                    "454": "",
                    "455": "\t\t\t\t__fallthrough;",
                    "456": "\t\t\tcase CBPRINTF_PACKAGE_ARG_TYPE_PTR_VOID:",
                    "457": "\t\t\t\talign = VA_STACK_ALIGN(void *);",
                    "458": "\t\t\t\tsize = sizeof(void *);",
                    "459": "\t\t\t\tbreak;",
                    "460": "",
                    "461": "\t\t\tdefault:",
                    "462": "\t\t\t\treturn -EINVAL;",
                    "463": "\t\t\t}",
                    "464": "",
                    "465": "\t\t} else",
                    "466": "#endif /* CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS */",
                    "467": "\t\t{",
                    "468": "\t\t\t/* Scan the format string */",
                    "469": "\t\t\tif (*++fmt == '\\0') {",
                    "470": "\t\t\t\tbreak;",
                    "471": "\t\t\t}",
                    "472": "",
                    "473": "\t\t\tif (!parsing) {",
                    "474": "\t\t\t\tif (*fmt == '%') {",
                    "475": "\t\t\t\t\tparsing = true;",
                    "476": "\t\t\t\t\targ_idx++;",
                    "477": "\t\t\t\t\talign = VA_STACK_ALIGN(int);",
                    "478": "\t\t\t\t\tsize = sizeof(int);",
                    "479": "\t\t\t\t}",
                    "480": "\t\t\t\tcontinue;",
                    "481": "\t\t\t}",
                    "482": "\t\t\tswitch (*fmt) {",
                    "483": "\t\t\tcase '%':",
                    "484": "\t\t\t\tparsing = false;",
                    "485": "\t\t\t\targ_idx--;",
                    "486": "\t\t\t\tcontinue;",
                    "487": "",
                    "488": "\t\t\tcase '#':",
                    "489": "\t\t\tcase '-':",
                    "490": "\t\t\tcase '+':",
                    "491": "\t\t\tcase ' ':",
                    "492": "\t\t\tcase '0':",
                    "493": "\t\t\tcase '1':",
                    "494": "\t\t\tcase '2':",
                    "495": "\t\t\tcase '3':",
                    "496": "\t\t\tcase '4':",
                    "497": "\t\t\tcase '5':",
                    "498": "\t\t\tcase '6':",
                    "499": "\t\t\tcase '7':",
                    "500": "\t\t\tcase '8':",
                    "501": "\t\t\tcase '9':",
                    "502": "\t\t\tcase '.':",
                    "503": "\t\t\tcase 'h':",
                    "504": "\t\t\tcase 'l':",
                    "505": "\t\t\tcase 'L':",
                    "506": "\t\t\t\tcontinue;",
                    "507": "",
                    "508": "\t\t\tcase '*':",
                    "509": "\t\t\t\tbreak;",
                    "510": "",
                    "511": "\t\t\tcase 'j':",
                    "512": "\t\t\t\talign = VA_STACK_ALIGN(intmax_t);",
                    "513": "\t\t\t\tsize = sizeof(intmax_t);",
                    "514": "\t\t\t\tcontinue;",
                    "515": "",
                    "516": "\t\t\tcase 'z':",
                    "517": "\t\t\t\talign = VA_STACK_ALIGN(size_t);",
                    "518": "\t\t\t\tsize = sizeof(size_t);",
                    "519": "\t\t\t\tcontinue;",
                    "520": "",
                    "521": "\t\t\tcase 't':",
                    "522": "\t\t\t\talign = VA_STACK_ALIGN(ptrdiff_t);",
                    "523": "\t\t\t\tsize = sizeof(ptrdiff_t);",
                    "524": "\t\t\t\tcontinue;",
                    "525": "",
                    "526": "\t\t\tcase 'c':",
                    "527": "\t\t\tcase 'd':",
                    "528": "\t\t\tcase 'i':",
                    "529": "\t\t\tcase 'o':",
                    "530": "\t\t\tcase 'u':",
                    "531": "\t\t\tcase 'x':",
                    "532": "\t\t\tcase 'X':",
                    "533": "\t\t\t\tif (fmt[-1] == 'l') {",
                    "534": "\t\t\t\t\tif (fmt[-2] == 'l') {",
                    "535": "\t\t\t\t\t\talign = VA_STACK_ALIGN(long long);",
                    "536": "\t\t\t\t\t\tsize = sizeof(long long);",
                    "537": "\t\t\t\t\t} else {",
                    "538": "\t\t\t\t\t\talign = VA_STACK_ALIGN(long);",
                    "539": "\t\t\t\t\t\tsize = sizeof(long);",
                    "540": "\t\t\t\t\t}",
                    "541": "\t\t\t\t}",
                    "542": "\t\t\t\tparsing = false;",
                    "543": "\t\t\t\tbreak;",
                    "544": "",
                    "545": "\t\t\tcase 's':",
                    "546": "\t\t\t\tis_str_arg = true;",
                    "547": "",
                    "548": "\t\t\t\t__fallthrough;",
                    "549": "\t\t\tcase 'p':",
                    "550": "\t\t\tcase 'n':",
                    "551": "\t\t\t\talign = VA_STACK_ALIGN(void *);",
                    "552": "\t\t\t\tsize = sizeof(void *);",
                    "553": "\t\t\t\tparsing = false;",
                    "554": "\t\t\t\tbreak;",
                    "555": "",
                    "556": "\t\t\tcase 'a':",
                    "557": "\t\t\tcase 'A':",
                    "558": "\t\t\tcase 'e':",
                    "559": "\t\t\tcase 'E':",
                    "560": "\t\t\tcase 'f':",
                    "561": "\t\t\tcase 'F':",
                    "562": "\t\t\tcase 'g':",
                    "563": "\t\t\tcase 'G': {",
                    "564": "\t\t\t\t/*",
                    "565": "\t\t\t\t * Handle floats separately as they may be",
                    "566": "\t\t\t\t * held in a different register set.",
                    "567": "\t\t\t\t */",
                    "568": "\t\t\t\tunion { double d; long double ld; } v;",
                    "569": "",
                    "570": "\t\t\t\tif (fmt[-1] == 'L') {",
                    "571": "\t\t\t\t\tv.ld = va_arg(ap, long double);",
                    "572": "\t\t\t\t\talign = VA_STACK_ALIGN(long double);",
                    "573": "\t\t\t\t\tsize = sizeof(long double);",
                    "574": "\t\t\t\t} else {",
                    "575": "\t\t\t\t\tv.d = va_arg(ap, double);",
                    "576": "\t\t\t\t\talign = VA_STACK_ALIGN(double);",
                    "577": "\t\t\t\t\tsize = sizeof(double);",
                    "578": "\t\t\t\t}",
                    "579": "\t\t\t\t/* align destination buffer location */",
                    "580": "\t\t\t\tbuf = ROUND_UP(buf, align);",
                    "581": "\t\t\t\tif (buf0 != NULL) {",
                    "582": "\t\t\t\t\t/* make sure it fits */",
                    "583": "\t\t\t\t\tif (BUF_OFFSET + size > len) {",
                    "584": "\t\t\t\t\t\treturn -ENOSPC;",
                    "585": "\t\t\t\t\t}",
                    "586": "\t\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {",
                    "587": "\t\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, size);",
                    "588": "\t\t\t\t\t} else if (fmt[-1] == 'L') {",
                    "589": "\t\t\t\t\t\t*(long double *)buf = v.ld;",
                    "590": "\t\t\t\t\t} else {",
                    "591": "\t\t\t\t\t\t*(double *)buf = v.d;",
                    "592": "\t\t\t\t\t}",
                    "593": "\t\t\t\t}",
                    "594": "\t\t\t\tbuf += size;",
                    "595": "\t\t\t\tparsing = false;",
                    "596": "\t\t\t\tcontinue;",
                    "597": "\t\t\t}",
                    "598": "",
                    "599": "\t\t\tdefault:",
                    "600": "\t\t\t\tparsing = false;",
                    "601": "\t\t\t\tcontinue;",
                    "602": "\t\t\t}",
                    "603": "\t\t}",
                    "604": "",
                    "605": "\t\t/* align destination buffer location */",
                    "606": "\t\tbuf = ROUND_UP(buf, align);",
                    "607": "",
                    "608": "\t\t/* make sure the data fits */",
                    "609": "\t\tif ((buf0 != NULL) && (BUF_OFFSET + size) > len) {",
                    "610": "\t\t\treturn -ENOSPC;",
                    "611": "\t\t}",
                    "612": "",
                    "613": "\t\t/* copy va_list data over to our buffer */",
                    "614": "\t\tif (is_str_arg) {",
                    "615": "\t\t\ts = va_arg(ap, char *);",
                    "616": "process_string:",
                    "617": "\t\t\tif (buf0 != NULL) {",
                    "618": "\t\t\t\t*(const char **)buf = s;",
                    "619": "\t\t\t}",
                    "620": "",
                    "621": "\t\t\tbool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);",
                    "622": "\t\t\tbool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);",
                    "623": "",
                    "624": "\t\t\tif (is_ro && !do_ro) {",
                    "625": "\t\t\t\t/* nothing to do */",
                    "626": "\t\t\t} else {",
                    "627": "\t\t\t\tuint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);",
                    "628": "",
                    "629": "\t\t\t\t/*",
                    "630": "\t\t\t\t * In the do_ro case we must consider",
                    "631": "\t\t\t\t * room for possible STR_POS_RO_FLAG.",
                    "632": "\t\t\t\t * Otherwise the index range is 8 bits",
                    "633": "\t\t\t\t * and any overflow is caught later.",
                    "634": "\t\t\t\t */",
                    "635": "\t\t\t\tif (do_ro && s_ptr_idx > STR_POS_MASK) {",
                    "636": "\t\t\t\t\t__ASSERT(false, \"String with too many arguments\");",
                    "637": "\t\t\t\t\treturn -EINVAL;",
                    "638": "\t\t\t\t}",
                    "639": "",
                    "640": "\t\t\t\tif (s_idx >= ARRAY_SIZE(str_ptr_pos)) {",
                    "641": "\t\t\t\t\t__ASSERT(false, \"str_ptr_pos[] too small\");",
                    "642": "\t\t\t\t\treturn -EINVAL;",
                    "643": "\t\t\t\t}",
                    "644": "",
                    "645": "\t\t\t\tif (buf0 != NULL) {",
                    "646": "\t\t\t\t\t/*",
                    "647": "\t\t\t\t\t * Remember string pointer location.",
                    "648": "\t\t\t\t\t * We will append non-ro strings later.",
                    "649": "\t\t\t\t\t */",
                    "650": "\t\t\t\t\tstr_ptr_pos[s_idx] = s_ptr_idx;",
                    "651": "\t\t\t\t\tstr_ptr_arg[s_idx] = arg_idx;",
                    "652": "\t\t\t\t\tif (is_ro) {",
                    "653": "\t\t\t\t\t\t/* flag read-only string. */",
                    "654": "\t\t\t\t\t\tstr_ptr_pos[s_idx] |= STR_POS_RO_FLAG;",
                    "655": "\t\t\t\t\t\ts_ro_cnt++;",
                    "656": "\t\t\t\t\t} else {",
                    "657": "\t\t\t\t\t\ts_rw_cnt++;",
                    "658": "\t\t\t\t\t}",
                    "659": "\t\t\t\t} else if (is_ro) {",
                    "660": "\t\t\t\t\t/*",
                    "661": "\t\t\t\t\t * Add only pointer position prefix",
                    "662": "\t\t\t\t\t * when counting strings.",
                    "663": "\t\t\t\t\t */",
                    "664": "\t\t\t\t\tlen += 1;",
                    "665": "\t\t\t\t} else if (rws_pos_en) {",
                    "666": "\t\t\t\t\t/*",
                    "667": "\t\t\t\t\t * Add only pointer position prefix and",
                    "668": "\t\t\t\t\t * argument index when counting strings.",
                    "669": "\t\t\t\t\t */",
                    "670": "\t\t\t\t\tlen += 2;",
                    "671": "\t\t\t\t} else {",
                    "672": "\t\t\t\t\t/*",
                    "673": "\t\t\t\t\t * Add the string length, the final '\\0'",
                    "674": "\t\t\t\t\t * and size of the pointer position prefix.",
                    "675": "\t\t\t\t\t */",
                    "676": "\t\t\t\t\tlen += strlen(s) + 1 + 1;",
                    "677": "\t\t\t\t}",
                    "678": "",
                    "679": "\t\t\t\ts_idx++;",
                    "680": "\t\t\t}",
                    "681": "\t\t\tbuf += sizeof(char *);",
                    "682": "",
                    "683": "\t\t\tis_str_arg = false;",
                    "684": "\t\t} else if (size == sizeof(int)) {",
                    "685": "\t\t\tint v = va_arg(ap, int);",
                    "686": "",
                    "687": "\t\t\tif (buf0 != NULL) {",
                    "688": "\t\t\t\t*(int *)buf = v;",
                    "689": "\t\t\t}",
                    "690": "\t\t\tbuf += sizeof(int);",
                    "691": "\t\t} else if (size == sizeof(long)) {",
                    "692": "\t\t\tlong v = va_arg(ap, long);",
                    "693": "",
                    "694": "\t\t\tif (buf0 != NULL) {",
                    "695": "\t\t\t\t*(long *)buf = v;",
                    "696": "\t\t\t}",
                    "697": "\t\t\tbuf += sizeof(long);",
                    "698": "\t\t} else if (size == sizeof(long long)) {",
                    "699": "\t\t\tlong long v = va_arg(ap, long long);",
                    "700": "",
                    "701": "\t\t\tif (buf0 != NULL) {",
                    "702": "\t\t\t\tif (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {",
                    "703": "\t\t\t\t\tmemcpy((void *)buf, (uint8_t *)&v, sizeof(long long));",
                    "704": "\t\t\t\t} else {",
                    "705": "\t\t\t\t\t*(long long *)buf = v;",
                    "706": "\t\t\t\t}",
                    "707": "\t\t\t}",
                    "708": "\t\t\tbuf += sizeof(long long);",
                    "709": "\t\t} else {",
                    "710": "\t\t\t__ASSERT(false, \"unexpected size %u\", size);",
                    "711": "\t\t\treturn -EINVAL;",
                    "712": "\t\t}",
                    "713": "\t}",
                    "714": "",
                    "715": "\t/*",
                    "716": "\t * We remember the size of the argument list as a multiple of",
                    "717": "\t * sizeof(int) and limit it to a 8-bit field. That means 1020 bytes",
                    "718": "\t * worth of va_list, or about 127 arguments on a 64-bit system",
                    "719": "\t * (twice that on 32-bit systems). That ought to be good enough.",
                    "720": "\t */",
                    "721": "\tif ((BUF_OFFSET / sizeof(int)) > 255) {",
                    "722": "\t\t__ASSERT(false, \"too many format args\");",
                    "723": "\t\treturn -EINVAL;",
                    "724": "\t}",
                    "725": "",
                    "726": "\t/*",
                    "727": "\t * If all we wanted was to count required buffer size",
                    "728": "\t * then we have it now.",
                    "729": "\t */",
                    "730": "\tif (buf0 == NULL) {",
                    "731": "\t\treturn BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;",
                    "732": "\t}",
                    "733": "",
                    "734": "\t/* Clear our buffer header. We made room for it initially. */",
                    "735": "\t*(char **)buf0 = NULL;",
                    "736": "",
                    "737": "\t/* Record end of argument list. */",
                    "738": "\tpkg_hdr->desc.len = BUF_OFFSET / sizeof(int);",
                    "739": "",
                    "740": "\tif (rws_pos_en) {",
                    "741": "\t\t/* Strings are appended, update location counter. */",
                    "742": "\t\tpkg_hdr->desc.str_cnt = 0;",
                    "743": "\t\tpkg_hdr->desc.rw_str_cnt = s_rw_cnt;",
                    "744": "\t} else {",
                    "745": "\t\t/* Strings are appended, update append counter. */",
                    "746": "\t\tpkg_hdr->desc.str_cnt = s_rw_cnt;",
                    "747": "\t\tpkg_hdr->desc.rw_str_cnt = 0;",
                    "748": "\t}",
                    "749": "",
                    "750": "\tpkg_hdr->desc.ro_str_cnt = s_ro_cnt;",
                    "751": "",
                    "752": "#ifdef CONFIG_CBPRINTF_PACKAGE_HEADER_STORE_CREATION_FLAGS",
                    "753": "\tpkg_hdr->desc.pkg_flags = flags;",
                    "754": "#endif",
                    "755": "",
                    "756": "\t/* Store strings pointer locations of read only strings. */",
                    "757": "\tif (s_ro_cnt != 0U) {",
                    "758": "\t\tfor (i = 0; i < s_idx; i++) {",
                    "759": "\t\t\tif (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {",
                    "760": "\t\t\t\tcontinue;",
                    "761": "\t\t\t}",
                    "762": "",
                    "763": "\t\t\tuint8_t pos = str_ptr_pos[i] & STR_POS_MASK;",
                    "764": "",
                    "765": "\t\t\t/* make sure it fits */",
                    "766": "\t\t\tif ((BUF_OFFSET + 1) > len) {",
                    "767": "\t\t\t\treturn -ENOSPC;",
                    "768": "\t\t\t}",
                    "769": "\t\t\t/* store the pointer position prefix */",
                    "770": "\t\t\t*(uint8_t *)buf = pos;",
                    "771": "\t\t\t++buf;",
                    "772": "\t\t}",
                    "773": "\t}",
                    "774": "",
                    "775": "\t/* Store strings prefixed by their pointer location. */",
                    "776": "\tfor (i = 0; i < s_idx; i++) {",
                    "777": "\t\t/* Process only RW strings. */",
                    "778": "\t\tif (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {",
                    "779": "\t\t\tcontinue;",
                    "780": "\t\t}",
                    "781": "",
                    "782": "\t\tif (rws_pos_en) {",
                    "783": "\t\t\tsize = 0;",
                    "784": "\t\t\t*(uint8_t *)buf = str_ptr_arg[i];",
                    "785": "\t\t\t++buf;",
                    "786": "\t\t} else {",
                    "787": "\t\t\t/* retrieve the string pointer */",
                    "788": "\t\t\ts = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));",
                    "789": "\t\t\t/* clear the in-buffer pointer (less entropy if compressed) */",
                    "790": "\t\t\t*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;",
                    "791": "\t\t\t/* find the string length including terminating '\\0' */",
                    "792": "\t\t\tsize = strlen(s) + 1;",
                    "793": "\t\t}",
                    "794": "",
                    "795": "\t\t/* make sure it fits */",
                    "796": "\t\tif ((BUF_OFFSET + 1 + size) > len) {",
                    "797": "\t\t\treturn -ENOSPC;",
                    "798": "\t\t}",
                    "799": "\t\t/* store the pointer position prefix */",
                    "800": "\t\t*(uint8_t *)buf = str_ptr_pos[i];",
                    "801": "\t\t++buf;",
                    "802": "\t\t/* copy the string with its terminating '\\0' */",
                    "803": "\t\tmemcpy((void *)buf, (uint8_t *)s, size);",
                    "804": "\t\tbuf += size;",
                    "805": "\t}",
                    "806": "",
                    "807": "\t/*",
                    "808": "\t * TODO: remove pointers for appended strings since they're useless.",
                    "809": "\t * TODO: explore leveraging same mechanism to remove alignment padding",
                    "810": "\t */",
                    "811": "",
                    "812": "\treturn BUF_OFFSET;",
                    "813": "",
                    "814": "#undef BUF_OFFSET",
                    "815": "#undef STR_POS_RO_FLAG",
                    "816": "#undef STR_POS_MASK",
                    "817": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "cbprintf_package": {
            "name": "cbprintf_package",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 819,
            "function_content": [
                "/*\n* TODO: remove pointers for appended strings since they're useless.\n* TODO: explore leveraging same mechanism to remove alignment padding\n*/\nint cbprintf_package(void *packaged, size_t len, uint32_t flags,\n\t\t     const char *format, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, format);\n\tret = cbvprintf_package(packaged, len, flags, format, ap);\n\tva_end(ap);\n\treturn ret;\n}\n",
                {
                    "819": "int cbprintf_package(void *packaged, size_t len, uint32_t flags,",
                    "820": "\t\t     const char *format, ...)",
                    "821": "{",
                    "822": "\tva_list ap;",
                    "823": "\tint ret;",
                    "824": "",
                    "825": "\tva_start(ap, format);",
                    "826": "\tret = cbvprintf_package(packaged, len, flags, format, ap);",
                    "827": "\tva_end(ap);",
                    "828": "\treturn ret;",
                    "829": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "cbprintf": {
            "name": "cbprintf",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf.c",
            "location_line": 11,
            "function_content": [
                "/*\n* Copyright (c) 2020 Nordic Semiconductor ASA\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nint cbprintf(cbprintf_cb out, void *ctx, const char *format, ...)\n{\n\tva_list ap;\n\tint rc;\n\n\tva_start(ap, format);\n\trc = cbvprintf(out, ctx, format, ap);\n\tva_end(ap);\n\n\treturn rc;\n}\n",
                {
                    "11": "int cbprintf(cbprintf_cb out, void *ctx, const char *format, ...)",
                    "12": "{",
                    "13": "\tva_list ap;",
                    "14": "\tint rc;",
                    "15": "",
                    "16": "\tva_start(ap, format);",
                    "17": "\trc = cbvprintf(out, ctx, format, ap);",
                    "18": "\tva_end(ap);",
                    "19": "",
                    "20": "\treturn rc;",
                    "21": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "encode_uint": {
            "name": "encode_uint",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_complete.c",
            "location_line": 791,
            "function_content": [
                "/* Writes the given value into the buffer in the specified base.\n*\n* Precision is applied *ONLY* within the space allowed.\n*\n* Alternate form value is applied to o, x, and X conversions.\n*\n* The buffer is filled backwards, so the input bpe is the end of the\n* generated representation.  The returned pointer is to the first\n* character of the representation.\n*/\nstatic char *encode_uint(uint_value_type value,\n\t\t\t struct conversion *conv,\n\t\t\t char *bps,\n\t\t\t const char *bpe)\n{\n\tbool upcase = isupper((int)conv->specifier) != 0;\n\tconst unsigned int radix = conversion_radix(conv->specifier);\n\tchar *bp = bps + (bpe - bps);\n\n\tdo {\n\t\tunsigned int lsv = (unsigned int)(value % radix);\n\n\t\t--bp;\n\t\t*bp = (lsv <= 9) ? ('0' + lsv)\n\t\t\t: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);\n\t\tvalue /= radix;\n\t} while ((value != 0) && (bps < bp));\n\n\t/* Record required alternate forms.  This can be determined\n\t * from the radix without re-checking specifier.\n\t */\n\tif (conv->flag_hash) {\n\t\tif (radix == 8) {\n\t\t\tconv->altform_0 = true;\n\t\t} else if (radix == 16) {\n\t\t\tconv->altform_0c = true;\n\t\t} else {\n\t\t\t;\n\t\t}\n\t}\n\n\treturn bp;\n}\n",
                {
                    "791": "static char *encode_uint(uint_value_type value,",
                    "792": "\t\t\t struct conversion *conv,",
                    "793": "\t\t\t char *bps,",
                    "794": "\t\t\t const char *bpe)",
                    "795": "{",
                    "796": "\tbool upcase = isupper((int)conv->specifier) != 0;",
                    "797": "\tconst unsigned int radix = conversion_radix(conv->specifier);",
                    "798": "\tchar *bp = bps + (bpe - bps);",
                    "799": "",
                    "800": "\tdo {",
                    "801": "\t\tunsigned int lsv = (unsigned int)(value % radix);",
                    "802": "",
                    "803": "\t\t--bp;",
                    "804": "\t\t*bp = (lsv <= 9) ? ('0' + lsv)",
                    "805": "\t\t\t: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);",
                    "806": "\t\tvalue /= radix;",
                    "807": "\t} while ((value != 0) && (bps < bp));",
                    "808": "",
                    "809": "\t/* Record required alternate forms.  This can be determined",
                    "810": "\t * from the radix without re-checking specifier.",
                    "811": "\t */",
                    "812": "\tif (conv->flag_hash) {",
                    "813": "\t\tif (radix == 8) {",
                    "814": "\t\t\tconv->altform_0 = true;",
                    "815": "\t\t} else if (radix == 16) {",
                    "816": "\t\t\tconv->altform_0c = true;",
                    "817": "\t\t} else {",
                    "818": "\t\t\t;",
                    "819": "\t\t}",
                    "820": "\t}",
                    "821": "",
                    "822": "\treturn bp;",
                    "823": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "extract_decimal": {
            "name": "extract_decimal",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_complete.c",
            "location_line": 318,
            "function_content": [
                "/** Get a size represented as a sequence of decimal digits.\n*\n* @param[inout] str where to read from.  Updated to point to the first\n* unconsumed character.  There must be at least one non-digit character in\n* the referenced text.\n*\n* @return the decoded integer value.\n*/\nstatic size_t extract_decimal(const char **str)\n{\n\tconst char *sp = *str;\n\tsize_t val = 0;\n\n\twhile (isdigit((int)(unsigned char)*sp) != 0) {\n\t\tval = 10U * val + *sp++ - '0';\n\t}\n\t*str = sp;\n\treturn val;\n}\n",
                {
                    "318": "static size_t extract_decimal(const char **str)",
                    "319": "{",
                    "320": "\tconst char *sp = *str;",
                    "321": "\tsize_t val = 0;",
                    "322": "",
                    "323": "\twhile (isdigit((int)(unsigned char)*sp) != 0) {",
                    "324": "\t\tval = 10U * val + *sp++ - '0';",
                    "325": "\t}",
                    "326": "\t*str = sp;",
                    "327": "\treturn val;",
                    "328": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "append_string": {
            "name": "append_string",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 223,
            "function_content": [
                "/* Move beyond strings appended to the package. */\nstatic int append_string(cbprintf_convert_cb cb, void *ctx, const char *str, uint16_t strl)\n{\n\tif (cb == NULL) {\n\t\treturn 1 + strlen(str);\n\t}\n\n\tstrl = strl > 0 ? strl : strlen(str) + 1;\n\treturn cb(str, strl, ctx);\n}\n",
                {
                    "223": "static int append_string(cbprintf_convert_cb cb, void *ctx, const char *str, uint16_t strl)",
                    "224": "{",
                    "225": "\tif (cb == NULL) {",
                    "226": "\t\treturn 1 + strlen(str);",
                    "227": "\t}",
                    "228": "",
                    "229": "\tstrl = strl > 0 ? strl : strlen(str) + 1;",
                    "230": "\treturn cb(str, strl, ctx);",
                    "231": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_package_len": {
            "name": "get_package_len",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 196,
            "function_content": [
                "/*\n* Default implementation shared by many architectures like\n* 32-bit ARM and Intel.\n*\n* We assume va_list is a simple pointer.\n*/\nstatic size_t get_package_len(void *packaged)\n{\n\t__ASSERT_NO_MSG(packaged != NULL);\n\n\tuint8_t *buf = packaged;\n\tuint8_t *start = buf;\n\tunsigned int args_size, s_nbr, ros_nbr;\n\n\targs_size = buf[0] * sizeof(int);\n\ts_nbr     = buf[1];\n\tros_nbr   = buf[2];\n\n\t/* Move beyond args. */\n\tbuf += args_size;\n\n\t/* Move beyond read-only string indexes array. */\n\tbuf += ros_nbr;\n\n\t/* Move beyond strings appended to the package. */\n\tfor (unsigned int i = 0; i < s_nbr; i++) {\n\t\tbuf++;\n\t\tbuf += strlen((const char *)buf) + 1;\n\t}\n\n\treturn (size_t)(uintptr_t)(buf - start);\n}\n",
                {
                    "196": "static size_t get_package_len(void *packaged)",
                    "197": "{",
                    "198": "\t__ASSERT_NO_MSG(packaged != NULL);",
                    "199": "",
                    "200": "\tuint8_t *buf = packaged;",
                    "201": "\tuint8_t *start = buf;",
                    "202": "\tunsigned int args_size, s_nbr, ros_nbr;",
                    "203": "",
                    "204": "\targs_size = buf[0] * sizeof(int);",
                    "205": "\ts_nbr     = buf[1];",
                    "206": "\tros_nbr   = buf[2];",
                    "207": "",
                    "208": "\t/* Move beyond args. */",
                    "209": "\tbuf += args_size;",
                    "210": "",
                    "211": "\t/* Move beyond read-only string indexes array. */",
                    "212": "\tbuf += ros_nbr;",
                    "213": "",
                    "214": "\t/* Move beyond strings appended to the package. */",
                    "215": "\tfor (unsigned int i = 0; i < s_nbr; i++) {",
                    "216": "\t\tbuf++;",
                    "217": "\t\tbuf += strlen((const char *)buf) + 1;",
                    "218": "\t}",
                    "219": "",
                    "220": "\treturn (size_t)(uintptr_t)(buf - start);",
                    "221": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "cbprintf_via_va_list": {
            "name": "cbprintf_via_va_list",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/lib/os/cbprintf_packaged.c",
            "location_line": 113,
            "function_content": [
                "/*\n* Reference:\n*\n* System V Application Binary Interface\n* AMD64 Architecture Processor Supplement\n*/\nstatic int cbprintf_via_va_list(cbprintf_cb out,\n\t\t\t\tcbvprintf_external_formatter_func formatter,\n\t\t\t\tvoid *ctx,\n\t\t\t\tconst char *fmt, void *buf)\n{\n\tunion {\n\t\tva_list ap;\n\t\tstruct __va_list __ap;\n\t} u;\n\n\t/* create a valid va_list with our buffer */\n\tu.__ap.overflow_arg_area = buf;\n\tu.__ap.reg_save_area = NULL;\n\tu.__ap.gp_offset = (6 * 8);\n\tu.__ap.fp_offset = (6 * 8 + 16 * 16);\n\n\treturn formatter(out, ctx, fmt, u.ap);\n}\n",
                {
                    "113": "static int cbprintf_via_va_list(cbprintf_cb out,",
                    "114": "\t\t\t\tcbvprintf_external_formatter_func formatter,",
                    "115": "\t\t\t\tvoid *ctx,",
                    "116": "\t\t\t\tconst char *fmt, void *buf)",
                    "117": "{",
                    "118": "\tunion {",
                    "119": "\t\tva_list ap;",
                    "120": "\t\tstruct __va_list __ap;",
                    "121": "\t} u;",
                    "122": "",
                    "123": "\t/* create a valid va_list with our buffer */",
                    "124": "\tu.__ap.overflow_arg_area = buf;",
                    "125": "\tu.__ap.reg_save_area = NULL;",
                    "126": "\tu.__ap.gp_offset = (6 * 8);",
                    "127": "\tu.__ap.fp_offset = (6 * 8 + 16 * 16);",
                    "128": "",
                    "129": "\treturn formatter(out, ctx, fmt, u.ap);",
                    "130": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "z_log_msg_enqueue": {
            "name": "z_log_msg_enqueue",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_core.c",
            "location_line": 849,
            "function_content": [
                "/* Use only one buffer if others are not registered. */\nvoid z_log_msg_enqueue(const struct log_link *link, const void *data, size_t len)\n{\n\tstruct log_msg *log_msg = (struct log_msg *)data;\n\tsize_t wlen = DIV_ROUND_UP(ROUND_UP(len, Z_LOG_MSG_ALIGNMENT), sizeof(int));\n\tstruct mpsc_pbuf_buffer *mpsc_pbuffer = link->mpsc_pbuf ? link->mpsc_pbuf : &log_buffer;\n\tstruct log_msg *local_msg = msg_alloc(mpsc_pbuffer, wlen);\n\n\tif (!local_msg) {\n\t\tz_log_dropped(false);\n\t\treturn;\n\t}\n\n\tlog_msg->hdr.desc.valid = 0;\n\tlog_msg->hdr.desc.busy = 0;\n\tlog_msg->hdr.desc.domain += link->ctrl_blk->domain_offset;\n\tmemcpy((void *)local_msg, data, len);\n\tmsg_commit(mpsc_pbuffer, local_msg);\n}\n",
                {
                    "849": "void z_log_msg_enqueue(const struct log_link *link, const void *data, size_t len)",
                    "850": "{",
                    "851": "\tstruct log_msg *log_msg = (struct log_msg *)data;",
                    "852": "\tsize_t wlen = DIV_ROUND_UP(ROUND_UP(len, Z_LOG_MSG_ALIGNMENT), sizeof(int));",
                    "853": "\tstruct mpsc_pbuf_buffer *mpsc_pbuffer = link->mpsc_pbuf ? link->mpsc_pbuf : &log_buffer;",
                    "854": "\tstruct log_msg *local_msg = msg_alloc(mpsc_pbuffer, wlen);",
                    "855": "",
                    "856": "\tif (!local_msg) {",
                    "857": "\t\tz_log_dropped(false);",
                    "858": "\t\treturn;",
                    "859": "\t}",
                    "860": "",
                    "861": "\tlog_msg->hdr.desc.valid = 0;",
                    "862": "\tlog_msg->hdr.desc.busy = 0;",
                    "863": "\tlog_msg->hdr.desc.domain += link->ctrl_blk->domain_offset;",
                    "864": "\tmemcpy((void *)local_msg, data, len);",
                    "865": "\tmsg_commit(mpsc_pbuffer, local_msg);",
                    "866": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ids_print": {
            "name": "ids_print",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_output.c",
            "location_line": 297,
            "function_content": [
                "#endif /* CONFIG_POSIX_C_LANG_SUPPORT_R */\nstatic int ids_print(const struct log_output *output,\n\t\t     bool level_on,\n\t\t     bool func_on,\n\t\t     bool thread_on,\n\t\t     const char *domain,\n\t\t     const char *source,\n\t\t     k_tid_t tid,\n\t\t     uint32_t level)\n{\n\tint total = 0;\n\n\tif (level_on) {\n\t\ttotal += print_formatted(output, \"<%s> \", severity[level]);\n\t}\n\n\tif (IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) && thread_on) {\n\t\tif (tid == NULL) {\n\t\t\ttotal += print_formatted(output, \"[irq] \");\n\t\t} else if (IS_ENABLED(CONFIG_THREAD_NAME)) {\n\t\t\ttotal += print_formatted(output,\n\t\t\t\t\t\"[%3d %s] \",\n\t\t\t\t\tk_thread_priority_get(tid),\n\t\t\t\t\tk_thread_name_get(tid));\n\t\t} else {\n\t\t\ttotal += print_formatted(output,\n\t\t\t\t\t\"[%3d %p] \",\n\t\t\t\t\tk_thread_priority_get(tid),\n\t\t\t\t\ttid);\n\t\t}\n\t}\n\n\tif (domain) {\n\t\ttotal += print_formatted(output, \"%s/\", domain);\n\t}\n\n\tif (source) {\n\t\ttotal += print_formatted(output,\n\t\t\t\t(func_on &&\n\t\t\t\t((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?\n\t\t\t\t\"%s.\" : \"%s: \",\n\t\t\t\tsource);\n\t}\n\n\treturn total;\n}\n",
                {
                    "297": "static int ids_print(const struct log_output *output,",
                    "298": "\t\t     bool level_on,",
                    "299": "\t\t     bool func_on,",
                    "300": "\t\t     bool thread_on,",
                    "301": "\t\t     const char *domain,",
                    "302": "\t\t     const char *source,",
                    "303": "\t\t     k_tid_t tid,",
                    "304": "\t\t     uint32_t level)",
                    "305": "{",
                    "306": "\tint total = 0;",
                    "307": "",
                    "308": "\tif (level_on) {",
                    "309": "\t\ttotal += print_formatted(output, \"<%s> \", severity[level]);",
                    "310": "\t}",
                    "311": "",
                    "312": "\tif (IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) && thread_on) {",
                    "313": "\t\tif (tid == NULL) {",
                    "314": "\t\t\ttotal += print_formatted(output, \"[irq] \");",
                    "315": "\t\t} else if (IS_ENABLED(CONFIG_THREAD_NAME)) {",
                    "316": "\t\t\ttotal += print_formatted(output,",
                    "317": "\t\t\t\t\t\"[%3d %s] \",",
                    "318": "\t\t\t\t\tk_thread_priority_get(tid),",
                    "319": "\t\t\t\t\tk_thread_name_get(tid));",
                    "320": "\t\t} else {",
                    "321": "\t\t\ttotal += print_formatted(output,",
                    "322": "\t\t\t\t\t\"[%3d %p] \",",
                    "323": "\t\t\t\t\tk_thread_priority_get(tid),",
                    "324": "\t\t\t\t\ttid);",
                    "325": "\t\t}",
                    "326": "\t}",
                    "327": "",
                    "328": "\tif (domain) {",
                    "329": "\t\ttotal += print_formatted(output, \"%s/\", domain);",
                    "330": "\t}",
                    "331": "",
                    "332": "\tif (source) {",
                    "333": "\t\ttotal += print_formatted(output,",
                    "334": "\t\t\t\t(func_on &&",
                    "335": "\t\t\t\t((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?",
                    "336": "\t\t\t\t\"%s.\" : \"%s: \",",
                    "337": "\t\t\t\tsource);",
                    "338": "\t}",
                    "339": "",
                    "340": "\treturn total;",
                    "341": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "print_formatted": {
            "name": "print_formatted",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/logging/log_output.c",
            "location_line": 129,
            "function_content": [
                "/* Need that step for big endian */\nstatic int print_formatted(const struct log_output *output,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint length = 0;\n\n\tva_start(args, fmt);\n\tlength = cbvprintf(out_func, (void *)output, fmt, args);\n\tva_end(args);\n\n\treturn length;\n}\n",
                {
                    "129": "static int print_formatted(const struct log_output *output,",
                    "130": "\t\t\t   const char *fmt, ...)",
                    "131": "{",
                    "132": "\tva_list args;",
                    "133": "\tint length = 0;",
                    "134": "",
                    "135": "\tva_start(args, fmt);",
                    "136": "\tlength = cbvprintf(out_func, (void *)output, fmt, args);",
                    "137": "\tva_end(args);",
                    "138": "",
                    "139": "\treturn length;",
                    "140": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "conn_addr_cmp": {
            "name": "conn_addr_cmp",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/connection.c",
            "location_line": 504,
            "function_content": [
                "/* Check if we already have identical connection handler installed. */\nstatic bool conn_addr_cmp(struct net_pkt *pkt,\n\t\t\t  union net_ip_header *ip_hdr,\n\t\t\t  struct net_sockaddr *addr,\n\t\t\t  bool is_remote)\n{\n\tif (addr->sa_family != net_pkt_family(pkt)) {\n\t\treturn false;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_pkt_family(pkt) == NET_AF_INET6 &&\n\t    addr->sa_family == NET_AF_INET6) {\n\t\tuint8_t *addr6;\n\n\t\tif (is_remote) {\n\t\t\taddr6 = ip_hdr->ipv6->src;\n\t\t} else {\n\t\t\taddr6 = ip_hdr->ipv6->dst;\n\t\t}\n\n\t\tif (!net_ipv6_is_addr_unspecified(\n\t\t\t    &net_sin6(addr)->sin6_addr)) {\n\t\t\tif (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,\n\t\t\t\t\t\t   addr6)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\t   net_pkt_family(pkt) == NET_AF_INET &&\n\t\t   addr->sa_family == NET_AF_INET) {\n\t\tuint8_t *addr4;\n\n\t\tif (is_remote) {\n\t\t\taddr4 = ip_hdr->ipv4->src;\n\t\t} else {\n\t\t\taddr4 = ip_hdr->ipv4->dst;\n\t\t}\n\n\t\tif (net_sin(addr)->sin_addr.s_addr) {\n\t\t\tif (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,\n\t\t\t\t\t\t   addr4)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n",
                {
                    "504": "static bool conn_addr_cmp(struct net_pkt *pkt,",
                    "505": "\t\t\t  union net_ip_header *ip_hdr,",
                    "506": "\t\t\t  struct net_sockaddr *addr,",
                    "507": "\t\t\t  bool is_remote)",
                    "508": "{",
                    "509": "\tif (addr->sa_family != net_pkt_family(pkt)) {",
                    "510": "\t\treturn false;",
                    "511": "\t}",
                    "512": "",
                    "513": "\tif (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "514": "\t    net_pkt_family(pkt) == NET_AF_INET6 &&",
                    "515": "\t    addr->sa_family == NET_AF_INET6) {",
                    "516": "\t\tuint8_t *addr6;",
                    "517": "",
                    "518": "\t\tif (is_remote) {",
                    "519": "\t\t\taddr6 = ip_hdr->ipv6->src;",
                    "520": "\t\t} else {",
                    "521": "\t\t\taddr6 = ip_hdr->ipv6->dst;",
                    "522": "\t\t}",
                    "523": "",
                    "524": "\t\tif (!net_ipv6_is_addr_unspecified(",
                    "525": "\t\t\t    &net_sin6(addr)->sin6_addr)) {",
                    "526": "\t\t\tif (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,",
                    "527": "\t\t\t\t\t\t   addr6)) {",
                    "528": "\t\t\t\treturn false;",
                    "529": "\t\t\t}",
                    "530": "\t\t}",
                    "531": "",
                    "532": "\t\treturn true;",
                    "533": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "534": "\t\t   net_pkt_family(pkt) == NET_AF_INET &&",
                    "535": "\t\t   addr->sa_family == NET_AF_INET) {",
                    "536": "\t\tuint8_t *addr4;",
                    "537": "",
                    "538": "\t\tif (is_remote) {",
                    "539": "\t\t\taddr4 = ip_hdr->ipv4->src;",
                    "540": "\t\t} else {",
                    "541": "\t\t\taddr4 = ip_hdr->ipv4->dst;",
                    "542": "\t\t}",
                    "543": "",
                    "544": "\t\tif (net_sin(addr)->sin_addr.s_addr) {",
                    "545": "\t\t\tif (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,",
                    "546": "\t\t\t\t\t\t   addr4)) {",
                    "547": "\t\t\t\treturn false;",
                    "548": "\t\t\t}",
                    "549": "\t\t}",
                    "550": "\t}",
                    "551": "",
                    "552": "\treturn true;",
                    "553": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "send_icmpv6_echo_request": {
            "name": "send_icmpv6_echo_request",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/icmp.c",
            "location_line": 250,
            "function_content": [
                "/* No payload. */\nstatic int send_icmpv6_echo_request(struct net_icmp_ctx *ctx,\n\t\t\t\t    struct net_if *iface,\n\t\t\t\t    struct net_in6_addr *dst,\n\t\t\t\t    struct net_icmp_ping_params *params,\n\t\t\t\t    void *user_data,\n\t\t\t\t    k_timeout_t timeout)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,\n\t\t\t\t\t      struct net_icmpv6_echo_req);\n\tint ret = -ENOBUFS;\n\tstruct net_icmpv6_echo_req *echo_req;\n\tconst struct net_in6_addr *src;\n\tstruct net_pkt *pkt;\n\n\tif (!iface->config.ip.ipv6) {\n\t\treturn -ENETUNREACH;\n\t}\n\n\tsrc = net_if_ipv6_select_src_addr(iface, dst);\n\n\tpkt = net_pkt_alloc_with_buffer(iface,\n\t\t\t\t\tsizeof(struct net_icmpv6_echo_req)\n\t\t\t\t\t+ params->data_size,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\ttimeout);\n\tif (!pkt) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_NET_ALLOW_ANY_PRIORITY) &&\n\t    params->priority >= NET_MAX_PRIORITIES) {\n\t\tNET_ERR(\"Priority %d is too large, maximum allowed is %d\",\n\t\t\tparams->priority, NET_MAX_PRIORITIES - 1);\n\t\tret = -EINVAL;\n\t\tgoto drop;\n\t}\n\n\tif (params->priority < 0) {\n\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(params->tc_tos));\n\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(params->tc_tos));\n\t} else {\n\t\tnet_pkt_set_priority(pkt, params->priority);\n\t}\n\n\tif (net_ipv6_create(pkt, src, dst) ||\n\t    net_icmpv6_create(pkt, NET_ICMPV6_ECHO_REQUEST, 0)) {\n\t\tgoto drop;\n\t}\n\n\techo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(\n\t\t\t\t\t\t\tpkt, &icmpv6_access);\n\tif (!echo_req) {\n\t\tgoto drop;\n\t}\n\n\techo_req->identifier = net_htons(params->identifier);\n\techo_req->sequence   = net_htons(params->sequence);\n\n\tnet_pkt_set_data(pkt, &icmpv6_access);\n\n\tif (params->data != NULL && params->data_size > 0) {\n\t\tnet_pkt_write(pkt, params->data, params->data_size);\n\t} else if (params->data == NULL && params->data_size > 0) {\n\t\t/* Generate payload. */\n\t\tif (params->data_size >= sizeof(uint32_t)) {\n\t\t\tuint32_t time_stamp = net_htonl(k_cycle_get_32());\n\n\t\t\tnet_pkt_write(pkt, &time_stamp, sizeof(time_stamp));\n\t\t\tparams->data_size -= sizeof(time_stamp);\n\t\t}\n\n\t\tfor (size_t i = 0; i < params->data_size; i++) {\n\t\t\tnet_pkt_write_u8(pkt, (uint8_t)i);\n\t\t}\n\t} else {\n\t\t/* No payload. */\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tNET_DBG(\"Sending ICMPv6 Echo Request type %d from %s to %s\",\n\t\tNET_ICMPV6_ECHO_REQUEST,\n\t\tnet_sprint_ipv6_addr(src),\n\t\tnet_sprint_ipv6_addr(dst));\n\n\tctx->user_data = user_data;\n\tctx->iface = iface;\n\n\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {\n\t\tnet_stats_update_icmp_sent(iface);\n\t\treturn 0;\n\t}\n\n\tnet_stats_update_icmp_drop(iface);\n\n\tret = -EIO;\n\ndrop:\n\tnet_pkt_unref(pkt);\n\n\treturn ret;\n}\n",
                {
                    "250": "static int send_icmpv6_echo_request(struct net_icmp_ctx *ctx,",
                    "251": "\t\t\t\t    struct net_if *iface,",
                    "252": "\t\t\t\t    struct net_in6_addr *dst,",
                    "253": "\t\t\t\t    struct net_icmp_ping_params *params,",
                    "254": "\t\t\t\t    void *user_data,",
                    "255": "\t\t\t\t    k_timeout_t timeout)",
                    "256": "{",
                    "257": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,",
                    "258": "\t\t\t\t\t      struct net_icmpv6_echo_req);",
                    "259": "\tint ret = -ENOBUFS;",
                    "260": "\tstruct net_icmpv6_echo_req *echo_req;",
                    "261": "\tconst struct net_in6_addr *src;",
                    "262": "\tstruct net_pkt *pkt;",
                    "263": "",
                    "264": "\tif (!iface->config.ip.ipv6) {",
                    "265": "\t\treturn -ENETUNREACH;",
                    "266": "\t}",
                    "267": "",
                    "268": "\tsrc = net_if_ipv6_select_src_addr(iface, dst);",
                    "269": "",
                    "270": "\tpkt = net_pkt_alloc_with_buffer(iface,",
                    "271": "\t\t\t\t\tsizeof(struct net_icmpv6_echo_req)",
                    "272": "\t\t\t\t\t+ params->data_size,",
                    "273": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "274": "\t\t\t\t\ttimeout);",
                    "275": "\tif (!pkt) {",
                    "276": "\t\treturn -ENOMEM;",
                    "277": "\t}",
                    "278": "",
                    "279": "\tif (!IS_ENABLED(CONFIG_NET_ALLOW_ANY_PRIORITY) &&",
                    "280": "\t    params->priority >= NET_MAX_PRIORITIES) {",
                    "281": "\t\tNET_ERR(\"Priority %d is too large, maximum allowed is %d\",",
                    "282": "\t\t\tparams->priority, NET_MAX_PRIORITIES - 1);",
                    "283": "\t\tret = -EINVAL;",
                    "284": "\t\tgoto drop;",
                    "285": "\t}",
                    "286": "",
                    "287": "\tif (params->priority < 0) {",
                    "288": "\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(params->tc_tos));",
                    "289": "\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(params->tc_tos));",
                    "290": "\t} else {",
                    "291": "\t\tnet_pkt_set_priority(pkt, params->priority);",
                    "292": "\t}",
                    "293": "",
                    "294": "\tif (net_ipv6_create(pkt, src, dst) ||",
                    "295": "\t    net_icmpv6_create(pkt, NET_ICMPV6_ECHO_REQUEST, 0)) {",
                    "296": "\t\tgoto drop;",
                    "297": "\t}",
                    "298": "",
                    "299": "\techo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(",
                    "300": "\t\t\t\t\t\t\tpkt, &icmpv6_access);",
                    "301": "\tif (!echo_req) {",
                    "302": "\t\tgoto drop;",
                    "303": "\t}",
                    "304": "",
                    "305": "\techo_req->identifier = net_htons(params->identifier);",
                    "306": "\techo_req->sequence   = net_htons(params->sequence);",
                    "307": "",
                    "308": "\tnet_pkt_set_data(pkt, &icmpv6_access);",
                    "309": "",
                    "310": "\tif (params->data != NULL && params->data_size > 0) {",
                    "311": "\t\tnet_pkt_write(pkt, params->data, params->data_size);",
                    "312": "\t} else if (params->data == NULL && params->data_size > 0) {",
                    "313": "\t\t/* Generate payload. */",
                    "314": "\t\tif (params->data_size >= sizeof(uint32_t)) {",
                    "315": "\t\t\tuint32_t time_stamp = net_htonl(k_cycle_get_32());",
                    "316": "",
                    "317": "\t\t\tnet_pkt_write(pkt, &time_stamp, sizeof(time_stamp));",
                    "318": "\t\t\tparams->data_size -= sizeof(time_stamp);",
                    "319": "\t\t}",
                    "320": "",
                    "321": "\t\tfor (size_t i = 0; i < params->data_size; i++) {",
                    "322": "\t\t\tnet_pkt_write_u8(pkt, (uint8_t)i);",
                    "323": "\t\t}",
                    "324": "\t} else {",
                    "325": "\t\t/* No payload. */",
                    "326": "\t}",
                    "327": "",
                    "328": "\tnet_pkt_cursor_init(pkt);",
                    "329": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "330": "",
                    "331": "\tNET_DBG(\"Sending ICMPv6 Echo Request type %d from %s to %s\",",
                    "332": "\t\tNET_ICMPV6_ECHO_REQUEST,",
                    "333": "\t\tnet_sprint_ipv6_addr(src),",
                    "334": "\t\tnet_sprint_ipv6_addr(dst));",
                    "335": "",
                    "336": "\tctx->user_data = user_data;",
                    "337": "\tctx->iface = iface;",
                    "338": "",
                    "339": "\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {",
                    "340": "\t\tnet_stats_update_icmp_sent(iface);",
                    "341": "\t\treturn 0;",
                    "342": "\t}",
                    "343": "",
                    "344": "\tnet_stats_update_icmp_drop(iface);",
                    "345": "",
                    "346": "\tret = -EIO;",
                    "347": "",
                    "348": "drop:",
                    "349": "\tnet_pkt_unref(pkt);",
                    "350": "",
                    "351": "\treturn ret;",
                    "352": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_icmpv6_send_error": {
            "name": "net_icmpv6_send_error",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/icmpv6.c",
            "location_line": 194,
            "function_content": [
                "/* We must not set the destination ll address here but trust\n* that it is set properly using a value from neighbor cache.\n* Same for source as it points to original pkt ll src address.\n*/\nint net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,\n\t\t\t  uint32_t param)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tint err = -EIO;\n\tstruct net_in6_addr orig_src, orig_dst;\n\tstruct net_ipv6_hdr *ip_hdr;\n\tconst struct net_in6_addr *src;\n\tstruct net_pkt *pkt;\n\tsize_t copy_len;\n\tint ret;\n\n\tnet_pkt_cursor_init(orig);\n\n\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);\n\tif (!ip_hdr) {\n\t\tgoto drop_no_pkt;\n\t}\n\n\tif (ip_hdr->nexthdr == NET_IPPROTO_ICMPV6) {\n\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,\n\t\t\t\t\t\t      struct net_icmp_hdr);\n\t\tstruct net_icmp_hdr *icmp_hdr;\n\n\t\tnet_pkt_acknowledge_data(orig, &ipv6_access);\n\n\t\ticmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(\n\t\t\t\t\t\t\torig, &icmpv6_access);\n\t\tif (!icmp_hdr || icmp_hdr->type < 128) {\n\t\t\t/* We must not send ICMP errors back */\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop_no_pkt;\n\t\t}\n\n\t\tnet_pkt_cursor_init(orig);\n\t}\n\n\tnet_ipv6_addr_copy_raw(orig_src.s6_addr, ip_hdr->src);\n\tnet_ipv6_addr_copy_raw(orig_dst.s6_addr, ip_hdr->dst);\n\n\tif (ip_hdr->nexthdr == NET_IPPROTO_UDP) {\n\t\tcopy_len = sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_udp_hdr);\n\t} else if (ip_hdr->nexthdr == NET_IPPROTO_TCP) {\n\t\tcopy_len = sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_tcp_hdr);\n\t} else {\n\t\tcopy_len = net_pkt_get_len(orig);\n\t}\n\n\tpkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),\n\t\t\t\t\tnet_pkt_lladdr_src(orig)->len * 2 +\n\t\t\t\t\tcopy_len + NET_ICMPV6_UNUSED_LEN,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tPKT_WAIT_TIME);\n\tif (!pkt) {\n\t\terr = -ENOMEM;\n\t\tgoto drop_no_pkt;\n\t}\n\n\t/* We created above a new packet that contains some extra space that we\n\t * will use to store the destination and source link addresses. This is\n\t * needed because we cannot use the original pkt, which contains the\n\t * link address where the new packet will be sent, as that pkt might\n\t * get re-used before we have managed to set the link addresses in L2\n\t * as that (link address setting) happens in a different thread (TX)\n\t * than this one.\n\t * So we copy the destination and source link addresses here, then set\n\t * the link address pointers correctly, and skip the needed space\n\t * as the link address will be set in the pkt when the packet is\n\t * constructed in L2. So basically all this for just to create some\n\t * extra space for link addresses so that we can set the lladdr\n\t * pointers in net_pkt.\n\t */\n\tret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,\n\t\t\t    net_pkt_lladdr_src(orig)->len);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto drop;\n\t}\n\n\tmemcpy(net_pkt_lladdr_dst(pkt)->addr, pkt->buffer->data,\n\t       net_pkt_lladdr_dst(orig)->len);\n\n\tret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,\n\t\t\t    net_pkt_lladdr_dst(orig)->len);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto drop;\n\t}\n\n\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);\n\n\tmemcpy(net_pkt_lladdr_src(pkt)->addr, pkt->buffer->data,\n\t       net_pkt_lladdr_src(orig)->len);\n\n\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);\n\n\tnet_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;\n\tnet_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;\n\n\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {\n\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),\n\t\t\t\t\t\t  &orig_dst);\n\t} else {\n\t\tsrc = &orig_dst;\n\t}\n\n\tif (net_ipv6_create(pkt, src, &orig_src) ||\n\t    net_icmpv6_create(pkt, type, code)) {\n\t\tgoto drop;\n\t}\n\n\t/* Depending on error option, we store the param into the ICMP message.\n\t */\n\tif (type == NET_ICMPV6_PARAM_PROBLEM) {\n\t\terr = net_pkt_write_be32(pkt, param);\n\t} else {\n\t\terr = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);\n\t}\n\n\t/* Allocator might not have been able to allocate all requested space,\n\t * so let's copy as much as we can.\n\t */\n\tcopy_len = net_pkt_available_buffer(pkt);\n\n\tif (err || net_pkt_copy(pkt, orig, copy_len)) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tNET_DBG(\"Sending ICMPv6 Error Message type %d code %d param %d\"\n\t\t\" from %s to %s\", type, code, param,\n\t\tnet_sprint_ipv6_addr(src),\n\t\tnet_sprint_ipv6_addr(&orig_src));\n\n\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {\n\t\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\t\treturn 0;\n\t}\n\ndrop:\n\tnet_pkt_unref(pkt);\n\ndrop_no_pkt:\n\tnet_stats_update_icmp_drop(net_pkt_iface(orig));\n\n\treturn err;\n}\n",
                {
                    "194": "int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,",
                    "195": "\t\t\t  uint32_t param)",
                    "196": "{",
                    "197": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "198": "\tint err = -EIO;",
                    "199": "\tstruct net_in6_addr orig_src, orig_dst;",
                    "200": "\tstruct net_ipv6_hdr *ip_hdr;",
                    "201": "\tconst struct net_in6_addr *src;",
                    "202": "\tstruct net_pkt *pkt;",
                    "203": "\tsize_t copy_len;",
                    "204": "\tint ret;",
                    "205": "",
                    "206": "\tnet_pkt_cursor_init(orig);",
                    "207": "",
                    "208": "\tip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);",
                    "209": "\tif (!ip_hdr) {",
                    "210": "\t\tgoto drop_no_pkt;",
                    "211": "\t}",
                    "212": "",
                    "213": "\tif (ip_hdr->nexthdr == NET_IPPROTO_ICMPV6) {",
                    "214": "\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,",
                    "215": "\t\t\t\t\t\t      struct net_icmp_hdr);",
                    "216": "\t\tstruct net_icmp_hdr *icmp_hdr;",
                    "217": "",
                    "218": "\t\tnet_pkt_acknowledge_data(orig, &ipv6_access);",
                    "219": "",
                    "220": "\t\ticmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(",
                    "221": "\t\t\t\t\t\t\torig, &icmpv6_access);",
                    "222": "\t\tif (!icmp_hdr || icmp_hdr->type < 128) {",
                    "223": "\t\t\t/* We must not send ICMP errors back */",
                    "224": "\t\t\terr = -EINVAL;",
                    "225": "\t\t\tgoto drop_no_pkt;",
                    "226": "\t\t}",
                    "227": "",
                    "228": "\t\tnet_pkt_cursor_init(orig);",
                    "229": "\t}",
                    "230": "",
                    "231": "\tnet_ipv6_addr_copy_raw(orig_src.s6_addr, ip_hdr->src);",
                    "232": "\tnet_ipv6_addr_copy_raw(orig_dst.s6_addr, ip_hdr->dst);",
                    "233": "",
                    "234": "\tif (ip_hdr->nexthdr == NET_IPPROTO_UDP) {",
                    "235": "\t\tcopy_len = sizeof(struct net_ipv6_hdr) +",
                    "236": "\t\t\tsizeof(struct net_udp_hdr);",
                    "237": "\t} else if (ip_hdr->nexthdr == NET_IPPROTO_TCP) {",
                    "238": "\t\tcopy_len = sizeof(struct net_ipv6_hdr) +",
                    "239": "\t\t\tsizeof(struct net_tcp_hdr);",
                    "240": "\t} else {",
                    "241": "\t\tcopy_len = net_pkt_get_len(orig);",
                    "242": "\t}",
                    "243": "",
                    "244": "\tpkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),",
                    "245": "\t\t\t\t\tnet_pkt_lladdr_src(orig)->len * 2 +",
                    "246": "\t\t\t\t\tcopy_len + NET_ICMPV6_UNUSED_LEN,",
                    "247": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "248": "\t\t\t\t\tPKT_WAIT_TIME);",
                    "249": "\tif (!pkt) {",
                    "250": "\t\terr = -ENOMEM;",
                    "251": "\t\tgoto drop_no_pkt;",
                    "252": "\t}",
                    "253": "",
                    "254": "\t/* We created above a new packet that contains some extra space that we",
                    "255": "\t * will use to store the destination and source link addresses. This is",
                    "256": "\t * needed because we cannot use the original pkt, which contains the",
                    "257": "\t * link address where the new packet will be sent, as that pkt might",
                    "258": "\t * get re-used before we have managed to set the link addresses in L2",
                    "259": "\t * as that (link address setting) happens in a different thread (TX)",
                    "260": "\t * than this one.",
                    "261": "\t * So we copy the destination and source link addresses here, then set",
                    "262": "\t * the link address pointers correctly, and skip the needed space",
                    "263": "\t * as the link address will be set in the pkt when the packet is",
                    "264": "\t * constructed in L2. So basically all this for just to create some",
                    "265": "\t * extra space for link addresses so that we can set the lladdr",
                    "266": "\t * pointers in net_pkt.",
                    "267": "\t */",
                    "268": "\tret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,",
                    "269": "\t\t\t    net_pkt_lladdr_src(orig)->len);",
                    "270": "\tif (ret < 0) {",
                    "271": "\t\terr = ret;",
                    "272": "\t\tgoto drop;",
                    "273": "\t}",
                    "274": "",
                    "275": "\tmemcpy(net_pkt_lladdr_dst(pkt)->addr, pkt->buffer->data,",
                    "276": "\t       net_pkt_lladdr_dst(orig)->len);",
                    "277": "",
                    "278": "\tret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,",
                    "279": "\t\t\t    net_pkt_lladdr_dst(orig)->len);",
                    "280": "\tif (ret < 0) {",
                    "281": "\t\terr = ret;",
                    "282": "\t\tgoto drop;",
                    "283": "\t}",
                    "284": "",
                    "285": "\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);",
                    "286": "",
                    "287": "\tmemcpy(net_pkt_lladdr_src(pkt)->addr, pkt->buffer->data,",
                    "288": "\t       net_pkt_lladdr_src(orig)->len);",
                    "289": "",
                    "290": "\tnet_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);",
                    "291": "",
                    "292": "\tnet_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;",
                    "293": "\tnet_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;",
                    "294": "",
                    "295": "\tif (net_ipv6_is_addr_mcast_raw(ip_hdr->dst)) {",
                    "296": "\t\tsrc = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),",
                    "297": "\t\t\t\t\t\t  &orig_dst);",
                    "298": "\t} else {",
                    "299": "\t\tsrc = &orig_dst;",
                    "300": "\t}",
                    "301": "",
                    "302": "\tif (net_ipv6_create(pkt, src, &orig_src) ||",
                    "303": "\t    net_icmpv6_create(pkt, type, code)) {",
                    "304": "\t\tgoto drop;",
                    "305": "\t}",
                    "306": "",
                    "307": "\t/* Depending on error option, we store the param into the ICMP message.",
                    "308": "\t */",
                    "309": "\tif (type == NET_ICMPV6_PARAM_PROBLEM) {",
                    "310": "\t\terr = net_pkt_write_be32(pkt, param);",
                    "311": "\t} else {",
                    "312": "\t\terr = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);",
                    "313": "\t}",
                    "314": "",
                    "315": "\t/* Allocator might not have been able to allocate all requested space,",
                    "316": "\t * so let's copy as much as we can.",
                    "317": "\t */",
                    "318": "\tcopy_len = net_pkt_available_buffer(pkt);",
                    "319": "",
                    "320": "\tif (err || net_pkt_copy(pkt, orig, copy_len)) {",
                    "321": "\t\tgoto drop;",
                    "322": "\t}",
                    "323": "",
                    "324": "\tnet_pkt_cursor_init(pkt);",
                    "325": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "326": "",
                    "327": "\tNET_DBG(\"Sending ICMPv6 Error Message type %d code %d param %d\"",
                    "328": "\t\t\" from %s to %s\", type, code, param,",
                    "329": "\t\tnet_sprint_ipv6_addr(src),",
                    "330": "\t\tnet_sprint_ipv6_addr(&orig_src));",
                    "331": "",
                    "332": "\tif (net_try_send_data(pkt, K_NO_WAIT) >= 0) {",
                    "333": "\t\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "334": "\t\treturn 0;",
                    "335": "\t}",
                    "336": "",
                    "337": "drop:",
                    "338": "\tnet_pkt_unref(pkt);",
                    "339": "",
                    "340": "drop_no_pkt:",
                    "341": "\tnet_stats_update_icmp_drop(net_pkt_iface(orig));",
                    "342": "",
                    "343": "\treturn err;",
                    "344": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_input": {
            "name": "net_ipv6_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6.c",
            "location_line": 478,
            "function_content": [
                "/* Destination header can appears twice */\nenum net_verdict net_ipv6_input(struct net_pkt *pkt)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);\n\tstruct net_if *pkt_iface = net_pkt_iface(pkt);\n\tenum net_verdict verdict = NET_DROP;\n\tint real_len = net_pkt_get_len(pkt);\n\tuint8_t ext_bitmap = 0U;\n\tuint16_t ext_len = 0U;\n\tuint8_t current_hdr, nexthdr, prev_hdr_offset;\n\tunion net_proto_header proto_hdr;\n\tstruct net_ipv6_hdr *hdr;\n\tstruct net_if_mcast_addr *if_mcast_addr;\n\tunion net_ip_header ip;\n\tint pkt_len;\n\n#if defined(CONFIG_NET_L2_IPIP)\n\tstruct net_pkt_cursor hdr_start;\n\n\tnet_pkt_cursor_backup(pkt, &hdr_start);\n#endif\n\n\tnet_stats_update_ipv6_recv(pkt_iface);\n\n\thdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);\n\tif (!hdr) {\n\t\tNET_DBG(\"DROP: no buffer\");\n\t\tgoto drop;\n\t}\n\n\tpkt_len = net_ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);\n\tif (real_len < pkt_len) {\n\t\tNET_DBG(\"DROP: pkt len per hdr %d != pkt real len %d\",\n\t\t\tpkt_len, real_len);\n\t\tgoto drop;\n\t} else if (real_len > pkt_len) {\n\t\tnet_pkt_update_length(pkt, pkt_len);\n\t}\n\n\tNET_DBG(\"IPv6 packet len %d received from %s to %s\", pkt_len,\n\t\tnet_sprint_ipv6_addr(&hdr->src),\n\t\tnet_sprint_ipv6_addr(&hdr->dst));\n\n\tif (net_ipv6_is_addr_unspecified_raw(hdr->src)) {\n\t\t/* If this is a possible DAD message, let it pass. Extra checks\n\t\t * are done in duplicate address detection code to verify that\n\t\t * the packet is ok.\n\t\t */\n\t\tif (!(IS_ENABLED(CONFIG_NET_IPV6_DAD) &&\n\t\t      net_ipv6_is_addr_solicited_node_raw(hdr->dst))) {\n\t\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (net_ipv6_is_addr_mcast_raw(hdr->src) ||\n\t    net_ipv6_is_addr_mcast_scope_raw(hdr->dst, 0)) {\n\t\tNET_DBG(\"DROP: multicast packet\");\n\t\tgoto drop;\n\t}\n\n\tif (!net_pkt_is_loopback(pkt)) {\n\t\tif (net_ipv6_is_addr_loopback_raw(hdr->dst) ||\n\t\t    net_ipv6_is_addr_loopback_raw(hdr->src)) {\n\t\t\tNET_DBG(\"DROP: ::1 packet\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||\n\t\t    (net_ipv6_is_addr_mcast_group_raw(\n\t\t\t    hdr->dst,\n\t\t\t    (const uint8_t *)net_ipv6_unspecified_address()) &&\n\t\t     (net_ipv6_is_addr_mcast_site_raw(hdr->dst) ||\n\t\t      net_ipv6_is_addr_mcast_org_raw(hdr->dst)))) {\n\t\t\tNET_DBG(\"DROP: invalid scope multicast packet\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* We need to pass the packet through in case our address is\n\t\t * tentative, as receiving a packet with a tentative address as\n\t\t * source means that duplicate address has been detected.\n\t\t * This check is done later on if routing features are enabled.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_NET_ROUTING) && !IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&\n\t\t    is_src_non_tentative_itself(hdr->src)) {\n\t\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Reconstruct TC field. */\n\n\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {\n\t\tuint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);\n\n\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));\n\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));\n\t}\n\n\t/* Check extension headers */\n\tnet_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);\n\tnet_pkt_set_ipv6_ext_len(pkt, 0);\n\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);\n\tnet_pkt_set_family(pkt, NET_PF_INET6);\n\n\tif (!net_pkt_filter_ip_recv_ok(pkt)) {\n\t\t/* drop the packet */\n\t\tNET_DBG(\"DROP: pkt filter\");\n\t\tnet_stats_update_filter_rx_ipv6_drop(net_pkt_iface(pkt));\n\t\treturn NET_DROP;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&\n\t\tnet_ipv6_is_addr_mcast_raw(hdr->dst) && !net_pkt_forwarding(pkt)) {\n\t\t/* If the packet is a multicast packet and multicast routing\n\t\t * is activated, we give the packet to the routing engine.\n\t\t *\n\t\t * But we only drop the packet if an error occurs, otherwise\n\t\t * it might be eminent to respond on the packet on application\n\t\t * layer.\n\t\t */\n\t\tif (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {\n\t\t\tNET_DBG(\"DROP: forward mcast\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!net_ipv6_is_addr_mcast_raw(hdr->dst)) {\n\t\tif (!net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {\n\t\t\tif (ipv6_route_packet(pkt, hdr) == NET_OK) {\n\t\t\t\treturn NET_OK;\n\t\t\t}\n\n\t\t\tNET_DBG(\"DROP: no such address %s in iface %d\",\n\t\t\t\tnet_sprint_ipv6_addr(hdr->dst),\n\t\t\t\tnet_if_get_by_iface(pkt_iface));\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* If we receive a packet with ll source address fe80: and\n\t\t * destination address is one of ours, and if the packet would\n\t\t * cross interface boundary, then drop the packet.\n\t\t * RFC 4291 ch 2.5.6\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&\n\t\t    net_ipv6_is_ll_addr_raw(hdr->src) &&\n\t\t    !net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {\n\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);\n\t\t\tNET_DBG(\"DROP: cross interface boundary\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif ((IS_ENABLED(CONFIG_NET_ROUTING) || IS_ENABLED(CONFIG_NET_ROUTE_MCAST)) &&\n\t    !net_pkt_is_loopback(pkt) && is_src_non_tentative_itself(hdr->src)) {\n\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");\n\t\tgoto drop;\n\t}\n\n\tif (net_ipv6_is_addr_mcast_raw(hdr->dst) &&\n\t    !(net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||\n\t      net_ipv6_is_addr_mcast_link_all_nodes_raw(hdr->dst))) {\n\t\t/* If we receive a packet with a interface-local or\n\t\t * link-local all-nodes multicast destination address we\n\t\t * always have to pass it to the upper layer.\n\t\t *\n\t\t * For all other destination multicast addresses we have to\n\t\t * check if one of the joined multicast groups on the\n\t\t * originating interface of the packet matches. Otherwise the\n\t\t * packet will be dropped.\n\t\t * RFC4291 ch 2.7.1, ch 2.8\n\t\t */\n\t\tif_mcast_addr = net_if_ipv6_maddr_lookup_raw(hdr->dst, &pkt_iface);\n\t\tif (!if_mcast_addr ||\n\t\t    !net_if_ipv6_maddr_is_joined(if_mcast_addr)) {\n\t\t\tNET_DBG(\"DROP: packet for unjoined multicast address\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &ipv6_access);\n\n\tcurrent_hdr = hdr->nexthdr;\n\text_bitmap = extension_to_bitmap(current_hdr, ext_bitmap);\n\t/* Offset of \"nexthdr\" in the IPv6 header */\n\tprev_hdr_offset = (uint8_t *)&hdr->nexthdr - (uint8_t *)hdr;\n\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);\n\n\twhile (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {\n\t\tint exthdr_len;\n\t\tuint8_t ext_bit;\n\n\t\tNET_DBG(\"IPv6 next header %d\", current_hdr);\n\n\t\tif (current_hdr == NET_IPV6_NEXTHDR_NONE) {\n\t\t\t/* There is nothing after this header (see RFC 2460,\n\t\t\t * ch 4.7), so we can drop the packet now.\n\t\t\t * This is not an error case so do not update drop\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tNET_DBG(\"DROP: none nexthdr\");\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\t/* Offset of \"nexthdr\" in the Extension Header */\n\t\tprev_hdr_offset = net_pkt_get_current_offset(pkt);\n\n\t\tif (net_pkt_read_u8(pkt, &nexthdr)) {\n\t\t\tNET_DBG(\"DROP: pkt invalid read\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Detect duplicated Extension headers */\n\t\text_bit = extension_to_bitmap(nexthdr, ext_bitmap);\n\t\tif (ext_bit & ext_bitmap) {\n\t\t\tgoto bad_hdr;\n\t\t}\n\t\text_bitmap |= ext_bit;\n\n\t\t/* Make sure that nexthdr is valid, reject the Extension Header early otherwise.\n\t\t * This is also important so that the \"pointer\" field in the ICMPv6 error\n\t\t * message points to the \"nexthdr\" field.\n\t\t */\n\t\tswitch (nexthdr) {\n\t\tcase NET_IPV6_NEXTHDR_HBHO:\n\t\t\t/* Hop-by-hop header can appear only once and must appear right after\n\t\t\t * the IPv6 header. Consequently the \"nexthdr\" field of an Extension\n\t\t\t * Header can never be an HBH option.\n\t\t\t */\n\t\t\tgoto bad_hdr;\n\n\t\tcase NET_IPV6_NEXTHDR_DESTO:\n\t\tcase NET_IPV6_NEXTHDR_FRAG:\n\t\tcase NET_IPV6_NEXTHDR_NONE:\n\t\t\t/* Valid values */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto bad_hdr;\n\t\t}\n\n\t\t/* Process the current Extension Header */\n\t\tswitch (current_hdr) {\n\t\tcase NET_IPV6_NEXTHDR_HBHO:\n\t\tcase NET_IPV6_NEXTHDR_DESTO:\n\t\t\t/* Process options below */\n\t\t\tbreak;\n\n\t\tcase NET_IPV6_NEXTHDR_FRAG:\n\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6_FRAGMENT)) {\n\t\t\t\tnet_pkt_set_ipv6_fragment_start(\n\t\t\t\t\tpkt,\n\t\t\t\t\tnet_pkt_get_current_offset(pkt) - 1);\n\t\t\t\treturn net_ipv6_handle_fragment_hdr(pkt, hdr,\n\t\t\t\t\t\t\t\t    current_hdr);\n\t\t\t}\n\n\t\t\tgoto bad_hdr;\n\n\t\tdefault:\n\t\t\t/* Unsupported */\n\t\t\tgoto bad_hdr;\n\t\t}\n\n\t\texthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);\n\t\tif (exthdr_len < 0) {\n\t\t\tNET_DBG(\"DROP: extension hdr len (%d)\", exthdr_len);\n\t\t\tgoto drop;\n\t\t}\n\n\t\text_len += exthdr_len;\n\t\tcurrent_hdr = nexthdr;\n\t\t/* Save the offset to \"nexthdr\" in case we need to overwrite it\n\t\t * when processing a fragment header\n\t\t */\n\t\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);\n\t}\n\n\tnet_pkt_set_ipv6_ext_len(pkt, ext_len);\n\n\tip.ipv6 = hdr;\n\n\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW)) {\n\t\tif (net_conn_raw_ip_input(pkt, &ip, current_hdr) == NET_DROP) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tswitch (current_hdr) {\n\tcase NET_IPPROTO_ICMPV6:\n\t\tverdict = net_icmpv6_input(pkt, hdr);\n\t\tbreak;\n\tcase NET_IPPROTO_TCP:\n\t\tproto_hdr.tcp = net_tcp_input(pkt, &tcp_access);\n\t\tif (proto_hdr.tcp) {\n\t\t\tverdict = NET_OK;\n\t\t}\n\n\t\tNET_DBG(\"%s verdict %s\", \"TCP\", net_verdict2str(verdict));\n\t\tbreak;\n\tcase NET_IPPROTO_UDP:\n\t\tproto_hdr.udp = net_udp_input(pkt, &udp_access);\n\t\tif (proto_hdr.udp) {\n\t\t\tverdict = NET_OK;\n\t\t}\n\n\t\tNET_DBG(\"%s verdict %s\", \"UDP\", net_verdict2str(verdict));\n\t\tbreak;\n\n#if defined(CONFIG_NET_L2_IPIP)\n\tcase NET_IPPROTO_IPV6:\n\tcase NET_IPPROTO_IPIP: {\n\t\tstruct net_sockaddr_in6 remote_addr = { 0 };\n\t\tstruct net_if *tunnel_iface;\n\n\t\tremote_addr.sin6_family = NET_AF_INET6;\n\t\tnet_ipv6_addr_copy_raw((uint8_t *)&remote_addr.sin6_addr, hdr->src);\n\n\t\tnet_pkt_set_remote_address(pkt, (struct net_sockaddr *)&remote_addr,\n\t\t\t\t\t   sizeof(struct net_sockaddr_in6));\n\n\t\t/* Get rid of the old IP header */\n\t\tnet_pkt_cursor_restore(pkt, &hdr_start);\n\t\tnet_pkt_pull(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t     net_pkt_ipv6_ext_len(pkt));\n\n\t\ttunnel_iface = net_ipip_get_virtual_interface(net_pkt_iface(pkt));\n\t\tif (tunnel_iface != NULL && net_if_l2(tunnel_iface)->recv != NULL) {\n\t\t\treturn net_if_l2(tunnel_iface)->recv(net_pkt_iface(pkt), pkt);\n\t\t}\n\t}\n#endif\n\t}\n\n\tif (verdict == NET_DROP) {\n\t\tNET_DBG(\"DROP: because verdict\");\n\t\tgoto drop;\n\t} else if (current_hdr == NET_IPPROTO_ICMPV6) {\n\t\tNET_DBG(\"%s verdict %s\", \"ICMPv6\", net_verdict2str(verdict));\n\t\treturn verdict;\n\t}\n\n\tverdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);\n\n\tNET_DBG(\"%s verdict %s\", \"Connection\", net_verdict2str(verdict));\n\n\tif (verdict != NET_DROP) {\n\t\treturn verdict;\n\t}\n\ndrop:\n\tnet_stats_update_ipv6_drop(pkt_iface);\n\treturn NET_DROP;\n\nbad_hdr:\n\t/* Send error message about parameter problem (RFC 2460) */\n\tnet_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,\n\t\t\t      NET_ICMPV6_PARAM_PROB_NEXTHEADER,\n\t\t\t      net_pkt_get_current_offset(pkt) - 1);\n\n\tNET_DBG(\"DROP: Unknown/wrong nexthdr type\");\n\tnet_stats_update_ip_errors_protoerr(pkt_iface);\n\n\treturn NET_DROP;\n}\n",
                {
                    "478": "enum net_verdict net_ipv6_input(struct net_pkt *pkt)",
                    "479": "{",
                    "480": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);",
                    "481": "\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);",
                    "482": "\tNET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);",
                    "483": "\tstruct net_if *pkt_iface = net_pkt_iface(pkt);",
                    "484": "\tenum net_verdict verdict = NET_DROP;",
                    "485": "\tint real_len = net_pkt_get_len(pkt);",
                    "486": "\tuint8_t ext_bitmap = 0U;",
                    "487": "\tuint16_t ext_len = 0U;",
                    "488": "\tuint8_t current_hdr, nexthdr, prev_hdr_offset;",
                    "489": "\tunion net_proto_header proto_hdr;",
                    "490": "\tstruct net_ipv6_hdr *hdr;",
                    "491": "\tstruct net_if_mcast_addr *if_mcast_addr;",
                    "492": "\tunion net_ip_header ip;",
                    "493": "\tint pkt_len;",
                    "494": "",
                    "495": "#if defined(CONFIG_NET_L2_IPIP)",
                    "496": "\tstruct net_pkt_cursor hdr_start;",
                    "497": "",
                    "498": "\tnet_pkt_cursor_backup(pkt, &hdr_start);",
                    "499": "#endif",
                    "500": "",
                    "501": "\tnet_stats_update_ipv6_recv(pkt_iface);",
                    "502": "",
                    "503": "\thdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);",
                    "504": "\tif (!hdr) {",
                    "505": "\t\tNET_DBG(\"DROP: no buffer\");",
                    "506": "\t\tgoto drop;",
                    "507": "\t}",
                    "508": "",
                    "509": "\tpkt_len = net_ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);",
                    "510": "\tif (real_len < pkt_len) {",
                    "511": "\t\tNET_DBG(\"DROP: pkt len per hdr %d != pkt real len %d\",",
                    "512": "\t\t\tpkt_len, real_len);",
                    "513": "\t\tgoto drop;",
                    "514": "\t} else if (real_len > pkt_len) {",
                    "515": "\t\tnet_pkt_update_length(pkt, pkt_len);",
                    "516": "\t}",
                    "517": "",
                    "518": "\tNET_DBG(\"IPv6 packet len %d received from %s to %s\", pkt_len,",
                    "519": "\t\tnet_sprint_ipv6_addr(&hdr->src),",
                    "520": "\t\tnet_sprint_ipv6_addr(&hdr->dst));",
                    "521": "",
                    "522": "\tif (net_ipv6_is_addr_unspecified_raw(hdr->src)) {",
                    "523": "\t\t/* If this is a possible DAD message, let it pass. Extra checks",
                    "524": "\t\t * are done in duplicate address detection code to verify that",
                    "525": "\t\t * the packet is ok.",
                    "526": "\t\t */",
                    "527": "\t\tif (!(IS_ENABLED(CONFIG_NET_IPV6_DAD) &&",
                    "528": "\t\t      net_ipv6_is_addr_solicited_node_raw(hdr->dst))) {",
                    "529": "\t\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");",
                    "530": "\t\t\tgoto drop;",
                    "531": "\t\t}",
                    "532": "\t}",
                    "533": "",
                    "534": "\tif (net_ipv6_is_addr_mcast_raw(hdr->src) ||",
                    "535": "\t    net_ipv6_is_addr_mcast_scope_raw(hdr->dst, 0)) {",
                    "536": "\t\tNET_DBG(\"DROP: multicast packet\");",
                    "537": "\t\tgoto drop;",
                    "538": "\t}",
                    "539": "",
                    "540": "\tif (!net_pkt_is_loopback(pkt)) {",
                    "541": "\t\tif (net_ipv6_is_addr_loopback_raw(hdr->dst) ||",
                    "542": "\t\t    net_ipv6_is_addr_loopback_raw(hdr->src)) {",
                    "543": "\t\t\tNET_DBG(\"DROP: ::1 packet\");",
                    "544": "\t\t\tgoto drop;",
                    "545": "\t\t}",
                    "546": "",
                    "547": "\t\tif (net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||",
                    "548": "\t\t    (net_ipv6_is_addr_mcast_group_raw(",
                    "549": "\t\t\t    hdr->dst,",
                    "550": "\t\t\t    (const uint8_t *)net_ipv6_unspecified_address()) &&",
                    "551": "\t\t     (net_ipv6_is_addr_mcast_site_raw(hdr->dst) ||",
                    "552": "\t\t      net_ipv6_is_addr_mcast_org_raw(hdr->dst)))) {",
                    "553": "\t\t\tNET_DBG(\"DROP: invalid scope multicast packet\");",
                    "554": "\t\t\tgoto drop;",
                    "555": "\t\t}",
                    "556": "",
                    "557": "\t\t/* We need to pass the packet through in case our address is",
                    "558": "\t\t * tentative, as receiving a packet with a tentative address as",
                    "559": "\t\t * source means that duplicate address has been detected.",
                    "560": "\t\t * This check is done later on if routing features are enabled.",
                    "561": "\t\t */",
                    "562": "\t\tif (!IS_ENABLED(CONFIG_NET_ROUTING) && !IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&",
                    "563": "\t\t    is_src_non_tentative_itself(hdr->src)) {",
                    "564": "\t\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");",
                    "565": "\t\t\tgoto drop;",
                    "566": "\t\t}",
                    "567": "\t}",
                    "568": "",
                    "569": "\t/* Reconstruct TC field. */",
                    "570": "",
                    "571": "\tif (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {",
                    "572": "\t\tuint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);",
                    "573": "",
                    "574": "\t\tnet_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));",
                    "575": "\t\tnet_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));",
                    "576": "\t}",
                    "577": "",
                    "578": "\t/* Check extension headers */",
                    "579": "\tnet_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);",
                    "580": "\tnet_pkt_set_ipv6_ext_len(pkt, 0);",
                    "581": "\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));",
                    "582": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);",
                    "583": "\tnet_pkt_set_family(pkt, NET_PF_INET6);",
                    "584": "",
                    "585": "\tif (!net_pkt_filter_ip_recv_ok(pkt)) {",
                    "586": "\t\t/* drop the packet */",
                    "587": "\t\tNET_DBG(\"DROP: pkt filter\");",
                    "588": "\t\tnet_stats_update_filter_rx_ipv6_drop(net_pkt_iface(pkt));",
                    "589": "\t\treturn NET_DROP;",
                    "590": "\t}",
                    "591": "",
                    "592": "\tif (IS_ENABLED(CONFIG_NET_ROUTE_MCAST) &&",
                    "593": "\t\tnet_ipv6_is_addr_mcast_raw(hdr->dst) && !net_pkt_forwarding(pkt)) {",
                    "594": "\t\t/* If the packet is a multicast packet and multicast routing",
                    "595": "\t\t * is activated, we give the packet to the routing engine.",
                    "596": "\t\t *",
                    "597": "\t\t * But we only drop the packet if an error occurs, otherwise",
                    "598": "\t\t * it might be eminent to respond on the packet on application",
                    "599": "\t\t * layer.",
                    "600": "\t\t */",
                    "601": "\t\tif (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {",
                    "602": "\t\t\tNET_DBG(\"DROP: forward mcast\");",
                    "603": "\t\t\tgoto drop;",
                    "604": "\t\t}",
                    "605": "\t}",
                    "606": "",
                    "607": "\tif (!net_ipv6_is_addr_mcast_raw(hdr->dst)) {",
                    "608": "\t\tif (!net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {",
                    "609": "\t\t\tif (ipv6_route_packet(pkt, hdr) == NET_OK) {",
                    "610": "\t\t\t\treturn NET_OK;",
                    "611": "\t\t\t}",
                    "612": "",
                    "613": "\t\t\tNET_DBG(\"DROP: no such address %s in iface %d\",",
                    "614": "\t\t\t\tnet_sprint_ipv6_addr(hdr->dst),",
                    "615": "\t\t\t\tnet_if_get_by_iface(pkt_iface));",
                    "616": "\t\t\tgoto drop;",
                    "617": "\t\t}",
                    "618": "",
                    "619": "\t\t/* If we receive a packet with ll source address fe80: and",
                    "620": "\t\t * destination address is one of ours, and if the packet would",
                    "621": "\t\t * cross interface boundary, then drop the packet.",
                    "622": "\t\t * RFC 4291 ch 2.5.6",
                    "623": "\t\t */",
                    "624": "\t\tif (IS_ENABLED(CONFIG_NET_ROUTING) &&",
                    "625": "\t\t    net_ipv6_is_ll_addr_raw(hdr->src) &&",
                    "626": "\t\t    !net_if_ipv6_addr_lookup_by_iface_raw(pkt_iface, hdr->dst)) {",
                    "627": "\t\t\tipv6_no_route_info(pkt, hdr->src, hdr->dst);",
                    "628": "\t\t\tNET_DBG(\"DROP: cross interface boundary\");",
                    "629": "\t\t\tgoto drop;",
                    "630": "\t\t}",
                    "631": "\t}",
                    "632": "",
                    "633": "\tif ((IS_ENABLED(CONFIG_NET_ROUTING) || IS_ENABLED(CONFIG_NET_ROUTE_MCAST)) &&",
                    "634": "\t    !net_pkt_is_loopback(pkt) && is_src_non_tentative_itself(hdr->src)) {",
                    "635": "\t\tNET_DBG(\"DROP: src addr is %s\", \"mine\");",
                    "636": "\t\tgoto drop;",
                    "637": "\t}",
                    "638": "",
                    "639": "\tif (net_ipv6_is_addr_mcast_raw(hdr->dst) &&",
                    "640": "\t    !(net_ipv6_is_addr_mcast_iface_raw(hdr->dst) ||",
                    "641": "\t      net_ipv6_is_addr_mcast_link_all_nodes_raw(hdr->dst))) {",
                    "642": "\t\t/* If we receive a packet with a interface-local or",
                    "643": "\t\t * link-local all-nodes multicast destination address we",
                    "644": "\t\t * always have to pass it to the upper layer.",
                    "645": "\t\t *",
                    "646": "\t\t * For all other destination multicast addresses we have to",
                    "647": "\t\t * check if one of the joined multicast groups on the",
                    "648": "\t\t * originating interface of the packet matches. Otherwise the",
                    "649": "\t\t * packet will be dropped.",
                    "650": "\t\t * RFC4291 ch 2.7.1, ch 2.8",
                    "651": "\t\t */",
                    "652": "\t\tif_mcast_addr = net_if_ipv6_maddr_lookup_raw(hdr->dst, &pkt_iface);",
                    "653": "\t\tif (!if_mcast_addr ||",
                    "654": "\t\t    !net_if_ipv6_maddr_is_joined(if_mcast_addr)) {",
                    "655": "\t\t\tNET_DBG(\"DROP: packet for unjoined multicast address\");",
                    "656": "\t\t\tgoto drop;",
                    "657": "\t\t}",
                    "658": "\t}",
                    "659": "",
                    "660": "\tnet_pkt_acknowledge_data(pkt, &ipv6_access);",
                    "661": "",
                    "662": "\tcurrent_hdr = hdr->nexthdr;",
                    "663": "\text_bitmap = extension_to_bitmap(current_hdr, ext_bitmap);",
                    "664": "\t/* Offset of \"nexthdr\" in the IPv6 header */",
                    "665": "\tprev_hdr_offset = (uint8_t *)&hdr->nexthdr - (uint8_t *)hdr;",
                    "666": "\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);",
                    "667": "",
                    "668": "\twhile (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {",
                    "669": "\t\tint exthdr_len;",
                    "670": "\t\tuint8_t ext_bit;",
                    "671": "",
                    "672": "\t\tNET_DBG(\"IPv6 next header %d\", current_hdr);",
                    "673": "",
                    "674": "\t\tif (current_hdr == NET_IPV6_NEXTHDR_NONE) {",
                    "675": "\t\t\t/* There is nothing after this header (see RFC 2460,",
                    "676": "\t\t\t * ch 4.7), so we can drop the packet now.",
                    "677": "\t\t\t * This is not an error case so do not update drop",
                    "678": "\t\t\t * statistics.",
                    "679": "\t\t\t */",
                    "680": "\t\t\tNET_DBG(\"DROP: none nexthdr\");",
                    "681": "\t\t\treturn NET_DROP;",
                    "682": "\t\t}",
                    "683": "",
                    "684": "\t\t/* Offset of \"nexthdr\" in the Extension Header */",
                    "685": "\t\tprev_hdr_offset = net_pkt_get_current_offset(pkt);",
                    "686": "",
                    "687": "\t\tif (net_pkt_read_u8(pkt, &nexthdr)) {",
                    "688": "\t\t\tNET_DBG(\"DROP: pkt invalid read\");",
                    "689": "\t\t\tgoto drop;",
                    "690": "\t\t}",
                    "691": "",
                    "692": "\t\t/* Detect duplicated Extension headers */",
                    "693": "\t\text_bit = extension_to_bitmap(nexthdr, ext_bitmap);",
                    "694": "\t\tif (ext_bit & ext_bitmap) {",
                    "695": "\t\t\tgoto bad_hdr;",
                    "696": "\t\t}",
                    "697": "\t\text_bitmap |= ext_bit;",
                    "698": "",
                    "699": "\t\t/* Make sure that nexthdr is valid, reject the Extension Header early otherwise.",
                    "700": "\t\t * This is also important so that the \"pointer\" field in the ICMPv6 error",
                    "701": "\t\t * message points to the \"nexthdr\" field.",
                    "702": "\t\t */",
                    "703": "\t\tswitch (nexthdr) {",
                    "704": "\t\tcase NET_IPV6_NEXTHDR_HBHO:",
                    "705": "\t\t\t/* Hop-by-hop header can appear only once and must appear right after",
                    "706": "\t\t\t * the IPv6 header. Consequently the \"nexthdr\" field of an Extension",
                    "707": "\t\t\t * Header can never be an HBH option.",
                    "708": "\t\t\t */",
                    "709": "\t\t\tgoto bad_hdr;",
                    "710": "",
                    "711": "\t\tcase NET_IPV6_NEXTHDR_DESTO:",
                    "712": "\t\tcase NET_IPV6_NEXTHDR_FRAG:",
                    "713": "\t\tcase NET_IPV6_NEXTHDR_NONE:",
                    "714": "\t\t\t/* Valid values */",
                    "715": "\t\t\tbreak;",
                    "716": "",
                    "717": "\t\tdefault:",
                    "718": "\t\t\tif (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {",
                    "719": "\t\t\t\tbreak;",
                    "720": "\t\t\t}",
                    "721": "\t\t\tgoto bad_hdr;",
                    "722": "\t\t}",
                    "723": "",
                    "724": "\t\t/* Process the current Extension Header */",
                    "725": "\t\tswitch (current_hdr) {",
                    "726": "\t\tcase NET_IPV6_NEXTHDR_HBHO:",
                    "727": "\t\tcase NET_IPV6_NEXTHDR_DESTO:",
                    "728": "\t\t\t/* Process options below */",
                    "729": "\t\t\tbreak;",
                    "730": "",
                    "731": "\t\tcase NET_IPV6_NEXTHDR_FRAG:",
                    "732": "\t\t\tif (IS_ENABLED(CONFIG_NET_IPV6_FRAGMENT)) {",
                    "733": "\t\t\t\tnet_pkt_set_ipv6_fragment_start(",
                    "734": "\t\t\t\t\tpkt,",
                    "735": "\t\t\t\t\tnet_pkt_get_current_offset(pkt) - 1);",
                    "736": "\t\t\t\treturn net_ipv6_handle_fragment_hdr(pkt, hdr,",
                    "737": "\t\t\t\t\t\t\t\t    current_hdr);",
                    "738": "\t\t\t}",
                    "739": "",
                    "740": "\t\t\tgoto bad_hdr;",
                    "741": "",
                    "742": "\t\tdefault:",
                    "743": "\t\t\t/* Unsupported */",
                    "744": "\t\t\tgoto bad_hdr;",
                    "745": "\t\t}",
                    "746": "",
                    "747": "\t\texthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);",
                    "748": "\t\tif (exthdr_len < 0) {",
                    "749": "\t\t\tNET_DBG(\"DROP: extension hdr len (%d)\", exthdr_len);",
                    "750": "\t\t\tgoto drop;",
                    "751": "\t\t}",
                    "752": "",
                    "753": "\t\text_len += exthdr_len;",
                    "754": "\t\tcurrent_hdr = nexthdr;",
                    "755": "\t\t/* Save the offset to \"nexthdr\" in case we need to overwrite it",
                    "756": "\t\t * when processing a fragment header",
                    "757": "\t\t */",
                    "758": "\t\tnet_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);",
                    "759": "\t}",
                    "760": "",
                    "761": "\tnet_pkt_set_ipv6_ext_len(pkt, ext_len);",
                    "762": "",
                    "763": "\tip.ipv6 = hdr;",
                    "764": "",
                    "765": "\tif (IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW)) {",
                    "766": "\t\tif (net_conn_raw_ip_input(pkt, &ip, current_hdr) == NET_DROP) {",
                    "767": "\t\t\tgoto drop;",
                    "768": "\t\t}",
                    "769": "\t}",
                    "770": "",
                    "771": "\tswitch (current_hdr) {",
                    "772": "\tcase NET_IPPROTO_ICMPV6:",
                    "773": "\t\tverdict = net_icmpv6_input(pkt, hdr);",
                    "774": "\t\tbreak;",
                    "775": "\tcase NET_IPPROTO_TCP:",
                    "776": "\t\tproto_hdr.tcp = net_tcp_input(pkt, &tcp_access);",
                    "777": "\t\tif (proto_hdr.tcp) {",
                    "778": "\t\t\tverdict = NET_OK;",
                    "779": "\t\t}",
                    "780": "",
                    "781": "\t\tNET_DBG(\"%s verdict %s\", \"TCP\", net_verdict2str(verdict));",
                    "782": "\t\tbreak;",
                    "783": "\tcase NET_IPPROTO_UDP:",
                    "784": "\t\tproto_hdr.udp = net_udp_input(pkt, &udp_access);",
                    "785": "\t\tif (proto_hdr.udp) {",
                    "786": "\t\t\tverdict = NET_OK;",
                    "787": "\t\t}",
                    "788": "",
                    "789": "\t\tNET_DBG(\"%s verdict %s\", \"UDP\", net_verdict2str(verdict));",
                    "790": "\t\tbreak;",
                    "791": "",
                    "792": "#if defined(CONFIG_NET_L2_IPIP)",
                    "793": "\tcase NET_IPPROTO_IPV6:",
                    "794": "\tcase NET_IPPROTO_IPIP: {",
                    "795": "\t\tstruct net_sockaddr_in6 remote_addr = { 0 };",
                    "796": "\t\tstruct net_if *tunnel_iface;",
                    "797": "",
                    "798": "\t\tremote_addr.sin6_family = NET_AF_INET6;",
                    "799": "\t\tnet_ipv6_addr_copy_raw((uint8_t *)&remote_addr.sin6_addr, hdr->src);",
                    "800": "",
                    "801": "\t\tnet_pkt_set_remote_address(pkt, (struct net_sockaddr *)&remote_addr,",
                    "802": "\t\t\t\t\t   sizeof(struct net_sockaddr_in6));",
                    "803": "",
                    "804": "\t\t/* Get rid of the old IP header */",
                    "805": "\t\tnet_pkt_cursor_restore(pkt, &hdr_start);",
                    "806": "\t\tnet_pkt_pull(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "807": "\t\t\t     net_pkt_ipv6_ext_len(pkt));",
                    "808": "",
                    "809": "\t\ttunnel_iface = net_ipip_get_virtual_interface(net_pkt_iface(pkt));",
                    "810": "\t\tif (tunnel_iface != NULL && net_if_l2(tunnel_iface)->recv != NULL) {",
                    "811": "\t\t\treturn net_if_l2(tunnel_iface)->recv(net_pkt_iface(pkt), pkt);",
                    "812": "\t\t}",
                    "813": "\t}",
                    "814": "#endif",
                    "815": "\t}",
                    "816": "",
                    "817": "\tif (verdict == NET_DROP) {",
                    "818": "\t\tNET_DBG(\"DROP: because verdict\");",
                    "819": "\t\tgoto drop;",
                    "820": "\t} else if (current_hdr == NET_IPPROTO_ICMPV6) {",
                    "821": "\t\tNET_DBG(\"%s verdict %s\", \"ICMPv6\", net_verdict2str(verdict));",
                    "822": "\t\treturn verdict;",
                    "823": "\t}",
                    "824": "",
                    "825": "\tverdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);",
                    "826": "",
                    "827": "\tNET_DBG(\"%s verdict %s\", \"Connection\", net_verdict2str(verdict));",
                    "828": "",
                    "829": "\tif (verdict != NET_DROP) {",
                    "830": "\t\treturn verdict;",
                    "831": "\t}",
                    "832": "",
                    "833": "drop:",
                    "834": "\tnet_stats_update_ipv6_drop(pkt_iface);",
                    "835": "\treturn NET_DROP;",
                    "836": "",
                    "837": "bad_hdr:",
                    "838": "\t/* Send error message about parameter problem (RFC 2460) */",
                    "839": "\tnet_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,",
                    "840": "\t\t\t      NET_ICMPV6_PARAM_PROB_NEXTHEADER,",
                    "841": "\t\t\t      net_pkt_get_current_offset(pkt) - 1);",
                    "842": "",
                    "843": "\tNET_DBG(\"DROP: Unknown/wrong nexthdr type\");",
                    "844": "\tnet_stats_update_ip_errors_protoerr(pkt_iface);",
                    "845": "",
                    "846": "\treturn NET_DROP;",
                    "847": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "handle_ra_input": {
            "name": "handle_ra_input",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 2616,
            "function_content": [
                "/* Skip the rest of the DNS servers. */\nstatic int handle_ra_input(struct net_icmp_ctx *ctx,\n\t\t\t   struct net_pkt *pkt,\n\t\t\t   struct net_icmp_ip_hdr *hdr,\n\t\t\t   struct net_icmp_hdr *icmp_hdr,\n\t\t\t   void *user_data)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,\n\t\t\t\t\t      struct net_icmpv6_ra_hdr);\n\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);\n\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;\n\tuint16_t length = net_pkt_get_len(pkt);\n\tstruct net_nbr *nbr = NULL;\n\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;\n\tstruct net_icmpv6_ra_hdr *ra_hdr;\n\tstruct net_if_router *router;\n\tuint32_t mtu, reachable_time, retrans_timer;\n\tuint16_t router_lifetime;\n\tstruct net_in6_addr ra_src;\n\n\tARG_UNUSED(user_data);\n\n\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {\n\t\tgoto drop;\n\t}\n\n\tra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);\n\tif (!ra_hdr) {\n\t\tNET_ERR(\"DROP: NULL RA header\");\n\t\tgoto drop;\n\t}\n\n\tdbg_addr_recv(\"Router Advertisement\", &ip_hdr->src, &ip_hdr->dst, pkt);\n\n\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));\n\n\tnet_ipv6_addr_copy_raw(ra_src.s6_addr, ip_hdr->src);\n\n\tif (((length < (sizeof(struct net_ipv6_hdr) +\n\t\t\tsizeof(struct net_icmp_hdr) +\n\t\t\tsizeof(struct net_icmpv6_ra_hdr) +\n\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||\n\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||\n\t     !net_ipv6_is_ll_addr(&ra_src)) &&\n\t\ticmp_hdr->code != 0U) {\n\t\tgoto drop;\n\t}\n\n\tnet_pkt_acknowledge_data(pkt, &ra_access);\n\n\trouter_lifetime = net_ntohs(ra_hdr->router_lifetime);\n\treachable_time = net_ntohl(ra_hdr->reachable_time);\n\tretrans_timer = net_ntohl(ra_hdr->retrans_timer);\n\n\tif (ra_hdr->cur_hop_limit) {\n\t\tnet_if_ipv6_set_hop_limit(net_pkt_iface(pkt),\n\t\t\t\t\t  ra_hdr->cur_hop_limit);\n\t\tNET_DBG(\"New hop limit %d\",\n\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));\n\t}\n\n\tif (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&\n\t    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=\n\t     reachable_time)) {\n\t\tnet_if_ipv6_set_base_reachable_time(net_pkt_iface(pkt),\n\t\t\t\t\t\t    reachable_time);\n\t\tnet_if_ipv6_set_reachable_time(\n\t\t\tnet_pkt_iface(pkt)->config.ip.ipv6);\n\t}\n\n\tif (retrans_timer) {\n\t\tnet_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),\n\t\t\t\t\t      ra_hdr->retrans_timer);\n\t}\n\n\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));\n\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));\n\n\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\n\twhile (nd_opt_hdr) {\n\t\tnet_pkt_acknowledge_data(pkt, &nd_access);\n\n\t\tswitch (nd_opt_hdr->type) {\n\t\tcase NET_ICMPV6_ND_OPT_SLLAO:\n\t\t\t/* Update existing neighbor cache entry with link layer address. */\n\t\t\tnbr = handle_ra_neighbor(pkt, nd_opt_hdr->len, &ra_src);\n\t\t\tif (!nbr) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase NET_ICMPV6_ND_OPT_MTU:\n\t\t\t/* MTU has reserved 2 bytes, so skip it. */\n\t\t\tif (net_pkt_skip(pkt, 2) ||\n\t\t\t    net_pkt_read_be32(pkt, &mtu)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {\n\t\t\t\tNET_ERR(\"DROP: Unsupported MTU %u, min is %u, \"\n\t\t\t\t\t\"max is %u\",\n\t\t\t\t\tmtu, MIN_IPV6_MTU, MAX_IPV6_MTU);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tnet_if_set_mtu(net_pkt_iface(pkt), mtu);\n\n\t\t\tbreak;\n\t\tcase NET_ICMPV6_ND_OPT_PREFIX_INFO:\n\t\t\tif (nd_opt_hdr->len != 4) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",\n\t\t\t\t\t\"prefix opt\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_prefix(pkt)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#if defined(CONFIG_NET_6LO_CONTEXT)\n\t\tcase NET_ICMPV6_ND_OPT_6CO:\n\t\t\t/* RFC 6775, 4.2 (Length)*/\n\t\t\tif (!(nd_opt_hdr->len == 2U || nd_opt_hdr->len == 3U)) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length %d\",\n\t\t\t\t\t\"6CO\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_6co(pkt, nd_opt_hdr->len)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#endif\n\t\tcase NET_ICMPV6_ND_OPT_ROUTE:\n\t\t\tif (!IS_ENABLED(CONFIG_NET_ROUTE)) {\n\t\t\t\tNET_DBG(\"Route option skipped\");\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\t/* RFC 4191, ch. 2.3 */\n\t\t\tif (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {\n\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",\n\t\t\t\t\t\"route info opt\", nd_opt_hdr->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (!handle_ra_route_info(pkt, nd_opt_hdr->len, &ra_src)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n#if defined(CONFIG_NET_IPV6_RA_RDNSS)\n\t\tcase NET_ICMPV6_ND_OPT_RDNSS:\n\t\t\tif (!handle_ra_rdnss(pkt, nd_opt_hdr->len)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tcase NET_ICMPV6_ND_OPT_DNSSL:\n\t\t\tNET_DBG(\"DNSSL option skipped\");\n\t\t\tgoto skip;\n\n\t\tdefault:\n\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);\n\t\tskip:\n\t\t\tif (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)\n\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);\n\t}\n\n\tif (nbr == NULL) {\n\t\t/* Add neighbor cache entry using link local address, regardless\n\t\t * of link layer address presence in Router Advertisement.\n\t\t */\n\t\tnbr = net_ipv6_nbr_add(net_pkt_iface(pkt), &ra_src,\n\t\t\t\t       NULL, true, NET_IPV6_NBR_STATE_INCOMPLETE);\n\t}\n\n\trouter = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ra_src);\n\tif (router) {\n\t\tif (!router_lifetime) {\n\t\t\t/* TODO: Start rs_timer on iface if no routers\n\t\t\t * at all available on iface.\n\t\t\t */\n\t\t\tnet_if_ipv6_router_rm(router);\n\t\t} else {\n\t\t\tif (nbr) {\n\t\t\t\tnet_ipv6_nbr_data(nbr)->is_router = true;\n\t\t\t}\n\n\t\t\tnet_if_ipv6_router_update_lifetime(\n\t\t\t\t\trouter, router_lifetime);\n\t\t}\n\t} else {\n\t\tnet_if_ipv6_router_add(net_pkt_iface(pkt), &ra_src,\n\t\t\t\t       router_lifetime);\n\t}\n\n\tnet_ipv6_nbr_lock();\n\n\tif (nbr != NULL) {\n\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tstruct net_pkt *pending;\n\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tNET_DBG(\"Sending pending pkt %p to %s\",\n\t\t\t\tpending,\n\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));\n\n\t\t\tif (net_send_data(pending) < 0) {\n\t\t\t\tnet_pkt_unref(pending);\n\t\t\t}\n\t\t}\n\n\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\n\t/* Cancel the RS timer on iface */\n\tnet_if_stop_rs(net_pkt_iface(pkt));\n\n\treturn 0;\n\ndrop:\n\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n\n\treturn -EIO;\n}\n",
                {
                    "2616": "static int handle_ra_input(struct net_icmp_ctx *ctx,",
                    "2617": "\t\t\t   struct net_pkt *pkt,",
                    "2618": "\t\t\t   struct net_icmp_ip_hdr *hdr,",
                    "2619": "\t\t\t   struct net_icmp_hdr *icmp_hdr,",
                    "2620": "\t\t\t   void *user_data)",
                    "2621": "{",
                    "2622": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,",
                    "2623": "\t\t\t\t\t      struct net_icmpv6_ra_hdr);",
                    "2624": "\tNET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);",
                    "2625": "\tstruct net_ipv6_hdr *ip_hdr = hdr->ipv6;",
                    "2626": "\tuint16_t length = net_pkt_get_len(pkt);",
                    "2627": "\tstruct net_nbr *nbr = NULL;",
                    "2628": "\tstruct net_icmpv6_nd_opt_hdr *nd_opt_hdr;",
                    "2629": "\tstruct net_icmpv6_ra_hdr *ra_hdr;",
                    "2630": "\tstruct net_if_router *router;",
                    "2631": "\tuint32_t mtu, reachable_time, retrans_timer;",
                    "2632": "\tuint16_t router_lifetime;",
                    "2633": "\tstruct net_in6_addr ra_src;",
                    "2634": "",
                    "2635": "\tARG_UNUSED(user_data);",
                    "2636": "",
                    "2637": "\tif (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {",
                    "2638": "\t\tgoto drop;",
                    "2639": "\t}",
                    "2640": "",
                    "2641": "\tra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);",
                    "2642": "\tif (!ra_hdr) {",
                    "2643": "\t\tNET_ERR(\"DROP: NULL RA header\");",
                    "2644": "\t\tgoto drop;",
                    "2645": "\t}",
                    "2646": "",
                    "2647": "\tdbg_addr_recv(\"Router Advertisement\", &ip_hdr->src, &ip_hdr->dst, pkt);",
                    "2648": "",
                    "2649": "\tnet_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));",
                    "2650": "",
                    "2651": "\tnet_ipv6_addr_copy_raw(ra_src.s6_addr, ip_hdr->src);",
                    "2652": "",
                    "2653": "\tif (((length < (sizeof(struct net_ipv6_hdr) +",
                    "2654": "\t\t\tsizeof(struct net_icmp_hdr) +",
                    "2655": "\t\t\tsizeof(struct net_icmpv6_ra_hdr) +",
                    "2656": "\t\t\tsizeof(struct net_icmpv6_nd_opt_hdr))) ||",
                    "2657": "\t     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||",
                    "2658": "\t     !net_ipv6_is_ll_addr(&ra_src)) &&",
                    "2659": "\t\ticmp_hdr->code != 0U) {",
                    "2660": "\t\tgoto drop;",
                    "2661": "\t}",
                    "2662": "",
                    "2663": "\tnet_pkt_acknowledge_data(pkt, &ra_access);",
                    "2664": "",
                    "2665": "\trouter_lifetime = net_ntohs(ra_hdr->router_lifetime);",
                    "2666": "\treachable_time = net_ntohl(ra_hdr->reachable_time);",
                    "2667": "\tretrans_timer = net_ntohl(ra_hdr->retrans_timer);",
                    "2668": "",
                    "2669": "\tif (ra_hdr->cur_hop_limit) {",
                    "2670": "\t\tnet_if_ipv6_set_hop_limit(net_pkt_iface(pkt),",
                    "2671": "\t\t\t\t\t  ra_hdr->cur_hop_limit);",
                    "2672": "\t\tNET_DBG(\"New hop limit %d\",",
                    "2673": "\t\t\tnet_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));",
                    "2674": "\t}",
                    "2675": "",
                    "2676": "\tif (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&",
                    "2677": "\t    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=",
                    "2678": "\t     reachable_time)) {",
                    "2679": "\t\tnet_if_ipv6_set_base_reachable_time(net_pkt_iface(pkt),",
                    "2680": "\t\t\t\t\t\t    reachable_time);",
                    "2681": "\t\tnet_if_ipv6_set_reachable_time(",
                    "2682": "\t\t\tnet_pkt_iface(pkt)->config.ip.ipv6);",
                    "2683": "\t}",
                    "2684": "",
                    "2685": "\tif (retrans_timer) {",
                    "2686": "\t\tnet_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),",
                    "2687": "\t\t\t\t\t      ra_hdr->retrans_timer);",
                    "2688": "\t}",
                    "2689": "",
                    "2690": "\tnet_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));",
                    "2691": "\tlength -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));",
                    "2692": "",
                    "2693": "\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "2694": "\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "2695": "",
                    "2696": "\twhile (nd_opt_hdr) {",
                    "2697": "\t\tnet_pkt_acknowledge_data(pkt, &nd_access);",
                    "2698": "",
                    "2699": "\t\tswitch (nd_opt_hdr->type) {",
                    "2700": "\t\tcase NET_ICMPV6_ND_OPT_SLLAO:",
                    "2701": "\t\t\t/* Update existing neighbor cache entry with link layer address. */",
                    "2702": "\t\t\tnbr = handle_ra_neighbor(pkt, nd_opt_hdr->len, &ra_src);",
                    "2703": "\t\t\tif (!nbr) {",
                    "2704": "\t\t\t\tgoto drop;",
                    "2705": "\t\t\t}",
                    "2706": "",
                    "2707": "\t\t\tbreak;",
                    "2708": "\t\tcase NET_ICMPV6_ND_OPT_MTU:",
                    "2709": "\t\t\t/* MTU has reserved 2 bytes, so skip it. */",
                    "2710": "\t\t\tif (net_pkt_skip(pkt, 2) ||",
                    "2711": "\t\t\t    net_pkt_read_be32(pkt, &mtu)) {",
                    "2712": "\t\t\t\tgoto drop;",
                    "2713": "\t\t\t}",
                    "2714": "",
                    "2715": "\t\t\tif (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {",
                    "2716": "\t\t\t\tNET_ERR(\"DROP: Unsupported MTU %u, min is %u, \"",
                    "2717": "\t\t\t\t\t\"max is %u\",",
                    "2718": "\t\t\t\t\tmtu, MIN_IPV6_MTU, MAX_IPV6_MTU);",
                    "2719": "\t\t\t\tgoto drop;",
                    "2720": "\t\t\t}",
                    "2721": "",
                    "2722": "\t\t\tnet_if_set_mtu(net_pkt_iface(pkt), mtu);",
                    "2723": "",
                    "2724": "\t\t\tbreak;",
                    "2725": "\t\tcase NET_ICMPV6_ND_OPT_PREFIX_INFO:",
                    "2726": "\t\t\tif (nd_opt_hdr->len != 4) {",
                    "2727": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",",
                    "2728": "\t\t\t\t\t\"prefix opt\", nd_opt_hdr->len);",
                    "2729": "\t\t\t\tgoto drop;",
                    "2730": "\t\t\t}",
                    "2731": "",
                    "2732": "\t\t\tif (!handle_ra_prefix(pkt)) {",
                    "2733": "\t\t\t\tgoto drop;",
                    "2734": "\t\t\t}",
                    "2735": "",
                    "2736": "\t\t\tbreak;",
                    "2737": "#if defined(CONFIG_NET_6LO_CONTEXT)",
                    "2738": "\t\tcase NET_ICMPV6_ND_OPT_6CO:",
                    "2739": "\t\t\t/* RFC 6775, 4.2 (Length)*/",
                    "2740": "\t\t\tif (!(nd_opt_hdr->len == 2U || nd_opt_hdr->len == 3U)) {",
                    "2741": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length %d\",",
                    "2742": "\t\t\t\t\t\"6CO\", nd_opt_hdr->len);",
                    "2743": "\t\t\t\tgoto drop;",
                    "2744": "\t\t\t}",
                    "2745": "",
                    "2746": "\t\t\tif (!handle_ra_6co(pkt, nd_opt_hdr->len)) {",
                    "2747": "\t\t\t\tgoto drop;",
                    "2748": "\t\t\t}",
                    "2749": "",
                    "2750": "\t\t\tbreak;",
                    "2751": "#endif",
                    "2752": "\t\tcase NET_ICMPV6_ND_OPT_ROUTE:",
                    "2753": "\t\t\tif (!IS_ENABLED(CONFIG_NET_ROUTE)) {",
                    "2754": "\t\t\t\tNET_DBG(\"Route option skipped\");",
                    "2755": "\t\t\t\tgoto skip;",
                    "2756": "\t\t\t}",
                    "2757": "",
                    "2758": "\t\t\t/* RFC 4191, ch. 2.3 */",
                    "2759": "\t\t\tif (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {",
                    "2760": "\t\t\t\tNET_ERR(\"DROP: Invalid %s length (%d)\",",
                    "2761": "\t\t\t\t\t\"route info opt\", nd_opt_hdr->len);",
                    "2762": "\t\t\t\tgoto drop;",
                    "2763": "\t\t\t}",
                    "2764": "",
                    "2765": "\t\t\tif (!handle_ra_route_info(pkt, nd_opt_hdr->len, &ra_src)) {",
                    "2766": "\t\t\t\tgoto drop;",
                    "2767": "\t\t\t}",
                    "2768": "",
                    "2769": "\t\t\tbreak;",
                    "2770": "#if defined(CONFIG_NET_IPV6_RA_RDNSS)",
                    "2771": "\t\tcase NET_ICMPV6_ND_OPT_RDNSS:",
                    "2772": "\t\t\tif (!handle_ra_rdnss(pkt, nd_opt_hdr->len)) {",
                    "2773": "\t\t\t\tgoto drop;",
                    "2774": "\t\t\t}",
                    "2775": "\t\t\tbreak;",
                    "2776": "#endif",
                    "2777": "",
                    "2778": "\t\tcase NET_ICMPV6_ND_OPT_DNSSL:",
                    "2779": "\t\t\tNET_DBG(\"DNSSL option skipped\");",
                    "2780": "\t\t\tgoto skip;",
                    "2781": "",
                    "2782": "\t\tdefault:",
                    "2783": "\t\t\tNET_DBG(\"Unknown ND option 0x%x\", nd_opt_hdr->type);",
                    "2784": "\t\tskip:",
                    "2785": "\t\t\tif (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {",
                    "2786": "\t\t\t\tgoto drop;",
                    "2787": "\t\t\t}",
                    "2788": "",
                    "2789": "\t\t\tbreak;",
                    "2790": "\t\t}",
                    "2791": "",
                    "2792": "\t\tnd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)",
                    "2793": "\t\t\t\t\tnet_pkt_get_data(pkt, &nd_access);",
                    "2794": "\t}",
                    "2795": "",
                    "2796": "\tif (nbr == NULL) {",
                    "2797": "\t\t/* Add neighbor cache entry using link local address, regardless",
                    "2798": "\t\t * of link layer address presence in Router Advertisement.",
                    "2799": "\t\t */",
                    "2800": "\t\tnbr = net_ipv6_nbr_add(net_pkt_iface(pkt), &ra_src,",
                    "2801": "\t\t\t\t       NULL, true, NET_IPV6_NBR_STATE_INCOMPLETE);",
                    "2802": "\t}",
                    "2803": "",
                    "2804": "\trouter = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ra_src);",
                    "2805": "\tif (router) {",
                    "2806": "\t\tif (!router_lifetime) {",
                    "2807": "\t\t\t/* TODO: Start rs_timer on iface if no routers",
                    "2808": "\t\t\t * at all available on iface.",
                    "2809": "\t\t\t */",
                    "2810": "\t\t\tnet_if_ipv6_router_rm(router);",
                    "2811": "\t\t} else {",
                    "2812": "\t\t\tif (nbr) {",
                    "2813": "\t\t\t\tnet_ipv6_nbr_data(nbr)->is_router = true;",
                    "2814": "\t\t\t}",
                    "2815": "",
                    "2816": "\t\t\tnet_if_ipv6_router_update_lifetime(",
                    "2817": "\t\t\t\t\trouter, router_lifetime);",
                    "2818": "\t\t}",
                    "2819": "\t} else {",
                    "2820": "\t\tnet_if_ipv6_router_add(net_pkt_iface(pkt), &ra_src,",
                    "2821": "\t\t\t\t       router_lifetime);",
                    "2822": "\t}",
                    "2823": "",
                    "2824": "\tnet_ipv6_nbr_lock();",
                    "2825": "",
                    "2826": "\tif (nbr != NULL) {",
                    "2827": "\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "2828": "\t\t\tstruct net_pkt *pending;",
                    "2829": "",
                    "2830": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "2831": "\t\t\t\t\t     K_FOREVER);",
                    "2832": "",
                    "2833": "\t\t\tNET_DBG(\"Sending pending pkt %p to %s\",",
                    "2834": "\t\t\t\tpending,",
                    "2835": "\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));",
                    "2836": "",
                    "2837": "\t\t\tif (net_send_data(pending) < 0) {",
                    "2838": "\t\t\t\tnet_pkt_unref(pending);",
                    "2839": "\t\t\t}",
                    "2840": "\t\t}",
                    "2841": "",
                    "2842": "\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));",
                    "2843": "\t}",
                    "2844": "",
                    "2845": "\tnet_ipv6_nbr_unlock();",
                    "2846": "",
                    "2847": "\t/* Cancel the RS timer on iface */",
                    "2848": "\tnet_if_stop_rs(net_pkt_iface(pkt));",
                    "2849": "",
                    "2850": "\treturn 0;",
                    "2851": "",
                    "2852": "drop:",
                    "2853": "\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));",
                    "2854": "",
                    "2855": "\treturn -EIO;",
                    "2856": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_ipv6_send_ns": {
            "name": "net_ipv6_send_ns",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 2004,
            "function_content": [
                "/* Update the statistics but silently drop NA msg if the sender\n* is not known or if there was an error in the message.\n* Returning <0 will cause error message to be printed which\n* is too much for this non error.\n*/\nint net_ipv6_send_ns(struct net_if *iface,\n\t\t     struct net_pkt *pending,\n\t\t     const struct net_in6_addr *src,\n\t\t     const struct net_in6_addr *dst,\n\t\t     const struct net_in6_addr *tgt,\n\t\t     bool is_my_address)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,\n\t\t\t\t\t      struct net_icmpv6_ns_hdr);\n\tstruct net_pkt *pkt = NULL;\n\tint ret = -ENOBUFS;\n\tstruct net_icmpv6_ns_hdr *ns_hdr;\n\tstruct net_in6_addr node_dst;\n\tstruct net_nbr *nbr;\n\tuint8_t llao_len;\n\n\tif (!dst) {\n\t\tnet_ipv6_addr_create_solicited_node(tgt, &node_dst);\n\t\tdst = &node_dst;\n\t}\n\n\tllao_len = get_llao_len(iface);\n\n\tif (is_my_address) {\n\t\tsrc = net_ipv6_unspecified_address();\n\t\tllao_len = 0U;\n\t} else {\n\t\tif (!src) {\n\t\t\tsrc = net_if_ipv6_select_src_addr(iface, tgt);\n\t\t}\n\n\t\tif (net_ipv6_is_addr_unspecified(src)) {\n\t\t\tNET_DBG(\"No source address for NS (tgt %s)\",\n\t\t\t\tnet_sprint_ipv6_addr(tgt));\n\t\t\tret = -EINVAL;\n\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tpkt = net_pkt_alloc_with_buffer(iface,\n\t\t\t\t\tsizeof(struct net_icmpv6_ns_hdr) +\n\t\t\t\t\tllao_len,\n\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,\n\t\t\t\t\tND_NET_BUF_TIMEOUT);\n\tif (!pkt) {\n\t\tret = -ENOMEM;\n\t\tgoto drop;\n\t}\n\n\t/* Avoid recursive loop with network packet capturing */\n\tif (IS_ENABLED(CONFIG_NET_CAPTURE) && pending) {\n\t\tnet_pkt_set_captured(pkt, net_pkt_is_captured(pending));\n\t}\n\n\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);\n\n\tif (net_ipv6_create(pkt, src, dst) ||\n\t    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {\n\t\tgoto drop;\n\t}\n\n\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);\n\tif (!ns_hdr) {\n\t\tgoto drop;\n\t}\n\n\tns_hdr->reserved = 0U;\n\tnet_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);\n\n\tif (net_pkt_set_data(pkt, &ns_access)) {\n\t\tgoto drop;\n\t}\n\n\tif (!is_my_address) {\n\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),\n\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnet_pkt_cursor_init(pkt);\n\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);\n\n\tnet_ipv6_nbr_lock();\n\tnbr = add_nbr(iface, tgt, false,\n\t\t      NET_IPV6_NBR_STATE_INCOMPLETE);\n\tif (!nbr) {\n\t\tNET_DBG(\"Could not create new neighbor %s\",\n\t\t\tnet_sprint_ipv6_addr(&ns_hdr->tgt));\n\t\tnet_ipv6_nbr_unlock();\n\t\tgoto drop;\n\t}\n\n\tif (pending != NULL) {\n\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tk_fifo_put(&net_ipv6_nbr_data(nbr)->pending_queue, pending);\n\t\t\tpending = net_pkt_ref(pending);\n\n\t\t\tNET_DBG(\"Setting timeout %d for NS\", NS_REPLY_TIMEOUT);\n\n\t\t\tnet_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();\n\n\t\t\t/* Let's start the timer if necessary */\n\t\t\tif (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {\n\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,\n\t\t\t\t\t\t  K_MSEC(NS_REPLY_TIMEOUT));\n\t\t\t}\n\t\t} else {\n\t\t\t/* If there is already a pending packet\n\t\t\t * for this neighbor, we do not send the NS but just\n\t\t\t * add the packet to the pending queue.\n\t\t\t */\n\t\t\tif (k_queue_unique_append(&net_ipv6_nbr_data(nbr)->pending_queue._queue,\n\t\t\t\t\t\t  pending)) {\n\t\t\t\tNET_DBG(\"Adding pending packet %p for NS to nbr %p\",\n\t\t\t\t\tpending, nbr);\n\n\t\t\t\tpending = net_pkt_ref(pending);\n\t\t\t} else {\n\t\t\t\tNET_DBG(\"Packet %p already pending for \"\n\t\t\t\t\t\"operation for nbr %p.\",\n\t\t\t\t\tpending, nbr);\n\t\t\t}\n\n\t\t\t/* Let the system timeout and then send the NS again */\n\t\t\tnet_ipv6_nbr_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdbg_addr_sent_tgt(\"Neighbor Solicitation\", src, dst, &ns_hdr->tgt, pkt);\n\n\tif (net_send_data(pkt) < 0) {\n\t\tNET_DBG(\"Cannot send NS %p (pending %p)\", pkt, pending);\n\n\t\tif (pending != NULL) {\n\t\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));\n\t\t\tpending = NULL;\n\t\t}\n\n\t\tnet_ipv6_nbr_unlock();\n\t\tgoto drop;\n\t}\n\n\tnet_ipv6_nbr_unlock();\n\n\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));\n\tnet_stats_update_ipv6_nd_sent(iface);\n\n\treturn 0;\n\ndrop:\n\tif (pending != NULL) {\n\t\tnet_pkt_unref(pending);\n\t}\n\n\tif (pkt) {\n\t\tnet_pkt_unref(pkt);\n\t}\n\n\tnet_stats_update_ipv6_nd_drop(iface);\n\n\treturn ret;\n}\n",
                {
                    "2004": "int net_ipv6_send_ns(struct net_if *iface,",
                    "2005": "\t\t     struct net_pkt *pending,",
                    "2006": "\t\t     const struct net_in6_addr *src,",
                    "2007": "\t\t     const struct net_in6_addr *dst,",
                    "2008": "\t\t     const struct net_in6_addr *tgt,",
                    "2009": "\t\t     bool is_my_address)",
                    "2010": "{",
                    "2011": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,",
                    "2012": "\t\t\t\t\t      struct net_icmpv6_ns_hdr);",
                    "2013": "\tstruct net_pkt *pkt = NULL;",
                    "2014": "\tint ret = -ENOBUFS;",
                    "2015": "\tstruct net_icmpv6_ns_hdr *ns_hdr;",
                    "2016": "\tstruct net_in6_addr node_dst;",
                    "2017": "\tstruct net_nbr *nbr;",
                    "2018": "\tuint8_t llao_len;",
                    "2019": "",
                    "2020": "\tif (!dst) {",
                    "2021": "\t\tnet_ipv6_addr_create_solicited_node(tgt, &node_dst);",
                    "2022": "\t\tdst = &node_dst;",
                    "2023": "\t}",
                    "2024": "",
                    "2025": "\tllao_len = get_llao_len(iface);",
                    "2026": "",
                    "2027": "\tif (is_my_address) {",
                    "2028": "\t\tsrc = net_ipv6_unspecified_address();",
                    "2029": "\t\tllao_len = 0U;",
                    "2030": "\t} else {",
                    "2031": "\t\tif (!src) {",
                    "2032": "\t\t\tsrc = net_if_ipv6_select_src_addr(iface, tgt);",
                    "2033": "\t\t}",
                    "2034": "",
                    "2035": "\t\tif (net_ipv6_is_addr_unspecified(src)) {",
                    "2036": "\t\t\tNET_DBG(\"No source address for NS (tgt %s)\",",
                    "2037": "\t\t\t\tnet_sprint_ipv6_addr(tgt));",
                    "2038": "\t\t\tret = -EINVAL;",
                    "2039": "",
                    "2040": "\t\t\tgoto drop;",
                    "2041": "\t\t}",
                    "2042": "\t}",
                    "2043": "",
                    "2044": "\tpkt = net_pkt_alloc_with_buffer(iface,",
                    "2045": "\t\t\t\t\tsizeof(struct net_icmpv6_ns_hdr) +",
                    "2046": "\t\t\t\t\tllao_len,",
                    "2047": "\t\t\t\t\tNET_AF_INET6, NET_IPPROTO_ICMPV6,",
                    "2048": "\t\t\t\t\tND_NET_BUF_TIMEOUT);",
                    "2049": "\tif (!pkt) {",
                    "2050": "\t\tret = -ENOMEM;",
                    "2051": "\t\tgoto drop;",
                    "2052": "\t}",
                    "2053": "",
                    "2054": "\t/* Avoid recursive loop with network packet capturing */",
                    "2055": "\tif (IS_ENABLED(CONFIG_NET_CAPTURE) && pending) {",
                    "2056": "\t\tnet_pkt_set_captured(pkt, net_pkt_is_captured(pending));",
                    "2057": "\t}",
                    "2058": "",
                    "2059": "\tnet_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);",
                    "2060": "",
                    "2061": "\tif (net_ipv6_create(pkt, src, dst) ||",
                    "2062": "\t    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {",
                    "2063": "\t\tgoto drop;",
                    "2064": "\t}",
                    "2065": "",
                    "2066": "\tns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);",
                    "2067": "\tif (!ns_hdr) {",
                    "2068": "\t\tgoto drop;",
                    "2069": "\t}",
                    "2070": "",
                    "2071": "\tns_hdr->reserved = 0U;",
                    "2072": "\tnet_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);",
                    "2073": "",
                    "2074": "\tif (net_pkt_set_data(pkt, &ns_access)) {",
                    "2075": "\t\tgoto drop;",
                    "2076": "\t}",
                    "2077": "",
                    "2078": "\tif (!is_my_address) {",
                    "2079": "\t\tif (!set_llao(pkt, net_if_get_link_addr(iface),",
                    "2080": "\t\t\t      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {",
                    "2081": "\t\t\tgoto drop;",
                    "2082": "\t\t}",
                    "2083": "\t}",
                    "2084": "",
                    "2085": "\tnet_pkt_cursor_init(pkt);",
                    "2086": "\tnet_ipv6_finalize(pkt, NET_IPPROTO_ICMPV6);",
                    "2087": "",
                    "2088": "\tnet_ipv6_nbr_lock();",
                    "2089": "\tnbr = add_nbr(iface, tgt, false,",
                    "2090": "\t\t      NET_IPV6_NBR_STATE_INCOMPLETE);",
                    "2091": "\tif (!nbr) {",
                    "2092": "\t\tNET_DBG(\"Could not create new neighbor %s\",",
                    "2093": "\t\t\tnet_sprint_ipv6_addr(&ns_hdr->tgt));",
                    "2094": "\t\tnet_ipv6_nbr_unlock();",
                    "2095": "\t\tgoto drop;",
                    "2096": "\t}",
                    "2097": "",
                    "2098": "\tif (pending != NULL) {",
                    "2099": "\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "2100": "\t\t\tk_fifo_put(&net_ipv6_nbr_data(nbr)->pending_queue, pending);",
                    "2101": "\t\t\tpending = net_pkt_ref(pending);",
                    "2102": "",
                    "2103": "\t\t\tNET_DBG(\"Setting timeout %d for NS\", NS_REPLY_TIMEOUT);",
                    "2104": "",
                    "2105": "\t\t\tnet_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();",
                    "2106": "",
                    "2107": "\t\t\t/* Let's start the timer if necessary */",
                    "2108": "\t\t\tif (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {",
                    "2109": "\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,",
                    "2110": "\t\t\t\t\t\t  K_MSEC(NS_REPLY_TIMEOUT));",
                    "2111": "\t\t\t}",
                    "2112": "\t\t} else {",
                    "2113": "\t\t\t/* If there is already a pending packet",
                    "2114": "\t\t\t * for this neighbor, we do not send the NS but just",
                    "2115": "\t\t\t * add the packet to the pending queue.",
                    "2116": "\t\t\t */",
                    "2117": "\t\t\tif (k_queue_unique_append(&net_ipv6_nbr_data(nbr)->pending_queue._queue,",
                    "2118": "\t\t\t\t\t\t  pending)) {",
                    "2119": "\t\t\t\tNET_DBG(\"Adding pending packet %p for NS to nbr %p\",",
                    "2120": "\t\t\t\t\tpending, nbr);",
                    "2121": "",
                    "2122": "\t\t\t\tpending = net_pkt_ref(pending);",
                    "2123": "\t\t\t} else {",
                    "2124": "\t\t\t\tNET_DBG(\"Packet %p already pending for \"",
                    "2125": "\t\t\t\t\t\"operation for nbr %p.\",",
                    "2126": "\t\t\t\t\tpending, nbr);",
                    "2127": "\t\t\t}",
                    "2128": "",
                    "2129": "\t\t\t/* Let the system timeout and then send the NS again */",
                    "2130": "\t\t\tnet_ipv6_nbr_unlock();",
                    "2131": "\t\t\treturn 0;",
                    "2132": "\t\t}",
                    "2133": "\t}",
                    "2134": "",
                    "2135": "\tdbg_addr_sent_tgt(\"Neighbor Solicitation\", src, dst, &ns_hdr->tgt, pkt);",
                    "2136": "",
                    "2137": "\tif (net_send_data(pkt) < 0) {",
                    "2138": "\t\tNET_DBG(\"Cannot send NS %p (pending %p)\", pkt, pending);",
                    "2139": "",
                    "2140": "\t\tif (pending != NULL) {",
                    "2141": "\t\t\tnbr_clear_ns_pending(net_ipv6_nbr_data(nbr));",
                    "2142": "\t\t\tpending = NULL;",
                    "2143": "\t\t}",
                    "2144": "",
                    "2145": "\t\tnet_ipv6_nbr_unlock();",
                    "2146": "\t\tgoto drop;",
                    "2147": "\t}",
                    "2148": "",
                    "2149": "\tnet_ipv6_nbr_unlock();",
                    "2150": "",
                    "2151": "\tnet_stats_update_icmp_sent(net_pkt_iface(pkt));",
                    "2152": "\tnet_stats_update_ipv6_nd_sent(iface);",
                    "2153": "",
                    "2154": "\treturn 0;",
                    "2155": "",
                    "2156": "drop:",
                    "2157": "\tif (pending != NULL) {",
                    "2158": "\t\tnet_pkt_unref(pending);",
                    "2159": "\t}",
                    "2160": "",
                    "2161": "\tif (pkt) {",
                    "2162": "\t\tnet_pkt_unref(pkt);",
                    "2163": "\t}",
                    "2164": "",
                    "2165": "\tnet_stats_update_ipv6_nd_drop(iface);",
                    "2166": "",
                    "2167": "\treturn ret;",
                    "2168": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "dbg_update_neighbor_lladdr_raw": {
            "name": "dbg_update_neighbor_lladdr_raw",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 518,
            "function_content": [
                "/* Initialize the pending queue for this neighbor */\nstatic void dbg_update_neighbor_lladdr_raw(uint8_t *new_lladdr,\n\t\t\t\t\t   struct net_linkaddr *old_lladdr,\n\t\t\t\t\t   struct net_in6_addr *addr)\n{\n\tstruct net_linkaddr lladdr = {\n\t\t.len = old_lladdr->len,\n\t};\n\n\tmemcpy(lladdr.addr, new_lladdr, lladdr.len);\n\n\tdbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);\n}\n",
                {
                    "518": "static void dbg_update_neighbor_lladdr_raw(uint8_t *new_lladdr,",
                    "519": "\t\t\t\t\t   struct net_linkaddr *old_lladdr,",
                    "520": "\t\t\t\t\t   struct net_in6_addr *addr)",
                    "521": "{",
                    "522": "\tstruct net_linkaddr lladdr = {",
                    "523": "\t\t.len = old_lladdr->len,",
                    "524": "\t};",
                    "525": "",
                    "526": "\tmemcpy(lladdr.addr, new_lladdr, lladdr.len);",
                    "527": "",
                    "528": "\tdbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);",
                    "529": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ipv6_ns_reply_timeout": {
            "name": "ipv6_ns_reply_timeout",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/ipv6_nbr.c",
            "location_line": 349,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6_NBR_CACHE */\nstatic void ipv6_ns_reply_timeout(struct k_work *work)\n{\n\tint64_t current = k_uptime_get();\n\tstruct net_nbr *nbr = NULL;\n\tstruct net_ipv6_nbr_data *data;\n\tstruct net_pkt *pending;\n\tint i;\n\n\tARG_UNUSED(work);\n\n\tnet_ipv6_nbr_lock();\n\n\tfor (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {\n\t\tint64_t remaining;\n\t\tnbr = get_nbr(i);\n\n\t\tif (!nbr || !nbr->ref) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata = net_ipv6_nbr_data(nbr);\n\t\tif (!data) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->send_ns) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining = data->send_ns + NS_REPLY_TIMEOUT - current;\n\n\t\tif (remaining > 0) {\n\t\t\tif (!k_work_delayable_remaining_get(\n\t\t\t\t    &ipv6_ns_reply_timer)) {\n\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,\n\t\t\t\t\t\t  K_MSEC(remaining));\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->send_ns = 0;\n\n\t\t/* We did not receive reply to a sent NS */\n\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\t/* Silently return, this is not an error as the work\n\t\t\t * cannot be cancelled in certain cases.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\tenum net_verdict verdict;\n\n\t\t\t/* Remove the first pending packet from the queue\n\t\t\t * and unref it. If there are more pending packets,\n\t\t\t * they will be processed in the next round.\n\t\t\t */\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tNET_DBG(\"NS nbr %p pending %p timeout to %s\", nbr, pending,\n\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));\n\n\t\t\tNET_DBG(\"Dropping pending pkt %p\", pending);\n\n\t\t\t/* This gets rid of the reference that was\n\t\t\t * added when the packet was put into the pending queue.\n\t\t\t */\n\t\t\tnet_pkt_unref(pending);\n\n\t\t\t/* To unref the original pkt allocation */\n\t\t\tnet_pkt_unref(pending);\n\n\t\t\t/* If there are no more pending packets, we can\n\t\t\t * unref the neighbor.\n\t\t\t */\n\t\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {\n\t\t\t\tnet_nbr_unref(nbr);\n\n\t\t\t\tNET_DBG(\"Dropping neighbor %p\", nbr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If there are more pending packets, we need to\n\t\t\t * reschedule the work so that we can process them and\n\t\t\t * send a new NS.\n\t\t\t */\n\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,\n\t\t\t\t\t     K_FOREVER);\n\n\t\t\tverdict = net_ipv6_prepare_for_send(pending);\n\t\t\tif (verdict == NET_DROP) {\n\t\t\t\t/* The ref when added to the pending queue */\n\t\t\t\tnet_pkt_unref(pending);\n\n\t\t\t\t/* To unref the original pkt allocation */\n\t\t\t\tnet_pkt_unref(pending);\n\n\t\t\t\t/* Get next packet from the list */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Now wait timeout again */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnet_ipv6_nbr_unlock();\n}\n",
                {
                    "349": "static void ipv6_ns_reply_timeout(struct k_work *work)",
                    "350": "{",
                    "351": "\tint64_t current = k_uptime_get();",
                    "352": "\tstruct net_nbr *nbr = NULL;",
                    "353": "\tstruct net_ipv6_nbr_data *data;",
                    "354": "\tstruct net_pkt *pending;",
                    "355": "\tint i;",
                    "356": "",
                    "357": "\tARG_UNUSED(work);",
                    "358": "",
                    "359": "\tnet_ipv6_nbr_lock();",
                    "360": "",
                    "361": "\tfor (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {",
                    "362": "\t\tint64_t remaining;",
                    "363": "\t\tnbr = get_nbr(i);",
                    "364": "",
                    "365": "\t\tif (!nbr || !nbr->ref) {",
                    "366": "\t\t\tcontinue;",
                    "367": "\t\t}",
                    "368": "",
                    "369": "\t\tdata = net_ipv6_nbr_data(nbr);",
                    "370": "\t\tif (!data) {",
                    "371": "\t\t\tcontinue;",
                    "372": "\t\t}",
                    "373": "",
                    "374": "\t\tif (!data->send_ns) {",
                    "375": "\t\t\tcontinue;",
                    "376": "\t\t}",
                    "377": "",
                    "378": "\t\tremaining = data->send_ns + NS_REPLY_TIMEOUT - current;",
                    "379": "",
                    "380": "\t\tif (remaining > 0) {",
                    "381": "\t\t\tif (!k_work_delayable_remaining_get(",
                    "382": "\t\t\t\t    &ipv6_ns_reply_timer)) {",
                    "383": "\t\t\t\tk_work_reschedule(&ipv6_ns_reply_timer,",
                    "384": "\t\t\t\t\t\t  K_MSEC(remaining));",
                    "385": "\t\t\t}",
                    "386": "",
                    "387": "\t\t\tcontinue;",
                    "388": "\t\t}",
                    "389": "",
                    "390": "\t\tdata->send_ns = 0;",
                    "391": "",
                    "392": "\t\t/* We did not receive reply to a sent NS */",
                    "393": "\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "394": "\t\t\t/* Silently return, this is not an error as the work",
                    "395": "\t\t\t * cannot be cancelled in certain cases.",
                    "396": "\t\t\t */",
                    "397": "\t\t\tcontinue;",
                    "398": "\t\t}",
                    "399": "",
                    "400": "\t\twhile (!k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "401": "\t\t\tenum net_verdict verdict;",
                    "402": "",
                    "403": "\t\t\t/* Remove the first pending packet from the queue",
                    "404": "\t\t\t * and unref it. If there are more pending packets,",
                    "405": "\t\t\t * they will be processed in the next round.",
                    "406": "\t\t\t */",
                    "407": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "408": "\t\t\t\t\t     K_FOREVER);",
                    "409": "",
                    "410": "\t\t\tNET_DBG(\"NS nbr %p pending %p timeout to %s\", nbr, pending,",
                    "411": "\t\t\t\tnet_sprint_ipv6_addr(&NET_IPV6_HDR(pending)->dst));",
                    "412": "",
                    "413": "\t\t\tNET_DBG(\"Dropping pending pkt %p\", pending);",
                    "414": "",
                    "415": "\t\t\t/* This gets rid of the reference that was",
                    "416": "\t\t\t * added when the packet was put into the pending queue.",
                    "417": "\t\t\t */",
                    "418": "\t\t\tnet_pkt_unref(pending);",
                    "419": "",
                    "420": "\t\t\t/* To unref the original pkt allocation */",
                    "421": "\t\t\tnet_pkt_unref(pending);",
                    "422": "",
                    "423": "\t\t\t/* If there are no more pending packets, we can",
                    "424": "\t\t\t * unref the neighbor.",
                    "425": "\t\t\t */",
                    "426": "\t\t\tif (k_fifo_is_empty(&net_ipv6_nbr_data(nbr)->pending_queue)) {",
                    "427": "\t\t\t\tnet_nbr_unref(nbr);",
                    "428": "",
                    "429": "\t\t\t\tNET_DBG(\"Dropping neighbor %p\", nbr);",
                    "430": "\t\t\t\tbreak;",
                    "431": "\t\t\t}",
                    "432": "",
                    "433": "\t\t\t/* If there are more pending packets, we need to",
                    "434": "\t\t\t * reschedule the work so that we can process them and",
                    "435": "\t\t\t * send a new NS.",
                    "436": "\t\t\t */",
                    "437": "\t\t\tpending = k_fifo_get(&net_ipv6_nbr_data(nbr)->pending_queue,",
                    "438": "\t\t\t\t\t     K_FOREVER);",
                    "439": "",
                    "440": "\t\t\tverdict = net_ipv6_prepare_for_send(pending);",
                    "441": "\t\t\tif (verdict == NET_DROP) {",
                    "442": "\t\t\t\t/* The ref when added to the pending queue */",
                    "443": "\t\t\t\tnet_pkt_unref(pending);",
                    "444": "",
                    "445": "\t\t\t\t/* To unref the original pkt allocation */",
                    "446": "\t\t\t\tnet_pkt_unref(pending);",
                    "447": "",
                    "448": "\t\t\t\t/* Get next packet from the list */",
                    "449": "\t\t\t\tcontinue;",
                    "450": "\t\t\t}",
                    "451": "",
                    "452": "\t\t\t/* Now wait timeout again */",
                    "453": "\t\t\tbreak;",
                    "454": "\t\t}",
                    "455": "\t}",
                    "456": "",
                    "457": "\tnet_ipv6_nbr_unlock();",
                    "458": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_ipv6_mtu": {
            "name": "set_context_ipv6_mtu",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3702,
            "function_content": [
                "/* If value is -1 then use the system default.\n* This is done same way as in Linux.\n*/\nstatic int set_context_ipv6_mtu(struct net_context *context,\n\t\t\t\tconst void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_IPV6)\n\tstruct net_if *iface;\n\tuint16_t mtu;\n\n\tif (len != sizeof(int)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmtu = *((int *)value);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {\n\t\tint ret;\n\n\t\tret = net_pmtu_update_mtu(&context->remote, mtu);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (net_context_is_bound_to_iface(context)) {\n\t\tiface = net_context_get_iface(context);\n\t} else {\n\t\tnet_sa_family_t family = net_context_get_family(context);\n\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\t\tiface = net_if_ipv6_select_src_iface(\n\t\t\t\t&net_sin6(&context->remote)->sin6_addr);\n\t\t} else {\n\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\t}\n\n\tnet_if_set_mtu(iface, (uint16_t)mtu);\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3702": "static int set_context_ipv6_mtu(struct net_context *context,",
                    "3703": "\t\t\t\tconst void *value, uint32_t len)",
                    "3704": "{",
                    "3705": "#if defined(CONFIG_NET_IPV6)",
                    "3706": "\tstruct net_if *iface;",
                    "3707": "\tuint16_t mtu;",
                    "3708": "",
                    "3709": "\tif (len != sizeof(int)) {",
                    "3710": "\t\treturn -EINVAL;",
                    "3711": "\t}",
                    "3712": "",
                    "3713": "\tmtu = *((int *)value);",
                    "3714": "",
                    "3715": "\tif (IS_ENABLED(CONFIG_NET_IPV6_PMTU)) {",
                    "3716": "\t\tint ret;",
                    "3717": "",
                    "3718": "\t\tret = net_pmtu_update_mtu(&context->remote, mtu);",
                    "3719": "\t\tif (ret < 0) {",
                    "3720": "\t\t\treturn ret;",
                    "3721": "\t\t}",
                    "3722": "",
                    "3723": "\t\treturn 0;",
                    "3724": "\t}",
                    "3725": "",
                    "3726": "\tif (net_context_is_bound_to_iface(context)) {",
                    "3727": "\t\tiface = net_context_get_iface(context);",
                    "3728": "\t} else {",
                    "3729": "\t\tnet_sa_family_t family = net_context_get_family(context);",
                    "3730": "",
                    "3731": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "3732": "\t\t\tiface = net_if_ipv6_select_src_iface(",
                    "3733": "\t\t\t\t&net_sin6(&context->remote)->sin6_addr);",
                    "3734": "\t\t} else {",
                    "3735": "\t\t\treturn -EAFNOSUPPORT;",
                    "3736": "\t\t}",
                    "3737": "\t}",
                    "3738": "",
                    "3739": "\tnet_if_set_mtu(iface, (uint16_t)mtu);",
                    "3740": "",
                    "3741": "\treturn 0;",
                    "3742": "#else",
                    "3743": "\tARG_UNUSED(context);",
                    "3744": "\tARG_UNUSED(value);",
                    "3745": "\tARG_UNUSED(len);",
                    "3746": "",
                    "3747": "\treturn -ENOTSUP;",
                    "3748": "#endif",
                    "3749": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_unicast_hop_limit": {
            "name": "set_context_unicast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3641,
            "function_content": [
                "/* If value is -1 then use the system default.\n* This is done same way as in Linux.\n*/\nstatic int set_context_unicast_hop_limit(struct net_context *context,\n\t\t\t\t\t const void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_IPV6)\n\tuint8_t unicast_hop_limit = *((int *)value);\n\n\tlen = sizeof(context->ipv6_hop_limit);\n\n\treturn set_uint8_option(&context->ipv6_hop_limit,\n\t\t\t\t&unicast_hop_limit, len);\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3641": "static int set_context_unicast_hop_limit(struct net_context *context,",
                    "3642": "\t\t\t\t\t const void *value, uint32_t len)",
                    "3643": "{",
                    "3644": "#if defined(CONFIG_NET_IPV6)",
                    "3645": "\tuint8_t unicast_hop_limit = *((int *)value);",
                    "3646": "",
                    "3647": "\tlen = sizeof(context->ipv6_hop_limit);",
                    "3648": "",
                    "3649": "\treturn set_uint8_option(&context->ipv6_hop_limit,",
                    "3650": "\t\t\t\t&unicast_hop_limit, len);",
                    "3651": "#else",
                    "3652": "\tARG_UNUSED(context);",
                    "3653": "\tARG_UNUSED(value);",
                    "3654": "\tARG_UNUSED(len);",
                    "3655": "",
                    "3656": "\treturn -ENOTSUP;",
                    "3657": "#endif",
                    "3658": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_mcast_hop_limit": {
            "name": "set_context_mcast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3605,
            "function_content": [
                "#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */\nstatic int set_context_mcast_hop_limit(struct net_context *context,\n\t\t\t\t       const void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_IPV6)\n\tint mcast_hop_limit = *((int *)value);\n\n\tif (len != sizeof(int)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (mcast_hop_limit == -1) {\n\t\t/* If value is -1 then use the system default.\n\t\t * This is done same way as in Linux.\n\t\t */\n\t\tif (net_if_get_by_index(context->iface) == NULL) {\n\t\t\tmcast_hop_limit = INITIAL_MCAST_HOP_LIMIT;\n\t\t} else {\n\t\t\tmcast_hop_limit = net_if_ipv6_get_mcast_hop_limit(\n\t\t\t\tnet_if_get_by_index(context->iface));\n\t\t}\n\t} else if (mcast_hop_limit < 0 || mcast_hop_limit > 255) {\n\t\treturn -EINVAL;\n\t}\n\n\tcontext->ipv6_mcast_hop_limit = mcast_hop_limit;\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3605": "static int set_context_mcast_hop_limit(struct net_context *context,",
                    "3606": "\t\t\t\t       const void *value, uint32_t len)",
                    "3607": "{",
                    "3608": "#if defined(CONFIG_NET_IPV6)",
                    "3609": "\tint mcast_hop_limit = *((int *)value);",
                    "3610": "",
                    "3611": "\tif (len != sizeof(int)) {",
                    "3612": "\t\treturn -EINVAL;",
                    "3613": "\t}",
                    "3614": "",
                    "3615": "\tif (mcast_hop_limit == -1) {",
                    "3616": "\t\t/* If value is -1 then use the system default.",
                    "3617": "\t\t * This is done same way as in Linux.",
                    "3618": "\t\t */",
                    "3619": "\t\tif (net_if_get_by_index(context->iface) == NULL) {",
                    "3620": "\t\t\tmcast_hop_limit = INITIAL_MCAST_HOP_LIMIT;",
                    "3621": "\t\t} else {",
                    "3622": "\t\t\tmcast_hop_limit = net_if_ipv6_get_mcast_hop_limit(",
                    "3623": "\t\t\t\tnet_if_get_by_index(context->iface));",
                    "3624": "\t\t}",
                    "3625": "\t} else if (mcast_hop_limit < 0 || mcast_hop_limit > 255) {",
                    "3626": "\t\treturn -EINVAL;",
                    "3627": "\t}",
                    "3628": "",
                    "3629": "\tcontext->ipv6_mcast_hop_limit = mcast_hop_limit;",
                    "3630": "",
                    "3631": "\treturn 0;",
                    "3632": "#else",
                    "3633": "\tARG_UNUSED(context);",
                    "3634": "\tARG_UNUSED(value);",
                    "3635": "\tARG_UNUSED(len);",
                    "3636": "",
                    "3637": "\treturn -ENOTSUP;",
                    "3638": "#endif",
                    "3639": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_context_dscp_ecn": {
            "name": "set_context_dscp_ecn",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3541,
            "function_content": [
                "#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */\nstatic int set_context_dscp_ecn(struct net_context *context,\n\t\t\t\tconst void *value, uint32_t len)\n{\n#if defined(CONFIG_NET_CONTEXT_DSCP_ECN)\n\treturn set_uint8_option(&context->options.dscp_ecn, value, len);\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "3541": "static int set_context_dscp_ecn(struct net_context *context,",
                    "3542": "\t\t\t\tconst void *value, uint32_t len)",
                    "3543": "{",
                    "3544": "#if defined(CONFIG_NET_CONTEXT_DSCP_ECN)",
                    "3545": "\treturn set_uint8_option(&context->options.dscp_ecn, value, len);",
                    "3546": "#else",
                    "3547": "\tARG_UNUSED(context);",
                    "3548": "\tARG_UNUSED(value);",
                    "3549": "\tARG_UNUSED(len);",
                    "3550": "",
                    "3551": "\treturn -ENOTSUP;",
                    "3552": "#endif",
                    "3553": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_uint8_option": {
            "name": "set_uint8_option",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 3379,
            "function_content": [
                "#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */\n__maybe_unused static int set_uint8_option(uint8_t *option, const void *value, uint32_t len)\n{\n\tif (value == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (len > sizeof(uint8_t)) {\n\t\treturn -EINVAL;\n\t}\n\n\t*option = *((uint8_t *)value);\n\n\treturn 0;\n}\n",
                {
                    "3379": "__maybe_unused static int set_uint8_option(uint8_t *option, const void *value, uint32_t len)",
                    "3380": "{",
                    "3381": "\tif (value == NULL) {",
                    "3382": "\t\treturn -EINVAL;",
                    "3383": "\t}",
                    "3384": "",
                    "3385": "\tif (len > sizeof(uint8_t)) {",
                    "3386": "\t\treturn -EINVAL;",
                    "3387": "\t}",
                    "3388": "",
                    "3389": "\t*option = *((uint8_t *)value);",
                    "3390": "",
                    "3391": "\treturn 0;",
                    "3392": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "context_sendto": {
            "name": "context_sendto",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2385,
            "function_content": [
                "/* This function is meant to be temporary: once all moved to new\n* API, it will be up to net_send_data() to finalize the packet.\n*/\nstatic int context_sendto(struct net_context *context,\n\t\t\t  const void *buf,\n\t\t\t  size_t len,\n\t\t\t  const struct net_sockaddr *dst_addr,\n\t\t\t  net_socklen_t addrlen,\n\t\t\t  net_context_send_cb_t cb,\n\t\t\t  k_timeout_t timeout,\n\t\t\t  void *user_data,\n\t\t\t  bool sendto)\n{\n\tconst struct net_msghdr *msghdr = NULL;\n\tstruct net_if *iface = NULL;\n\tstruct net_pkt *pkt = NULL;\n\tnet_sa_family_t family;\n\tsize_t tmp_len;\n\tint ret;\n\n\tNET_ASSERT(PART_OF_ARRAY(contexts, context));\n\n\tif (!net_context_is_used(context)) {\n\t\treturn -EBADF;\n\t}\n\n\tif (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {\n\t\t/* User wants to call sendmsg */\n\t\tmsghdr = buf;\n\t}\n\n\tif (!msghdr && !dst_addr) {\n\t\treturn -EDESTADDRREQ;\n\t}\n\n\t/* Are we trying to send IPv4 packet to mapped V6 address, in that case\n\t * we need to set the family to NET_AF_INET so that various checks below\n\t * are done to the packet correctly and we actually send an IPv4 pkt.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&\n\t    IS_ENABLED(CONFIG_NET_IPV6) &&\n\t    net_context_get_family(context) == NET_AF_INET6) {\n\t\tconst struct net_sockaddr_in6 *addr6 = NULL;\n\n\t\tif (dst_addr != NULL) {\n\t\t\taddr6 = (const struct net_sockaddr_in6 *)dst_addr;\n\t\t} else if (msghdr != NULL) {\n\t\t\taddr6 = msghdr->msg_name;\n\t\t}\n\n\t\tif (addr6 != NULL && net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {\n\t\t\tfamily = NET_AF_INET;\n\t\t} else {\n\t\t\tfamily = net_context_get_family(context);\n\t\t}\n\t} else {\n\t\tfamily = net_context_get_family(context);\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\tconst struct net_sockaddr_in6 *addr6 =\n\t\t\t(const struct net_sockaddr_in6 *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\taddr6 = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!addr6) {\n\t\t\t\taddr6 = net_sin6(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_in6);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr6;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,\n\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,\n\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));\n\t\t\t}\n\n\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr) &&\n\t\t\t    !net_context_is_bound_to_iface(context) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,\n\t\t\t\t\t(addr6->sin6_scope_id > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6, (\n\t\t\t\t\t   iface = net_if_get_by_index(addr6->sin6_scope_id)));\n\t\t\t\tif (iface != NULL) {\n\t\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If application has not yet set the destination address\n\t\t * i.e., by not calling connect(), then set the interface\n\t\t * here so that the packet gets sent to the correct network\n\t\t * interface. This issue can be seen if there are multiple\n\t\t * network interfaces and we are trying to send data to\n\t\t * second or later network interface.\n\t\t */\n\t\tif (iface == NULL) {\n\t\t\tif (net_ipv6_is_addr_unspecified(\n\t\t\t\t    &net_sin6(&context->remote)->sin6_addr) &&\n\t\t\t    !net_context_is_bound_to_iface(context)) {\n\t\t\t\tiface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);\n\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\tconst struct net_sockaddr_in *addr4 = (const struct net_sockaddr_in *)dst_addr;\n\t\tstruct net_sockaddr_in mapped;\n\n\t\tif (msghdr) {\n\t\t\taddr4 = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!addr4) {\n\t\t\t\taddr4 = net_sin(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_in);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr4;\n\t\t}\n\n\t\t/* Get the destination address from the mapped IPv6 address */\n\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&\n\t\t    addr4->sin_family == NET_AF_INET6 &&\n\t\t    net_ipv6_addr_is_v4_mapped(&net_sin6(dst_addr)->sin6_addr)) {\n\t\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;\n\n\t\t\tmapped.sin_port = addr6->sin6_port;\n\t\t\tmapped.sin_family = NET_AF_INET;\n\t\t\tnet_ipaddr_copy(&mapped.sin_addr,\n\t\t\t\t\t(struct net_in_addr *)(&addr6->sin6_addr.s6_addr32[3]));\n\t\t\taddr4 = &mapped;\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)addr4;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!addr4->sin_addr.s_addr) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&\n\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr) &&\n\t\t\t    COND_CODE_1(CONFIG_NET_IPV4,\n\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0), (false))) {\n\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,\n\t\t\t\t\t   (iface = net_if_get_by_index(\n\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));\n\t\t\t}\n\t\t}\n\n\t\t/* If application has not yet set the destination address\n\t\t * i.e., by not calling connect(), then set the interface\n\t\t * here so that the packet gets sent to the correct network\n\t\t * interface. This issue can be seen if there are multiple\n\t\t * network interfaces and we are trying to send data to\n\t\t * second or later network interface.\n\t\t */\n\t\tif (iface == NULL) {\n\t\t\tif (net_sin(&context->remote)->sin_addr.s_addr == 0U &&\n\t\t\t    !net_context_is_bound_to_iface(context)) {\n\t\t\t\tiface = net_if_ipv4_select_src_iface(&addr4->sin_addr);\n\t\t\t\tnet_context_set_iface(context, iface);\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {\n\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\tll_addr = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!ll_addr) {\n\t\t\t\tll_addr = (struct net_sockaddr_ll *)\n\t\t\t\t\t\t\t(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_ll);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)ll_addr;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiface = net_context_get_iface(context);\n\t\tif (iface == NULL) {\n\t\t\tif (ll_addr->sll_ifindex < 0) {\n\t\t\t\treturn -EDESTADDRREQ;\n\t\t\t}\n\n\t\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);\n\t\t\tif (iface == NULL) {\n\t\t\t\tNET_ERR(\"Cannot bind to interface index %d\",\n\t\t\t\t\tll_addr->sll_ifindex);\n\t\t\t\treturn -EDESTADDRREQ;\n\t\t\t}\n\n\t\t\tnet_context_set_iface(context, iface);\n\t\t}\n\n\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM) {\n\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;\n\n\t\t\t/* The user must set the protocol in send call */\n\n\t\t\t/* For sendmsg() call, we might have set ll_addr to\n\t\t\t * point to remote addr.\n\t\t\t */\n\t\t\tif ((void *)&context->remote != (void *)ll_addr) {\n\t\t\t\tmemcpy((struct net_sockaddr_ll *)&context->remote,\n\t\t\t\t       ll_addr, sizeof(struct net_sockaddr_ll));\n\t\t\t}\n\t\t}\n\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN) {\n\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)dst_addr;\n\n\t\tif (msghdr) {\n\t\t\tcan_addr = msghdr->msg_name;\n\t\t\taddrlen = msghdr->msg_namelen;\n\n\t\t\tif (!can_addr) {\n\t\t\t\tcan_addr = (struct net_sockaddr_can *)\n\t\t\t\t\t\t\t(&context->remote);\n\t\t\t\taddrlen = sizeof(struct net_sockaddr_can);\n\t\t\t}\n\n\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.\n\t\t\t */\n\t\t\tdst_addr = (const struct net_sockaddr *)can_addr;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (can_addr->can_ifindex < 0) {\n\t\t\t/* The index should have been set in bind */\n\t\t\tcan_addr->can_ifindex =\n\t\t\t\tnet_can_ptr(&context->local)->can_ifindex;\n\t\t}\n\n\t\tif (can_addr->can_ifindex < 0) {\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\t\tiface = net_if_get_by_index(can_addr->can_ifindex);\n\t\tif (!iface) {\n\t\t\tNET_ERR(\"Cannot bind to interface index %d\",\n\t\t\t\tcan_addr->can_ifindex);\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\t} else {\n\t\tNET_DBG(\"Invalid protocol family %d\", family);\n\t\treturn -EINVAL;\n\t}\n\n\tif (msghdr && len == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {\n\t\t\tlen += msghdr->msg_iov[i].iov_len;\n\t\t}\n\t}\n\n\tiface = net_context_get_iface(context);\n\tif (iface && !net_if_is_up(iface)) {\n\t\treturn -ENETDOWN;\n\t}\n\n\tcontext->send_cb = cb;\n\tcontext->user_data = user_data;\n\n\tif (IS_ENABLED(CONFIG_NET_TCP) &&\n\t    net_context_get_proto(context) == NET_IPPROTO_TCP &&\n\t    !net_if_is_ip_offloaded(net_context_get_iface(context))) {\n\t\tgoto skip_alloc;\n\t}\n\n\tpkt = context_alloc_pkt(context, family, len, PKT_WAIT_TIME);\n\tif (!pkt) {\n\t\tNET_ERR(\"Failed to allocate net_pkt\");\n\t\treturn -ENOBUFS;\n\t}\n\n\ttmp_len = net_pkt_available_payload_buffer(\n\t\t\t\tpkt, net_context_get_proto(context));\n\tif (tmp_len < len) {\n\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM ||\n\t\t    net_context_get_type(context) == NET_SOCK_RAW) {\n\t\t\tNET_ERR(\"Available payload buffer (%zu) is not enough for requested DGRAM (%zu)\",\n\t\t\t\ttmp_len, len);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tlen = tmp_len;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {\n\t\tuint8_t priority;\n\n\t\tget_context_priority(context, &priority, NULL);\n\t\tnet_pkt_set_priority(pkt, priority);\n\t}\n\n\t/* If there is ancillary data in msghdr, then we need to add that\n\t * to net_pkt as there is no other way to store it.\n\t */\n\tif (msghdr && msghdr->msg_control && msghdr->msg_controllen) {\n\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_TXTIME)) {\n\t\t\tint is_txtime;\n\n\t\t\tget_context_txtime(context, &is_txtime, NULL);\n\t\t\tif (is_txtime) {\n\t\t\t\tset_pkt_txtime(pkt, msghdr);\n\t\t\t}\n\t\t}\n\n\t\tset_pkt_hoplimit(pkt, msghdr);\n\n\t}\n\nskip_alloc:\n\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&\n\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tif (sendto) {\n\t\t\tret = net_offload_sendto(net_context_get_iface(context),\n\t\t\t\t\t\t pkt, dst_addr, addrlen, cb,\n\t\t\t\t\t\t timeout, user_data);\n\t\t} else {\n\t\t\tret = net_offload_send(net_context_get_iface(context),\n\t\t\t\t\t       pkt, cb, timeout, user_data);\n\t\t}\n\t} else if (((IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) ||\n\t\t    (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6)) &&\n\t\t   IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&\n\t\t   net_context_get_type(context) == NET_SOCK_RAW) {\n\t\tret = context_setup_raw_ip_packet(family, pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_UDP) &&\n\t    net_context_get_proto(context) == NET_IPPROTO_UDP) {\n\t\tret = context_setup_udp_packet(context, family, pkt, buf, len, msghdr,\n\t\t\t\t\t       dst_addr, addrlen);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tcontext_finalize_packet(context, family, pkt);\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&\n\t\t   net_context_get_proto(context) == NET_IPPROTO_TCP) {\n\n\t\tret = net_tcp_queue(context, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlen = ret;\n\n\t\tret = net_tcp_send_data(context, cb, user_data);\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tstruct net_sockaddr_ll_ptr *ll_src_addr;\n\t\tstruct net_sockaddr_ll *ll_dst_addr;\n\n\t\t/* The destination address is set in remote for this\n\t\t * socket type.\n\t\t */\n\t\tll_dst_addr = (struct net_sockaddr_ll *)&context->remote;\n\t\tll_src_addr = (struct net_sockaddr_ll_ptr *)&context->local;\n\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),\n\t\t\t\t       ll_dst_addr->sll_addr,\n\t\t\t\t       sizeof(struct net_eth_addr));\n\t\t(void)net_linkaddr_set(net_pkt_lladdr_src(pkt),\n\t\t\t\t       ll_src_addr->sll_addr,\n\t\t\t\t       sizeof(struct net_eth_addr));\n\n\t\tnet_pkt_set_ll_proto_type(pkt, net_ntohs(ll_dst_addr->sll_protocol));\n\n\t\tnet_if_try_queue_tx(net_pkt_iface(pkt), pkt, timeout);\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN &&\n\t\t   net_context_get_proto(context) == NET_CAN_RAW) {\n\t\tret = context_write_data(pkt, buf, len, msghdr);\n\t\tif (ret < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet_pkt_cursor_init(pkt);\n\n\t\tret = net_try_send_data(pkt, timeout);\n\t} else {\n\t\tNET_DBG(\"Unknown protocol while sending packet: %d\",\n\t\tnet_context_get_proto(context));\n\t\tret = -EPROTONOSUPPORT;\n\t}\n\n\tif (ret < 0) {\n\t\tgoto fail;\n\t}\n\n\treturn len;\nfail:\n\tif (pkt != NULL) {\n\t\tnet_pkt_unref(pkt);\n\t}\n\n\treturn ret;\n}\n",
                {
                    "2385": "static int context_sendto(struct net_context *context,",
                    "2386": "\t\t\t  const void *buf,",
                    "2387": "\t\t\t  size_t len,",
                    "2388": "\t\t\t  const struct net_sockaddr *dst_addr,",
                    "2389": "\t\t\t  net_socklen_t addrlen,",
                    "2390": "\t\t\t  net_context_send_cb_t cb,",
                    "2391": "\t\t\t  k_timeout_t timeout,",
                    "2392": "\t\t\t  void *user_data,",
                    "2393": "\t\t\t  bool sendto)",
                    "2394": "{",
                    "2395": "\tconst struct net_msghdr *msghdr = NULL;",
                    "2396": "\tstruct net_if *iface = NULL;",
                    "2397": "\tstruct net_pkt *pkt = NULL;",
                    "2398": "\tnet_sa_family_t family;",
                    "2399": "\tsize_t tmp_len;",
                    "2400": "\tint ret;",
                    "2401": "",
                    "2402": "\tNET_ASSERT(PART_OF_ARRAY(contexts, context));",
                    "2403": "",
                    "2404": "\tif (!net_context_is_used(context)) {",
                    "2405": "\t\treturn -EBADF;",
                    "2406": "\t}",
                    "2407": "",
                    "2408": "\tif (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {",
                    "2409": "\t\t/* User wants to call sendmsg */",
                    "2410": "\t\tmsghdr = buf;",
                    "2411": "\t}",
                    "2412": "",
                    "2413": "\tif (!msghdr && !dst_addr) {",
                    "2414": "\t\treturn -EDESTADDRREQ;",
                    "2415": "\t}",
                    "2416": "",
                    "2417": "\t/* Are we trying to send IPv4 packet to mapped V6 address, in that case",
                    "2418": "\t * we need to set the family to NET_AF_INET so that various checks below",
                    "2419": "\t * are done to the packet correctly and we actually send an IPv4 pkt.",
                    "2420": "\t */",
                    "2421": "\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&",
                    "2422": "\t    IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "2423": "\t    net_context_get_family(context) == NET_AF_INET6) {",
                    "2424": "\t\tconst struct net_sockaddr_in6 *addr6 = NULL;",
                    "2425": "",
                    "2426": "\t\tif (dst_addr != NULL) {",
                    "2427": "\t\t\taddr6 = (const struct net_sockaddr_in6 *)dst_addr;",
                    "2428": "\t\t} else if (msghdr != NULL) {",
                    "2429": "\t\t\taddr6 = msghdr->msg_name;",
                    "2430": "\t\t}",
                    "2431": "",
                    "2432": "\t\tif (addr6 != NULL && net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {",
                    "2433": "\t\t\tfamily = NET_AF_INET;",
                    "2434": "\t\t} else {",
                    "2435": "\t\t\tfamily = net_context_get_family(context);",
                    "2436": "\t\t}",
                    "2437": "\t} else {",
                    "2438": "\t\tfamily = net_context_get_family(context);",
                    "2439": "\t}",
                    "2440": "",
                    "2441": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "2442": "\t\tconst struct net_sockaddr_in6 *addr6 =",
                    "2443": "\t\t\t(const struct net_sockaddr_in6 *)dst_addr;",
                    "2444": "",
                    "2445": "\t\tif (msghdr) {",
                    "2446": "\t\t\taddr6 = msghdr->msg_name;",
                    "2447": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2448": "",
                    "2449": "\t\t\tif (!addr6) {",
                    "2450": "\t\t\t\taddr6 = net_sin6(&context->remote);",
                    "2451": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_in6);",
                    "2452": "\t\t\t}",
                    "2453": "",
                    "2454": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2455": "\t\t\t */",
                    "2456": "\t\t\tdst_addr = (const struct net_sockaddr *)addr6;",
                    "2457": "\t\t}",
                    "2458": "",
                    "2459": "\t\tif (addrlen < sizeof(struct net_sockaddr_in6)) {",
                    "2460": "\t\t\treturn -EINVAL;",
                    "2461": "\t\t}",
                    "2462": "",
                    "2463": "\t\tif (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {",
                    "2464": "\t\t\treturn -EDESTADDRREQ;",
                    "2465": "\t\t}",
                    "2466": "",
                    "2467": "\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2468": "\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2469": "\t\t\tif (net_ipv6_is_addr_mcast(&addr6->sin6_addr) &&",
                    "2470": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,",
                    "2471": "\t\t\t\t\t(context->options.ipv6_mcast_ifindex > 0), (false))) {",
                    "2472": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6,",
                    "2473": "\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "2474": "\t\t\t\t\t\t   context->options.ipv6_mcast_ifindex)));",
                    "2475": "\t\t\t}",
                    "2476": "",
                    "2477": "\t\t\tif (net_ipv6_is_ll_addr(&addr6->sin6_addr) &&",
                    "2478": "\t\t\t    !net_context_is_bound_to_iface(context) &&",
                    "2479": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV6,",
                    "2480": "\t\t\t\t\t(addr6->sin6_scope_id > 0), (false))) {",
                    "2481": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV6, (",
                    "2482": "\t\t\t\t\t   iface = net_if_get_by_index(addr6->sin6_scope_id)));",
                    "2483": "\t\t\t\tif (iface != NULL) {",
                    "2484": "\t\t\t\t\tnet_context_set_iface(context, iface);",
                    "2485": "\t\t\t\t}",
                    "2486": "\t\t\t}",
                    "2487": "\t\t}",
                    "2488": "",
                    "2489": "\t\t/* If application has not yet set the destination address",
                    "2490": "\t\t * i.e., by not calling connect(), then set the interface",
                    "2491": "\t\t * here so that the packet gets sent to the correct network",
                    "2492": "\t\t * interface. This issue can be seen if there are multiple",
                    "2493": "\t\t * network interfaces and we are trying to send data to",
                    "2494": "\t\t * second or later network interface.",
                    "2495": "\t\t */",
                    "2496": "\t\tif (iface == NULL) {",
                    "2497": "\t\t\tif (net_ipv6_is_addr_unspecified(",
                    "2498": "\t\t\t\t    &net_sin6(&context->remote)->sin6_addr) &&",
                    "2499": "\t\t\t    !net_context_is_bound_to_iface(context)) {",
                    "2500": "\t\t\t\tiface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);",
                    "2501": "\t\t\t\tnet_context_set_iface(context, iface);",
                    "2502": "\t\t\t}",
                    "2503": "\t\t}",
                    "2504": "",
                    "2505": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "2506": "\t\tconst struct net_sockaddr_in *addr4 = (const struct net_sockaddr_in *)dst_addr;",
                    "2507": "\t\tstruct net_sockaddr_in mapped;",
                    "2508": "",
                    "2509": "\t\tif (msghdr) {",
                    "2510": "\t\t\taddr4 = msghdr->msg_name;",
                    "2511": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2512": "",
                    "2513": "\t\t\tif (!addr4) {",
                    "2514": "\t\t\t\taddr4 = net_sin(&context->remote);",
                    "2515": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_in);",
                    "2516": "\t\t\t}",
                    "2517": "",
                    "2518": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2519": "\t\t\t */",
                    "2520": "\t\t\tdst_addr = (const struct net_sockaddr *)addr4;",
                    "2521": "\t\t}",
                    "2522": "",
                    "2523": "\t\t/* Get the destination address from the mapped IPv6 address */",
                    "2524": "\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) &&",
                    "2525": "\t\t    addr4->sin_family == NET_AF_INET6 &&",
                    "2526": "\t\t    net_ipv6_addr_is_v4_mapped(&net_sin6(dst_addr)->sin6_addr)) {",
                    "2527": "\t\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;",
                    "2528": "",
                    "2529": "\t\t\tmapped.sin_port = addr6->sin6_port;",
                    "2530": "\t\t\tmapped.sin_family = NET_AF_INET;",
                    "2531": "\t\t\tnet_ipaddr_copy(&mapped.sin_addr,",
                    "2532": "\t\t\t\t\t(struct net_in_addr *)(&addr6->sin6_addr.s6_addr32[3]));",
                    "2533": "\t\t\taddr4 = &mapped;",
                    "2534": "",
                    "2535": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2536": "\t\t\t */",
                    "2537": "\t\t\tdst_addr = (const struct net_sockaddr *)addr4;",
                    "2538": "\t\t}",
                    "2539": "",
                    "2540": "\t\tif (addrlen < sizeof(struct net_sockaddr_in)) {",
                    "2541": "\t\t\treturn -EINVAL;",
                    "2542": "\t\t}",
                    "2543": "",
                    "2544": "\t\tif (!addr4->sin_addr.s_addr) {",
                    "2545": "\t\t\treturn -EDESTADDRREQ;",
                    "2546": "\t\t}",
                    "2547": "",
                    "2548": "\t\tif (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2549": "\t\t    net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2550": "\t\t\tif (net_ipv4_is_addr_mcast(&addr4->sin_addr) &&",
                    "2551": "\t\t\t    COND_CODE_1(CONFIG_NET_IPV4,",
                    "2552": "\t\t\t\t\t(context->options.ipv4_mcast_ifindex > 0), (false))) {",
                    "2553": "\t\t\t\tIF_ENABLED(CONFIG_NET_IPV4,",
                    "2554": "\t\t\t\t\t   (iface = net_if_get_by_index(",
                    "2555": "\t\t\t\t\t\t   context->options.ipv4_mcast_ifindex)));",
                    "2556": "\t\t\t}",
                    "2557": "\t\t}",
                    "2558": "",
                    "2559": "\t\t/* If application has not yet set the destination address",
                    "2560": "\t\t * i.e., by not calling connect(), then set the interface",
                    "2561": "\t\t * here so that the packet gets sent to the correct network",
                    "2562": "\t\t * interface. This issue can be seen if there are multiple",
                    "2563": "\t\t * network interfaces and we are trying to send data to",
                    "2564": "\t\t * second or later network interface.",
                    "2565": "\t\t */",
                    "2566": "\t\tif (iface == NULL) {",
                    "2567": "\t\t\tif (net_sin(&context->remote)->sin_addr.s_addr == 0U &&",
                    "2568": "\t\t\t    !net_context_is_bound_to_iface(context)) {",
                    "2569": "\t\t\t\tiface = net_if_ipv4_select_src_iface(&addr4->sin_addr);",
                    "2570": "\t\t\t\tnet_context_set_iface(context, iface);",
                    "2571": "\t\t\t}",
                    "2572": "\t\t}",
                    "2573": "",
                    "2574": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {",
                    "2575": "\t\tstruct net_sockaddr_ll *ll_addr = (struct net_sockaddr_ll *)dst_addr;",
                    "2576": "",
                    "2577": "\t\tif (msghdr) {",
                    "2578": "\t\t\tll_addr = msghdr->msg_name;",
                    "2579": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2580": "",
                    "2581": "\t\t\tif (!ll_addr) {",
                    "2582": "\t\t\t\tll_addr = (struct net_sockaddr_ll *)",
                    "2583": "\t\t\t\t\t\t\t(&context->remote);",
                    "2584": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_ll);",
                    "2585": "\t\t\t}",
                    "2586": "",
                    "2587": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2588": "\t\t\t */",
                    "2589": "\t\t\tdst_addr = (const struct net_sockaddr *)ll_addr;",
                    "2590": "\t\t}",
                    "2591": "",
                    "2592": "\t\tif (addrlen < sizeof(struct net_sockaddr_ll)) {",
                    "2593": "\t\t\treturn -EINVAL;",
                    "2594": "\t\t}",
                    "2595": "",
                    "2596": "\t\tiface = net_context_get_iface(context);",
                    "2597": "\t\tif (iface == NULL) {",
                    "2598": "\t\t\tif (ll_addr->sll_ifindex < 0) {",
                    "2599": "\t\t\t\treturn -EDESTADDRREQ;",
                    "2600": "\t\t\t}",
                    "2601": "",
                    "2602": "\t\t\tiface = net_if_get_by_index(ll_addr->sll_ifindex);",
                    "2603": "\t\t\tif (iface == NULL) {",
                    "2604": "\t\t\t\tNET_ERR(\"Cannot bind to interface index %d\",",
                    "2605": "\t\t\t\t\tll_addr->sll_ifindex);",
                    "2606": "\t\t\t\treturn -EDESTADDRREQ;",
                    "2607": "\t\t\t}",
                    "2608": "",
                    "2609": "\t\t\tnet_context_set_iface(context, iface);",
                    "2610": "\t\t}",
                    "2611": "",
                    "2612": "\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM) {",
                    "2613": "\t\t\tcontext->flags |= NET_CONTEXT_REMOTE_ADDR_SET;",
                    "2614": "",
                    "2615": "\t\t\t/* The user must set the protocol in send call */",
                    "2616": "",
                    "2617": "\t\t\t/* For sendmsg() call, we might have set ll_addr to",
                    "2618": "\t\t\t * point to remote addr.",
                    "2619": "\t\t\t */",
                    "2620": "\t\t\tif ((void *)&context->remote != (void *)ll_addr) {",
                    "2621": "\t\t\t\tmemcpy((struct net_sockaddr_ll *)&context->remote,",
                    "2622": "\t\t\t\t       ll_addr, sizeof(struct net_sockaddr_ll));",
                    "2623": "\t\t\t}",
                    "2624": "\t\t}",
                    "2625": "",
                    "2626": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN) {",
                    "2627": "\t\tstruct net_sockaddr_can *can_addr = (struct net_sockaddr_can *)dst_addr;",
                    "2628": "",
                    "2629": "\t\tif (msghdr) {",
                    "2630": "\t\t\tcan_addr = msghdr->msg_name;",
                    "2631": "\t\t\taddrlen = msghdr->msg_namelen;",
                    "2632": "",
                    "2633": "\t\t\tif (!can_addr) {",
                    "2634": "\t\t\t\tcan_addr = (struct net_sockaddr_can *)",
                    "2635": "\t\t\t\t\t\t\t(&context->remote);",
                    "2636": "\t\t\t\taddrlen = sizeof(struct net_sockaddr_can);",
                    "2637": "\t\t\t}",
                    "2638": "",
                    "2639": "\t\t\t/* For sendmsg(), the dst_addr is NULL so set it here.",
                    "2640": "\t\t\t */",
                    "2641": "\t\t\tdst_addr = (const struct net_sockaddr *)can_addr;",
                    "2642": "\t\t}",
                    "2643": "",
                    "2644": "\t\tif (addrlen < sizeof(struct net_sockaddr_can)) {",
                    "2645": "\t\t\treturn -EINVAL;",
                    "2646": "\t\t}",
                    "2647": "",
                    "2648": "\t\tif (can_addr->can_ifindex < 0) {",
                    "2649": "\t\t\t/* The index should have been set in bind */",
                    "2650": "\t\t\tcan_addr->can_ifindex =",
                    "2651": "\t\t\t\tnet_can_ptr(&context->local)->can_ifindex;",
                    "2652": "\t\t}",
                    "2653": "",
                    "2654": "\t\tif (can_addr->can_ifindex < 0) {",
                    "2655": "\t\t\treturn -EDESTADDRREQ;",
                    "2656": "\t\t}",
                    "2657": "",
                    "2658": "\t\tiface = net_if_get_by_index(can_addr->can_ifindex);",
                    "2659": "\t\tif (!iface) {",
                    "2660": "\t\t\tNET_ERR(\"Cannot bind to interface index %d\",",
                    "2661": "\t\t\t\tcan_addr->can_ifindex);",
                    "2662": "\t\t\treturn -EDESTADDRREQ;",
                    "2663": "\t\t}",
                    "2664": "\t} else {",
                    "2665": "\t\tNET_DBG(\"Invalid protocol family %d\", family);",
                    "2666": "\t\treturn -EINVAL;",
                    "2667": "\t}",
                    "2668": "",
                    "2669": "\tif (msghdr && len == 0) {",
                    "2670": "\t\tint i;",
                    "2671": "",
                    "2672": "\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {",
                    "2673": "\t\t\tlen += msghdr->msg_iov[i].iov_len;",
                    "2674": "\t\t}",
                    "2675": "\t}",
                    "2676": "",
                    "2677": "\tiface = net_context_get_iface(context);",
                    "2678": "\tif (iface && !net_if_is_up(iface)) {",
                    "2679": "\t\treturn -ENETDOWN;",
                    "2680": "\t}",
                    "2681": "",
                    "2682": "\tcontext->send_cb = cb;",
                    "2683": "\tcontext->user_data = user_data;",
                    "2684": "",
                    "2685": "\tif (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "2686": "\t    net_context_get_proto(context) == NET_IPPROTO_TCP &&",
                    "2687": "\t    !net_if_is_ip_offloaded(net_context_get_iface(context))) {",
                    "2688": "\t\tgoto skip_alloc;",
                    "2689": "\t}",
                    "2690": "",
                    "2691": "\tpkt = context_alloc_pkt(context, family, len, PKT_WAIT_TIME);",
                    "2692": "\tif (!pkt) {",
                    "2693": "\t\tNET_ERR(\"Failed to allocate net_pkt\");",
                    "2694": "\t\treturn -ENOBUFS;",
                    "2695": "\t}",
                    "2696": "",
                    "2697": "\ttmp_len = net_pkt_available_payload_buffer(",
                    "2698": "\t\t\t\tpkt, net_context_get_proto(context));",
                    "2699": "\tif (tmp_len < len) {",
                    "2700": "\t\tif (net_context_get_type(context) == NET_SOCK_DGRAM ||",
                    "2701": "\t\t    net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2702": "\t\t\tNET_ERR(\"Available payload buffer (%zu) is not enough for requested DGRAM (%zu)\",",
                    "2703": "\t\t\t\ttmp_len, len);",
                    "2704": "\t\t\tret = -ENOMEM;",
                    "2705": "\t\t\tgoto fail;",
                    "2706": "\t\t}",
                    "2707": "\t\tlen = tmp_len;",
                    "2708": "\t}",
                    "2709": "",
                    "2710": "\tif (IS_ENABLED(CONFIG_NET_CONTEXT_PRIORITY)) {",
                    "2711": "\t\tuint8_t priority;",
                    "2712": "",
                    "2713": "\t\tget_context_priority(context, &priority, NULL);",
                    "2714": "\t\tnet_pkt_set_priority(pkt, priority);",
                    "2715": "\t}",
                    "2716": "",
                    "2717": "\t/* If there is ancillary data in msghdr, then we need to add that",
                    "2718": "\t * to net_pkt as there is no other way to store it.",
                    "2719": "\t */",
                    "2720": "\tif (msghdr && msghdr->msg_control && msghdr->msg_controllen) {",
                    "2721": "\t\tif (IS_ENABLED(CONFIG_NET_CONTEXT_TXTIME)) {",
                    "2722": "\t\t\tint is_txtime;",
                    "2723": "",
                    "2724": "\t\t\tget_context_txtime(context, &is_txtime, NULL);",
                    "2725": "\t\t\tif (is_txtime) {",
                    "2726": "\t\t\t\tset_pkt_txtime(pkt, msghdr);",
                    "2727": "\t\t\t}",
                    "2728": "\t\t}",
                    "2729": "",
                    "2730": "\t\tset_pkt_hoplimit(pkt, msghdr);",
                    "2731": "",
                    "2732": "\t}",
                    "2733": "",
                    "2734": "skip_alloc:",
                    "2735": "\tif (IS_ENABLED(CONFIG_NET_OFFLOAD) &&",
                    "2736": "\t    net_if_is_ip_offloaded(net_context_get_iface(context))) {",
                    "2737": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2738": "\t\tif (ret < 0) {",
                    "2739": "\t\t\tgoto fail;",
                    "2740": "\t\t}",
                    "2741": "",
                    "2742": "\t\tnet_pkt_cursor_init(pkt);",
                    "2743": "",
                    "2744": "\t\tif (sendto) {",
                    "2745": "\t\t\tret = net_offload_sendto(net_context_get_iface(context),",
                    "2746": "\t\t\t\t\t\t pkt, dst_addr, addrlen, cb,",
                    "2747": "\t\t\t\t\t\t timeout, user_data);",
                    "2748": "\t\t} else {",
                    "2749": "\t\t\tret = net_offload_send(net_context_get_iface(context),",
                    "2750": "\t\t\t\t\t       pkt, cb, timeout, user_data);",
                    "2751": "\t\t}",
                    "2752": "\t} else if (((IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) ||",
                    "2753": "\t\t    (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6)) &&",
                    "2754": "\t\t   IS_ENABLED(CONFIG_NET_SOCKETS_INET_RAW) &&",
                    "2755": "\t\t   net_context_get_type(context) == NET_SOCK_RAW) {",
                    "2756": "\t\tret = context_setup_raw_ip_packet(family, pkt, buf, len, msghdr);",
                    "2757": "\t\tif (ret < 0) {",
                    "2758": "\t\t\tgoto fail;",
                    "2759": "\t\t}",
                    "2760": "",
                    "2761": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2762": "\t} else if (IS_ENABLED(CONFIG_NET_UDP) &&",
                    "2763": "\t    net_context_get_proto(context) == NET_IPPROTO_UDP) {",
                    "2764": "\t\tret = context_setup_udp_packet(context, family, pkt, buf, len, msghdr,",
                    "2765": "\t\t\t\t\t       dst_addr, addrlen);",
                    "2766": "\t\tif (ret < 0) {",
                    "2767": "\t\t\tgoto fail;",
                    "2768": "\t\t}",
                    "2769": "",
                    "2770": "\t\tcontext_finalize_packet(context, family, pkt);",
                    "2771": "",
                    "2772": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2773": "\t} else if (IS_ENABLED(CONFIG_NET_TCP) &&",
                    "2774": "\t\t   net_context_get_proto(context) == NET_IPPROTO_TCP) {",
                    "2775": "",
                    "2776": "\t\tret = net_tcp_queue(context, buf, len, msghdr);",
                    "2777": "\t\tif (ret < 0) {",
                    "2778": "\t\t\tgoto fail;",
                    "2779": "\t\t}",
                    "2780": "",
                    "2781": "\t\tlen = ret;",
                    "2782": "",
                    "2783": "\t\tret = net_tcp_send_data(context, cb, user_data);",
                    "2784": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) && family == NET_AF_PACKET) {",
                    "2785": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2786": "\t\tif (ret < 0) {",
                    "2787": "\t\t\tgoto fail;",
                    "2788": "\t\t}",
                    "2789": "",
                    "2790": "\t\tnet_pkt_cursor_init(pkt);",
                    "2791": "",
                    "2792": "\t\tstruct net_sockaddr_ll_ptr *ll_src_addr;",
                    "2793": "\t\tstruct net_sockaddr_ll *ll_dst_addr;",
                    "2794": "",
                    "2795": "\t\t/* The destination address is set in remote for this",
                    "2796": "\t\t * socket type.",
                    "2797": "\t\t */",
                    "2798": "\t\tll_dst_addr = (struct net_sockaddr_ll *)&context->remote;",
                    "2799": "\t\tll_src_addr = (struct net_sockaddr_ll_ptr *)&context->local;",
                    "2800": "",
                    "2801": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_dst(pkt),",
                    "2802": "\t\t\t\t       ll_dst_addr->sll_addr,",
                    "2803": "\t\t\t\t       sizeof(struct net_eth_addr));",
                    "2804": "\t\t(void)net_linkaddr_set(net_pkt_lladdr_src(pkt),",
                    "2805": "\t\t\t\t       ll_src_addr->sll_addr,",
                    "2806": "\t\t\t\t       sizeof(struct net_eth_addr));",
                    "2807": "",
                    "2808": "\t\tnet_pkt_set_ll_proto_type(pkt, net_ntohs(ll_dst_addr->sll_protocol));",
                    "2809": "",
                    "2810": "\t\tnet_if_try_queue_tx(net_pkt_iface(pkt), pkt, timeout);",
                    "2811": "\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == NET_AF_CAN &&",
                    "2812": "\t\t   net_context_get_proto(context) == NET_CAN_RAW) {",
                    "2813": "\t\tret = context_write_data(pkt, buf, len, msghdr);",
                    "2814": "\t\tif (ret < 0) {",
                    "2815": "\t\t\tgoto fail;",
                    "2816": "\t\t}",
                    "2817": "",
                    "2818": "\t\tnet_pkt_cursor_init(pkt);",
                    "2819": "",
                    "2820": "\t\tret = net_try_send_data(pkt, timeout);",
                    "2821": "\t} else {",
                    "2822": "\t\tNET_DBG(\"Unknown protocol while sending packet: %d\",",
                    "2823": "\t\tnet_context_get_proto(context));",
                    "2824": "\t\tret = -EPROTONOSUPPORT;",
                    "2825": "\t}",
                    "2826": "",
                    "2827": "\tif (ret < 0) {",
                    "2828": "\t\tgoto fail;",
                    "2829": "\t}",
                    "2830": "",
                    "2831": "\treturn len;",
                    "2832": "fail:",
                    "2833": "\tif (pkt != NULL) {",
                    "2834": "\t\tnet_pkt_unref(pkt);",
                    "2835": "\t}",
                    "2836": "",
                    "2837": "\treturn ret;",
                    "2838": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_pkt_hoplimit": {
            "name": "set_pkt_hoplimit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2345,
            "function_content": [
                "/* This function is meant to be temporary: once all moved to new\n* API, it will be up to net_send_data() to finalize the packet.\n*/\nstatic void set_pkt_hoplimit(struct net_pkt *pkt, const struct net_msghdr *msg_hdr)\n{\n\tstruct net_cmsghdr *cmsg;\n\tconst struct net_sockaddr_in6 *addr6 = NULL;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) && IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\taddr6 = msg_hdr->msg_name;\n\t}\n\n\tfor (cmsg = NET_CMSG_FIRSTHDR(msg_hdr); cmsg != NULL;\n\t     cmsg = NET_CMSG_NXTHDR(msg_hdr, cmsg)) {\n\t\tif (net_pkt_family(pkt) == NET_AF_INET6) {\n\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&\n\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {\n\t\t\t\tnet_pkt_set_ipv6_hop_limit(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (net_pkt_family(pkt) == NET_AF_INET) {\n\t\t\tif (addr6  == NULL ||\n\t\t\t    (addr6 != NULL && !net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr))) {\n\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IP &&\n\t\t\t\t    cmsg->cmsg_type == ZSOCK_IP_TTL) {\n\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (addr6 != NULL &&\n\t\t\t\t   net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {\n\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&\n\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&\n\t\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {\n\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
                {
                    "2345": "static void set_pkt_hoplimit(struct net_pkt *pkt, const struct net_msghdr *msg_hdr)",
                    "2346": "{",
                    "2347": "\tstruct net_cmsghdr *cmsg;",
                    "2348": "\tconst struct net_sockaddr_in6 *addr6 = NULL;",
                    "2349": "",
                    "2350": "\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6) && IS_ENABLED(CONFIG_NET_IPV6)) {",
                    "2351": "\t\taddr6 = msg_hdr->msg_name;",
                    "2352": "\t}",
                    "2353": "",
                    "2354": "\tfor (cmsg = NET_CMSG_FIRSTHDR(msg_hdr); cmsg != NULL;",
                    "2355": "\t     cmsg = NET_CMSG_NXTHDR(msg_hdr, cmsg)) {",
                    "2356": "\t\tif (net_pkt_family(pkt) == NET_AF_INET6) {",
                    "2357": "\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2358": "\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&",
                    "2359": "\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {",
                    "2360": "\t\t\t\tnet_pkt_set_ipv6_hop_limit(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2361": "\t\t\t\tbreak;",
                    "2362": "\t\t\t}",
                    "2363": "\t\t} else if (net_pkt_family(pkt) == NET_AF_INET) {",
                    "2364": "\t\t\tif (addr6  == NULL ||",
                    "2365": "\t\t\t    (addr6 != NULL && !net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr))) {",
                    "2366": "\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2367": "\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IP &&",
                    "2368": "\t\t\t\t    cmsg->cmsg_type == ZSOCK_IP_TTL) {",
                    "2369": "\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2370": "\t\t\t\t\tbreak;",
                    "2371": "\t\t\t\t}",
                    "2372": "\t\t\t} else if (addr6 != NULL &&",
                    "2373": "\t\t\t\t   net_ipv6_addr_is_v4_mapped(&addr6->sin6_addr)) {",
                    "2374": "\t\t\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(int)) &&",
                    "2375": "\t\t\t\t    cmsg->cmsg_level == NET_IPPROTO_IPV6 &&",
                    "2376": "\t\t\t\t    cmsg->cmsg_type == ZSOCK_IPV6_HOPLIMIT) {",
                    "2377": "\t\t\t\t\tnet_pkt_set_ipv4_ttl(pkt, *(uint8_t *)NET_CMSG_DATA(cmsg));",
                    "2378": "\t\t\t\t\tbreak;",
                    "2379": "\t\t\t\t}",
                    "2380": "\t\t\t}",
                    "2381": "\t\t}",
                    "2382": "\t}",
                    "2383": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "set_pkt_txtime": {
            "name": "set_pkt_txtime",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2330,
            "function_content": [
                "/* This function is meant to be temporary: once all moved to new\n* API, it will be up to net_send_data() to finalize the packet.\n*/\nstatic void set_pkt_txtime(struct net_pkt *pkt, const struct net_msghdr *msghdr)\n{\n\tstruct net_cmsghdr *cmsg;\n\n\tfor (cmsg = NET_CMSG_FIRSTHDR(msghdr); cmsg != NULL;\n\t     cmsg = NET_CMSG_NXTHDR(msghdr, cmsg)) {\n\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(uint64_t)) &&\n\t\t    cmsg->cmsg_level == ZSOCK_SOL_SOCKET &&\n\t\t    cmsg->cmsg_type == ZSOCK_SCM_TXTIME) {\n\t\t\tnet_pkt_set_timestamp_ns(pkt, *(net_time_t *)NET_CMSG_DATA(cmsg));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
                {
                    "2330": "static void set_pkt_txtime(struct net_pkt *pkt, const struct net_msghdr *msghdr)",
                    "2331": "{",
                    "2332": "\tstruct net_cmsghdr *cmsg;",
                    "2333": "",
                    "2334": "\tfor (cmsg = NET_CMSG_FIRSTHDR(msghdr); cmsg != NULL;",
                    "2335": "\t     cmsg = NET_CMSG_NXTHDR(msghdr, cmsg)) {",
                    "2336": "\t\tif (cmsg->cmsg_len == NET_CMSG_LEN(sizeof(uint64_t)) &&",
                    "2337": "\t\t    cmsg->cmsg_level == ZSOCK_SOL_SOCKET &&",
                    "2338": "\t\t    cmsg->cmsg_type == ZSOCK_SCM_TXTIME) {",
                    "2339": "\t\t\tnet_pkt_set_timestamp_ns(pkt, *(net_time_t *)NET_CMSG_DATA(cmsg));",
                    "2340": "\t\t\tbreak;",
                    "2341": "\t\t}",
                    "2342": "\t}",
                    "2343": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "context_setup_raw_ip_packet": {
            "name": "context_setup_raw_ip_packet",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2223,
            "function_content": [
                "/* If buf is not NULL, then use it. Otherwise read the data to be written\n* to net_pkt from msghdr.\n*/\nstatic int context_setup_raw_ip_packet(net_sa_family_t family,\n\t\t\t\t       struct net_pkt *pkt,\n\t\t\t\t       const void *buf,\n\t\t\t\t       size_t len,\n\t\t\t\t       const struct net_msghdr *msg)\n{\n\tint ret;\n\n\tret = context_write_data(pkt, buf, len, msg);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (family == NET_AF_INET) {\n\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,\n\t\t\t\t\t\t      struct net_ipv4_hdr);\n\t\tstruct net_ipv4_hdr *ipv4_hdr;\n\t\tuint8_t hdr_len;\n\n\t\tnet_pkt_cursor_init(pkt);\n\t\tnet_pkt_set_overwrite(pkt, true);\n\n\t\tipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);\n\t\tif (ipv4_hdr == NULL) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));\n\n\t\thdr_len = (ipv4_hdr->vhl & 0x0F) * 4;\n\t\tif (hdr_len > sizeof(struct net_ipv4_hdr)) {\n\t\t\tnet_pkt_set_ipv4_opts_len(\n\t\t\t\tpkt, hdr_len - sizeof(struct net_ipv4_hdr));\n\t\t}\n\n\t\tif (net_if_need_calc_tx_checksum(net_pkt_iface(pkt),\n\t\t\t\t\t\t NET_IF_CHECKSUM_IPV4_HEADER)) {\n\t\t\tipv4_hdr->chksum = 0;\n\t\t\tipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);\n\t\t\tnet_pkt_set_data(pkt, &ipv4_access);\n\t\t}\n\n\t\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IP);\n\t} else {\n\t\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));\n\t\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IPV6);\n\t}\n\n\treturn 0;\n}\n",
                {
                    "2223": "static int context_setup_raw_ip_packet(net_sa_family_t family,",
                    "2224": "\t\t\t\t       struct net_pkt *pkt,",
                    "2225": "\t\t\t\t       const void *buf,",
                    "2226": "\t\t\t\t       size_t len,",
                    "2227": "\t\t\t\t       const struct net_msghdr *msg)",
                    "2228": "{",
                    "2229": "\tint ret;",
                    "2230": "",
                    "2231": "\tret = context_write_data(pkt, buf, len, msg);",
                    "2232": "\tif (ret < 0) {",
                    "2233": "\t\treturn ret;",
                    "2234": "\t}",
                    "2235": "",
                    "2236": "\tif (family == NET_AF_INET) {",
                    "2237": "\t\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,",
                    "2238": "\t\t\t\t\t\t      struct net_ipv4_hdr);",
                    "2239": "\t\tstruct net_ipv4_hdr *ipv4_hdr;",
                    "2240": "\t\tuint8_t hdr_len;",
                    "2241": "",
                    "2242": "\t\tnet_pkt_cursor_init(pkt);",
                    "2243": "\t\tnet_pkt_set_overwrite(pkt, true);",
                    "2244": "",
                    "2245": "\t\tipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);",
                    "2246": "\t\tif (ipv4_hdr == NULL) {",
                    "2247": "\t\t\treturn -ENOBUFS;",
                    "2248": "\t\t}",
                    "2249": "",
                    "2250": "\t\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));",
                    "2251": "",
                    "2252": "\t\thdr_len = (ipv4_hdr->vhl & 0x0F) * 4;",
                    "2253": "\t\tif (hdr_len > sizeof(struct net_ipv4_hdr)) {",
                    "2254": "\t\t\tnet_pkt_set_ipv4_opts_len(",
                    "2255": "\t\t\t\tpkt, hdr_len - sizeof(struct net_ipv4_hdr));",
                    "2256": "\t\t}",
                    "2257": "",
                    "2258": "\t\tif (net_if_need_calc_tx_checksum(net_pkt_iface(pkt),",
                    "2259": "\t\t\t\t\t\t NET_IF_CHECKSUM_IPV4_HEADER)) {",
                    "2260": "\t\t\tipv4_hdr->chksum = 0;",
                    "2261": "\t\t\tipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);",
                    "2262": "\t\t\tnet_pkt_set_data(pkt, &ipv4_access);",
                    "2263": "\t\t}",
                    "2264": "",
                    "2265": "\t\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IP);",
                    "2266": "\t} else {",
                    "2267": "\t\tnet_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));",
                    "2268": "\t\tnet_pkt_set_ll_proto_type(pkt, NET_ETH_PTYPE_IPV6);",
                    "2269": "\t}",
                    "2270": "",
                    "2271": "\treturn 0;",
                    "2272": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "context_setup_udp_packet": {
            "name": "context_setup_udp_packet",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2160,
            "function_content": [
                "/* If buf is not NULL, then use it. Otherwise read the data to be written\n* to net_pkt from msghdr.\n*/\nstatic int context_setup_udp_packet(struct net_context *context,\n\t\t\t\t    net_sa_family_t family,\n\t\t\t\t    struct net_pkt *pkt,\n\t\t\t\t    const void *buf,\n\t\t\t\t    size_t len,\n\t\t\t\t    const struct net_msghdr *msg,\n\t\t\t\t    const struct net_sockaddr *dst_addr,\n\t\t\t\t    net_socklen_t addrlen)\n{\n\tint ret = -EINVAL;\n\tuint16_t dst_port = 0U;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;\n\n\t\tdst_port = addr6->sin6_port;\n\n\t\tret = net_context_create_ipv6_new(context, pkt,\n\t\t\t\t\t\t  NULL, &addr6->sin6_addr);\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)dst_addr;\n\n\t\tdst_port = addr4->sin_port;\n\n\t\tret = net_context_create_ipv4_new(context, pkt,\n\t\t\t\t\t\t  NULL, &addr4->sin_addr);\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = bind_default(context);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tret = net_udp_create(pkt,\n\t\t\t     net_sin((struct net_sockaddr *)\n\t\t\t\t     &context->local)->sin_port,\n\t\t\t     dst_port);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tret = context_write_data(pkt, buf, len, msg);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n#if defined(CONFIG_NET_CONTEXT_TIMESTAMPING)\n\tif (context->options.timestamping & ZSOCK_SOF_TIMESTAMPING_TX_HARDWARE) {\n\t\tnet_pkt_set_tx_timestamping(pkt, true);\n\t}\n\n\tif (context->options.timestamping & ZSOCK_SOF_TIMESTAMPING_RX_HARDWARE) {\n\t\tnet_pkt_set_rx_timestamping(pkt, true);\n\t}\n#endif\n\n\treturn 0;\n}\n",
                {
                    "2160": "static int context_setup_udp_packet(struct net_context *context,",
                    "2161": "\t\t\t\t    net_sa_family_t family,",
                    "2162": "\t\t\t\t    struct net_pkt *pkt,",
                    "2163": "\t\t\t\t    const void *buf,",
                    "2164": "\t\t\t\t    size_t len,",
                    "2165": "\t\t\t\t    const struct net_msghdr *msg,",
                    "2166": "\t\t\t\t    const struct net_sockaddr *dst_addr,",
                    "2167": "\t\t\t\t    net_socklen_t addrlen)",
                    "2168": "{",
                    "2169": "\tint ret = -EINVAL;",
                    "2170": "\tuint16_t dst_port = 0U;",
                    "2171": "",
                    "2172": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "2173": "\t\tstruct net_sockaddr_in6 *addr6 = (struct net_sockaddr_in6 *)dst_addr;",
                    "2174": "",
                    "2175": "\t\tdst_port = addr6->sin6_port;",
                    "2176": "",
                    "2177": "\t\tret = net_context_create_ipv6_new(context, pkt,",
                    "2178": "\t\t\t\t\t\t  NULL, &addr6->sin6_addr);",
                    "2179": "\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "2180": "\t\tstruct net_sockaddr_in *addr4 = (struct net_sockaddr_in *)dst_addr;",
                    "2181": "",
                    "2182": "\t\tdst_port = addr4->sin_port;",
                    "2183": "",
                    "2184": "\t\tret = net_context_create_ipv4_new(context, pkt,",
                    "2185": "\t\t\t\t\t\t  NULL, &addr4->sin_addr);",
                    "2186": "\t}",
                    "2187": "",
                    "2188": "\tif (ret < 0) {",
                    "2189": "\t\treturn ret;",
                    "2190": "\t}",
                    "2191": "",
                    "2192": "\tret = bind_default(context);",
                    "2193": "\tif (ret) {",
                    "2194": "\t\treturn ret;",
                    "2195": "\t}",
                    "2196": "",
                    "2197": "\tret = net_udp_create(pkt,",
                    "2198": "\t\t\t     net_sin((struct net_sockaddr *)",
                    "2199": "\t\t\t\t     &context->local)->sin_port,",
                    "2200": "\t\t\t     dst_port);",
                    "2201": "\tif (ret) {",
                    "2202": "\t\treturn ret;",
                    "2203": "\t}",
                    "2204": "",
                    "2205": "\tret = context_write_data(pkt, buf, len, msg);",
                    "2206": "\tif (ret) {",
                    "2207": "\t\treturn ret;",
                    "2208": "\t}",
                    "2209": "",
                    "2210": "#if defined(CONFIG_NET_CONTEXT_TIMESTAMPING)",
                    "2211": "\tif (context->options.timestamping & ZSOCK_SOF_TIMESTAMPING_TX_HARDWARE) {",
                    "2212": "\t\tnet_pkt_set_tx_timestamping(pkt, true);",
                    "2213": "\t}",
                    "2214": "",
                    "2215": "\tif (context->options.timestamping & ZSOCK_SOF_TIMESTAMPING_RX_HARDWARE) {",
                    "2216": "\t\tnet_pkt_set_rx_timestamping(pkt, true);",
                    "2217": "\t}",
                    "2218": "#endif",
                    "2219": "",
                    "2220": "\treturn 0;",
                    "2221": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "context_write_data": {
            "name": "context_write_data",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 2131,
            "function_content": [
                "/* If buf is not NULL, then use it. Otherwise read the data to be written\n* to net_pkt from msghdr.\n*/\nstatic int context_write_data(struct net_pkt *pkt, const void *buf,\n\t\t\t      int buf_len, const struct net_msghdr *msghdr)\n{\n\tint ret = 0;\n\n\tif (msghdr) {\n\t\tint i;\n\n\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {\n\t\t\tint len = MIN(msghdr->msg_iov[i].iov_len, buf_len);\n\n\t\t\tret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,\n\t\t\t\t\t    len);\n\t\t\tif (ret < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbuf_len -= len;\n\t\t\tif (buf_len == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = net_pkt_write(pkt, buf, buf_len);\n\t}\n\n\treturn ret;\n}\n",
                {
                    "2131": "static int context_write_data(struct net_pkt *pkt, const void *buf,",
                    "2132": "\t\t\t      int buf_len, const struct net_msghdr *msghdr)",
                    "2133": "{",
                    "2134": "\tint ret = 0;",
                    "2135": "",
                    "2136": "\tif (msghdr) {",
                    "2137": "\t\tint i;",
                    "2138": "",
                    "2139": "\t\tfor (i = 0; i < msghdr->msg_iovlen; i++) {",
                    "2140": "\t\t\tint len = MIN(msghdr->msg_iov[i].iov_len, buf_len);",
                    "2141": "",
                    "2142": "\t\t\tret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,",
                    "2143": "\t\t\t\t\t    len);",
                    "2144": "\t\t\tif (ret < 0) {",
                    "2145": "\t\t\t\tbreak;",
                    "2146": "\t\t\t}",
                    "2147": "",
                    "2148": "\t\t\tbuf_len -= len;",
                    "2149": "\t\t\tif (buf_len == 0) {",
                    "2150": "\t\t\t\tbreak;",
                    "2151": "\t\t\t}",
                    "2152": "\t\t}",
                    "2153": "\t} else {",
                    "2154": "\t\tret = net_pkt_write(pkt, buf, buf_len);",
                    "2155": "\t}",
                    "2156": "",
                    "2157": "\treturn ret;",
                    "2158": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_context_unicast_hop_limit": {
            "name": "get_context_unicast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1864,
            "function_content": [
                "ret = -EINVAL; /* Not IPv4 or IPv6 */\nstatic int get_context_unicast_hop_limit(struct net_context *context,\n\t\t\t\t\t void *value, uint32_t *len)\n{\n#if defined(CONFIG_NET_IPV6)\n\t*((int *)value) = context->ipv6_hop_limit;\n\n\tif (len) {\n\t\t*len = sizeof(int);\n\t}\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "1864": "static int get_context_unicast_hop_limit(struct net_context *context,",
                    "1865": "\t\t\t\t\t void *value, uint32_t *len)",
                    "1866": "{",
                    "1867": "#if defined(CONFIG_NET_IPV6)",
                    "1868": "\t*((int *)value) = context->ipv6_hop_limit;",
                    "1869": "",
                    "1870": "\tif (len) {",
                    "1871": "\t\t*len = sizeof(int);",
                    "1872": "\t}",
                    "1873": "",
                    "1874": "\treturn 0;",
                    "1875": "#else",
                    "1876": "\tARG_UNUSED(context);",
                    "1877": "\tARG_UNUSED(value);",
                    "1878": "\tARG_UNUSED(len);",
                    "1879": "",
                    "1880": "\treturn -ENOTSUP;",
                    "1881": "#endif",
                    "1882": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_context_mcast_hop_limit": {
            "name": "get_context_mcast_hop_limit",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_context.c",
            "location_line": 1844,
            "function_content": [
                "ret = -EINVAL; /* Not IPv4 or IPv6 */\nstatic int get_context_mcast_hop_limit(struct net_context *context,\n\t\t\t\t       void *value, uint32_t *len)\n{\n#if defined(CONFIG_NET_IPV6)\n\t*((int *)value) = context->ipv6_mcast_hop_limit;\n\n\tif (len) {\n\t\t*len = sizeof(int);\n\t}\n\n\treturn 0;\n#else\n\tARG_UNUSED(context);\n\tARG_UNUSED(value);\n\tARG_UNUSED(len);\n\n\treturn -ENOTSUP;\n#endif\n}\n",
                {
                    "1844": "static int get_context_mcast_hop_limit(struct net_context *context,",
                    "1845": "\t\t\t\t       void *value, uint32_t *len)",
                    "1846": "{",
                    "1847": "#if defined(CONFIG_NET_IPV6)",
                    "1848": "\t*((int *)value) = context->ipv6_mcast_hop_limit;",
                    "1849": "",
                    "1850": "\tif (len) {",
                    "1851": "\t\t*len = sizeof(int);",
                    "1852": "\t}",
                    "1853": "",
                    "1854": "\treturn 0;",
                    "1855": "#else",
                    "1856": "\tARG_UNUSED(context);",
                    "1857": "\tARG_UNUSED(value);",
                    "1858": "\tARG_UNUSED(len);",
                    "1859": "",
                    "1860": "\treturn -ENOTSUP;",
                    "1861": "#endif",
                    "1862": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "get_ifaddr": {
            "name": "get_ifaddr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 5248,
            "function_content": [
                "#endif /* !CONFIG_NET_NATIVE_IPV4 */\nstatic struct net_if_addr *get_ifaddr(struct net_if *iface,\n\t\t\t\t      net_sa_family_t family,\n\t\t\t\t      const void *addr,\n\t\t\t\t      unsigned int *mcast_addr_count)\n{\n\tstruct net_if_addr *ifaddr = NULL;\n\n\tnet_if_lock(iface);\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\tstruct net_if_ipv6 *ipv6 =\n\t\t\tCOND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));\n\t\tstruct net_in6_addr maddr;\n\t\tunsigned int maddr_count = 0;\n\t\tint found = -1;\n\n\t\tif (ipv6 == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tnet_ipv6_addr_create_solicited_node((struct net_in6_addr *)addr,\n\t\t\t\t\t\t    &maddr);\n\n\t\tARRAY_FOR_EACH(ipv6->unicast, i) {\n\t\t\tstruct net_in6_addr unicast_maddr;\n\n\t\t\tif (!ipv6->unicast[i].is_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Count how many times this solicited-node multicast address is identical\n\t\t\t * for all the used unicast addresses\n\t\t\t */\n\t\t\tnet_ipv6_addr_create_solicited_node(\n\t\t\t\t&ipv6->unicast[i].address.in6_addr,\n\t\t\t\t&unicast_maddr);\n\n\t\t\tif (net_ipv6_addr_cmp(&maddr, &unicast_maddr)) {\n\t\t\t\tmaddr_count++;\n\t\t\t}\n\n\t\t\tif (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr, addr)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = i;\n\t\t}\n\n\t\tif (found >= 0) {\n\t\t\tifaddr = &ipv6->unicast[found];\n\n\t\t\tif (mcast_addr_count != NULL) {\n\t\t\t\t*mcast_addr_count = maddr_count;\n\t\t\t}\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\tstruct net_if_ipv4 *ipv4 =\n\t\t\tCOND_CODE_1(CONFIG_NET_IPV4, (iface->config.ip.ipv4), (NULL));\n\n\t\tif (ipv4 == NULL) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tARRAY_FOR_EACH(ipv4->unicast, i) {\n\t\t\tif (!ipv4->unicast[i].ipv4.is_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!net_ipv4_addr_cmp(&ipv4->unicast[i].ipv4.address.in_addr,\n\t\t\t\t\t       addr)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tifaddr = &ipv4->unicast[i].ipv4;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tnet_if_unlock(iface);\n\n\treturn ifaddr;\n}\n",
                {
                    "5248": "static struct net_if_addr *get_ifaddr(struct net_if *iface,",
                    "5249": "\t\t\t\t      net_sa_family_t family,",
                    "5250": "\t\t\t\t      const void *addr,",
                    "5251": "\t\t\t\t      unsigned int *mcast_addr_count)",
                    "5252": "{",
                    "5253": "\tstruct net_if_addr *ifaddr = NULL;",
                    "5254": "",
                    "5255": "\tnet_if_lock(iface);",
                    "5256": "",
                    "5257": "\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "5258": "\t\tstruct net_if_ipv6 *ipv6 =",
                    "5259": "\t\t\tCOND_CODE_1(CONFIG_NET_IPV6, (iface->config.ip.ipv6), (NULL));",
                    "5260": "\t\tstruct net_in6_addr maddr;",
                    "5261": "\t\tunsigned int maddr_count = 0;",
                    "5262": "\t\tint found = -1;",
                    "5263": "",
                    "5264": "\t\tif (ipv6 == NULL) {",
                    "5265": "\t\t\tgoto out;",
                    "5266": "\t\t}",
                    "5267": "",
                    "5268": "\t\tnet_ipv6_addr_create_solicited_node((struct net_in6_addr *)addr,",
                    "5269": "\t\t\t\t\t\t    &maddr);",
                    "5270": "",
                    "5271": "\t\tARRAY_FOR_EACH(ipv6->unicast, i) {",
                    "5272": "\t\t\tstruct net_in6_addr unicast_maddr;",
                    "5273": "",
                    "5274": "\t\t\tif (!ipv6->unicast[i].is_used) {",
                    "5275": "\t\t\t\tcontinue;",
                    "5276": "\t\t\t}",
                    "5277": "",
                    "5278": "\t\t\t/* Count how many times this solicited-node multicast address is identical",
                    "5279": "\t\t\t * for all the used unicast addresses",
                    "5280": "\t\t\t */",
                    "5281": "\t\t\tnet_ipv6_addr_create_solicited_node(",
                    "5282": "\t\t\t\t&ipv6->unicast[i].address.in6_addr,",
                    "5283": "\t\t\t\t&unicast_maddr);",
                    "5284": "",
                    "5285": "\t\t\tif (net_ipv6_addr_cmp(&maddr, &unicast_maddr)) {",
                    "5286": "\t\t\t\tmaddr_count++;",
                    "5287": "\t\t\t}",
                    "5288": "",
                    "5289": "\t\t\tif (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr, addr)) {",
                    "5290": "\t\t\t\tcontinue;",
                    "5291": "\t\t\t}",
                    "5292": "",
                    "5293": "\t\t\tfound = i;",
                    "5294": "\t\t}",
                    "5295": "",
                    "5296": "\t\tif (found >= 0) {",
                    "5297": "\t\t\tifaddr = &ipv6->unicast[found];",
                    "5298": "",
                    "5299": "\t\t\tif (mcast_addr_count != NULL) {",
                    "5300": "\t\t\t\t*mcast_addr_count = maddr_count;",
                    "5301": "\t\t\t}",
                    "5302": "\t\t}",
                    "5303": "",
                    "5304": "\t\tgoto out;",
                    "5305": "\t}",
                    "5306": "",
                    "5307": "\tif (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "5308": "\t\tstruct net_if_ipv4 *ipv4 =",
                    "5309": "\t\t\tCOND_CODE_1(CONFIG_NET_IPV4, (iface->config.ip.ipv4), (NULL));",
                    "5310": "",
                    "5311": "\t\tif (ipv4 == NULL) {",
                    "5312": "\t\t\tgoto out;",
                    "5313": "\t\t}",
                    "5314": "",
                    "5315": "\t\tARRAY_FOR_EACH(ipv4->unicast, i) {",
                    "5316": "\t\t\tif (!ipv4->unicast[i].ipv4.is_used) {",
                    "5317": "\t\t\t\tcontinue;",
                    "5318": "\t\t\t}",
                    "5319": "",
                    "5320": "\t\t\tif (!net_ipv4_addr_cmp(&ipv4->unicast[i].ipv4.address.in_addr,",
                    "5321": "\t\t\t\t\t       addr)) {",
                    "5322": "\t\t\t\tcontinue;",
                    "5323": "\t\t\t}",
                    "5324": "",
                    "5325": "\t\t\tifaddr = &ipv4->unicast[i].ipv4;",
                    "5326": "",
                    "5327": "\t\t\tgoto out;",
                    "5328": "\t\t}",
                    "5329": "\t}",
                    "5330": "",
                    "5331": "out:",
                    "5332": "\tnet_if_unlock(iface);",
                    "5333": "",
                    "5334": "\treturn ifaddr;",
                    "5335": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "iface_router_add": {
            "name": "iface_router_add",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 850,
            "function_content": [
                "/* We have to loop on all active routers as their\n* lifetime differ from each other.\n*/\nstatic struct net_if_router *iface_router_add(struct net_if *iface,\n\t\t\t\t\t      uint8_t family, const void *addr,\n\t\t\t\t\t      bool is_default,\n\t\t\t\t\t      uint16_t lifetime)\n{\n\tstruct net_if_router *router = NULL;\n\tint i;\n\n\tk_mutex_lock(&lock, K_FOREVER);\n\n\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {\n\t\tif (routers[i].is_used) {\n\t\t\tcontinue;\n\t\t}\n\n\t\trouters[i].is_used = true;\n\t\trouters[i].iface = iface;\n\t\trouters[i].address.family = family;\n\n\t\tif (lifetime) {\n\t\t\trouters[i].is_default = true;\n\t\t\trouters[i].is_infinite = false;\n\t\t\trouters[i].lifetime = lifetime;\n\t\t\trouters[i].life_start = k_uptime_get_32();\n\n\t\t\tsys_slist_append(&active_router_timers,\n\t\t\t\t\t &routers[i].node);\n\n\t\t\tiface_router_update_timer(routers[i].life_start);\n\t\t} else {\n\t\t\trouters[i].is_default = false;\n\t\t\trouters[i].is_infinite = true;\n\t\t\trouters[i].lifetime = 0;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {\n\t\t\tmemcpy(net_if_router_ipv6(&routers[i]), addr,\n\t\t\t       sizeof(struct net_in6_addr));\n\t\t\tnet_mgmt_event_notify_with_info(\n\t\t\t\t\tNET_EVENT_IPV6_ROUTER_ADD, iface,\n\t\t\t\t\t&routers[i].address.in6_addr,\n\t\t\t\t\tsizeof(struct net_in6_addr));\n\n\t\t\tNET_DBG(\"interface %p router %s lifetime %u default %d \"\n\t\t\t\t\"added\", iface,\n\t\t\t\tnet_sprint_ipv6_addr(addr),\n\t\t\t\tlifetime, routers[i].is_default);\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {\n\t\t\tmemcpy(net_if_router_ipv4(&routers[i]), addr,\n\t\t\t       sizeof(struct net_in_addr));\n\t\t\trouters[i].is_default = is_default;\n\n\t\t\tnet_mgmt_event_notify_with_info(\n\t\t\t\t\tNET_EVENT_IPV4_ROUTER_ADD, iface,\n\t\t\t\t\t&routers[i].address.in_addr,\n\t\t\t\t\tsizeof(struct net_in_addr));\n\n\t\t\tNET_DBG(\"interface %p router %s lifetime %u default %d \"\n\t\t\t\t\"added\", iface,\n\t\t\t\tnet_sprint_ipv4_addr((struct net_in_addr *)addr),\n\t\t\t\tlifetime, is_default);\n\t\t}\n\n\t\trouter = &routers[i];\n\t\tgoto out;\n\t}\n\nout:\n\tk_mutex_unlock(&lock);\n\n\treturn router;\n}\n",
                {
                    "850": "static struct net_if_router *iface_router_add(struct net_if *iface,",
                    "851": "\t\t\t\t\t      uint8_t family, const void *addr,",
                    "852": "\t\t\t\t\t      bool is_default,",
                    "853": "\t\t\t\t\t      uint16_t lifetime)",
                    "854": "{",
                    "855": "\tstruct net_if_router *router = NULL;",
                    "856": "\tint i;",
                    "857": "",
                    "858": "\tk_mutex_lock(&lock, K_FOREVER);",
                    "859": "",
                    "860": "\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {",
                    "861": "\t\tif (routers[i].is_used) {",
                    "862": "\t\t\tcontinue;",
                    "863": "\t\t}",
                    "864": "",
                    "865": "\t\trouters[i].is_used = true;",
                    "866": "\t\trouters[i].iface = iface;",
                    "867": "\t\trouters[i].address.family = family;",
                    "868": "",
                    "869": "\t\tif (lifetime) {",
                    "870": "\t\t\trouters[i].is_default = true;",
                    "871": "\t\t\trouters[i].is_infinite = false;",
                    "872": "\t\t\trouters[i].lifetime = lifetime;",
                    "873": "\t\t\trouters[i].life_start = k_uptime_get_32();",
                    "874": "",
                    "875": "\t\t\tsys_slist_append(&active_router_timers,",
                    "876": "\t\t\t\t\t &routers[i].node);",
                    "877": "",
                    "878": "\t\t\tiface_router_update_timer(routers[i].life_start);",
                    "879": "\t\t} else {",
                    "880": "\t\t\trouters[i].is_default = false;",
                    "881": "\t\t\trouters[i].is_infinite = true;",
                    "882": "\t\t\trouters[i].lifetime = 0;",
                    "883": "\t\t}",
                    "884": "",
                    "885": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6) {",
                    "886": "\t\t\tmemcpy(net_if_router_ipv6(&routers[i]), addr,",
                    "887": "\t\t\t       sizeof(struct net_in6_addr));",
                    "888": "\t\t\tnet_mgmt_event_notify_with_info(",
                    "889": "\t\t\t\t\tNET_EVENT_IPV6_ROUTER_ADD, iface,",
                    "890": "\t\t\t\t\t&routers[i].address.in6_addr,",
                    "891": "\t\t\t\t\tsizeof(struct net_in6_addr));",
                    "892": "",
                    "893": "\t\t\tNET_DBG(\"interface %p router %s lifetime %u default %d \"",
                    "894": "\t\t\t\t\"added\", iface,",
                    "895": "\t\t\t\tnet_sprint_ipv6_addr(addr),",
                    "896": "\t\t\t\tlifetime, routers[i].is_default);",
                    "897": "\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET) {",
                    "898": "\t\t\tmemcpy(net_if_router_ipv4(&routers[i]), addr,",
                    "899": "\t\t\t       sizeof(struct net_in_addr));",
                    "900": "\t\t\trouters[i].is_default = is_default;",
                    "901": "",
                    "902": "\t\t\tnet_mgmt_event_notify_with_info(",
                    "903": "\t\t\t\t\tNET_EVENT_IPV4_ROUTER_ADD, iface,",
                    "904": "\t\t\t\t\t&routers[i].address.in_addr,",
                    "905": "\t\t\t\t\tsizeof(struct net_in_addr));",
                    "906": "",
                    "907": "\t\t\tNET_DBG(\"interface %p router %s lifetime %u default %d \"",
                    "908": "\t\t\t\t\"added\", iface,",
                    "909": "\t\t\t\tnet_sprint_ipv4_addr((struct net_in_addr *)addr),",
                    "910": "\t\t\t\tlifetime, is_default);",
                    "911": "\t\t}",
                    "912": "",
                    "913": "\t\trouter = &routers[i];",
                    "914": "\t\tgoto out;",
                    "915": "\t}",
                    "916": "",
                    "917": "out:",
                    "918": "\tk_mutex_unlock(&lock);",
                    "919": "",
                    "920": "\treturn router;",
                    "921": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "iface_router_lookup": {
            "name": "iface_router_lookup",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_if.c",
            "location_line": 719,
            "function_content": [
                "#endif /* CONFIG_NET_IP */\nstatic struct net_if_router *iface_router_lookup(struct net_if *iface,\n\t\t\t\t\t\t uint8_t family,\n\t\t\t\t\t\t const void *addr)\n{\n\tstruct net_if_router *router = NULL;\n\tint i;\n\n\tk_mutex_lock(&lock, K_FOREVER);\n\n\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {\n\t\tif (!routers[i].is_used ||\n\t\t    routers[i].address.family != family ||\n\t\t    routers[i].iface != iface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 &&\n\t\t     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),\n\t\t\t\t       (const struct net_in6_addr *)addr)) ||\n\t\t    (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET &&\n\t\t     net_ipv4_addr_cmp(net_if_router_ipv4(&routers[i]),\n\t\t\t\t       (const struct net_in_addr *)addr))) {\n\t\t\trouter = &routers[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tk_mutex_unlock(&lock);\n\n\treturn router;\n}\n",
                {
                    "719": "static struct net_if_router *iface_router_lookup(struct net_if *iface,",
                    "720": "\t\t\t\t\t\t uint8_t family,",
                    "721": "\t\t\t\t\t\t const void *addr)",
                    "722": "{",
                    "723": "\tstruct net_if_router *router = NULL;",
                    "724": "\tint i;",
                    "725": "",
                    "726": "\tk_mutex_lock(&lock, K_FOREVER);",
                    "727": "",
                    "728": "\tfor (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {",
                    "729": "\t\tif (!routers[i].is_used ||",
                    "730": "\t\t    routers[i].address.family != family ||",
                    "731": "\t\t    routers[i].iface != iface) {",
                    "732": "\t\t\tcontinue;",
                    "733": "\t\t}",
                    "734": "",
                    "735": "\t\tif ((IS_ENABLED(CONFIG_NET_IPV6) && family == NET_AF_INET6 &&",
                    "736": "\t\t     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),",
                    "737": "\t\t\t\t       (const struct net_in6_addr *)addr)) ||",
                    "738": "\t\t    (IS_ENABLED(CONFIG_NET_IPV4) && family == NET_AF_INET &&",
                    "739": "\t\t     net_ipv4_addr_cmp(net_if_router_ipv4(&routers[i]),",
                    "740": "\t\t\t\t       (const struct net_in_addr *)addr))) {",
                    "741": "\t\t\trouter = &routers[i];",
                    "742": "\t\t\tgoto out;",
                    "743": "\t\t}",
                    "744": "\t}",
                    "745": "",
                    "746": "out:",
                    "747": "\tk_mutex_unlock(&lock);",
                    "748": "",
                    "749": "\treturn router;",
                    "750": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_set_hdr": {
            "name": "net_udp_set_hdr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 95,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstruct net_udp_hdr *net_udp_set_hdr(struct net_pkt *pkt,\n\t\t\t\t    struct net_udp_hdr *hdr)\n{\n\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);\n\tstruct net_pkt_cursor backup;\n\tstruct net_udp_hdr *udp_hdr;\n\tbool overwrite;\n\n\toverwrite = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t net_pkt_ip_opts_len(pkt))) {\n\t\tudp_hdr = NULL;\n\t\tgoto out;\n\t}\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);\n\tif (!udp_hdr) {\n\t\tgoto out;\n\t}\n\n\tmemcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));\n\n\tnet_pkt_set_data(pkt, &udp_access);\nout:\n\tnet_pkt_cursor_restore(pkt, &backup);\n\tnet_pkt_set_overwrite(pkt, overwrite);\n\n\treturn udp_hdr == NULL ? NULL : hdr;\n}\n",
                {
                    "95": "struct net_udp_hdr *net_udp_set_hdr(struct net_pkt *pkt,",
                    "96": "\t\t\t\t    struct net_udp_hdr *hdr)",
                    "97": "{",
                    "98": "\tNET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);",
                    "99": "\tstruct net_pkt_cursor backup;",
                    "100": "\tstruct net_udp_hdr *udp_hdr;",
                    "101": "\tbool overwrite;",
                    "102": "",
                    "103": "\toverwrite = net_pkt_is_being_overwritten(pkt);",
                    "104": "\tnet_pkt_set_overwrite(pkt, true);",
                    "105": "",
                    "106": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "107": "\tnet_pkt_cursor_init(pkt);",
                    "108": "",
                    "109": "\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "110": "\t\t\t net_pkt_ip_opts_len(pkt))) {",
                    "111": "\t\tudp_hdr = NULL;",
                    "112": "\t\tgoto out;",
                    "113": "\t}",
                    "114": "",
                    "115": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);",
                    "116": "\tif (!udp_hdr) {",
                    "117": "\t\tgoto out;",
                    "118": "\t}",
                    "119": "",
                    "120": "\tmemcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));",
                    "121": "",
                    "122": "\tnet_pkt_set_data(pkt, &udp_access);",
                    "123": "out:",
                    "124": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "125": "\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "126": "",
                    "127": "\treturn udp_hdr == NULL ? NULL : hdr;",
                    "128": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_udp_get_hdr": {
            "name": "net_udp_get_hdr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/udp.c",
            "location_line": 64,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstruct net_udp_hdr *net_udp_get_hdr(struct net_pkt *pkt,\n\t\t\t\t    struct net_udp_hdr *hdr)\n{\n\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(udp_access, struct net_udp_hdr);\n\tstruct net_pkt_cursor backup;\n\tstruct net_udp_hdr *udp_hdr;\n\tbool overwrite;\n\n\tudp_access.data = hdr;\n\n\toverwrite = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +\n\t\t\t net_pkt_ip_opts_len(pkt))) {\n\t\tudp_hdr = NULL;\n\t\tgoto out;\n\t}\n\n\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);\n\nout:\n\tnet_pkt_cursor_restore(pkt, &backup);\n\tnet_pkt_set_overwrite(pkt, overwrite);\n\n\treturn udp_hdr;\n}\n",
                {
                    "64": "struct net_udp_hdr *net_udp_get_hdr(struct net_pkt *pkt,",
                    "65": "\t\t\t\t    struct net_udp_hdr *hdr)",
                    "66": "{",
                    "67": "\tNET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(udp_access, struct net_udp_hdr);",
                    "68": "\tstruct net_pkt_cursor backup;",
                    "69": "\tstruct net_udp_hdr *udp_hdr;",
                    "70": "\tbool overwrite;",
                    "71": "",
                    "72": "\tudp_access.data = hdr;",
                    "73": "",
                    "74": "\toverwrite = net_pkt_is_being_overwritten(pkt);",
                    "75": "\tnet_pkt_set_overwrite(pkt, true);",
                    "76": "",
                    "77": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "78": "\tnet_pkt_cursor_init(pkt);",
                    "79": "",
                    "80": "\tif (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +",
                    "81": "\t\t\t net_pkt_ip_opts_len(pkt))) {",
                    "82": "\t\tudp_hdr = NULL;",
                    "83": "\t\tgoto out;",
                    "84": "\t}",
                    "85": "",
                    "86": "\tudp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);",
                    "87": "",
                    "88": "out:",
                    "89": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "90": "\tnet_pkt_set_overwrite(pkt, overwrite);",
                    "91": "",
                    "92": "\treturn udp_hdr;",
                    "93": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_pkt_cursor_operate": {
            "name": "net_pkt_cursor_operate",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1835,
            "function_content": [
                "/* Internal function that does all operation (skip/read/write/memset) */\nstatic int net_pkt_cursor_operate(struct net_pkt *pkt,\n\t\t\t\t  void *data, size_t length,\n\t\t\t\t  bool copy, bool write)\n{\n\t/* We use such variable to avoid lengthy lines */\n\tstruct net_pkt_cursor *c_op = &pkt->cursor;\n\n\twhile (c_op->buf && length) {\n\t\tsize_t d_len, len;\n\n\t\tpkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?\n\t\t\t\t   false : write);\n\t\tif (c_op->buf == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {\n\t\t\td_len = net_buf_max_len(c_op->buf) -\n\t\t\t\t(c_op->pos - c_op->buf->data);\n\t\t} else {\n\t\t\td_len = c_op->buf->len - (c_op->pos - c_op->buf->data);\n\t\t}\n\n\t\tif (!d_len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (length < d_len) {\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tlen = d_len;\n\t\t}\n\n\t\tif (copy && data) {\n\t\t\tmemcpy(write ? c_op->pos : data,\n\t\t\t       write ? data : c_op->pos,\n\t\t\t       len);\n\t\t} else if (data) {\n\t\t\tmemset(c_op->pos, *(int *)data, len);\n\t\t}\n\n\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {\n\t\t\tnet_buf_add(c_op->buf, len);\n\t\t}\n\n\t\tpkt_cursor_update(pkt, len, write);\n\n\t\tif (copy && data) {\n\t\t\tdata = (uint8_t *) data + len;\n\t\t}\n\n\t\tlength -= len;\n\t}\n\n\tif (length) {\n\t\tNET_DBG(\"Still some length to go %zu\", length);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n",
                {
                    "1835": "static int net_pkt_cursor_operate(struct net_pkt *pkt,",
                    "1836": "\t\t\t\t  void *data, size_t length,",
                    "1837": "\t\t\t\t  bool copy, bool write)",
                    "1838": "{",
                    "1839": "\t/* We use such variable to avoid lengthy lines */",
                    "1840": "\tstruct net_pkt_cursor *c_op = &pkt->cursor;",
                    "1841": "",
                    "1842": "\twhile (c_op->buf && length) {",
                    "1843": "\t\tsize_t d_len, len;",
                    "1844": "",
                    "1845": "\t\tpkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?",
                    "1846": "\t\t\t\t   false : write);",
                    "1847": "\t\tif (c_op->buf == NULL) {",
                    "1848": "\t\t\tbreak;",
                    "1849": "\t\t}",
                    "1850": "",
                    "1851": "\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {",
                    "1852": "\t\t\td_len = net_buf_max_len(c_op->buf) -",
                    "1853": "\t\t\t\t(c_op->pos - c_op->buf->data);",
                    "1854": "\t\t} else {",
                    "1855": "\t\t\td_len = c_op->buf->len - (c_op->pos - c_op->buf->data);",
                    "1856": "\t\t}",
                    "1857": "",
                    "1858": "\t\tif (!d_len) {",
                    "1859": "\t\t\tbreak;",
                    "1860": "\t\t}",
                    "1861": "",
                    "1862": "\t\tif (length < d_len) {",
                    "1863": "\t\t\tlen = length;",
                    "1864": "\t\t} else {",
                    "1865": "\t\t\tlen = d_len;",
                    "1866": "\t\t}",
                    "1867": "",
                    "1868": "\t\tif (copy && data) {",
                    "1869": "\t\t\tmemcpy(write ? c_op->pos : data,",
                    "1870": "\t\t\t       write ? data : c_op->pos,",
                    "1871": "\t\t\t       len);",
                    "1872": "\t\t} else if (data) {",
                    "1873": "\t\t\tmemset(c_op->pos, *(int *)data, len);",
                    "1874": "\t\t}",
                    "1875": "",
                    "1876": "\t\tif (write && !net_pkt_is_being_overwritten(pkt)) {",
                    "1877": "\t\t\tnet_buf_add(c_op->buf, len);",
                    "1878": "\t\t}",
                    "1879": "",
                    "1880": "\t\tpkt_cursor_update(pkt, len, write);",
                    "1881": "",
                    "1882": "\t\tif (copy && data) {",
                    "1883": "\t\t\tdata = (uint8_t *) data + len;",
                    "1884": "\t\t}",
                    "1885": "",
                    "1886": "\t\tlength -= len;",
                    "1887": "\t}",
                    "1888": "",
                    "1889": "\tif (length) {",
                    "1890": "\t\tNET_DBG(\"Still some length to go %zu\", length);",
                    "1891": "\t\treturn -ENOBUFS;",
                    "1892": "\t}",
                    "1893": "",
                    "1894": "\treturn 0;",
                    "1895": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_update": {
            "name": "pkt_cursor_update",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1814,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_update(struct net_pkt *pkt,\n\t\t\t      size_t length, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\tsize_t len;\n\n\tif (net_pkt_is_being_overwritten(pkt)) {\n\t\twrite = false;\n\t}\n\n\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\tif (length + (cursor->pos - cursor->buf->data) == len &&\n\t    !(net_pkt_is_being_overwritten(pkt) &&\n\t      len < net_buf_max_len(cursor->buf))) {\n\t\tpkt_cursor_jump(pkt, write);\n\t} else {\n\t\tcursor->pos += length;\n\t}\n}\n",
                {
                    "1814": "static void pkt_cursor_update(struct net_pkt *pkt,",
                    "1815": "\t\t\t      size_t length, bool write)",
                    "1816": "{",
                    "1817": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1818": "\tsize_t len;",
                    "1819": "",
                    "1820": "\tif (net_pkt_is_being_overwritten(pkt)) {",
                    "1821": "\t\twrite = false;",
                    "1822": "\t}",
                    "1823": "",
                    "1824": "\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1825": "\tif (length + (cursor->pos - cursor->buf->data) == len &&",
                    "1826": "\t    !(net_pkt_is_being_overwritten(pkt) &&",
                    "1827": "\t      len < net_buf_max_len(cursor->buf))) {",
                    "1828": "\t\tpkt_cursor_jump(pkt, write);",
                    "1829": "\t} else {",
                    "1830": "\t\tcursor->pos += length;",
                    "1831": "\t}",
                    "1832": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_advance": {
            "name": "pkt_cursor_advance",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1799,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_advance(struct net_pkt *pkt, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\tsize_t len;\n\n\tif (!cursor->buf) {\n\t\treturn;\n\t}\n\n\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\tif ((cursor->pos - cursor->buf->data) == len) {\n\t\tpkt_cursor_jump(pkt, write);\n\t}\n}\n",
                {
                    "1799": "static void pkt_cursor_advance(struct net_pkt *pkt, bool write)",
                    "1800": "{",
                    "1801": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1802": "\tsize_t len;",
                    "1803": "",
                    "1804": "\tif (!cursor->buf) {",
                    "1805": "\t\treturn;",
                    "1806": "\t}",
                    "1807": "",
                    "1808": "\tlen = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1809": "\tif ((cursor->pos - cursor->buf->data) == len) {",
                    "1810": "\t\tpkt_cursor_jump(pkt, write);",
                    "1811": "\t}",
                    "1812": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "pkt_cursor_jump": {
            "name": "pkt_cursor_jump",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_pkt.c",
            "location_line": 1776,
            "function_content": [
                "#endif /* CONFIG_NET_RAW_MODE */\nstatic void pkt_cursor_jump(struct net_pkt *pkt, bool write)\n{\n\tstruct net_pkt_cursor *cursor = &pkt->cursor;\n\n\tcursor->buf = cursor->buf->frags;\n\twhile (cursor->buf) {\n\t\tconst size_t len =\n\t\t\twrite ? net_buf_max_len(cursor->buf) : cursor->buf->len;\n\n\t\tif (!len) {\n\t\t\tcursor->buf = cursor->buf->frags;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cursor->buf) {\n\t\tcursor->pos = cursor->buf->data;\n\t} else {\n\t\tcursor->pos = NULL;\n\t}\n}\n",
                {
                    "1776": "static void pkt_cursor_jump(struct net_pkt *pkt, bool write)",
                    "1777": "{",
                    "1778": "\tstruct net_pkt_cursor *cursor = &pkt->cursor;",
                    "1779": "",
                    "1780": "\tcursor->buf = cursor->buf->frags;",
                    "1781": "\twhile (cursor->buf) {",
                    "1782": "\t\tconst size_t len =",
                    "1783": "\t\t\twrite ? net_buf_max_len(cursor->buf) : cursor->buf->len;",
                    "1784": "",
                    "1785": "\t\tif (!len) {",
                    "1786": "\t\t\tcursor->buf = cursor->buf->frags;",
                    "1787": "\t\t} else {",
                    "1788": "\t\t\tbreak;",
                    "1789": "\t\t}",
                    "1790": "\t}",
                    "1791": "",
                    "1792": "\tif (cursor->buf) {",
                    "1793": "\t\tcursor->pos = cursor->buf->data;",
                    "1794": "\t} else {",
                    "1795": "\t\tcursor->pos = NULL;",
                    "1796": "\t}",
                    "1797": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_calc_chksum": {
            "name": "net_calc_chksum",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 687,
            "function_content": [
                "/* Sum in is in host endianness, working order endianness is both dependent on endianness\n* and the offset of starting\n*/\nuint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)\n{\n\tsize_t len = 0U;\n\tuint16_t sum = 0U;\n\tstruct net_pkt_cursor backup;\n\tbool ow;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t    net_pkt_family(pkt) == NET_AF_INET) {\n\t\tif (proto != NET_IPPROTO_ICMP && proto != NET_IPPROTO_IGMP) {\n\t\t\tlen = 2 * sizeof(struct net_in_addr);\n\t\t\tsum = net_pkt_get_len(pkt) -\n\t\t\t\tnet_pkt_ip_hdr_len(pkt) -\n\t\t\t\tnet_pkt_ipv4_opts_len(pkt) + proto;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t   net_pkt_family(pkt) == NET_AF_INET6) {\n\t\tlen = 2 * sizeof(struct net_in6_addr);\n\t\tsum =  net_pkt_get_len(pkt) -\n\t\t\tnet_pkt_ip_hdr_len(pkt) -\n\t\t\tnet_pkt_ipv6_ext_len(pkt) + proto;\n\t} else {\n\t\tNET_DBG(\"Unknown protocol family %d\", net_pkt_family(pkt));\n\t\treturn 0;\n\t}\n\n\tnet_pkt_cursor_backup(pkt, &backup);\n\tnet_pkt_cursor_init(pkt);\n\n\tow = net_pkt_is_being_overwritten(pkt);\n\tnet_pkt_set_overwrite(pkt, true);\n\n\tnet_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);\n\n\tsum = calc_chksum(sum, pkt->cursor.pos, len);\n\tnet_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));\n\n\tsum = pkt_calc_chksum(pkt, sum);\n\n\tsum = (sum == 0U) ? 0xffff : net_htons(sum);\n\n\tnet_pkt_cursor_restore(pkt, &backup);\n\n\tnet_pkt_set_overwrite(pkt, ow);\n\n\treturn ~sum;\n}\n",
                {
                    "687": "uint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)",
                    "688": "{",
                    "689": "\tsize_t len = 0U;",
                    "690": "\tuint16_t sum = 0U;",
                    "691": "\tstruct net_pkt_cursor backup;",
                    "692": "\tbool ow;",
                    "693": "",
                    "694": "\tif (IS_ENABLED(CONFIG_NET_IPV4) &&",
                    "695": "\t    net_pkt_family(pkt) == NET_AF_INET) {",
                    "696": "\t\tif (proto != NET_IPPROTO_ICMP && proto != NET_IPPROTO_IGMP) {",
                    "697": "\t\t\tlen = 2 * sizeof(struct net_in_addr);",
                    "698": "\t\t\tsum = net_pkt_get_len(pkt) -",
                    "699": "\t\t\t\tnet_pkt_ip_hdr_len(pkt) -",
                    "700": "\t\t\t\tnet_pkt_ipv4_opts_len(pkt) + proto;",
                    "701": "\t\t}",
                    "702": "\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&",
                    "703": "\t\t   net_pkt_family(pkt) == NET_AF_INET6) {",
                    "704": "\t\tlen = 2 * sizeof(struct net_in6_addr);",
                    "705": "\t\tsum =  net_pkt_get_len(pkt) -",
                    "706": "\t\t\tnet_pkt_ip_hdr_len(pkt) -",
                    "707": "\t\t\tnet_pkt_ipv6_ext_len(pkt) + proto;",
                    "708": "\t} else {",
                    "709": "\t\tNET_DBG(\"Unknown protocol family %d\", net_pkt_family(pkt));",
                    "710": "\t\treturn 0;",
                    "711": "\t}",
                    "712": "",
                    "713": "\tnet_pkt_cursor_backup(pkt, &backup);",
                    "714": "\tnet_pkt_cursor_init(pkt);",
                    "715": "",
                    "716": "\tow = net_pkt_is_being_overwritten(pkt);",
                    "717": "\tnet_pkt_set_overwrite(pkt, true);",
                    "718": "",
                    "719": "\tnet_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);",
                    "720": "",
                    "721": "\tsum = calc_chksum(sum, pkt->cursor.pos, len);",
                    "722": "\tnet_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));",
                    "723": "",
                    "724": "\tsum = pkt_calc_chksum(pkt, sum);",
                    "725": "",
                    "726": "\tsum = (sum == 0U) ? 0xffff : net_htons(sum);",
                    "727": "",
                    "728": "\tnet_pkt_cursor_restore(pkt, &backup);",
                    "729": "",
                    "730": "\tnet_pkt_set_overwrite(pkt, ow);",
                    "731": "",
                    "732": "\treturn ~sum;",
                    "733": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "calc_chksum": {
            "name": "calc_chksum",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 579,
            "function_content": [
                "/* Word based checksum calculation based on:\n* https://blogs.igalia.com/dpino/2018/06/14/fast-checksum-computation/\n* Its not necessary to add octets as 16-bit words. Due to the associative property of addition,\n* it is possible to do parallel addition using larger word sizes such as 32-bit or 64-bit words.\n* In those cases the variable that stores the accumulative sum has to be bigger too.\n* Once the sum is computed a final step folds the sum to a 16-bit word (adding carry if any).\n*/\nuint16_t calc_chksum(uint16_t sum_in, const uint8_t *data, size_t len)\n{\n\tuint64_t sum;\n\tuint32_t *p;\n\tsize_t i = 0;\n\tsize_t pending = len;\n\tint odd_start = ((uintptr_t)data & 0x01);\n\n\t/* Sum in is in host endianness, working order endianness is both dependent on endianness\n\t * and the offset of starting\n\t */\n\tif (odd_start == CHECKSUM_BIG_ENDIAN) {\n\t\tsum = BSWAP_16(sum_in);\n\t} else {\n\t\tsum = sum_in;\n\t}\n\n\t/* Process up to 3 data elements up front, so the data is aligned further down the line */\n\tif ((((uintptr_t)data & 0x01) != 0) && (pending >= 1)) {\n\t\tsum += offset_based_swap8(data);\n\t\tdata++;\n\t\tpending--;\n\t}\n\tif ((((uintptr_t)data & 0x02) != 0) && (pending >= sizeof(uint16_t))) {\n\t\tpending -= sizeof(uint16_t);\n\t\tsum = sum + *((uint16_t *)data);\n\t\tdata += sizeof(uint16_t);\n\t}\n\tp = (uint32_t *)data;\n\n\t/* Do loop unrolling for the very large data sets */\n\twhile (pending >= sizeof(uint32_t) * 4) {\n\t\tuint64_t sum_a = p[i];\n\t\tuint64_t sum_b = p[i + 1];\n\n\t\tpending -= sizeof(uint32_t) * 4;\n\t\tsum_a += p[i + 2];\n\t\tsum_b += p[i + 3];\n\t\ti += 4;\n\t\tsum += sum_a + sum_b;\n\t}\n\twhile (pending >= sizeof(uint32_t)) {\n\t\tpending -= sizeof(uint32_t);\n\t\tsum = sum + p[i++];\n\t}\n\tdata = (uint8_t *)(p + i);\n\tif (pending >= 2) {\n\t\tpending -= sizeof(uint16_t);\n\t\tsum = sum + *((uint16_t *)data);\n\t\tdata += sizeof(uint16_t);\n\t}\n\tif (pending == 1) {\n\t\tsum += offset_based_swap8(data);\n\t}\n\n\t/* Fold sum into 16-bit word. */\n\twhile (sum >> 16) {\n\t\tsum = (sum & 0xffff) + (sum >> 16);\n\t}\n\n\t/* Sum in is in host endianness, working order endianness is both dependent on endianness\n\t * and the offset of starting\n\t */\n\tif (odd_start == CHECKSUM_BIG_ENDIAN) {\n\t\treturn BSWAP_16((uint16_t)sum);\n\t} else {\n\t\treturn sum;\n\t}\n}\n",
                {
                    "579": "uint16_t calc_chksum(uint16_t sum_in, const uint8_t *data, size_t len)",
                    "580": "{",
                    "581": "\tuint64_t sum;",
                    "582": "\tuint32_t *p;",
                    "583": "\tsize_t i = 0;",
                    "584": "\tsize_t pending = len;",
                    "585": "\tint odd_start = ((uintptr_t)data & 0x01);",
                    "586": "",
                    "587": "\t/* Sum in is in host endianness, working order endianness is both dependent on endianness",
                    "588": "\t * and the offset of starting",
                    "589": "\t */",
                    "590": "\tif (odd_start == CHECKSUM_BIG_ENDIAN) {",
                    "591": "\t\tsum = BSWAP_16(sum_in);",
                    "592": "\t} else {",
                    "593": "\t\tsum = sum_in;",
                    "594": "\t}",
                    "595": "",
                    "596": "\t/* Process up to 3 data elements up front, so the data is aligned further down the line */",
                    "597": "\tif ((((uintptr_t)data & 0x01) != 0) && (pending >= 1)) {",
                    "598": "\t\tsum += offset_based_swap8(data);",
                    "599": "\t\tdata++;",
                    "600": "\t\tpending--;",
                    "601": "\t}",
                    "602": "\tif ((((uintptr_t)data & 0x02) != 0) && (pending >= sizeof(uint16_t))) {",
                    "603": "\t\tpending -= sizeof(uint16_t);",
                    "604": "\t\tsum = sum + *((uint16_t *)data);",
                    "605": "\t\tdata += sizeof(uint16_t);",
                    "606": "\t}",
                    "607": "\tp = (uint32_t *)data;",
                    "608": "",
                    "609": "\t/* Do loop unrolling for the very large data sets */",
                    "610": "\twhile (pending >= sizeof(uint32_t) * 4) {",
                    "611": "\t\tuint64_t sum_a = p[i];",
                    "612": "\t\tuint64_t sum_b = p[i + 1];",
                    "613": "",
                    "614": "\t\tpending -= sizeof(uint32_t) * 4;",
                    "615": "\t\tsum_a += p[i + 2];",
                    "616": "\t\tsum_b += p[i + 3];",
                    "617": "\t\ti += 4;",
                    "618": "\t\tsum += sum_a + sum_b;",
                    "619": "\t}",
                    "620": "\twhile (pending >= sizeof(uint32_t)) {",
                    "621": "\t\tpending -= sizeof(uint32_t);",
                    "622": "\t\tsum = sum + p[i++];",
                    "623": "\t}",
                    "624": "\tdata = (uint8_t *)(p + i);",
                    "625": "\tif (pending >= 2) {",
                    "626": "\t\tpending -= sizeof(uint16_t);",
                    "627": "\t\tsum = sum + *((uint16_t *)data);",
                    "628": "\t\tdata += sizeof(uint16_t);",
                    "629": "\t}",
                    "630": "\tif (pending == 1) {",
                    "631": "\t\tsum += offset_based_swap8(data);",
                    "632": "\t}",
                    "633": "",
                    "634": "\t/* Fold sum into 16-bit word. */",
                    "635": "\twhile (sum >> 16) {",
                    "636": "\t\tsum = (sum & 0xffff) + (sum >> 16);",
                    "637": "\t}",
                    "638": "",
                    "639": "\t/* Sum in is in host endianness, working order endianness is both dependent on endianness",
                    "640": "\t * and the offset of starting",
                    "641": "\t */",
                    "642": "\tif (odd_start == CHECKSUM_BIG_ENDIAN) {",
                    "643": "\t\treturn BSWAP_16((uint16_t)sum);",
                    "644": "\t} else {",
                    "645": "\t\treturn sum;",
                    "646": "\t}",
                    "647": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_sprint_addr": {
            "name": "net_sprint_addr",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 30,
            "function_content": [
                "/*\n* Copyright (c) 2016 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nchar *net_sprint_addr(net_sa_family_t af, const void *addr)\n{\n#define NBUFS 3\n\tstatic char buf[NBUFS][NET_IPV6_ADDR_LEN];\n\tstatic int i;\n\tchar *s = buf[++i % NBUFS];\n\n\treturn net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);\n}\n",
                {
                    "30": "char *net_sprint_addr(net_sa_family_t af, const void *addr)",
                    "31": "{",
                    "32": "#define NBUFS 3",
                    "33": "\tstatic char buf[NBUFS][NET_IPV6_ADDR_LEN];",
                    "34": "\tstatic int i;",
                    "35": "\tchar *s = buf[++i % NBUFS];",
                    "36": "",
                    "37": "\treturn net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);",
                    "38": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "net_tc_submit_to_rx_queue": {
            "name": "net_tc_submit_to_rx_queue",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_tc.c",
            "location_line": 84,
            "function_content": [
                "/* Stacks for RX work queue */\nenum net_verdict net_tc_submit_to_rx_queue(uint8_t tc, struct net_pkt *pkt)\n{\n#if NET_TC_RX_COUNT > 0\n#if NET_TC_RX_EFFECTIVE_COUNT > 1\n\tuint8_t retry_cnt = NET_TC_RETRY_CNT;\n#endif\n\tnet_pkt_set_rx_stats_tick(pkt, k_cycle_get_32());\n\n#if NET_TC_RX_EFFECTIVE_COUNT > 1\n\twhile (k_sem_take(&rx_classes[tc].fifo_slot, K_NO_WAIT) != 0) {\n\t\tif (k_is_in_isr() || retry_cnt == 0) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tretry_cnt--;\n\t\t/* Let thread with same priority run,\n\t\t * try to reduce dropping packets\n\t\t */\n\t\tk_yield();\n\t}\n#endif\n\n\tk_fifo_put(&rx_classes[tc].fifo, pkt);\n\treturn NET_OK;\n#else\n\tARG_UNUSED(tc);\n\tARG_UNUSED(pkt);\n\treturn NET_DROP;\n#endif\n}\n",
                {
                    "84": "enum net_verdict net_tc_submit_to_rx_queue(uint8_t tc, struct net_pkt *pkt)",
                    "85": "{",
                    "86": "#if NET_TC_RX_COUNT > 0",
                    "87": "#if NET_TC_RX_EFFECTIVE_COUNT > 1",
                    "88": "\tuint8_t retry_cnt = NET_TC_RETRY_CNT;",
                    "89": "#endif",
                    "90": "\tnet_pkt_set_rx_stats_tick(pkt, k_cycle_get_32());",
                    "91": "",
                    "92": "#if NET_TC_RX_EFFECTIVE_COUNT > 1",
                    "93": "\twhile (k_sem_take(&rx_classes[tc].fifo_slot, K_NO_WAIT) != 0) {",
                    "94": "\t\tif (k_is_in_isr() || retry_cnt == 0) {",
                    "95": "\t\t\treturn NET_DROP;",
                    "96": "\t\t}",
                    "97": "",
                    "98": "\t\tretry_cnt--;",
                    "99": "\t\t/* Let thread with same priority run,",
                    "100": "\t\t * try to reduce dropping packets",
                    "101": "\t\t */",
                    "102": "\t\tk_yield();",
                    "103": "\t}",
                    "104": "#endif",
                    "105": "",
                    "106": "\tk_fifo_put(&rx_classes[tc].fifo, pkt);",
                    "107": "\treturn NET_OK;",
                    "108": "#else",
                    "109": "\tARG_UNUSED(tc);",
                    "110": "\tARG_UNUSED(pkt);",
                    "111": "\treturn NET_DROP;",
                    "112": "#endif",
                    "113": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "tc_rx_handler": {
            "name": "tc_rx_handler",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/net_tc.c",
            "location_line": 256,
            "function_content": [
                "/* Fixup the traffic class statistics so that \"net stats\" shell command will\n* print output correctly.\n*/\nstatic void tc_rx_handler(void *p1, void *p2, void *p3)\n{\n\tARG_UNUSED(p3);\n\n\tstruct k_fifo *fifo = p1;\n#if NET_TC_RX_EFFECTIVE_COUNT > 1\n\tstruct k_sem *fifo_slot = p2;\n#else\n\tARG_UNUSED(p2);\n#endif\n\tstruct net_pkt *pkt;\n\n\twhile (1) {\n\t\tpkt = k_fifo_get(fifo, K_FOREVER);\n\t\tif (pkt == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n#if NET_TC_RX_EFFECTIVE_COUNT > 1\n\t\tk_sem_give(fifo_slot);\n#endif\n\n\t\tnet_process_rx_packet(pkt);\n\t}\n}\n",
                {
                    "256": "static void tc_rx_handler(void *p1, void *p2, void *p3)",
                    "257": "{",
                    "258": "\tARG_UNUSED(p3);",
                    "259": "",
                    "260": "\tstruct k_fifo *fifo = p1;",
                    "261": "#if NET_TC_RX_EFFECTIVE_COUNT > 1",
                    "262": "\tstruct k_sem *fifo_slot = p2;",
                    "263": "#else",
                    "264": "\tARG_UNUSED(p2);",
                    "265": "#endif",
                    "266": "\tstruct net_pkt *pkt;",
                    "267": "",
                    "268": "\twhile (1) {",
                    "269": "\t\tpkt = k_fifo_get(fifo, K_FOREVER);",
                    "270": "\t\tif (pkt == NULL) {",
                    "271": "\t\t\tcontinue;",
                    "272": "\t\t}",
                    "273": "",
                    "274": "#if NET_TC_RX_EFFECTIVE_COUNT > 1",
                    "275": "\t\tk_sem_give(fifo_slot);",
                    "276": "#endif",
                    "277": "",
                    "278": "\t\tnet_process_rx_packet(pkt);",
                    "279": "\t}",
                    "280": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "parse_ipv6": {
            "name": "parse_ipv6",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 778,
            "function_content": [
                "#endif /* CONFIG_NET_IP */\nstatic bool parse_ipv6(const char *str, size_t str_len,\n\t\t       struct net_sockaddr *addr, bool has_port)\n{\n\tchar *ptr = NULL;\n\tstruct net_in6_addr *addr6;\n\tchar ipaddr[NET_INET6_ADDRSTRLEN + 1];\n\tint end, len, ret, i;\n\tuint16_t port;\n\n\tlen = MIN(NET_INET6_ADDRSTRLEN, str_len);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!str[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_port) {\n\t\t/* IPv6 address with port number */\n\t\tptr = memchr(str, ']', len);\n\t\tif (!ptr) {\n\t\t\treturn false;\n\t\t}\n\n\t\tend = MIN(len, ptr - (str + 1));\n\t\tmemcpy(ipaddr, str + 1, end);\n\t} else {\n\t\tend = len;\n\t\tmemcpy(ipaddr, str, end);\n\t}\n\n\tipaddr[end] = '\\0';\n\n\taddr6 = &net_sin6(addr)->sin6_addr;\n\n\tret = net_addr_pton(NET_AF_INET6, ipaddr, addr6);\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\n\tnet_sin6(addr)->sin6_family = NET_AF_INET6;\n\n\tif (!has_port) {\n\t\treturn true;\n\t}\n\n\tif ((ptr + 1) < (str + str_len) && *(ptr + 1) == ':') {\n\t\t/* -1 as end does not contain first [\n\t\t * -2 as pointer is advanced by 2, skipping ]:\n\t\t */\n\t\tlen = str_len - end - 1 - 2;\n\n\t\tptr += 2;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!ptr[i]) {\n\t\t\t\tlen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Re-use the ipaddr buf for port conversion */\n\t\tmemcpy(ipaddr, ptr, len);\n\t\tipaddr[len] = '\\0';\n\n\t\tret = convert_port(ipaddr, &port);\n\t\tif (!ret) {\n\t\t\treturn false;\n\t\t}\n\n\t\tnet_sin6(addr)->sin6_port = net_htons(port);\n\n\t\tNET_DBG(\"IPv6 host %s port %d\",\n\t\t\tnet_addr_ntop(NET_AF_INET6, addr6, ipaddr, sizeof(ipaddr) - 1),\n\t\t\tport);\n\t} else {\n\t\tNET_DBG(\"IPv6 host %s\",\n\t\t\tnet_addr_ntop(NET_AF_INET6, addr6, ipaddr, sizeof(ipaddr) - 1));\n\t}\n\n\treturn true;\n}\n",
                {
                    "778": "static bool parse_ipv6(const char *str, size_t str_len,",
                    "779": "\t\t       struct net_sockaddr *addr, bool has_port)",
                    "780": "{",
                    "781": "\tchar *ptr = NULL;",
                    "782": "\tstruct net_in6_addr *addr6;",
                    "783": "\tchar ipaddr[NET_INET6_ADDRSTRLEN + 1];",
                    "784": "\tint end, len, ret, i;",
                    "785": "\tuint16_t port;",
                    "786": "",
                    "787": "\tlen = MIN(NET_INET6_ADDRSTRLEN, str_len);",
                    "788": "",
                    "789": "\tfor (i = 0; i < len; i++) {",
                    "790": "\t\tif (!str[i]) {",
                    "791": "\t\t\tlen = i;",
                    "792": "\t\t\tbreak;",
                    "793": "\t\t}",
                    "794": "\t}",
                    "795": "",
                    "796": "\tif (has_port) {",
                    "797": "\t\t/* IPv6 address with port number */",
                    "798": "\t\tptr = memchr(str, ']', len);",
                    "799": "\t\tif (!ptr) {",
                    "800": "\t\t\treturn false;",
                    "801": "\t\t}",
                    "802": "",
                    "803": "\t\tend = MIN(len, ptr - (str + 1));",
                    "804": "\t\tmemcpy(ipaddr, str + 1, end);",
                    "805": "\t} else {",
                    "806": "\t\tend = len;",
                    "807": "\t\tmemcpy(ipaddr, str, end);",
                    "808": "\t}",
                    "809": "",
                    "810": "\tipaddr[end] = '\\0';",
                    "811": "",
                    "812": "\taddr6 = &net_sin6(addr)->sin6_addr;",
                    "813": "",
                    "814": "\tret = net_addr_pton(NET_AF_INET6, ipaddr, addr6);",
                    "815": "\tif (ret < 0) {",
                    "816": "\t\treturn false;",
                    "817": "\t}",
                    "818": "",
                    "819": "\tnet_sin6(addr)->sin6_family = NET_AF_INET6;",
                    "820": "",
                    "821": "\tif (!has_port) {",
                    "822": "\t\treturn true;",
                    "823": "\t}",
                    "824": "",
                    "825": "\tif ((ptr + 1) < (str + str_len) && *(ptr + 1) == ':') {",
                    "826": "\t\t/* -1 as end does not contain first [",
                    "827": "\t\t * -2 as pointer is advanced by 2, skipping ]:",
                    "828": "\t\t */",
                    "829": "\t\tlen = str_len - end - 1 - 2;",
                    "830": "",
                    "831": "\t\tptr += 2;",
                    "832": "",
                    "833": "\t\tfor (i = 0; i < len; i++) {",
                    "834": "\t\t\tif (!ptr[i]) {",
                    "835": "\t\t\t\tlen = i;",
                    "836": "\t\t\t\tbreak;",
                    "837": "\t\t\t}",
                    "838": "\t\t}",
                    "839": "",
                    "840": "\t\t/* Re-use the ipaddr buf for port conversion */",
                    "841": "\t\tmemcpy(ipaddr, ptr, len);",
                    "842": "\t\tipaddr[len] = '\\0';",
                    "843": "",
                    "844": "\t\tret = convert_port(ipaddr, &port);",
                    "845": "\t\tif (!ret) {",
                    "846": "\t\t\treturn false;",
                    "847": "\t\t}",
                    "848": "",
                    "849": "\t\tnet_sin6(addr)->sin6_port = net_htons(port);",
                    "850": "",
                    "851": "\t\tNET_DBG(\"IPv6 host %s port %d\",",
                    "852": "\t\t\tnet_addr_ntop(NET_AF_INET6, addr6, ipaddr, sizeof(ipaddr) - 1),",
                    "853": "\t\t\tport);",
                    "854": "\t} else {",
                    "855": "\t\tNET_DBG(\"IPv6 host %s\",",
                    "856": "\t\t\tnet_addr_ntop(NET_AF_INET6, addr6, ipaddr, sizeof(ipaddr) - 1));",
                    "857": "\t}",
                    "858": "",
                    "859": "\treturn true;",
                    "860": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "offset_based_swap8": {
            "name": "offset_based_swap8",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/ip/utils.c",
            "location_line": 561,
            "function_content": [
                "#endif /* CONFIG_USERSPACE */\nstatic uint16_t offset_based_swap8(const uint8_t *data)\n{\n\tuint16_t data16 = (uint16_t)*data;\n\n\tif (((uintptr_t)(data) & 1) == CHECKSUM_BIG_ENDIAN) {\n\t\treturn data16;\n\t} else {\n\t\treturn data16 << 8;\n\t}\n}\n",
                {
                    "561": "static uint16_t offset_based_swap8(const uint8_t *data)",
                    "562": "{",
                    "563": "\tuint16_t data16 = (uint16_t)*data;",
                    "564": "",
                    "565": "\tif (((uintptr_t)(data) & 1) == CHECKSUM_BIG_ENDIAN) {",
                    "566": "\t\treturn data16;",
                    "567": "\t} else {",
                    "568": "\t\treturn data16 << 8;",
                    "569": "\t}",
                    "570": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_update_tx_stats": {
            "name": "ethernet_update_tx_stats",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 664,
            "function_content": [
                "/* Make room for the header */\nstatic void ethernet_update_tx_stats(struct net_if *iface, struct net_pkt *pkt)\n{\n\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\n\tif (!IS_ENABLED(CONFIG_NET_STATISTICS_ETHERNET)) {\n\t\treturn;\n\t}\n\n\teth_stats_update_bytes_tx(iface, net_pkt_get_len(pkt));\n\teth_stats_update_pkts_tx(iface);\n\n\tif (net_eth_is_addr_multicast(&hdr->dst)) {\n\t\teth_stats_update_multicast_tx(iface);\n\t} else if (net_eth_is_addr_broadcast(&hdr->dst)) {\n\t\teth_stats_update_broadcast_tx(iface);\n\t}\n}\n",
                {
                    "664": "static void ethernet_update_tx_stats(struct net_if *iface, struct net_pkt *pkt)",
                    "665": "{",
                    "666": "\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "667": "",
                    "668": "\tif (!IS_ENABLED(CONFIG_NET_STATISTICS_ETHERNET)) {",
                    "669": "\t\treturn;",
                    "670": "\t}",
                    "671": "",
                    "672": "\teth_stats_update_bytes_tx(iface, net_pkt_get_len(pkt));",
                    "673": "\teth_stats_update_pkts_tx(iface);",
                    "674": "",
                    "675": "\tif (net_eth_is_addr_multicast(&hdr->dst)) {",
                    "676": "\t\teth_stats_update_multicast_tx(iface);",
                    "677": "\t} else if (net_eth_is_addr_broadcast(&hdr->dst)) {",
                    "678": "\t\teth_stats_update_broadcast_tx(iface);",
                    "679": "\t}",
                    "680": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_fill_header": {
            "name": "ethernet_fill_header",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 566,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6 */\nstatic struct net_buf *ethernet_fill_header(struct ethernet_context *ctx,\n\t\t\t\t\t    struct net_if *iface,\n\t\t\t\t\t    struct net_pkt *pkt,\n\t\t\t\t\t    uint32_t ptype)\n{\n\tstruct net_if *orig_iface = iface;\n\tstruct net_buf *hdr_frag;\n\tstruct net_eth_hdr *hdr;\n\tsize_t reserve_ll_header;\n\tsize_t hdr_len;\n\tbool is_vlan;\n\n\tis_vlan = IS_ENABLED(CONFIG_NET_VLAN) &&\n\t\tnet_eth_is_vlan_enabled(ctx, iface) &&\n\t\tnet_pkt_vlan_tag(pkt) != NET_VLAN_TAG_UNSPEC;\n\tif (is_vlan) {\n\t\torig_iface = net_eth_get_vlan_iface(iface, net_pkt_vlan_tag(pkt));\n\t}\n\n\treserve_ll_header = get_reserve_ll_header_size(orig_iface);\n\tif (reserve_ll_header > 0) {\n\t\thdr_len = reserve_ll_header;\n\t\thdr_frag = pkt->buffer;\n\n\t\tNET_DBG(\"Making room for link header %zd bytes\", hdr_len);\n\n\t\t/* Make room for the header */\n\t\tnet_buf_push(pkt->buffer, hdr_len);\n\t} else {\n\t\thdr_len = IS_ENABLED(CONFIG_NET_VLAN) ?\n\t\t\tsizeof(struct net_eth_vlan_hdr) :\n\t\t\tsizeof(struct net_eth_hdr);\n\n\t\thdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);\n\t\tif (!hdr_frag) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_vlan) {\n\t\tstruct net_eth_vlan_hdr *hdr_vlan;\n\n\t\tif (reserve_ll_header == 0U) {\n\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);\n\t\t\tnet_buf_add(hdr_frag, hdr_len);\n\t\t}\n\n\t\thdr_vlan = (struct net_eth_vlan_hdr *)(hdr_frag->data);\n\n\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||\n\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr_vlan->dst) &&\n\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr_vlan->dst))) {\n\t\t\tmemcpy(&hdr_vlan->dst, net_pkt_lladdr_dst(pkt)->addr,\n\t\t\t       sizeof(struct net_eth_addr));\n\t\t}\n\n\t\tmemcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,\n\t\t       sizeof(struct net_eth_addr));\n\n\t\thdr_vlan->type = ptype;\n\t\thdr_vlan->vlan.tpid = net_htons(NET_ETH_PTYPE_VLAN);\n\t\thdr_vlan->vlan.tci = net_htons(net_pkt_vlan_tci(pkt));\n\n\t\tprint_vlan_ll_addrs(pkt, net_ntohs(hdr_vlan->type),\n\t\t\t\t    net_pkt_vlan_tci(pkt),\n\t\t\t\t    hdr_len,\n\t\t\t\t    &hdr_vlan->src, &hdr_vlan->dst, false);\n\t} else {\n\t\thdr = (struct net_eth_hdr *)(hdr_frag->data);\n\n\t\tif (reserve_ll_header == 0U) {\n\t\t\thdr_len = sizeof(struct net_eth_hdr);\n\t\t\tnet_buf_add(hdr_frag, hdr_len);\n\t\t}\n\n\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||\n\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr->dst) &&\n\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr->dst))) {\n\t\t\tmemcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,\n\t\t\t       sizeof(struct net_eth_addr));\n\t\t}\n\n\t\tmemcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,\n\t\t       sizeof(struct net_eth_addr));\n\n\t\thdr->type = ptype;\n\n\t\tprint_ll_addrs(pkt, net_ntohs(hdr->type),\n\t\t\t       hdr_len, &hdr->src, &hdr->dst);\n\t}\n\n\tif (reserve_ll_header == 0U) {\n\t\tnet_pkt_frag_insert(pkt, hdr_frag);\n\t}\n\n\treturn hdr_frag;\n}\n",
                {
                    "566": "static struct net_buf *ethernet_fill_header(struct ethernet_context *ctx,",
                    "567": "\t\t\t\t\t    struct net_if *iface,",
                    "568": "\t\t\t\t\t    struct net_pkt *pkt,",
                    "569": "\t\t\t\t\t    uint32_t ptype)",
                    "570": "{",
                    "571": "\tstruct net_if *orig_iface = iface;",
                    "572": "\tstruct net_buf *hdr_frag;",
                    "573": "\tstruct net_eth_hdr *hdr;",
                    "574": "\tsize_t reserve_ll_header;",
                    "575": "\tsize_t hdr_len;",
                    "576": "\tbool is_vlan;",
                    "577": "",
                    "578": "\tis_vlan = IS_ENABLED(CONFIG_NET_VLAN) &&",
                    "579": "\t\tnet_eth_is_vlan_enabled(ctx, iface) &&",
                    "580": "\t\tnet_pkt_vlan_tag(pkt) != NET_VLAN_TAG_UNSPEC;",
                    "581": "\tif (is_vlan) {",
                    "582": "\t\torig_iface = net_eth_get_vlan_iface(iface, net_pkt_vlan_tag(pkt));",
                    "583": "\t}",
                    "584": "",
                    "585": "\treserve_ll_header = get_reserve_ll_header_size(orig_iface);",
                    "586": "\tif (reserve_ll_header > 0) {",
                    "587": "\t\thdr_len = reserve_ll_header;",
                    "588": "\t\thdr_frag = pkt->buffer;",
                    "589": "",
                    "590": "\t\tNET_DBG(\"Making room for link header %zd bytes\", hdr_len);",
                    "591": "",
                    "592": "\t\t/* Make room for the header */",
                    "593": "\t\tnet_buf_push(pkt->buffer, hdr_len);",
                    "594": "\t} else {",
                    "595": "\t\thdr_len = IS_ENABLED(CONFIG_NET_VLAN) ?",
                    "596": "\t\t\tsizeof(struct net_eth_vlan_hdr) :",
                    "597": "\t\t\tsizeof(struct net_eth_hdr);",
                    "598": "",
                    "599": "\t\thdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);",
                    "600": "\t\tif (!hdr_frag) {",
                    "601": "\t\t\treturn NULL;",
                    "602": "\t\t}",
                    "603": "\t}",
                    "604": "",
                    "605": "\tif (is_vlan) {",
                    "606": "\t\tstruct net_eth_vlan_hdr *hdr_vlan;",
                    "607": "",
                    "608": "\t\tif (reserve_ll_header == 0U) {",
                    "609": "\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);",
                    "610": "\t\t\tnet_buf_add(hdr_frag, hdr_len);",
                    "611": "\t\t}",
                    "612": "",
                    "613": "\t\thdr_vlan = (struct net_eth_vlan_hdr *)(hdr_frag->data);",
                    "614": "",
                    "615": "\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||",
                    "616": "\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr_vlan->dst) &&",
                    "617": "\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr_vlan->dst))) {",
                    "618": "\t\t\tmemcpy(&hdr_vlan->dst, net_pkt_lladdr_dst(pkt)->addr,",
                    "619": "\t\t\t       sizeof(struct net_eth_addr));",
                    "620": "\t\t}",
                    "621": "",
                    "622": "\t\tmemcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,",
                    "623": "\t\t       sizeof(struct net_eth_addr));",
                    "624": "",
                    "625": "\t\thdr_vlan->type = ptype;",
                    "626": "\t\thdr_vlan->vlan.tpid = net_htons(NET_ETH_PTYPE_VLAN);",
                    "627": "\t\thdr_vlan->vlan.tci = net_htons(net_pkt_vlan_tci(pkt));",
                    "628": "",
                    "629": "\t\tprint_vlan_ll_addrs(pkt, net_ntohs(hdr_vlan->type),",
                    "630": "\t\t\t\t    net_pkt_vlan_tci(pkt),",
                    "631": "\t\t\t\t    hdr_len,",
                    "632": "\t\t\t\t    &hdr_vlan->src, &hdr_vlan->dst, false);",
                    "633": "\t} else {",
                    "634": "\t\thdr = (struct net_eth_hdr *)(hdr_frag->data);",
                    "635": "",
                    "636": "\t\tif (reserve_ll_header == 0U) {",
                    "637": "\t\t\thdr_len = sizeof(struct net_eth_hdr);",
                    "638": "\t\t\tnet_buf_add(hdr_frag, hdr_len);",
                    "639": "\t\t}",
                    "640": "",
                    "641": "\t\tif (ptype == net_htons(NET_ETH_PTYPE_ARP) ||",
                    "642": "\t\t    (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr->dst) &&",
                    "643": "\t\t     !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr->dst))) {",
                    "644": "\t\t\tmemcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,",
                    "645": "\t\t\t       sizeof(struct net_eth_addr));",
                    "646": "\t\t}",
                    "647": "",
                    "648": "\t\tmemcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,",
                    "649": "\t\t       sizeof(struct net_eth_addr));",
                    "650": "",
                    "651": "\t\thdr->type = ptype;",
                    "652": "",
                    "653": "\t\tprint_ll_addrs(pkt, net_ntohs(hdr->type),",
                    "654": "\t\t\t       hdr_len, &hdr->src, &hdr->dst);",
                    "655": "\t}",
                    "656": "",
                    "657": "\tif (reserve_ll_header == 0U) {",
                    "658": "\t\tnet_pkt_frag_insert(pkt, hdr_frag);",
                    "659": "\t}",
                    "660": "",
                    "661": "\treturn hdr_frag;",
                    "662": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_fill_in_dst_on_ipv6_mcast": {
            "name": "ethernet_fill_in_dst_on_ipv6_mcast",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 520,
            "function_content": [
                "#endif /* CONFIG_NET_IPV4 */\nstatic bool ethernet_fill_in_dst_on_ipv6_mcast(struct net_pkt *pkt,\n\t\t\t\t\t       struct net_eth_addr *dst)\n{\n\tif (net_pkt_family(pkt) == NET_AF_INET6 &&\n\t    net_ipv6_is_addr_mcast_raw(NET_IPV6_HDR(pkt)->dst)) {\n\t\tmemcpy(dst, (uint8_t *)multicast_eth_addr.addr,\n\t\t       sizeof(struct net_eth_addr) - 4);\n\t\tmemcpy((uint8_t *)dst + 2,\n\t\t       NET_IPV6_HDR(pkt)->dst + 12,\n\t\t       sizeof(struct net_eth_addr) - 2);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
                {
                    "520": "static bool ethernet_fill_in_dst_on_ipv6_mcast(struct net_pkt *pkt,",
                    "521": "\t\t\t\t\t       struct net_eth_addr *dst)",
                    "522": "{",
                    "523": "\tif (net_pkt_family(pkt) == NET_AF_INET6 &&",
                    "524": "\t    net_ipv6_is_addr_mcast_raw(NET_IPV6_HDR(pkt)->dst)) {",
                    "525": "\t\tmemcpy(dst, (uint8_t *)multicast_eth_addr.addr,",
                    "526": "\t\t       sizeof(struct net_eth_addr) - 4);",
                    "527": "\t\tmemcpy((uint8_t *)dst + 2,",
                    "528": "\t\t       NET_IPV6_HDR(pkt)->dst + 12,",
                    "529": "\t\t       sizeof(struct net_eth_addr) - 2);",
                    "530": "",
                    "531": "\t\treturn true;",
                    "532": "\t}",
                    "533": "",
                    "534": "\treturn false;",
                    "535": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_ip_recv": {
            "name": "ethernet_ip_recv",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 429,
            "function_content": [
                "/* The packet will be processed further by IP-stack\n* when NET_CONTINUE is returned\n*/\nstatic enum net_verdict ethernet_ip_recv(struct net_if *iface,\n\t\t\t\t\t uint16_t ptype,\n\t\t\t\t\t struct net_pkt *pkt)\n{\n\tARG_UNUSED(iface);\n\n\tif (ptype == NET_ETH_PTYPE_IP) {\n\t\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\n\t\tif (ethernet_check_ipv4_bcast_addr(pkt, hdr) == NET_DROP) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tnet_pkt_set_family(pkt, NET_AF_INET);\n\t} else if (ptype == NET_ETH_PTYPE_IPV6) {\n\t\tnet_pkt_set_family(pkt, NET_AF_INET6);\n\t} else {\n\t\treturn NET_DROP;\n\t}\n\n\treturn NET_CONTINUE;\n}\n",
                {
                    "429": "static enum net_verdict ethernet_ip_recv(struct net_if *iface,",
                    "430": "\t\t\t\t\t uint16_t ptype,",
                    "431": "\t\t\t\t\t struct net_pkt *pkt)",
                    "432": "{",
                    "433": "\tARG_UNUSED(iface);",
                    "434": "",
                    "435": "\tif (ptype == NET_ETH_PTYPE_IP) {",
                    "436": "\t\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "437": "",
                    "438": "\t\tif (ethernet_check_ipv4_bcast_addr(pkt, hdr) == NET_DROP) {",
                    "439": "\t\t\treturn NET_DROP;",
                    "440": "\t\t}",
                    "441": "",
                    "442": "\t\tnet_pkt_set_family(pkt, NET_AF_INET);",
                    "443": "\t} else if (ptype == NET_ETH_PTYPE_IPV6) {",
                    "444": "\t\tnet_pkt_set_family(pkt, NET_AF_INET6);",
                    "445": "\t} else {",
                    "446": "\t\treturn NET_DROP;",
                    "447": "\t}",
                    "448": "",
                    "449": "\treturn NET_CONTINUE;",
                    "450": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "ethernet_recv": {
            "name": "ethernet_recv",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/net/l2/ethernet/ethernet.c",
            "location_line": 257,
            "function_content": [
                "#endif /* CONFIG_NET_IPV6 */\nstatic enum net_verdict ethernet_recv(struct net_if *iface,\n\t\t\t\t      struct net_pkt *pkt)\n{\n\tstruct ethernet_context *ctx = net_if_l2_data(iface);\n\tuint8_t hdr_len = sizeof(struct net_eth_hdr);\n\tsize_t body_len;\n\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);\n\tenum net_verdict verdict = NET_CONTINUE;\n\tbool is_vlan_pkt = false;\n\tbool handled = false;\n\tstruct net_linkaddr *lladdr;\n\tuint16_t type;\n\tbool dst_broadcast, dst_eth_multicast, dst_iface_addr;\n\tstruct net_if *iface_eth = iface;\n\n\t/* This expects that the Ethernet header is in the first net_buf\n\t * fragment. This is a safe expectation here as it would not make\n\t * any sense to split the Ethernet header to two net_buf's by the\n\t * Ethernet driver.\n\t */\n\tif (hdr == NULL || pkt->buffer->len < hdr_len) {\n\t\tgoto drop;\n\t}\n\n\t/* Set the pointers to ll src and dst addresses */\n\t(void)net_linkaddr_create(net_pkt_lladdr_src(pkt), hdr->src.addr,\n\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);\n\n\t(void)net_linkaddr_create(net_pkt_lladdr_dst(pkt), hdr->dst.addr,\n\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);\n\n\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_eth_iface_is_bridged(ctx)) {\n\t\tverdict = eth_bridge_input_process(iface, pkt);\n\t\tif (verdict == NET_DROP) {\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Handled by bridge locally */\n\t\tif (verdict == NET_OK) {\n\t\t\tiface = net_eth_get_bridge(ctx);\n\t\t}\n\t}\n\n\ttype = net_ntohs(hdr->type);\n\n\tif (IS_ENABLED(CONFIG_NET_VLAN) && type == NET_ETH_PTYPE_VLAN) {\n\t\tif (net_eth_is_vlan_enabled(ctx, iface) &&\n\t\t    !eth_is_vlan_tag_stripped(iface)) {\n\t\t\tstruct net_eth_vlan_hdr *hdr_vlan =\n\t\t\t\t(struct net_eth_vlan_hdr *)NET_ETH_HDR(pkt);\n\t\t\tstruct net_if *vlan_iface;\n\n\t\t\tnet_pkt_set_vlan_tci(pkt, net_ntohs(hdr_vlan->vlan.tci));\n\t\t\ttype = net_ntohs(hdr_vlan->type);\n\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);\n\t\t\tis_vlan_pkt = true;\n\n\t\t\t/* If we receive a packet with a VLAN tag, for that we don't\n\t\t\t * have a VLAN interface, drop the packet.\n\t\t\t */\n\t\t\tvlan_iface = net_eth_get_vlan_iface(iface,\n\t\t\t\t\t\t\t    net_pkt_vlan_tag(pkt));\n\t\t\tif (vlan_iface == NULL) {\n\t\t\t\tNET_DBG(\"Dropping frame, no VLAN interface for tag %d\",\n\t\t\t\t\tnet_pkt_vlan_tag(pkt));\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tnet_pkt_set_iface(pkt, vlan_iface);\n\n\t\t\tif (net_if_l2(net_pkt_iface(pkt)) == NULL) {\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (net_pkt_vlan_tag(pkt) != NET_VLAN_TAG_PRIORITY) {\n\t\t\t\t/* We could call VLAN interface directly but then the\n\t\t\t\t * interface statistics would not get updated so route\n\t\t\t\t * the call via Virtual L2 layer.\n\t\t\t\t */\n\t\t\t\tif (net_if_l2(net_pkt_iface(pkt))->recv != NULL) {\n\t\t\t\t\tverdict = net_if_l2(net_pkt_iface(pkt))->recv(iface, pkt);\n\t\t\t\t\tif (verdict == NET_DROP) {\n\t\t\t\t\t\tgoto drop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlladdr = net_pkt_lladdr_dst(pkt);\n\n\tnet_pkt_set_ll_proto_type(pkt, type);\n\tdst_broadcast = net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr);\n\tdst_eth_multicast = net_eth_is_addr_group((struct net_eth_addr *)lladdr->addr);\n\tdst_iface_addr = net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr);\n\n\tif (is_vlan_pkt) {\n\t\tprint_vlan_ll_addrs(pkt, type, net_pkt_vlan_tci(pkt),\n\t\t\t\t    net_pkt_get_len(pkt),\n\t\t\t\t    net_pkt_lladdr_src(pkt),\n\t\t\t\t    net_pkt_lladdr_dst(pkt),\n\t\t\t\t    eth_is_vlan_tag_stripped(iface));\n\t} else {\n\t\tprint_ll_addrs(pkt, type, net_pkt_get_len(pkt),\n\t\t\t       net_pkt_lladdr_src(pkt),\n\t\t\t       net_pkt_lladdr_dst(pkt));\n\t}\n\n\tif (!(dst_broadcast || dst_eth_multicast || dst_iface_addr)) {\n\t\t/* The ethernet frame is not for me as the link addresses\n\t\t * are different.\n\t\t */\n\t\tNET_DBG(\"Dropping frame, not for me [%s]\",\n\t\t\tnet_sprint_ll_addr(net_if_get_link_addr(iface)->addr,\n\t\t\t\t\t   sizeof(struct net_eth_addr)));\n\t\tgoto drop;\n\t}\n\n\t/* Get rid of the Ethernet header. */\n\tnet_buf_pull(pkt->frags, hdr_len);\n\n\tbody_len = net_pkt_get_len(pkt);\n\n\tSTRUCT_SECTION_FOREACH(net_l3_register, l3) {\n\t\tif (l3->ptype != type || l3->l2 != &NET_L2_GET_NAME(ETHERNET) ||\n\t\t    l3->handler == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tNET_DBG(\"Calling L3 %s handler for type 0x%04x iface %d (%p)\",\n\t\t\tl3->name, type, net_if_get_by_iface(iface), iface);\n\n\t\tverdict = l3->handler(iface, type, pkt);\n\t\tif (verdict == NET_OK) {\n\t\t\t/* the packet was consumed by the l3-handler */\n\t\t\tgoto out;\n\t\t} else if (verdict == NET_DROP) {\n\t\t\tNET_DBG(\"Dropping frame, packet rejected by %s\", l3->name);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* The packet will be processed further by IP-stack\n\t\t * when NET_CONTINUE is returned\n\t\t */\n\t\thandled = true;\n\t\tbreak;\n\t}\n\n\tif (!handled) {\n\t\tif (IS_ENABLED(CONFIG_NET_ETHERNET_FORWARD_UNRECOGNISED_ETHERTYPE)) {\n\t\t\tnet_pkt_set_family(pkt, NET_AF_UNSPEC);\n\t\t} else {\n\t\t\tNET_DBG(\"Unknown hdr type 0x%04x iface %d (%p)\", type,\n\t\t\t\tnet_if_get_by_iface(iface), iface);\n\t\t\teth_stats_update_unknown_protocol(iface_eth);\n\t\t\treturn NET_DROP;\n\t\t}\n\t}\n\n\tif (type != NET_ETH_PTYPE_EAPOL) {\n\t\tethernet_update_length(iface, pkt);\n\t}\n\nout:\n\tethernet_update_rx_stats(iface_eth, body_len + hdr_len, dst_broadcast, dst_eth_multicast);\n\treturn verdict;\ndrop:\n\teth_stats_update_errors_rx(iface_eth);\n\treturn NET_DROP;\n}\n",
                {
                    "257": "static enum net_verdict ethernet_recv(struct net_if *iface,",
                    "258": "\t\t\t\t      struct net_pkt *pkt)",
                    "259": "{",
                    "260": "\tstruct ethernet_context *ctx = net_if_l2_data(iface);",
                    "261": "\tuint8_t hdr_len = sizeof(struct net_eth_hdr);",
                    "262": "\tsize_t body_len;",
                    "263": "\tstruct net_eth_hdr *hdr = NET_ETH_HDR(pkt);",
                    "264": "\tenum net_verdict verdict = NET_CONTINUE;",
                    "265": "\tbool is_vlan_pkt = false;",
                    "266": "\tbool handled = false;",
                    "267": "\tstruct net_linkaddr *lladdr;",
                    "268": "\tuint16_t type;",
                    "269": "\tbool dst_broadcast, dst_eth_multicast, dst_iface_addr;",
                    "270": "\tstruct net_if *iface_eth = iface;",
                    "271": "",
                    "272": "\t/* This expects that the Ethernet header is in the first net_buf",
                    "273": "\t * fragment. This is a safe expectation here as it would not make",
                    "274": "\t * any sense to split the Ethernet header to two net_buf's by the",
                    "275": "\t * Ethernet driver.",
                    "276": "\t */",
                    "277": "\tif (hdr == NULL || pkt->buffer->len < hdr_len) {",
                    "278": "\t\tgoto drop;",
                    "279": "\t}",
                    "280": "",
                    "281": "\t/* Set the pointers to ll src and dst addresses */",
                    "282": "\t(void)net_linkaddr_create(net_pkt_lladdr_src(pkt), hdr->src.addr,",
                    "283": "\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);",
                    "284": "",
                    "285": "\t(void)net_linkaddr_create(net_pkt_lladdr_dst(pkt), hdr->dst.addr,",
                    "286": "\t\t\t\t  sizeof(struct net_eth_addr), NET_LINK_ETHERNET);",
                    "287": "",
                    "288": "\tif (IS_ENABLED(CONFIG_NET_ETHERNET_BRIDGE) && net_eth_iface_is_bridged(ctx)) {",
                    "289": "\t\tverdict = eth_bridge_input_process(iface, pkt);",
                    "290": "\t\tif (verdict == NET_DROP) {",
                    "291": "\t\t\tgoto drop;",
                    "292": "\t\t}",
                    "293": "",
                    "294": "\t\t/* Handled by bridge locally */",
                    "295": "\t\tif (verdict == NET_OK) {",
                    "296": "\t\t\tiface = net_eth_get_bridge(ctx);",
                    "297": "\t\t}",
                    "298": "\t}",
                    "299": "",
                    "300": "\ttype = net_ntohs(hdr->type);",
                    "301": "",
                    "302": "\tif (IS_ENABLED(CONFIG_NET_VLAN) && type == NET_ETH_PTYPE_VLAN) {",
                    "303": "\t\tif (net_eth_is_vlan_enabled(ctx, iface) &&",
                    "304": "\t\t    !eth_is_vlan_tag_stripped(iface)) {",
                    "305": "\t\t\tstruct net_eth_vlan_hdr *hdr_vlan =",
                    "306": "\t\t\t\t(struct net_eth_vlan_hdr *)NET_ETH_HDR(pkt);",
                    "307": "\t\t\tstruct net_if *vlan_iface;",
                    "308": "",
                    "309": "\t\t\tnet_pkt_set_vlan_tci(pkt, net_ntohs(hdr_vlan->vlan.tci));",
                    "310": "\t\t\ttype = net_ntohs(hdr_vlan->type);",
                    "311": "\t\t\thdr_len = sizeof(struct net_eth_vlan_hdr);",
                    "312": "\t\t\tis_vlan_pkt = true;",
                    "313": "",
                    "314": "\t\t\t/* If we receive a packet with a VLAN tag, for that we don't",
                    "315": "\t\t\t * have a VLAN interface, drop the packet.",
                    "316": "\t\t\t */",
                    "317": "\t\t\tvlan_iface = net_eth_get_vlan_iface(iface,",
                    "318": "\t\t\t\t\t\t\t    net_pkt_vlan_tag(pkt));",
                    "319": "\t\t\tif (vlan_iface == NULL) {",
                    "320": "\t\t\t\tNET_DBG(\"Dropping frame, no VLAN interface for tag %d\",",
                    "321": "\t\t\t\t\tnet_pkt_vlan_tag(pkt));",
                    "322": "\t\t\t\tgoto drop;",
                    "323": "\t\t\t}",
                    "324": "",
                    "325": "\t\t\tnet_pkt_set_iface(pkt, vlan_iface);",
                    "326": "",
                    "327": "\t\t\tif (net_if_l2(net_pkt_iface(pkt)) == NULL) {",
                    "328": "\t\t\t\tgoto drop;",
                    "329": "\t\t\t}",
                    "330": "",
                    "331": "\t\t\tif (net_pkt_vlan_tag(pkt) != NET_VLAN_TAG_PRIORITY) {",
                    "332": "\t\t\t\t/* We could call VLAN interface directly but then the",
                    "333": "\t\t\t\t * interface statistics would not get updated so route",
                    "334": "\t\t\t\t * the call via Virtual L2 layer.",
                    "335": "\t\t\t\t */",
                    "336": "\t\t\t\tif (net_if_l2(net_pkt_iface(pkt))->recv != NULL) {",
                    "337": "\t\t\t\t\tverdict = net_if_l2(net_pkt_iface(pkt))->recv(iface, pkt);",
                    "338": "\t\t\t\t\tif (verdict == NET_DROP) {",
                    "339": "\t\t\t\t\t\tgoto drop;",
                    "340": "\t\t\t\t\t}",
                    "341": "\t\t\t\t}",
                    "342": "\t\t\t}",
                    "343": "\t\t}",
                    "344": "\t}",
                    "345": "",
                    "346": "\tlladdr = net_pkt_lladdr_dst(pkt);",
                    "347": "",
                    "348": "\tnet_pkt_set_ll_proto_type(pkt, type);",
                    "349": "\tdst_broadcast = net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr);",
                    "350": "\tdst_eth_multicast = net_eth_is_addr_group((struct net_eth_addr *)lladdr->addr);",
                    "351": "\tdst_iface_addr = net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr);",
                    "352": "",
                    "353": "\tif (is_vlan_pkt) {",
                    "354": "\t\tprint_vlan_ll_addrs(pkt, type, net_pkt_vlan_tci(pkt),",
                    "355": "\t\t\t\t    net_pkt_get_len(pkt),",
                    "356": "\t\t\t\t    net_pkt_lladdr_src(pkt),",
                    "357": "\t\t\t\t    net_pkt_lladdr_dst(pkt),",
                    "358": "\t\t\t\t    eth_is_vlan_tag_stripped(iface));",
                    "359": "\t} else {",
                    "360": "\t\tprint_ll_addrs(pkt, type, net_pkt_get_len(pkt),",
                    "361": "\t\t\t       net_pkt_lladdr_src(pkt),",
                    "362": "\t\t\t       net_pkt_lladdr_dst(pkt));",
                    "363": "\t}",
                    "364": "",
                    "365": "\tif (!(dst_broadcast || dst_eth_multicast || dst_iface_addr)) {",
                    "366": "\t\t/* The ethernet frame is not for me as the link addresses",
                    "367": "\t\t * are different.",
                    "368": "\t\t */",
                    "369": "\t\tNET_DBG(\"Dropping frame, not for me [%s]\",",
                    "370": "\t\t\tnet_sprint_ll_addr(net_if_get_link_addr(iface)->addr,",
                    "371": "\t\t\t\t\t   sizeof(struct net_eth_addr)));",
                    "372": "\t\tgoto drop;",
                    "373": "\t}",
                    "374": "",
                    "375": "\t/* Get rid of the Ethernet header. */",
                    "376": "\tnet_buf_pull(pkt->frags, hdr_len);",
                    "377": "",
                    "378": "\tbody_len = net_pkt_get_len(pkt);",
                    "379": "",
                    "380": "\tSTRUCT_SECTION_FOREACH(net_l3_register, l3) {",
                    "381": "\t\tif (l3->ptype != type || l3->l2 != &NET_L2_GET_NAME(ETHERNET) ||",
                    "382": "\t\t    l3->handler == NULL) {",
                    "383": "\t\t\tcontinue;",
                    "384": "\t\t}",
                    "385": "",
                    "386": "\t\tNET_DBG(\"Calling L3 %s handler for type 0x%04x iface %d (%p)\",",
                    "387": "\t\t\tl3->name, type, net_if_get_by_iface(iface), iface);",
                    "388": "",
                    "389": "\t\tverdict = l3->handler(iface, type, pkt);",
                    "390": "\t\tif (verdict == NET_OK) {",
                    "391": "\t\t\t/* the packet was consumed by the l3-handler */",
                    "392": "\t\t\tgoto out;",
                    "393": "\t\t} else if (verdict == NET_DROP) {",
                    "394": "\t\t\tNET_DBG(\"Dropping frame, packet rejected by %s\", l3->name);",
                    "395": "\t\t\tgoto drop;",
                    "396": "\t\t}",
                    "397": "",
                    "398": "\t\t/* The packet will be processed further by IP-stack",
                    "399": "\t\t * when NET_CONTINUE is returned",
                    "400": "\t\t */",
                    "401": "\t\thandled = true;",
                    "402": "\t\tbreak;",
                    "403": "\t}",
                    "404": "",
                    "405": "\tif (!handled) {",
                    "406": "\t\tif (IS_ENABLED(CONFIG_NET_ETHERNET_FORWARD_UNRECOGNISED_ETHERTYPE)) {",
                    "407": "\t\t\tnet_pkt_set_family(pkt, NET_AF_UNSPEC);",
                    "408": "\t\t} else {",
                    "409": "\t\t\tNET_DBG(\"Unknown hdr type 0x%04x iface %d (%p)\", type,",
                    "410": "\t\t\t\tnet_if_get_by_iface(iface), iface);",
                    "411": "\t\t\teth_stats_update_unknown_protocol(iface_eth);",
                    "412": "\t\t\treturn NET_DROP;",
                    "413": "\t\t}",
                    "414": "\t}",
                    "415": "",
                    "416": "\tif (type != NET_ETH_PTYPE_EAPOL) {",
                    "417": "\t\tethernet_update_length(iface, pkt);",
                    "418": "\t}",
                    "419": "",
                    "420": "out:",
                    "421": "\tethernet_update_rx_stats(iface_eth, body_len + hdr_len, dst_broadcast, dst_eth_multicast);",
                    "422": "\treturn verdict;",
                    "423": "drop:",
                    "424": "\teth_stats_update_errors_rx(iface_eth);",
                    "425": "\treturn NET_DROP;",
                    "426": "}"
                }
            ],
            "function_content_in_lines": {}
        },
        "rand_get": {
            "name": "rand_get",
            "file_path": "/home/chenkaiqiu/LCMHalMCPServer/zephyr_official/subsys/random/random_entropy_device.c",
            "location_line": 15,
            "function_content": [
                "/*\n* Copyright (c) 2017 Intel Corporation\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\nstatic int rand_get(uint8_t *dst, size_t outlen, bool csrand)\n{\n\tuint32_t random_num;\n\tint ret;\n\n\tif (!device_is_ready(entropy_dev)) {\n\t\treturn -ENODEV;\n\t}\n\n\tret = entropy_get_entropy(entropy_dev, dst, outlen);\n\n\tif (unlikely(ret < 0)) {\n\t\t/* Don't try to fill the buffer in case of\n\t\t * cryptographically secure random numbers, just\n\t\t * propagate the driver error.\n\t\t */\n\t\tif (csrand) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Use system timer in case the entropy device couldn't deliver\n\t\t * 32-bit of data.  There's not much that can be done in this\n\t\t * situation.  An __ASSERT() isn't used here as the HWRNG might\n\t\t * still be gathering entropy during early boot situations.\n\t\t */\n\n\t\tuint32_t len = 0;\n\t\tuint32_t blocksize = 4;\n\n\t\twhile (len < outlen) {\n\t\t\tsize_t copylen = outlen - len;\n\n\t\t\tif (copylen > blocksize) {\n\t\t\t\tcopylen = blocksize;\n\t\t\t}\n\n\t\t\trandom_num = k_cycle_get_32();\n\t\t\t(void)memcpy(&(dst[len]), &random_num, copylen);\n\t\t\tlen += copylen;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
                {
                    "15": "static int rand_get(uint8_t *dst, size_t outlen, bool csrand)",
                    "16": "{",
                    "17": "\tuint32_t random_num;",
                    "18": "\tint ret;",
                    "19": "",
                    "20": "\tif (!device_is_ready(entropy_dev)) {",
                    "21": "\t\treturn -ENODEV;",
                    "22": "\t}",
                    "23": "",
                    "24": "\tret = entropy_get_entropy(entropy_dev, dst, outlen);",
                    "25": "",
                    "26": "\tif (unlikely(ret < 0)) {",
                    "27": "\t\t/* Don't try to fill the buffer in case of",
                    "28": "\t\t * cryptographically secure random numbers, just",
                    "29": "\t\t * propagate the driver error.",
                    "30": "\t\t */",
                    "31": "\t\tif (csrand) {",
                    "32": "\t\t\treturn ret;",
                    "33": "\t\t}",
                    "34": "",
                    "35": "\t\t/* Use system timer in case the entropy device couldn't deliver",
                    "36": "\t\t * 32-bit of data.  There's not much that can be done in this",
                    "37": "\t\t * situation.  An __ASSERT() isn't used here as the HWRNG might",
                    "38": "\t\t * still be gathering entropy during early boot situations.",
                    "39": "\t\t */",
                    "40": "",
                    "41": "\t\tuint32_t len = 0;",
                    "42": "\t\tuint32_t blocksize = 4;",
                    "43": "",
                    "44": "\t\twhile (len < outlen) {",
                    "45": "\t\t\tsize_t copylen = outlen - len;",
                    "46": "",
                    "47": "\t\t\tif (copylen > blocksize) {",
                    "48": "\t\t\t\tcopylen = blocksize;",
                    "49": "\t\t\t}",
                    "50": "",
                    "51": "\t\t\trandom_num = k_cycle_get_32();",
                    "52": "\t\t\t(void)memcpy(&(dst[len]), &random_num, copylen);",
                    "53": "\t\t\tlen += copylen;",
                    "54": "\t\t}",
                    "55": "\t}",
                    "56": "",
                    "57": "\treturn 0;",
                    "58": "}"
                }
            ],
            "function_content_in_lines": {}
        }
    },
    "mmioinfo_interestingmmioexpr_dict": {},
    "mmioinfo_mmioexpr_dict": {},
    "mmioinfo_interestingmmiofunc_contains_dict": {}
}